{"version":3,"sources":["webpack:///./node_modules/core-js/modules/_iter-define.js","webpack:///./node_modules/core-js/modules/es7.promise.finally.js","webpack:///./node_modules/core-js/modules/_object-keys.js","webpack:///./node_modules/core-js/modules/_object-dps.js","webpack:///./node_modules/core-js/modules/_task.js","webpack:///./node_modules/core-js/modules/_iter-call.js","webpack:///./node_modules/core-js/modules/_dom-create.js","webpack:///./node_modules/core-js/modules/_classof.js","webpack:///./node_modules/core-js/modules/_object-gops.js","webpack:///./node_modules/core-js/modules/core.get-iterator-method.js","webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js","webpack:///./node_modules/core-js/modules/_redefine.js","webpack:///./node_modules/core-js/modules/_object-create.js","webpack:///./node_modules/vue/dist/vue.runtime.esm.js","webpack:///./node_modules/core-js/modules/_wks.js","webpack:///./node_modules/core-js/modules/_library.js","webpack:///./node_modules/core-js/modules/_cof.js","webpack:///./node_modules/core-js/modules/es6.string.includes.js","webpack:///./node_modules/core-js/modules/_invoke.js","webpack:///./node_modules/core-js/modules/_hide.js","webpack:///./node_modules/core-js/modules/_is-array-iter.js","webpack:///./node_modules/core-js/modules/_object-gpo.js","webpack:///./node_modules/core-js/modules/_iter-create.js","webpack:///./node_modules/core-js/modules/es6.object.keys.js","webpack:///./node_modules/core-js/modules/_to-integer.js","webpack:///./node_modules/core-js/modules/_property-desc.js","webpack:///./node_modules/core-js/modules/_for-of.js","webpack:///./node_modules/core-js/modules/_to-object.js","webpack:///./node_modules/core-js/modules/_fails-is-regexp.js","webpack:///./node_modules/core-js/modules/_object-pie.js","webpack:///./node_modules/core-js/modules/es6.promise.js","webpack:///./node_modules/core-js/modules/_shared.js","webpack:///./node_modules/core-js/modules/_export.js","webpack:///./node_modules/core-js/modules/_iter-detect.js","webpack:///./node_modules/core-js/modules/_object-sap.js","webpack:///./node_modules/core-js/modules/_shared-key.js","webpack:///./node_modules/core-js/modules/_iobject.js","webpack:///./node_modules/core-js/modules/es7.array.includes.js","webpack:///./node_modules/core-js/modules/_to-iobject.js","webpack:///./node_modules/core-js/modules/_has.js","webpack:///./node_modules/core-js/modules/_to-primitive.js","webpack:///./node_modules/core-js/modules/_object-assign.js","webpack:///./node_modules/core-js/modules/_global.js","webpack:///./node_modules/core-js/modules/_to-absolute-index.js","webpack:///./node_modules/core-js/modules/_fails.js","webpack:///./node_modules/core-js/modules/_set-species.js","webpack:///./node_modules/mxgraph-lakshamana/javascript/dist/build.js","webpack:///./node_modules/core-js/modules/_set-to-string-tag.js","webpack:///./node_modules/core-js/modules/_microtask.js","webpack:///./node_modules/core-js/modules/_core.js","webpack:///./node_modules/core-js/modules/_iterators.js","webpack:///./node_modules/core-js/modules/_object-dp.js","webpack:///./node_modules/core-js/modules/_ctx.js","webpack:///./node_modules/core-js/modules/_add-to-unscopables.js","webpack:///./node_modules/core-js/modules/_perform.js","webpack:///./node_modules/core-js/modules/_to-length.js","webpack:///./node_modules/core-js/modules/_descriptors.js","webpack:///./node_modules/core-js/modules/_user-agent.js","webpack:///./node_modules/core-js/modules/_new-promise-capability.js","webpack:///./node_modules/core-js/modules/_is-regexp.js","webpack:///./node_modules/core-js/modules/web.dom.iterable.js","webpack:///./node_modules/core-js/modules/_promise-resolve.js","webpack:///./node_modules/core-js/modules/_defined.js","webpack:///./node_modules/core-js/modules/_array-includes.js","webpack:///./node_modules/core-js/modules/_ie8-dom-define.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/core-js/modules/_uid.js","webpack:///./node_modules/core-js/modules/es6.array.iterator.js","webpack:///./node_modules/core-js/modules/_an-object.js","webpack:///./node_modules/core-js/modules/_object-keys-internal.js","webpack:///./node_modules/core-js/modules/_string-context.js","webpack:///./node_modules/core-js/modules/_is-object.js","webpack:///./node_modules/core-js/modules/_iter-step.js","webpack:///./node_modules/core-js/modules/_a-function.js","webpack:///./node_modules/core-js/modules/_redefine-all.js","webpack:///./node_modules/core-js/modules/_enum-bug-keys.js","webpack:///./node_modules/core-js/modules/_species-constructor.js","webpack:///./node_modules/core-js/modules/_an-instance.js","webpack:///./node_modules/core-js/modules/es6.object.assign.js","webpack:///./node_modules/core-js/modules/_function-to-string.js","webpack:///./node_modules/core-js/modules/_html.js"],"names":["LIBRARY","__webpack_require__","$export","redefine","hide","Iterators","$iterCreate","setToStringTag","getPrototypeOf","ITERATOR","BUGGY","keys","FF_ITERATOR","KEYS","VALUES","returnThis","this","module","exports","Base","NAME","Constructor","next","DEFAULT","IS_SET","FORCED","methods","key","IteratorPrototype","getMethod","kind","proto","TAG","DEF_VALUES","VALUES_BUG","prototype","$native","$default","$entries","undefined","$anyNative","entries","call","Object","name","values","P","F","core","global","speciesConstructor","promiseResolve","R","finally","onFinally","C","Promise","isFunction","then","x","e","$keys","enumBugKeys","O","dP","anObject","getKeys","defineProperties","Properties","length","i","f","defer","channel","port","ctx","invoke","html","cel","process","setTask","setImmediate","clearTask","clearImmediate","MessageChannel","Dispatch","counter","queue","ONREADYSTATECHANGE","run","id","hasOwnProperty","fn","listener","event","data","args","arguments","push","Function","nextTick","now","port2","port1","onmessage","postMessage","addEventListener","importScripts","appendChild","removeChild","setTimeout","set","clear","iterator","value","ret","isObject","document","is","createElement","it","cof","ARG","tryGet","T","B","callee","getOwnPropertySymbols","classof","getIteratorMethod","normalizeComponent","scriptExports","render","staticRenderFns","functionalTemplate","injectStyles","scopeId","moduleIdentifier","shadowMode","hook","options","_compiled","functional","_scopeId","context","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","_injectStyles","originalRender","h","existing","beforeCreate","concat","d","__webpack_exports__","has","SRC","$toString","TO_STRING","TPL","split","inspectSource","val","safe","join","String","dPs","IE_PROTO","Empty","PROTOTYPE","createDict","iframeDocument","iframe","lt","gt","style","display","src","contentWindow","open","write","close","create","result","emptyObject","freeze","isUndef","v","isDef","isTrue","isFalse","isPrimitive","obj","_toString","toString","isPlainObject","isRegExp","isValidArrayIndex","n","parseFloat","Math","floor","isFinite","isPromise","catch","Array","isArray","JSON","stringify","toNumber","isNaN","makeMap","str","expectsLowerCase","map","list","toLowerCase","isReservedAttribute","remove","arr","item","index","indexOf","splice","hasOwn","cached","cache","hit","camelizeRE","camelize","replace","_","c","toUpperCase","capitalize","charAt","slice","hyphenateRE","hyphenate","polyfillBind","boundFn","a","l","apply","_length","nativeBind","bind","toArray","start","extend","to","_from","toObject","res","noop","b","no","identity","looseEqual","isObjectA","isObjectB","isArrayA","isArrayB","every","Date","getTime","keysA","keysB","looseIndexOf","once","called","SSR_ATTR","ASSET_TYPES","LIFECYCLE_HOOKS","config","optionMergeStrategies","silent","productionTip","devtools","performance","errorHandler","warnHandler","ignoredElements","keyCodes","isReservedTag","isReservedAttr","isUnknownElement","getTagNamespace","parsePlatformTagName","mustUseProp","async","_lifecycleHooks","unicodeRegExp","isReserved","charCodeAt","def","enumerable","defineProperty","writable","configurable","bailRE","RegExp","parsePath","path","test","segments","_isServer","hasProto","inBrowser","window","inWeex","WXEnvironment","platform","weexPlatform","UA","navigator","userAgent","isIE","isIE9","isEdge","isIOS","isFF","match","nativeWatch","watch","supportsPassive","opts","get","isServerRendering","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","isNative","Ctor","_Set","hasSymbol","Symbol","Reflect","ownKeys","Set","warn","uid","Dep","subs","addSub","sub","removeSub","depend","target","addDep","notify","update","targetStack","pushTarget","popTarget","pop","VNode","tag","children","text","elm","componentOptions","asyncFactory","ns","fnContext","fnOptions","fnScopeId","componentInstance","raw","isStatic","isRootInsert","isComment","isCloned","isOnce","asyncMeta","isAsyncPlaceholder","prototypeAccessors","child","createEmptyVNode","node","createTextVNode","cloneVNode","vnode","cloned","arrayProto","arrayMethods","methodsToPatch","forEach","method","original","len","inserted","ob","__ob__","observeArray","dep","arrayKeys","getOwnPropertyNames","shouldObserve","toggleObserving","Observer","vmCount","protoAugment","copyAugment","walk","__proto__","observe","asRootData","isExtensible","_isVue","defineReactive$$1","customSetter","shallow","property","getOwnPropertyDescriptor","getter","setter","childOb","dependArray","newVal","max","del","items","strats","mergeData","from","toVal","fromVal","mergeDataOrFn","parentVal","childVal","vm","instanceData","defaultData","mergeHook","dedupeHooks","hooks","mergeAssets","type","key$1","props","inject","computed","provide","defaultStrat","normalizeProps","normalizeInject","normalized","normalizeDirectives","dirs","directives","def$$1","mergeOptions","_base","extends","mixins","mergeField","strat","resolveAsset","warnMissing","assets","camelizedId","PascalCaseId","validateProp","propOptions","propsData","prop","absent","booleanIndex","getTypeIndex","Boolean","stringIndex","getPropDefaultValue","prevShouldObserve","default","_props","getType","isSameType","expectedTypes","handleError","err","info","cur","$parent","errorCaptured","capture","globalHandleError","invokeWithErrorHandling","handler","_handled","logError","console","error","timerFunc","isUsingMicroTask","callbacks","pending","flushCallbacks","copies","p","resolve","MutationObserver","observer","textNode","createTextNode","characterData","cb","_resolve","seenObjects","traverse","_traverse","seen","isA","isFrozen","depId","normalizeEvent","passive","once$$1","createFnInvoker","fns","invoker","arguments$1","updateListeners","on","oldOn","remove$$1","createOnceHandler","old","params","mergeVNodeHook","hookKey","oldHook","wrappedHook","merged","extractPropsFromVNodeData","attrs","altKey","checkProp","hash","preserve","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","isTextNode","nestedIndex","lastIndex","last","shift","_isVList","initProvide","_provided","initInjections","resolveInject","provideKey","source","provideDefault","resolveSlots","slots","slot","name$1","isWhitespace","normalizeScopedSlots","normalSlots","prevSlots","hasNormalSlots","isStable","$stable","$key","_normalized","$hasNormal","normalizeScopedSlot","key$2","proxyNormalSlot","proxy","renderList","done","renderSlot","fallback","bindObject","nodes","scopedSlotFn","$scopedSlots","$slots","$createElement","resolveFilter","isKeyNotMatch","expect","actual","checkKeyCodes","eventKeyCode","builtInKeyCode","eventKeyName","builtInKeyName","mappedKeyCode","bindObjectProps","asProp","isSync","loop","domProps","camelizedKey","hyphenatedKey","$event","renderStatic","isInFor","_staticTrees","tree","_renderProxy","markStatic","markOnce","markStaticNode","bindObjectListeners","ours","resolveScopedSlots","hasDynamicKeys","contentHashKey","bindDynamicKeys","baseObj","prependModifier","symbol","installRenderHelpers","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","_u","_g","_d","_p","FunctionalRenderContext","contextVm","this$1","_original","isCompiled","needNormalization","listeners","injections","scopedSlots","_c","createFunctionalComponent","mergeProps","renderContext","cloneAndMarkFunctionalResult","vnodes","clone","componentVNodeHooks","init","hydrating","_isDestroyed","keepAlive","mountedNode","prepatch","createComponentInstanceForVnode","activeInstance","$mount","oldVnode","updateChildComponent","insert","_isMounted","callHook","queueActivatedComponent","activateChildComponent","destroy","deactivateChildComponent","$destroy","hooksToMerge","createComponent","baseCtor","cid","resolveAsyncComponent","createAsyncPlaceholder","resolveConstructorOptions","model","transformModel","nativeOn","abstract","installComponentHooks","_isComponent","_parentVnode","inlineTemplate","toMerge","_merged","mergeHook$1","f1","f2","callback","SIMPLE_NORMALIZE","ALWAYS_NORMALIZE","normalizationType","alwaysNormalize","_createElement","pre","applyNS","registerDeepBindings","force","class","initRender","_vnode","parentVnode","_renderChildren","parentData","_parentListeners","currentRenderingInstance","renderMixin","Vue","$nextTick","_render","ref","ensureCtor","comp","base","__esModule","toStringTag","factory","errorComp","resolved","owner","owners","loading","loadingComp","sync","timerLoading","timerTimeout","$on","forceRender","renderCompleted","$forceUpdate","clearTimeout","reject","reason","component","delay","timeout","getFirstComponentChild","initEvents","_events","_hasHookEvent","updateComponentListeners","remove$1","$off","_target","onceHandler","oldListeners","eventsMixin","hookRE","$once","i$1","cbs","$emit","setActiveInstance","prevActiveInstance","initLifecycle","$children","$refs","_watcher","_inactive","_directInactive","_isBeingDestroyed","lifecycleMixin","_update","prevEl","$el","prevVnode","restoreActiveInstance","__patch__","__vue__","teardown","_watchers","_data","mountComponent","el","updateComponent","Watcher","before","renderChildren","newScopedSlots","oldScopedSlots","hasDynamicScopedSlot","needsForceUpdate","$attrs","$listeners","propKeys","_propKeys","isInInactiveTree","direct","handlers","j","activatedChildren","waiting","flushing","resetSchedulerState","currentFlushTimestamp","getNow","createEvent","timeStamp","flushSchedulerQueue","watcher","sort","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","emit","queueWatcher","uid$2","expOrFn","isRenderWatcher","deep","user","lazy","active","dirty","deps","newDeps","depIds","newDepIds","expression","cleanupDeps","tmp","oldValue","evaluate","sharedPropertyDefinition","sourceKey","initState","initProps","initMethods","initData","initComputed","initWatch","propsOptions","isRoot","getData","computedWatcherOptions","watchers","_computedWatchers","isSSR","userDef","defineComputed","shouldCache","createComputedGetter","createGetterInvoker","createWatcher","$watch","stateMixin","dataDef","propsDef","$set","$delete","immediate","uid$3","initMixin","_init","_uid","initInternalComponent","constructor","_self","vnodeComponentOptions","_componentTag","super","superOptions","cachedSuperOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","sealed","sealedOptions","initUse","use","plugin","installedPlugins","_installedPlugins","unshift","install","initMixin$1","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","initProps$1","initComputed$1","Comp","initAssetRegisters","definition","getComponentName","matches","pattern","pruneCache","keepAliveInstance","filter","cachedNode","pruneCacheEntry","current","cached$$1","patternTypes","KeepAlive","include","exclude","Number","created","destroyed","mounted","ref$1","parseInt","builtInComponents","initGlobalAPI","configDef","util","defineReactive","delete","observable","version","acceptValue","attr","isEnumeratedAttr","isValidContentEditableValue","convertEnumeratedValue","isFalsyAttrValue","isBooleanAttr","xlinkNS","isXlink","getXlinkProp","genClassForVnode","parentNode","childNode","mergeClassData","renderClass","staticClass","dynamicClass","stringifyClass","stringifyArray","stringifyObject","stringified","namespaceMap","svg","math","isHTMLTag","isSVG","unknownElementCache","HTMLUnknownElement","HTMLElement","isTextInputType","query","selected","querySelector","createElement$1","tagName","multiple","setAttribute","createElementNS","namespace","createComment","insertBefore","newNode","referenceNode","nextSibling","setTextContent","textContent","setStyleScope","nodeOps","registerRef","isRemoval","refs","refInFor","emptyNode","sameVnode","sameInputType","typeA","typeB","createKeyToOldIdx","beginIdx","endIdx","createPatchFunction","backend","modules","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","parentElm","refElm","nested","ownerArray","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","transition","activate","ref$$1","ancestor","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","rm","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","vnodeToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","findIdxInOld","end","hydrate","postpatch","invokeInsertHook","initial","isRenderedModule","inVPre","hasChildNodes","innerHTML","childrenMatch","firstChild","fullInvoke","isInitialPatch","isRealElement","nodeType","hasAttribute","removeAttribute","oldElm","_leaveCb","patchable","i$2","updateDirectives","oldDir","dir","isCreate","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldArg","arg","callHook$1","componentUpdated","callInsert","emptyModifiers","modifiers","getRawDirName","rawName","baseModules","updateAttrs","inheritAttrs","oldAttrs","setAttr","removeAttributeNS","baseSetAttr","setAttributeNS","__ieph","blocker","stopImmediatePropagation","removeEventListener","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","target$1","klass","RANGE_TOKEN","CHECKBOX_RADIO_TOKEN","normalizeEvents","change","createOnceHandler$1","remove$2","useMicrotaskFix","add$1","attachedTimestamp","_wrapper","currentTarget","ownerDocument","updateDOMListeners","svgContainer","events","updateDOMProps","oldProps","childNodes","_value","strCur","shouldUpdateValue","checkVal","composing","isNotInFocusAndDirty","isDirtyWithModifiers","notInFocus","activeElement","_vModifiers","number","trim","parseStyleText","cssText","listDelimiter","propertyDelimiter","normalizeStyleData","normalizeStyleBinding","staticStyle","bindingStyle","getStyle","checkChild","styleData","emptyStyle","cssVarRE","importantRE","setProp","setProperty","normalizedName","normalize","vendorNames","capName","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","whitespaceRE","addClass","classList","getAttribute","removeClass","tar","resolveTransition","css","autoCssTransition","enterClass","enterToClass","enterActiveClass","leaveClass","leaveToClass","leaveActiveClass","hasTransition","TRANSITION","ANIMATION","transitionProp","transitionEndEvent","animationProp","animationEndEvent","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","raf","requestAnimationFrame","nextFrame","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","expectedType","getTransitionInfo","propCount","ended","onEnd","transformRE","styles","getComputedStyle","transitionDelays","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationDurations","animationTimeout","hasTransform","delays","durations","toMs","s","enter","toggleDisplay","cancelled","_enterCb","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","transitionNode","isAppear","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","beforeLeave","afterLeave","leaveCancelled","delayLeave","explicitLeaveDuration","performLeave","invokerFns","_enter","platformModules","patch","vmodel","trigger","directive","binding","_vOptions","setSelected","getValue","onCompositionStart","onCompositionEnd","prevOptions","curOptions","some","o","needReset","hasNoMatchingOption","actuallySetSelected","isMultiple","option","selectedIndex","initEvent","dispatchEvent","locateNode","transition$$1","originalDisplay","__vOriginalDisplay","unbind","platformDirectives","transitionProps","mode","getRealChild","compOptions","extractTransitionData","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","isNotTextNode","isVShowDirective","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","beforeMount","kept","prevChildren","rawChildren","transitionData","removed","c$1","pos","getBoundingClientRect","updated","hasMove","callPendingCbs","recordPosition","applyTranslation","_reflow","body","offsetHeight","moved","transform","WebkitTransform","transitionDuration","_moveCb","propertyName","_hasMove","cloneNode","newPos","oldPos","dx","left","dy","top","platformComponents","store","USE_SYMBOL","$exports","INCLUDES","includes","searchString","that","un","createDesc","object","ArrayProto","ObjectProto","descriptor","ceil","bitmap","isArrayIter","toLength","getIterFn","BREAK","RETURN","iterable","step","iterFn","TypeError","defined","MATCH","KEY","re","propertyIsEnumerable","Internal","newGenericPromiseCapability","OwnPromiseCapability","Wrapper","aFunction","anInstance","forOf","task","microtask","newPromiseCapabilityModule","perform","PROMISE","versions","v8","$Promise","isNode","empty","newPromiseCapability","USE_NATIVE","promise","FakePromise","exec","PromiseRejectionEvent","isThenable","isReject","chain","ok","reaction","exited","fail","domain","_h","onHandleUnhandled","exit","onUnhandled","unhandled","isUnhandled","onunhandledrejection","_a","onrejectionhandled","$reject","_w","$resolve","wrapper","executor","onFulfilled","onRejected","G","W","S","r","capability","$$reject","iter","all","remaining","$index","alreadyCalled","race","SHARED","copyright","own","out","exp","IS_FORCED","IS_GLOBAL","IS_STATIC","IS_PROTO","IS_BIND","expProto","U","SAFE_CLOSING","riter","skipClosing","fails","shared","$includes","IObject","valueOf","DESCRIPTORS","gOPS","pIE","$assign","assign","A","K","k","aLen","getSymbols","isEnum","self","__g","toInteger","min","SPECIES","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","__mxOutput","mxClient","VERSION","IS_IE","IS_IE6","IS_IE11","IS_EDGE","IS_QUIRKS","documentMode","IS_EM","VML_PREFIX","OFFICE_PREFIX","IS_NS","IS_OP","IS_OT","IS_SF","IS_IOS","IS_GC","IS_CHROMEAPP","chrome","app","runtime","IS_FF","IS_MT","IS_VML","appName","IS_SVG","NO_FO","IS_WIN","appVersion","IS_MAC","IS_TOUCH","documentElement","IS_POINTER","PointerEvent","IS_LOCAL","location","href","defaultBundles","isBrowserSupported","link","rel","doc","head","getElementsByTagName","loadResources","lan","mxResources","mxLoadResources","mxForceIncludes","mxResourceExtension","mxLoadStylesheets","mxBasePath","substring","basePath","mxImageBasePath","imageBasePath","mxLanguage","language","userLanguage","mxDefaultLanguage","defaultLanguage","mxLanguages","languages","namespaces","styleSheets","styleSheet","createStyleSheet","mxLog","consoleName","TRACE","DEBUG","WARN","buffer","title","table","tbody","tr","td","verticalAlign","textarea","height","resize","compatMode","width","addButton","evt","content","mxUtils","getInnerHtml","debug","copy","alert","popup","w","innerHeight","innerWidth","clientHeight","clientWidth","mxWindow","setMaximizable","setScrollable","setResizable","setClosable","destroyOnClose","elt","getElement","resizeHandler","sender","addListener","mxEvent","RESIZE_END","MAXIMIZE","NORMALIZE","writeln","lab","funct","button","isVisible","setVisible","visible","string","t0","dt","visibility","scrollTop","scrollHeight","mxObjectIdentity","FIELD_NAME","ctor","getFunctionName","mxDictionary","put","previous","getValues","visit","visitor","resources","extension","resourcesEncoded","loadDefaultBundle","loadSpecialBundle","isLanguageSupported","getDefaultBundle","basename","getSpecialBundle","dash","mxConstants","NONE","defaultBundle","specialBundle","req","parse","getText","load","isReady","lines","idx","unescape","defaultValue","replacePlaceholders","mxPoint","y","mxRectangle","equals","setRect","getCenterX","getCenterY","rect","minX","minY","maxX","maxY","intersect","r1","r2","b1","b2","grow","amount","getPoint","rotate90","t","fromRectangle","mxEffects","animateChanges","graph","changes","maxStep","animate","isRequired","mxGeometryChange","mxTerminalChange","mxValueChange","mxChildChange","mxStyleChange","state","getView","getState","cell","setOpacity","shape","scale","geometry","sx","sy","cellRenderer","redraw","cascadeOpacity","opacity","childCount","getChildCount","getChildAt","childState","edges","getEdges","edgeState","fadeOut","isEnabled","errorResource","closeResource","errorImage","removeCursors","element","cursor","getCurrentStyle","currentStyle","parseCssNumber","setPrefixedStyle","prefix","hasScrollbars","overflow","scope","eval","expr","_mxJavaScriptExpression","message","findNode","NODETYPE_ELEMENT","ltrim","idx2","array","nodeName","attributeName","attributeValue","isAncestorNode","getChildNodes","importNode","allChildren","attributes","createXmlDocument","implementation","createDocument","ActiveXObject","parseXml","DOMParser","xml","parser","parseFromString","validateOnParse","resolveExternals","loadXML","clearSelection","selection","getSelection","removeAllRanges","getPrettyXml","tab","indent","NODETYPE_TEXT","getTextContent","htmlEntities","removeWhitespace","previousSibling","newline","isVml","tagUrn","getXml","linefeed","XMLSerializer","xmlSerializer","serializeToString","extractTextWithWhitespace","elems","blocks","doExtract","elts","elem","nodeValue","replaceTrailingNewlines","postfix","innerText","serializer","getOuterHtml","outerHTML","br","count","label","para","addTransparentBackgroundFilter","linkAction","editor","action","pad","execute","linkInvoke","functName","color","textDecoration","paddingLeft","getDocumentSize","fit","ds","offsetLeft","offsetWidth","offset","getDocumentScrollOrigin","sl","st","right","offsetTop","bottom","url","mxXmlRequest","send","onload","onerror","binary","ontimeout","setBinary","getAll","urls","remain","errors","status","getStatus","post","submit","simulate","loadInto","onreadystatechange","readyState","getNumber","getColor","transients","equalPoints","equalEntries","removeDuplicates","dict","superCtor","output","toRadians","deg","PI","toDegree","rad","arcToCurves","x0","y0","angle","largeArcFlag","sweepFlag","fS","psai","abs","sds","cty","cpsi","cos","spsi","sin","rxd","ryd","rxdd","rydd","r1x","r2y","lamda","sqrt","seif","txd","tyd","tx","ty","atan2","s1","dr","sse","seg","segr","cpsir1","cpsir2","spsir1","spsir2","mc","ms","x2","y2","x3","y3","getBoundingBox","rotation","cx","p1","p2","p3","p4","getRotatedPoint","pt","x1","y1","getPortConstraints","terminal","edge","STYLE_PORT_CONSTRAINT","STYLE_SOURCE_PORT_CONSTRAINT","STYLE_TARGET_PORT_CONSTRAINT","directions","returnValue","DIRECTION_MASK_NONE","constraintRotationEnabled","STYLE_PORT_CONSTRAINT_ROTATION","STYLE_ROTATION","quad","DIRECTION_NORTH","DIRECTION_MASK_NORTH","DIRECTION_MASK_EAST","DIRECTION_MASK_SOUTH","DIRECTION_MASK_WEST","DIRECTION_WEST","DIRECTION_SOUTH","DIRECTION_EAST","reversePortConstraints","constraint","findNearestSegment","absolutePoints","dist","ptSegDistSq","getDirectedBounds","m","flipH","flipV","STYLE_DIRECTION","STYLE_FLIPH","STYLE_FLIPV","round","m2","getPerimeterPoint","pts","center","point","intersection","ip","distSq","rectangleIntersectsSegment","bounds","contains","intersects","tw","th","rw","rh","rx","ry","intersectsHotspot","hotspot","cy","STYLE_STARTSIZE","view","STYLE_HORIZONTAL","alpha","getOffset","container","scrollOffset","fixed","position","scrollLeft","wnd","defaultView","parentWindow","pageXOffset","pageYOffset","getScrollOrigin","includeAncestors","includeDocument","origin","convertPoint","chars","rtrim","isNumeric","isInteger","mod","denom","nume_a","nume_b","ua","ub","px","py","projlenSq","dotprod","lenSq","ptLineDist","relativeCcw","ccw","createImage","imageNode","borderStyle","sortCells","cells","ascending","lookup","o1","o2","mxCellPath","PATH_SEPARATOR","compare","getStylename","pairs","stylename","getStylenames","indexOfStylename","tokens","addStylename","removeStylename","removeAllStylenames","setCellStyles","beginUpdate","setStyle","endUpdate","isValue","sep","setCellStyleFlags","flag","setStyleFlag","cont","getAlignmentAsPoint","align","valign","ALIGN_CENTER","ALIGN_RIGHT","ALIGN_MIDDLE","ALIGN_BOTTOM","getSizeForString","fontSize","fontFamily","textWidth","DEFAULT_FONTSIZE","DEFAULT_FONTFAMILY","div","lineHeight","LINE_HEIGHT","zoom","whiteSpace","size","getViewXml","getModel","getRoot","eventsEnabled","isEventsEnabled","setEventsEnabled","drawPane","overlayPane","dialect","DIALECT_SVG","NS_SVG","canvas","translate","getTranslate","temp","mxTemporaryCellStates","enc","mxCodec","encode","getScaleForPageCount","pageCount","pageFormat","border","PAGE_FORMAT_A4_PORTRAIT","availablePageWidth","availablePageHeight","graphBounds","getGraphBounds","sc","getScale","graphWidth","graphHeight","pageFormatAspectRatio","graphAspectRatio","pagesAspectRatio","pageRoot","pagesAspectRatioSqrt","numRowPages","numColumnPages","scaleChange","currentTotalPages","numLoops","roundRowDownProportion","roundColumnDownProportion","posterWidth","links","outer","ownerSVGElement","minWidth","minHeight","printScreen","print","focus","isInternalWindow","prompt","confirm","icon","padding","img","makeDraggable","graphF","dragElement","autoscroll","scalePreview","highlightDropTargets","getDropTarget","dragSource","mxDragSource","dragOffset","TOOLTIP_VERTICAL_OFFSET","setGuidesEnabled","getGraphForEvent","createDragElement","createPreviewElement","DEFAULT_HOTSPOT","MIN_HOTSPOT_SIZE","MAX_HOTSPOT_SIZE","RENDERING_HINT_EXACT","RENDERING_HINT_FASTER","RENDERING_HINT_FASTEST","DIALECT_VML","DIALECT_MIXEDHTML","DIALECT_PREFERHTML","DIALECT_STRICTHTML","NS_XHTML","NS_XLINK","SHADOWCOLOR","VML_SHADOWCOLOR","SHADOW_OFFSET_X","SHADOW_OFFSET_Y","SHADOW_OPACITY","NODETYPE_ATTRIBUTE","NODETYPE_CDATA","NODETYPE_ENTITY_REFERENCE","NODETYPE_ENTITY","NODETYPE_PROCESSING_INSTRUCTION","NODETYPE_COMMENT","NODETYPE_DOCUMENT","NODETYPE_DOCUMENTTYPE","NODETYPE_DOCUMENT_FRAGMENT","NODETYPE_NOTATION","DEFAULT_VALID_COLOR","DEFAULT_INVALID_COLOR","OUTLINE_HIGHLIGHT_COLOR","OUTLINE_HIGHLIGHT_STROKEWIDTH","HIGHLIGHT_STROKEWIDTH","HIGHLIGHT_SIZE","HIGHLIGHT_OPACITY","CURSOR_MOVABLE_VERTEX","CURSOR_MOVABLE_EDGE","CURSOR_LABEL_HANDLE","CURSOR_TERMINAL_HANDLE","CURSOR_BEND_HANDLE","CURSOR_VIRTUAL_BEND_HANDLE","CURSOR_CONNECT","HIGHLIGHT_COLOR","CONNECT_TARGET_COLOR","INVALID_CONNECT_TARGET_COLOR","DROP_TARGET_COLOR","VALID_COLOR","INVALID_COLOR","EDGE_SELECTION_COLOR","VERTEX_SELECTION_COLOR","VERTEX_SELECTION_STROKEWIDTH","EDGE_SELECTION_STROKEWIDTH","VERTEX_SELECTION_DASHED","EDGE_SELECTION_DASHED","GUIDE_COLOR","GUIDE_STROKEWIDTH","OUTLINE_COLOR","OUTLINE_STROKEWIDTH","HANDLE_SIZE","LABEL_HANDLE_SIZE","HANDLE_FILLCOLOR","HANDLE_STROKECOLOR","LABEL_HANDLE_FILLCOLOR","CONNECT_HANDLE_FILLCOLOR","LOCKED_HANDLE_FILLCOLOR","OUTLINE_HANDLE_FILLCOLOR","OUTLINE_HANDLE_STROKECOLOR","DEFAULT_TEXT_DIRECTION","WORD_WRAP","ABSOLUTE_LINE_HEIGHT","DEFAULT_FONTSTYLE","DEFAULT_STARTSIZE","DEFAULT_MARKERSIZE","DEFAULT_IMAGESIZE","ENTITY_SEGMENT","RECTANGLE_ROUNDING_FACTOR","LINE_ARCSIZE","ARROW_SPACING","ARROW_WIDTH","ARROW_SIZE","PAGE_FORMAT_A4_LANDSCAPE","PAGE_FORMAT_LETTER_PORTRAIT","PAGE_FORMAT_LETTER_LANDSCAPE","STYLE_PERIMETER","STYLE_SOURCE_PORT","STYLE_TARGET_PORT","STYLE_OPACITY","STYLE_FILL_OPACITY","STYLE_STROKE_OPACITY","STYLE_TEXT_OPACITY","STYLE_TEXT_DIRECTION","STYLE_OVERFLOW","STYLE_ORTHOGONAL","STYLE_EXIT_X","STYLE_EXIT_Y","STYLE_EXIT_DX","STYLE_EXIT_DY","STYLE_EXIT_PERIMETER","STYLE_ENTRY_X","STYLE_ENTRY_Y","STYLE_ENTRY_DX","STYLE_ENTRY_DY","STYLE_ENTRY_PERIMETER","STYLE_WHITE_SPACE","STYLE_FILLCOLOR","STYLE_POINTER_EVENTS","STYLE_SWIMLANE_FILLCOLOR","STYLE_MARGIN","STYLE_GRADIENTCOLOR","STYLE_GRADIENT_DIRECTION","STYLE_STROKECOLOR","STYLE_SEPARATORCOLOR","STYLE_STROKEWIDTH","STYLE_ALIGN","STYLE_VERTICAL_ALIGN","STYLE_LABEL_WIDTH","STYLE_LABEL_POSITION","STYLE_VERTICAL_LABEL_POSITION","STYLE_IMAGE_ASPECT","STYLE_IMAGE_ALIGN","STYLE_IMAGE_VERTICAL_ALIGN","STYLE_GLASS","STYLE_IMAGE","STYLE_IMAGE_WIDTH","STYLE_IMAGE_HEIGHT","STYLE_IMAGE_BACKGROUND","STYLE_IMAGE_BORDER","STYLE_NOLABEL","STYLE_NOEDGESTYLE","STYLE_LABEL_BACKGROUNDCOLOR","STYLE_LABEL_BORDERCOLOR","STYLE_LABEL_PADDING","STYLE_INDICATOR_SHAPE","STYLE_INDICATOR_IMAGE","STYLE_INDICATOR_COLOR","STYLE_INDICATOR_STROKECOLOR","STYLE_INDICATOR_GRADIENTCOLOR","STYLE_INDICATOR_SPACING","STYLE_INDICATOR_WIDTH","STYLE_INDICATOR_HEIGHT","STYLE_INDICATOR_DIRECTION","STYLE_SHADOW","STYLE_SEGMENT","STYLE_ENDARROW","STYLE_STARTARROW","STYLE_ENDSIZE","STYLE_SWIMLANE_LINE","STYLE_ENDFILL","STYLE_STARTFILL","STYLE_DASHED","STYLE_DASH_PATTERN","STYLE_FIX_DASH","STYLE_ROUNDED","STYLE_CURVED","STYLE_ARCSIZE","STYLE_ABSOLUTE_ARCSIZE","STYLE_SOURCE_PERIMETER_SPACING","STYLE_TARGET_PERIMETER_SPACING","STYLE_PERIMETER_SPACING","STYLE_SPACING","STYLE_SPACING_TOP","STYLE_SPACING_LEFT","STYLE_SPACING_BOTTOM","STYLE_SPACING_RIGHT","STYLE_ANCHOR_POINT_DIRECTION","STYLE_ELBOW","STYLE_FONTCOLOR","STYLE_FONTFAMILY","STYLE_FONTSIZE","STYLE_FONTSTYLE","STYLE_ASPECT","STYLE_AUTOSIZE","STYLE_FOLDABLE","STYLE_EDITABLE","STYLE_BACKGROUND_OUTLINE","STYLE_BENDABLE","STYLE_MOVABLE","STYLE_RESIZABLE","STYLE_RESIZE_WIDTH","STYLE_RESIZE_HEIGHT","STYLE_ROTATABLE","STYLE_CLONEABLE","STYLE_DELETABLE","STYLE_SHAPE","STYLE_EDGE","STYLE_JETTY_SIZE","STYLE_SOURCE_JETTY_SIZE","STYLE_TARGET_JETTY_SIZE","STYLE_LOOP","STYLE_ORTHOGONAL_LOOP","STYLE_ROUTING_CENTER_X","STYLE_ROUTING_CENTER_Y","FONT_BOLD","FONT_ITALIC","FONT_UNDERLINE","SHAPE_RECTANGLE","SHAPE_ELLIPSE","SHAPE_DOUBLE_ELLIPSE","SHAPE_RHOMBUS","SHAPE_LINE","SHAPE_IMAGE","SHAPE_ARROW","SHAPE_ARROW_CONNECTOR","SHAPE_LABEL","SHAPE_CYLINDER","SHAPE_SWIMLANE","SHAPE_CONNECTOR","SHAPE_ACTOR","SHAPE_CLOUD","SHAPE_TRIANGLE","SHAPE_HEXAGON","ARROW_CLASSIC","ARROW_CLASSIC_THIN","ARROW_BLOCK","ARROW_BLOCK_THIN","ARROW_OPEN","ARROW_OPEN_THIN","ARROW_OVAL","ARROW_DIAMOND","ARROW_DIAMOND_THIN","ALIGN_LEFT","ALIGN_TOP","TEXT_DIRECTION_DEFAULT","TEXT_DIRECTION_AUTO","TEXT_DIRECTION_LTR","TEXT_DIRECTION_RTL","DIRECTION_MASK_ALL","ELBOW_VERTICAL","ELBOW_HORIZONTAL","EDGESTYLE_ELBOW","EDGESTYLE_ENTITY_RELATION","EDGESTYLE_LOOP","EDGESTYLE_SIDETOSIDE","EDGESTYLE_TOPTOBOTTOM","EDGESTYLE_ORTHOGONAL","EDGESTYLE_SEGMENT","PERIMETER_ELLIPSE","PERIMETER_RECTANGLE","PERIMETER_RHOMBUS","PERIMETER_HEXAGON","PERIMETER_TRIANGLE","mxEventObject","properties","mxMouseEvent","sourceState","mxEventSource","eventSource","setEventSource","consumed","getName","getProperties","getProperty","isConsumed","consume","graphX","graphY","getEvent","getSource","isSource","getX","getClientX","getY","getClientY","getGraphX","getGraphY","getCell","isPopupTrigger","preventDefault","isMouseEvent","eventListeners","getEventSource","removeListener","fireEvent","listen","updateListenerList","eventName","mxListenerList","entry","attachEvent","updateListener","listenerCount","detachEvent","removeAllListeners","addGestureListeners","startListener","moveListener","endListener","removeGestureListeners","redirectMouseEvents","down","move","up","dblClick","fireMouseEvent","MOUSE_DOWN","MOUSE_MOVE","MOUSE_UP","release","addMouseWheelListener","wheelHandler","delta","detail","wheelDelta","disableContextMenu","srcElement","isTouchEvent","pointerType","MSPOINTER_TYPE_TOUCH","mozInputSource","isPenEvent","MSPOINTER_TYPE_PEN","isMultiTouchEvent","touches","MSPOINTER_TYPE_MOUSE","isLeftMouseButton","buttons","which","isMiddleMouseButton","isRightMouseButton","isControlDown","isShiftDown","isMetaDown","isAltDown","shiftKey","ctrlKey","metaKey","getMainEvent","changedTouches","clientX","clientY","stopPropagation","cancelBubble","LABEL_HANDLE","ROTATION_HANDLE","CUSTOM_HANDLE","VIRTUAL_HANDLE","ACTIVATE","RESIZE_START","RESIZE","MOVE_START","MOVE","MOVE_END","PAN_START","PAN","PAN_END","MINIMIZE","HIDE","SHOW","CLOSE","DESTROY","REFRESH","SIZE","SELECT","FIRED","FIRE_MOUSE_EVENT","GESTURE","TAP_AND_HOLD","GET","RECEIVE","CONNECT","DISCONNECT","SUSPEND","RESUME","MARK","ROOT","POST","OPEN","SAVE","BEFORE_ADD_VERTEX","ADD_VERTEX","AFTER_ADD_VERTEX","DONE","EXECUTE","EXECUTED","BEGIN_UPDATE","START_EDIT","END_UPDATE","END_EDIT","BEFORE_UNDO","UNDO","REDO","CHANGE","NOTIFY","LAYOUT_CELLS","CLICK","SCALE","TRANSLATE","SCALE_AND_TRANSLATE","UP","DOWN","ADD","REMOVE","CLEAR","ADD_CELLS","CELLS_ADDED","MOVE_CELLS","CELLS_MOVED","RESIZE_CELLS","CELLS_RESIZED","TOGGLE_CELLS","CELLS_TOGGLED","ORDER_CELLS","CELLS_ORDERED","REMOVE_CELLS","CELLS_REMOVED","GROUP_CELLS","UNGROUP_CELLS","REMOVE_CELLS_FROM_PARENT","FOLD_CELLS","CELLS_FOLDED","ALIGN_CELLS","LABEL_CHANGED","CONNECT_CELL","CELL_CONNECTED","SPLIT_EDGE","FLIP_EDGE","START_EDITING","EDITING_STARTED","EDITING_STOPPED","ADD_OVERLAY","REMOVE_OVERLAY","UPDATE_CELL_SIZE","ESCAPE","DOUBLE_CLICK","START","RESET","username","password","withCredentials","request","decodeSimulateValues","isBinary","responseText","getDocumentElement","responseXML","XMLHttpRequest","overrideMimeType","onreadystatechaange","setRequestHeaders","setRequestHeader","onbeforeunload","form","pars","decodeURIComponent","mxClipboard","STEPSIZE","insertCount","setCells","getCells","isEmpty","cut","removeCells","getSelectionCells","getExportableCells","getTopmostCells","cloneCells","paste","getImportableCells","getDefaultParent","importCells","setSelectionCells","minimizable","movable","replaceNode","installMaximizeHandler","installMinimizeHandler","installCloseHandler","setMinimizable","setTitle","installMoveHandler","replaceChild","mxForm","className","mxImage","mxDivResizer","resizeWidth","resizeHeight","handlingResize","dropHandler","mouseDown","eventConsumer","evtName","me","mxToolbar","mxUndoableEdit","significant","mxUndoManager","closeImage","minimizeImage","normalizeImage","maximizeImage","resizeImage","minimumSize","contentHeightCorrection","touchAction","contentWrapper","activator","scrollable","activeWindow","zIndex","previousWindow","isResizable","resizable","startX","startY","dragHandler","setSize","minimize","getMinimumSize","marginLeft","minimized","maxDisplay","maximize","minSize","maximizable","maximized","minDisplay","docHeight","setLocation","closeImg","setImage","image","marginRight","marginTop","closable","getTable","addButtons","okFunct","cancelFunct","addText","input","addField","addCheckbox","checked","addTextarea","rows","addCombo","isMultiSelect","select","addOption","combo","isSelected","getDocumentWidth","getDocumentHeight","previewElement","enabled","currentGraph","currentDropTarget","currentPoint","currentGuide","currentHighlight","guidesEnabled","gridEnabled","dragElementZIndex","dragElementOpacity","checkEventSource","setEnabled","isGuidesEnabled","isGridEnabled","setGridEnabled","getCellAt","isActive","mouseMoveHandler","reset","dragExit","removeDragElement","removeListeners","stopDrag","startDrag","mouseMove","mouseUpHandler","mouseUp","pointerEvents","getElementForEvent","elementFromPoint","graphContainsEvent","dragEnter","dragOver","drop","isMouseDown","isMouseTrigger","mxGuide","graphHandler","getGuideStates","mxCellHighlight","panDx","panDy","autoScroll","scrollPointToVisible","autoExtend","isDropEnabled","highlight","isGridEnabledEvent","hideGuide","isEnabledForEvent","off","gridSize","snap","previewOffset","dropTarget","noReset","updateDefaultMode","addItem","pressedIcon","factoryMethod","initialClassName","mouseHandler","backgroundColor","menu","mxPopupMenu","currentImg","isMenuShowing","hideMenu","addActionCombo","addSwitchMode","altIcon","selectedMode","defaultMode","selectMode","addMode","toggle","defaultFunction","domNode","resetMode","forced","addSeparator","addBreak","addLine","hr","undone","redone","isSignificant","die","undo","redo","history","indexOfNextAdd","canUndo","edit","canRedo","undoableEditHappened","undoableEdit","edits","mxUrlConverter","mxPanningManager","thread","tdx","tdy","t0x","t0y","scrollbars","mouseListener","stop","addMouseListener","mouseUpListener","createThread","setInterval","panGraph","getDx","getDy","panTo","handleMouseOut","damper","clearInterval","setTranslate","removeMouseListener","mxAutoSaveManager","changeHandler","graphModelChanged","setGraph","mxAnimation","mxMorphing","steps","ease","mxImageBundle","alt","images","mxImageExport","mxAbstractCanvas2D","converter","createUrlConverter","mxXmlCanvas2D","writeDefaults","mxSvgCanvas2D","styleEnabled","gradients","defs","createStyle","baseUrl","baseDomain","updateBaseUrl","protocol","host","pathname","lastIndexOf","getBaseUrl","setBaseUrl","getBaseDomain","setBaseDomain","isRelativeUrl","convert","submenuImage","useLeftButtonForPopup","itemCount","autoExpand","smartSeparators","labels","iconCls","willAddSeparator","containsItems","col1","col2","col3","paddingRight","textAlign","createSubmenu","currentSelection","eventReceiver","activeRow","hideSubmenu","showSubmenu","createRange","addCheckmark","backgroundImage","backgroundRepeat","backgroundPosition","row","showMenu","autoSaveDelay","autoSaveThrottle","autoSaveThreshold","ignoredChanges","lastSnapshot","save","isRunning","startAnimation","updateAnimation","stopAnimation","mxCellStatePreview","animateCell","recurse","getDelta","isVertex","moveState","stopRecursion","getOriginForCell","getParent","geo","getCellGeometry","relative","pgeo","putImage","getImage","includeOverlays","drawState","visitStatesRecursive","drawCellState","drawOverlays","getLinkForCellState","setLink","drawShape","drawText","mxShape","checkBounds","paint","restore","overlays","states","rotateHtml","lastX","lastY","moveOp","lineOp","quadOp","curveOp","closeOp","createState","fillAlpha","strokeAlpha","fillColor","gradientFillAlpha","gradientColor","gradientAlpha","gradientDirection","strokeColor","strokeWidth","dashed","dashPattern","fixDash","lineCap","lineJoin","miterLimit","fontColor","fontBackgroundColor","fontBorderColor","fontStyle","shadow","shadowColor","shadowAlpha","shadowDx","shadowDy","rotationCx","rotationCy","format","addOp","rotatePoint","theta","rotate","setAlpha","setFillAlpha","setStrokeAlpha","setFillColor","setGradient","color1","color2","direction","alpha1","alpha2","setStrokeColor","setStrokeWidth","setDashed","setDashPattern","setLineCap","setLineJoin","setMiterLimit","setFontColor","setFontBackgroundColor","setFontBorderColor","setFontSize","setFontFamily","setFontStyle","setShadow","setShadowColor","setShadowAlpha","setShadowOffset","begin","moveTo","lineTo","quadTo","curveTo","arcTo","curves","textEnabled","compressed","toFixed","roundrect","ellipse","aspect","wrap","clip","stroke","fill","fillAndStroke","useDomParser","matchHtmlAlignment","foEnabled","foAltText","foOffset","textOffset","imageOffset","strokeTolerance","minStrokeWidth","refCount","blockImagePointerEvents","lineHeightCorrection","pointerEventsValue","fontMetricsPadding","cacheOffsetSize","createAlternateContent","fo","createGradientId","getSvgGradient","gradient","tmpId","getElementById","createSvgGradient","op","addNode","filled","stroked","updateFill","updateStroke","createShadow","createTolerance","originalRoot","IS_CHROME_APP","getCurrentStrokeWidth","sw","updateStrokeAttributes","createDashPattern","pat","tol","convertHtml","xd","xb","adoptNode","ta","createDiv","lh","invalidateCachedOffsetSize","mxCachedOffsetWidth","mxCachedFinalOffsetWidth","mxCachedFinalOffsetHeight","updateText","group","maxHeight","maxWidth","ow","oh","padX","sizeDiv","padY","wordWrap","ws","div2","padDx","plainText","createClip","updateFont","anchor","textHeight","addTextBackground","bbox","getBBox","ie","fontWeight","mxVmlCanvas2D","setStates","stencil","initStyles","mxStencil","desc","parseDescription","parseConstraints","rotatedHtmlBackground","vmlScale","createVmlElement","coordsize","strokeweight","strokecolor","createStroke","createFill","createTransparentFill","flip","endcap","joinstyle","miterlimit","dashstyle","getVmlDashStyle","tok","createShadowStroke","createShadowFill","cpx0","cpy0","qpx1","qpy1","cpx3","cpy3","cpx1","cpy1","cpx2","cpy2","createRect","box","margin","inner","rot","real_cos","real_sin","top_fix","left_fix","divParent","textpathok","tp","horizontal","vertical","guideX","guideY","rounded","getGuideTolerance","createGuideShape","guide","mxPolyline","isDashed","trx","overrideX","stateX","valueX","overrideY","stateY","valueY","tt","ttX","ttY","middle","snapX","override","getOverlayPane","snapY","points","getGuideColor","scrollWidth","antiAlias","minSvgStrokeWidth","boundingBox","svgStrokeTolerance","svgPointerEvents","shapePointerEvents","stencilPointerEvents","outline","useSvgBoundingBox","strokewidth","fillOpacity","strokeOpacity","isParseVml","isHtmlAllowed","getSvgScreenOffset","createSvg","createHtml","createVml","reconfigure","updateBoundsFromPoints","redrawShape","redrawHtmlShape","updateBoundingBox","lastChild","getLabelBounds","isPaintBoundsInverted","getLabelMargins","createVmlGroup","createCanvas","insertAdjacentHTML","destroyCanvas","createSvgCanvas","updateVmlContainer","createVmlCanvas","updateHtmlBounds","updateHtmlFilters","updateHtmlColors","isShadow","east","south","west","north","borderColor","borderWidth","setTransparentBackgroundImage","mxRefCount","releaseSvgGradients","oldGradients","strokeDrawn","updateTransform","configureCanvas","bg","bb","createBoundingBox","createTransparentSvgRectangle","paintEdgeShape","paintVertexShape","getGradientBounds","getShapeRotation","paintBackground","paintForeground","getArcSize","paintGlassEffect","arc","isRounded","addPoints","arcSize","initialMove","pe","p0","wp","nx1","ny1","nx2","ny2","resetStyles","spacing","startSize","endSize","startArrow","endArrow","glass","setCursor","getCursor","isRoundable","augmentBoundingBox","getRotation","getTextRotation","mxText","verticalTextRotation","grads","defaultLocalized","allowEval","constraints","w0","h0","bgNode","fgNode","conns","parseConstraint","perimeter","mxConnectionConstraint","evaluateTextAttribute","attribute","evaluateAttribute","loc","computeAspect","minScale","drawChildren","disableShadow","drawNode","inverse","parseRegularly","pointCount","segs","childName","ps","arcsize","factor","mxStencilRegistry","getStencil","stencils","addStencil","mxMarker","markers","addMarker","createMarker","unitX","unitY","mxActor","mxCloud","mxRectangleShape","mxEllipse","mxDoubleEllipse","mxRhombus","mxArrow","arrowWidth","mxArrowConnector","arrowSpacing","family","spacingTop","spacingRight","spacingBottom","spacingLeft","background","clipped","labelPadding","textDirection","updateMargin","mxTriangle","mxHexagon","mxLine","mxImageShape","mxLabel","mxCylinder","mxConnector","mxSwimlane","mxGraphLayout","WeightedCellSorter","weightedValue","mxStackLayout","mxPartitionLayout","mxCompactTreeLayout","invert","mxRadialTreeLayout","mxFastOrganicLayout","mxCircleLayout","radius","mxParallelEdgeLayout","mxCompositeLayout","layouts","master","mxEdgeLabelLayout","mxGraphAbstractHierarchyCell","mxGraphHierarchyNode","connectsAsTarget","connectsAsSource","mxGraphHierarchyEdge","ids","mxGraphHierarchyModel","layout","vertices","roots","tightenToSource","getGraph","vertexMapper","edgeMapper","maxRank","internalVertices","getChildVertices","SOURCESCANSTARTRANK","createInternalCells","internalEdge","realEdges","realEdge","targetCell","getVisibleTerminal","internalTargetCell","mxSwimlaneModel","mxHierarchicalLayoutStage","mxMedianHybridCrossingReduction","MedianCellSorter","mxMinimumCycleRemover","mxCoordinateAssignment","intraCellSpacing","interRankCellSpacing","orientation","initialX","parallelEdgeSpacing","mxSwimlaneOrdering","mxHierarchicalLayout","deterministic","createArrow","widthFactor","endOffsetX","endOffsetY","createOpenArrow","diamond","swFactor","tk","redrawPath","hw","hh","prev","paintLine","paintCurvedLine","ix","iy","arrow","nx","ny","basex","basey","floorx","floory","p0x","p0y","p1x","p1y","p2x","p2y","p3x","p3y","p5x","p5y","getEdgeWidth","isMarkerStart","getStartArrowWidth","isMarkerEnd","getEndArrowWidth","startWidth","endWidth","edgeWidth","openEnded","isOpenEnded","markerStart","markerEnd","isArrowRounded","i0","orthx","orthy","startNx","startNy","paintMarker","outStartX","outStartY","inEndX","inEndY","dx1","dy1","dist1","tmp1","dist2","strokeWidthFactor","angleFactor","outX","outY","inX","inY","c1x","c1y","c2x","c2y","inStartX","inStartY","ptX","ptY","widthArrowRatio","spaceX","spaceY","baseSpacingTop","baseSpacingBottom","baseSpacingLeft","baseSpacingRight","replaceLinefeeds","ignoreClippedStringSize","ignoreStringSize","textWidthPadding","lastValue","cacheEnabled","unscaledWidth","lastUnscaledWidth","realHtml","fmt","getAutoDirection","updateSize","textDiv","updateHtmlFilter","updateHtmlTransform","updateInnerHtml","divs","unrotatedBoundingBox","updateValue","bd","enableWrap","getSpacing","mid","preserveImageAspect","useVml","imageSize","indicatorSize","indicatorSpacing","indicatorShape","indicator","indicatorColor","indicatorStrokeColor","indicatorGradientColor","indicatorDirection","paintImage","paintIndicator","getImageBounds","getIndicatorBounds","indicatorImage","getCylinderSize","isForeground","sourceMarker","targetMarker","getTitleSize","isHorizontal","shapeVertical","realHorizontal","realFlipH","realFlipV","swimlaneLine","paintRoundedSwimlane","paintSwimlane","paintSeparator","paintDivider","useBoundingBox","moveCell","getConstraint","getCellStyle","vertex","directed","func","visited","edgeCount","getEdgeCount","getEdgeAt","getTerminal","isAncestor","traverseAncestors","isVertexMovable","isCellMovable","isVertexIgnored","isCellVisible","isEdgeIgnored","setEdgeStyleEnabled","setOrthogonalEdge","getParentOffset","parentGeo","getGeometry","setEdgePoints","mxGeometry","setRelative","parentOffset","setGeometry","setVertexLocation","getVertexBounds","dx0","dy0","arrangeGroups","topBorder","rightBorder","bottomBorder","leftBorder","updateGroupBounds","nudge","rankIndex","marginBottom","keepFirstLocation","resizeParent","resizeParentMax","resizeLast","borderCollapse","allowGaps","pstate","getIndex","getParentSize","isLayer","currentRoot","getLayoutCells","c1","c2","geo1","geo2","fillValue","isSwimlane","horz","childStyle","setChildGeometry","isCellCollapsed","updateParentGeometry","pgeo2","resizeVertices","other","getStartSize","maintainParentLocation","groupPadding","groupPaddingTop","groupPaddingRight","groupPaddingBottom","groupPaddingLeft","parentsChanged","moveTree","levelDistance","nodeDistance","resetEdges","prefHozEdgeSep","prefVertEdgeOff","minEdgeJetty","channelBuffer","edgeRouting","sortEdges","alignRanks","maxRankHeight","getConnections","findTreeRoots","parentX","parentY","dfs","findRankHeights","setCellHeights","g","horizontalLayout","verticalLayout","moveNode","adjustParents","localEdgeProcessing","sortOutgoingEdges","e1","e2","end1","end2","rank","createNode","attachParent","layoutLeaf","offsetX","offsetY","siblingOffset","contour","upperHead","createLine","lowerHead","upperTail","lowerTail","sum","merge","total","upper","lower","bridge","a1","a2","line1","line2","line","processNodeOutgoing","parentCell","sortedCells","sortingCriterion","availableWidth","requiredWidth","edgeSpacing","currentXOffset","currentYOffset","maxYOffset","parentBounds","childCell","childBounds","getEdgesBetween","newPoints","angleOffset","rootx","rooty","autoRadius","rowMinX","rowMaxX","rowMinCenX","rowMaxCenX","rowRadi","rootBounds","centerX","centerY","vertexBounds","calcRowDims","maxLeftGrad","maxRightGrad","leftGrad","rightGrad","xLeftLimit","xRightLimit","fullWidth","xProportion","totalTheta","averTheta","nextTheta","lastTheta","rowNum","rowHasChildren","useInputOrigin","disableEdgeStyle","forceConstant","forceConstantSquared","minDistanceLimit","maxDistanceLimit","minDistanceLimitSquared","initialTemp","temperature","maxIterations","iteration","vertexArray","dispX","dispY","cellLocation","radiusSquared","isMoveable","neighbours","indices","allowedToRun","initialBounds","getBoundingBoxFromGeometry","getOpposites","resetEdge","calcRepulsion","calcAttraction","calcPositions","reduceTemperature","minx","miny","moveCells","deltaLength","newXDisp","newYDisp","xDelta","yDelta","deltaLengthSquared","displacementX","displacementY","vertexCount","random","deltaLengthWithRadius","moveCircle","getRadius","circle","phi","findParallels","parallels","getEdgeId","trg","route","scx","scy","tcx","tcy","placeLabels","avoid","labRect","dy2","dx2","minRank","nextLayerConnectedCells","previousLayerConnectedCells","getNextLayerConnectedCells","layer","getPreviousLayerConnectedCells","getGeneralPurposeVariable","setGeneralPurposeVariable","setX","setY","hashCode","getRankValue","otherNode","getCoreCell","isReversed","ranks","dfsCount","undirectedEdges","directedEdges","initialRank","startNodes","internalNode","internalNodes","startNodesCopy","edgesToBeMarked","layerDeterminingEdges","allEdgesScanned","minimumLayer","removedCell","currentMaxLayer","fixRanks","rankList","rootsArray","oldRootsArray","parentToCellRankDifference","dfsRoots","trackAncestors","seenNodes","extendedDfs","connectingEdge","rootId","outgoingEdges","targetNode","ancestors","childHash","hashCodeLength","ranksPerGroup","swimlanes","swimlaneIndex","ii","maxChainDfs","lowerRank","upperRank","chainCount","slIndex","incomingEdges","nestedBestRanks","currentBestCrossings","iterationsWithoutImprovement","maxNoImprovementIterations","calculateCrossings","weightedMedian","transpose","candidateCrossings","numRanks","totalCrossings","calculateRankCrossing","previousRank","tmpIndices","rankPosition","connectedCells","nodeIndices","connectedNode","otherCellRankPosition","firstIndex","treeSize","treeIndex","mainLoopIteration","improved","maxCount","orderedCells","tempRank","leftCellAboveConnections","leftCellBelowConnections","rightCellAboveConnections","rightCellBelowConnections","leftAbovePositions","leftBelowPositions","rightAbovePositions","rightBelowPositions","leftCell","rightCell","totalCurrentCrossings","totalSwitchedCrossings","ik","downwardSweep","medianRank","rankValue","numCellsForRank","medianValues","reservedPositions","nextLevelConnectedCells","nextRankValue","sorterEntry","medianValue","arrayCount","medianPoint","leftMedian","rightMedian","unseenNodesArray","unseenNodes","modelRoots","seenNodesCopy","jettyPositions","limitX","currentXDelta","widestRank","rankTopY","rankBottomY","widestRankValue","rankWidths","rankY","fineTuning","nextLayerConnectedCache","previousLayerConnectedCache","printStatus","initialCoords","minNode","bestXDelta","medianPos","minPath","setCellLocations","nodeList","nodeWrapper","maxTries","tolerance","cellWrapper","numNextLayerConnected","numPreviousLayerConnected","medianNextLevel","medianXValue","medianPreviousLevel","numConnectedNeighbours","currentPosition","cellMedian","positionChanged","leftLimit","rankSize","rightLimit","connectedCell","connectedCellWrapper","rankMedianPosition","weightedValues","cellMap","currentCell","calculatedWeightedValue","numConnectionsNextLevel","leftBuffer","rightBuffer","collection","totalWeight","facade","calculateWidestRank","rankCoordinates","localX","boundsWarning","numEdges","lastRankMaxCellHeight","maxCellHeight","distanceToNextRank","referenceX","edgeStraight","refSegCount","upSegCount","downSegCount","upXPositions","downXPositions","currentX","nextX","repositionValid","rankArray","MAX_VALUE","edgeStyle","mxHierarchicalEdgeStyle","ORTHOGONAL","POLYLINE","CURVE","setEdgePosition","cellIndex","currentCells","currentRank","sorter","connectedEdgeCount","connectedEdges","connections","innerCell","connIndex","connectedEdgeGroupCount","numActualEdges","parallelEdgeCount","jettys","layoutReversed","realSource","reversed","arrayOffset","jetty","modelSource","isPort","loopStart","loopLimit","loopDelta","positionX","topChannelY","bottomChannelY","modelTarget","realTarget","processReversedEdge","realCell","positionY","reversedOverSwimlane","cellId","STRAIGHT","mxSwimlaneLayout","mxGraphModel","currentEdit","createUndoableEdit","setRoot","mxRootChange","previousIndex","mxCollapseChange","collapsed","mxVisibleChange","mxCellAttributeChange","mxCell","onInit","moveParent","parentBorder","interHierarchySpacing","edgesCache","edgeSourceTermCache","edgesTargetTermCache","rootsCopy","findRoots","best","maxDiff","fanOut","fanIn","diff","cachedEdges","isCollapsed","terminalCache","term","hierarchyVertices","allVertexSet","filledVertexSet","filterDescendants","filledVertexSetEmpty","candidateRoots","vertexSet","cycleStage","layeringStage","crossingStage","placementStage","allVertices","currentComp","vertexID","edgeIsSource","netCount","isSource2","otherTerm","dummyVertices","dummyVertexWidth","getChildCells","insertVertex","layoutBounds","lane","childrenY","maxChildrenY","newGeo","leftGroupBorder","isValidAncestor","laneCounter","otherVertex","otherIndex","maintainEdgeParent","ignoreRelativeEdgeParent","createIds","nextId","updateLevel","endingUpdate","createRoot","isCreateIds","setCreateIds","filterCells","getDescendants","rootChanged","oldRoot","cellAdded","parentChanged","updateEdgeParents","getId","setId","createId","collision","updateEdgeParent","getNearestCommonAncestor","origin1","getOrigin","origin2","cell1","cell2","getParentPath","cellRemoved","parentForCellChanged","oldIndex","par","getChildren","getChildEdges","setTerminal","terminalChanged","setTerminals","terminalForCellChanged","insertEdge","removeEdge","getDirectedEdgeCount","outgoing","ignoredEdge","getIncomingEdges","getOutgoingEdges","incoming","includeLoops","tmp2","directedMatch","oppositeMatch","sources","targets","terminals","topmost","isConnectable","setValue","valueForCellChanged","valueChanged","geometryForCellChanged","styleForCellChanged","setCollapsed","collapsedStateForCellChanged","visibleStateForCellChanged","mergeChildren","cloneAllEdges","mapping","mergeChildrenImpl","getParents","parents","cloneCell","includeChildren","clones","cloneCellImpl","restoreClone","ident","cellCloned","cloneChild","connect","isConnect","connectable","mxTransient","newValue","setVertex","setEdge","setConnectable","setParent","removeFromParent","getEdgeIndex","isOutgoing","removeFromTerminal","userObject","cloneValue","TRANSLATE_CONTROL_POINTS","alternateBounds","sourcePoint","targetPoint","swap","getTerminalPoint","setTerminalPoint","ct","fixedAspect","t1","t2","mxPerimeter","RectanglePerimeter","orthogonal","pi","pi2","beta","tan","EllipsePerimeter","det","xout1","xout2","yout1","yout2","pow","xout","yout","RhombusPerimeter","TrianglePerimeter","corner","HexagonPerimeter","mxPrintPreview","pageSelector","pageScale","mxStylesheet","putDefaultVertexStyle","createDefaultVertexStyle","putDefaultEdgeStyle","createDefaultEdgeStyle","mxCellState","absoluteOffset","mxGraphSelectionModel","mxSelectionChange","selectionModel","added","mxCellEditor","zoomHandler","isEditing","editingCell","stopEditing","mxCellRenderer","autoOrigin","printOverlays","printControls","printBackgroundImage","targetWindow","clipping","getWindow","getDoctype","appendGraph","forcePageBreaks","keepOpen","previousInitializeOverlay","initializeOverlay","overlay","getDrawPane","initControl","control","handleEvents","clickHandler","isNewWindow","writeHead","currentScale","availableHeight","hpages","vpages","writePageSelector","createPageSelector","addPage","pageBreakAfter","addPageBreak","cov","getCoverPages","apx","getAppendices","pageNum","renderPage","addGraphFragment","insertBackgroundImage","closeDocument","writePostfix","js","pageNumber","pageBreakInside","innerDiv","viewport","previousContainer","getCanvas","backgroundPane","getBackgroundPane","graphEnabled","tempClip","rendering","orig","svgs","getLinkForCell","putCellStyle","getDefaultVertexStyle","getDefaultEdgeStyle","defaultStyle","tmpStyle","invalidStyle","invalid","visibleSourceState","visibleTargetState","terminalDistance","getPerimeterBounds","setAbsoluteTerminalPoint","getVisibleTerminalState","setVisibleTerminalState","terminalState","getCellBounds","cellBounds","getPaintBounds","paintBounds","updateCachedBounds","setState","doneResource","updatingSelectionResource","singleSelection","isSingleSelection","setSingleSelection","changeSelection","setCell","getFirstSelectableCell","isCellSelectable","addCell","addCells","removeCell","autoSize","selectText","emptyLabelText","escapeCancelsEditing","minResize","wordWrapPadding","blurEnabled","initialValue","contentEditable","isLegacyEditor","installListeners","applyValue","labelChanged","setAlign","getInitialValue","getEditingValue","getCurrentValue","isCancelEditingKeyEvent","focusLost","isStopEditingEvent","keyCode","keypressHandler","clearOnChange","getEmptyLabelText","keyupHandler","resizeThread","isEnterStopsCellEditing","isEventSource","lw","bds","hpos","vpos","legacySpacing","isWrapping","getEditorBounds","isInvokesStopCellEditing","getBackgroundColor","absoluteRoot","startEditing","tooltipHandler","hideTooltip","bold","italic","uline","isHideLabel","isSelectText","execCommand","cancel","blur","prepareTextarea","getEditingCell","defaultShapes","defaultEdgeShape","defaultVertexShape","defaultTextShape","legacyControlPosition","forceControlClickHandler","registerShape","initializeShape","configureShape","createShape","getShapeConstructor","createIndicatorShape","getShape","getIndicatorShape","getIndicatorColor","getIndicatorGradientColor","getIndicatorImage","postConfigureShape","resolveColor","checkPlaceholderStyles","field","referenced","getSwimlane","swimlaneIndicatorColorAttribute","rstate","getLabelValue","getLabel","createLabel","isForceHtml","isHtmlLabel","getVerticalAlign","isLabelClipped","initializeLabel","forceGetCell","isLabelEvent","nativeDblClickEnabled","createCellOverlays","getCellOverlays","installCellOverlayListeners","createControl","getFoldingImage","foldingEnabled","createControlClickHandler","collapse","foldCells","first","isShapeEvent","redrawLabel","wrapping","isTextShapeInvalid","nextScale","getTextScale","isClipping","vis","redrawLabelShape","check","dh","rotateLabelBounds","redrawCellOverlays","getBounds","redrawControl","getControlBounds","insertStateAfter","htmlNode","shapes","getShapesForState","shapeChanged","selectionCellsHandler","updateHandler","isShapeInvalid","doRedrawShape","mxEdgeStyle","EntityRelation","segment","isSourceLeft","sourceGeometry","isTargetLeft","targetGeometry","getRoutingCenterY","xe","ye","midY","Loop","transformControlPoint","getRoutingCenterX","ElbowConnector","SideToSide","TopToBottom","SegmentConnector","hints","lastPushed","hint","pushPoint","lastInx","newHints","currentTerm","currentPt","hozChan","vertChan","currentHint","fixedVertAlign","fixedHozAlign","inHozChan","inVertChan","orthBuffer","orthPointsFallback","dirVectors","wayPoints1","routePatterns","inlineRoutePatterns","vertexSeperations","limits","LEFT_MASK","TOP_MASK","RIGHT_MASK","BOTTOM_MASK","LEFT","TOP","RIGHT","BOTTOM","SIDE_MASK","CENTER_MASK","SOURCE_MASK","TARGET_MASK","VERTEX_MASK","getJettySize","OrthConnector","sourceEdge","targetEdge","sourceX","sourceY","sourceWidth","sourceHeight","targetX","targetY","targetWidth","targetHeight","scaledSourceBuffer","scaledTargetBuffer","totalBuffer","tooShort","portConstraint","newRect","sourceCenX","sourceCenY","targetCenX","targetCenY","sourceTopDist","sourceLeftDist","sourceBottomDist","sourceRightDist","dirPref","horPref","vertPref","preferredHorizDist","preferredVertDist","prefOrdering","preferredOrderSet","sourceIndex","targetIndex","routePattern","currentIndex","lastOrientation","initialOrientation","currentOrientation","nextDirection","directionIndex","sou","side","limit","souTar","deltaX","deltaY","targetOrientation","sameOrient","getRoutePattern","mxStyleRegistry","putValue","mxGraphView","mxCurrentRootChange","isUp","mxGraph","renderHint","stylesheet","mouseListeners","multiplicities","imageBundles","createCellRenderer","setSelectionModel","createSelectionModel","setStylesheet","createStylesheet","createGraphView","graphModelChangeListener","createHandlers","revalidate","mxCellOverlay","tooltip","mxOutline","mxMultiplicity","validNeighbors","countError","typeError","validNeighborsAllowed","mxLayoutManager","undoHandler","beforeUndo","moveHandler","cellsMoved","mxSwimlaneManager","addEnabled","resizeEnabled","addHandler","isAddEnabled","cellsAdded","isResizeEnabled","cellsResized","isCellVisibleFn","oldValidateCellState","validateCellState","oldBounds","oldStates","getStates","oldScale","oldDoRedrawShape","oldPaint","resurse","setScale","resetValidationState","validateCell","setGraphBounds","deltas","mxGraphHandler","panHandler","updatePreviewShape","updateHint","escapeHandler","refreshHandler","pBounds","getPreviewBounds","mxPanningHandler","forcePanningHandler","isForcePanningEvent","gestureHandler","eo","isPinchEnabled","initialScale","mouseDownEvent","maxScale","zoomTo","mxPopupMenuHandler","inTolerance","mxCellMarker","validColor","invalidColor","mxSelectionCellsHandler","refresh","getSelectionModel","mxConnectionHandler","mxConstraintHandler","resetHandler","currentFocus","mxRubberband","forceRubberbandHandler","isForceRubberbandEvent","repaint","mxHandle","mxVertexHandler","livePreview","invalidate","validate","mxEdgeHandler","isRendering","mxElbowEdgeHandler","mxEdgeSegmentHandler","mxKeyHandler","normalKeys","shiftKeys","controlKeys","controlShiftKeys","keydownHandler","keyDown","mxTooltipHandler","mxCellTracker","highlightColor","repaintHandler","mxDefaultKeyHandler","escape","hideProperties","mxDefaultPopupMenu","mxDefaultToolbar","mxEditor","actions","addActions","cycleAttributeValues","popupHandler","undoManager","createGraph","toolbar","createToolbar","keyHandler","configure","cycleAttributeName","EMPTY_POINT","updatingDocumentResource","captureDocumentGesture","optimizeVmlReflows","lastNode","lastHtmlNode","lastForegroundNode","lastForegroundHtmlNode","setCurrentRoot","sizeDidChange","scaleAndTranslate","previousScale","previousTranslate","viewStateChanged","removeState","includeEdges","invalidating","prevDisplay","getEmptyBounds","validateBackground","createBackgroundPageShape","validateBackgroundImage","validateBackgroundPage","getBackgroundImage","redrawBackgroundImage","pageVisible","getBackgroundPageBounds","backgroundPageShape","isHideOnHover","updateCellState","stateValidated","pState","getChildOffsetForCell","updateVertexState","updateEdgeState","updateVertexLabelOffset","updateFixedTerminalPoints","updatePoints","updateFloatingTerminalPoints","updateEdgeBounds","updateEdgeLabelOffset","fg","keepEdgesInForeground","keepEdgesInBackground","updateFixedTerminalPoint","getConnectionConstraint","getFixedTerminalPoint","getConnectionPoint","updateBoundsFromStencil","asp","getEdgeStyle","getTerminalPort","srcBounds","trgBounds","isLoopStyleEnabled","tc","defaultLoopStyle","isAllowEval","updateFloatingTerminalPoint","getFloatingTerminalPoint","getNextPoint","orth","isOrthogonal","getPerimeterFunction","opposite","markerSize","gx","gy","getRelativePoint","totalLength","minDist","xSegment","ySegment","projlen","yDistance","setRendering","setAllowEval","getCellStates","getDecoratorPane","decoratorPane","isContainerEvent","isScrollEvent","outWidth","inWidth","outHeight","inHeight","fireGestureEvent","popupMenuHandler","endHandler","createHtmlPane","updateContainerStyle","onResize","updateHtmlCanvasSize","pane","createVmlPane","getTranslateForRoot","cellEditor","portsEnabled","doubleTapEnabled","doubleTapTimeout","doubleTapTolerance","lastTouchY","lastTouchTime","tapAndHoldEnabled","tapAndHoldDelay","tapAndHoldInProgress","tapAndHoldValid","initialTouchX","initialTouchY","defaultOverlap","defaultParent","alternateEdgeStyle","pageBreaksVisible","pageBreakColor","pageBreakDashed","minPageBreakDist","preferPageSize","escapeEnabled","invokesStopCellEditing","enterStopsCellEditing","useScrollbarsForPanning","exportEnabled","importEnabled","cellsLocked","cellsCloneable","cellsEditable","cellsDeletable","cellsMovable","edgeLabelsMovable","vertexLabelsMovable","dropEnabled","splitEnabled","cellsResizable","cellsBendable","cellsSelectable","cellsDisconnectable","autoSizeCells","autoSizeCellsOnAdd","ignoreScrollbars","translateToScrollPosition","timerAutoScroll","allowAutoPanning","maximumGraphBounds","minimumGraphSize","minimumContainerSize","maximumContainerSize","resizeContainer","allowNegativeCoordinates","constrainChildren","constrainRelativeChildren","extendParents","extendParentsOnAdd","extendParentsOnMove","recursiveResize","collapseToPreferredSize","zoomFactor","keepSelectionVisibleOnZoom","centerZoom","resetViewOnRootChange","resetEdgesOnResize","resetEdgesOnMove","resetEdgesOnConnect","allowLoops","multigraph","connectableEdges","allowDanglingEdges","cloneInvalidEdges","disconnectOnMove","labelsVisible","htmlLabels","swimlaneSelectionEnabled","swimlaneNesting","minFitScale","maxFitScale","collapsedImage","expandedImage","warningImage","alreadyConnectedResource","containsValidationErrorsResource","collapseExpandResource","createCellEditor","createTooltipHandler","createSelectionCellsHandler","connectionHandler","createConnectionHandler","createGraphHandler","panningHandler","createPanningHandler","panningEnabled","createPopupMenuHandler","getStylesheet","getSelectionCellsForChanges","processChange","updateSelection","removeSelectionCells","setDefaultParent","removeStateForCell","newParent","home","addCellOverlay","removeCellOverlay","removeCellOverlays","clearCellOverlays","setCellWarning","warning","isSelect","setSelectionCell","startEditingAtCell","getSelectionCell","isCellEditable","convertValueToString","cellLabelChanged","isAutoSizeCell","cellSizeUpdated","click","mxe","isTransparentClickEvent","isCellSelected","selectCellForEvent","swimlane","isSwimlaneSelectionEnabled","getSwimlaneAt","isToggleEvent","tapAndHold","panningTrigger","marker","currentColor","markedState","mark","createEdgeState","panningManager","createPanningManager","getBorderSizes","borderLeftStyle","borderLeftWidth","paddingTop","borderTopStyle","borderTopWidth","borderRightStyle","borderRightWidth","paddingBottom","borderBottomStyle","borderBottomWidth","getPreferredPageSize","page","hCount","vCount","keepOrigin","ignoreWidth","ignoreHeight","getBorder","cssBorder","w1","h1","w2","h2","s2","doResizeContainer","updatePageBreaks","gb","horizontalCount","verticalCount","horizontalPageBreaks","verticalPageBreaks","drawPageBreaks","breaks","pageBreak","postProcessCellStyle","getImageFromBundles","encodeURIComponent","comma","setCellStyle","toggleCellStyle","toggleCellStyles","toggleCellStyleFlags","alignCells","param","resizeCell","flipEdge","addImageBundle","bundle","removeImageBundle","orderCells","back","cellsOrdered","groupCells","getCellsForGroup","createGroupCell","getBoundsForGroup","ungroupCells","removeCellsAfterUngroup","cellsRemoved","addAllEdges","removeCellsFromParent","moveGroup","allowInvalidEdges","keepPosition","trans","getEdgeValidationError","createVertex","createEdge","addEdge","absolute","constrain","parentState","zero","oldState","isAllowNegativeCoordinates","autoSizeCell","isExtendParentsOnAdd","isExtendParent","extendParent","constrainChild","cellConnected","updateCellSize","getDeletableCells","getAllEdges","disconnectTerminal","connected","tstate","splitEdge","newEdge","toggleCells","cellsToggled","checkFoldable","getFoldableCells","cellsFolded","isCellFoldable","swapBounds","willCollapse","updateAlternateBounds","getPreferredSizeForCell","allCells","ignoreChildren","cellStyle","gs2","resizeCells","isRecursiveResize","cellResized","ignoreRelative","resizeChildCells","constrainChildCells","scaleCell","isCellResizable","isCloneInvalidEdges","setAllowNegativeCoordinates","isDisconnectOnMove","isAllowDanglingEdges","isExtendParentsOnMove","disconnect","disconnectGraph","translateCell","getCellContainmentArea","getMaximumGraphBounds","sizeFirst","isConstrainRelativeChildren","isConstrainChild","overlap","getOverlap","getOutlineConstraint","getAllConnectionConstraints","setConnectionConstraint","connectCell","isPortsEnabled","getTerminalForPort","isCellDisconnectable","getCurrentRoot","enterGroup","isValidRoot","exitGroup","includeDescendants","addPoint","shiftPreview1","shiftPreview2","zoomIn","zoomOut","zoomActual","cw","sh","scrollRectToVisible","zoomToRect","scaleX","scaleY","aspectFactor","rectRight","rectBottom","newHeight","deltaHeightBuffer","upperBuffer","newWidth","deltaWidthBuffer","newScale","scrollCellToVisible","tr2","isChanged","widthLimit","heightLimit","ddx","ddy","isCellConnectable","isLoop","isCloneEvent","isConstrainedEvent","isIgnoreTerminalEvent","validationAlert","isEdgeValid","isValidConnection","sourceOut","targetIn","validateEdge","validateGraph","isValid","getCellValidationError","outCount","inCount","rule","setBackgroundImage","isHtmlLabels","setHtmlLabels","getTooltip","tip","getHandler","getTooltipForNode","getTooltipForCell","getCursorForMouseEvent","getCursorForCell","setBorder","isResizeContainer","setResizeContainer","isEscapeEnabled","setEscapeEnabled","setInvokesStopCellEditing","setEnterStopsCellEditing","isCellLocked","isCellsLocked","setCellsLocked","getCloneableCells","isCellCloneable","isCellsCloneable","setCellsCloneable","canExportCell","canImportCell","isCellsSelectable","setCellsSelectable","isCellDeletable","isCellsDeletable","setCellsDeletable","isLabelMovable","isCellRotatable","getMovableCells","isCellsMovable","setCellsMovable","setPortsEnabled","getGridSize","setGridSize","getTolerance","setTolerance","isVertexLabelsMovable","setVertexLabelsMovable","isEdgeLabelsMovable","setEdgeLabelsMovable","isSwimlaneNesting","setSwimlaneNesting","setSwimlaneSelectionEnabled","isMultigraph","setMultigraph","isAllowLoops","setAllowDanglingEdges","setConnectableEdges","isConnectableEdges","setCloneInvalidEdges","setAllowLoops","setDisconnectOnMove","setDropEnabled","isSplitEnabled","setSplitEnabled","isCellsResizable","setCellsResizable","isTerminalPointMovable","isCellBendable","isCellsBendable","setCellsBendable","isCellsEditable","setCellsEditable","isCellsDisconnectable","setCellsDisconnectable","isValidSource","isValidTarget","setTooltips","setPanning","isAutoSizeCells","setAutoSizeCells","isExtendParents","setExtendParents","setExtendParentsOnAdd","setExtendParentsOnMove","setRecursiveResize","isConstrainChildren","setConstrainChildren","setConstrainRelativeChildren","isAllowOverlapParent","isValidDropTarget","isSplitTarget","ignoreFn","hitsSwimlaneContent","getPointForEvent","addOffset","getCellsBeyond","rightHalfpane","bottomHalfpane","isolate","isSelectionEmpty","getSelectionCount","addSelectionCell","addSelectionCells","removeSelectionCell","selectRegion","selectCellsForEvent","selectNextCell","selectCell","selectPreviousCell","selectParentCell","selectChildCell","isNext","isParent","isChild","sel","selectAll","descendants","selectVertices","selectCells","selectEdges","createHandler","createEdgeHandler","createVertexHandler","createElbowEdgeHandler","createEdgeSegmentHandler","updateMouseEvent","getStateForTouchEvent","isEventIgnored","mouseEvent","lastEvent","mouseMoveRedirect","mouseUpRedirect","isSyntheticEventIgnored","lastMouseX","lastMouseY","ignoreMouseEvents","isEventSourceIgnored","candidate","getEventState","currentTime","fireDoubleClick","lastTouchEvent","lastTouchX","doubleClickCounter","doubleClickFired","lastTouchCell","valid","tapAndHoldThread","consumeMouseEvent","graphRenderHint","showViewport","sizerSize","updateOnPan","sizerImage","suspended","forceVmlHandles","outlineGraphModelChanged","selectionBorder","redirect","redirect2","sizer","createSizer","setZoomEnabled","getSourceContainerSize","getOutlineOffset","getSourceGraphBounds","sourceScale","scaledGraphBounds","unscaledGraphBounds","unscaledFinderBounds","union","completeWidth","completeHeight","outlineScale","navView","scale2","scale3","allowHandleBoundsCheck","getTranslateForEvent","viewRatio","checkTerminal","checkNeighbors","sourceValue","targetValue","checkType","attrValue","bubbling","isBubbling","setBubbling","getLayout","getCellsForChanges","executeLayoutForCells","sorted","reverse","layoutCells","getCellsForChange","executeLayout","setHorizontal","setAddEnabled","setResizeEnabled","isSwimlaneIgnored","isCellHorizontal","swimlaneAdded","parentHorizontal","resizeSwimlane","addEdges","translateState","revalidateState","maxCells","highlightEnabled","cloneEnabled","moveEnabled","currentDx","currentDy","updateCursor","selectEnabled","removeEmptyParents","connectOnDrop","scrollOnMove","previewColor","htmlPreview","scaleGrid","rotationEnabled","isCloneEnabled","setCloneEnabled","isMoveEnabled","setMoveEnabled","isSelectEnabled","setSelectEnabled","isRemoveCellsFromParent","setRemoveCellsFromParent","getInitialCellForEvent","isDelayedSelection","delayedSelection","cellWasClicked","initialCell","createPreviewShape","useGuidesForEvent","vector","roundLength","removeHint","setHighlightColor","selectDelayed","destroyShapes","guides","shouldRemoveCellsFromParent","shouldRemoveParent","log","useLeftButtonForPanning","usePopupTrigger","ignoreCell","previewEnabled","useGrid","pinchEnabled","isPanningEnabled","setPanningEnabled","setPinchEnabled","isPanningTrigger","consumePanningTrigger","selectOnPopup","clearSelectionOnBackground","triggerX","triggerY","screenX","screenY","isSelectOnPopup","popupTrigger","getCellForPopupEvent","hotspotEnabled","validState","setHotspot","getHotspot","setHotspotEnabled","isHotspotEnabled","hasValidState","getValidState","getMarkedState","unmark","setCurrentState","isValidState","getMarkerColor","markCell","getStateToMark","maxHandlers","oldHandlers","isHandlerActive","moveIconFront","moveIconBack","connectImage","targetConnectImage","createTarget","constraintHandler","waypointsEnabled","ignoreMouseDown","connectIconOffset","drillHandler","mouseDownCounter","movePreviewAway","outlineConnect","insertBeforeSource","isInsertBefore","isCreateTarget","setCreateTarget","iconState","redrawIcons","icons","isConnectableCell","isConnecting","validateConnection","getConnectImage","isMoveIconToFrontForState","createIcons","currentState","getIconPosition","destroyIcons","selectedIcon","isStartEvent","currentConstraint","sourceConstraint","waypoints","isImmediateConnectSource","isOutlineConnectEvent","clientLeft","clientTop","gridX","gridY","isHighlightAt","updateCurrentState","isCellEnabled","setFocus","convertWaypoint","snapToPreview","pt2","getTargetPerimeterPoint","getSourcePerimeterPoint","originalPoint","drawPreview","hitsIcon","updateIcons","realPoints","targetPerimeter","sourcePerimeter","isStopEvent","addWaypointForEvent","checkConstraints","updatePreview","getEdgeColor","terminalInserted","createTargetVertex","getAlignmentTolerance","pointImage","focusIcons","focusHighlight","currentFocusArea","focusPoints","getImageForConstraint","isStateIgnored","destroyFocusHighlight","isKeepFocusEvent","getCellForEvent","existingEdge","mouseleaveHandler","grid","mouse","minDistSq","hl","createHighlightShape","cp","defaultOpacity","sharedDiv","currentY","createMouseEvent","ignoreGrid","getPosition","setPosition","copyStyle","processEvent","getTotalRotation","flipPoint","snapPoint","isHtmlRequired","initShape","ignore","singleSizer","handleImage","parentHighlightEnabled","rotationRaster","rotationCursor","manageSizers","constrainGroupByChildren","rotationHandleVSpacing","horizontalOffset","verticalOffset","selectionBounds","getSelectionBounds","createSelectionShape","sizers","labelShape","isRotationHandleVisible","rotationShape","customHandles","createCustomHandles","updateMinBounds","isCenteredEvent","minBounds","createParentHighlightShape","getSelectionColor","getSelectionStrokeWidth","isSelectionDashed","createSizerShape","isSizerVisible","moveSizerTo","getHandleForEvent","checkShape","isCustomHandleEvent","handle","isLivePreviewBorder","childOffsetX","childOffsetY","preview","hideSizers","edgeHandlers","setHandlesVisible","checkTolerance","roundAngle","moveLabel","rotateVertex","resizeVertex","currentAlpha","atan","raster","redrawHandles","unscaledBounds","dx3","dy3","dx4","dy4","dx5","dy5","updateLivePreview","tempState","rotateCell","rotateClick","constrained","moveChildren","centered","cdx","cdy","getHandlePadding","crs","da","getRotationHandlePosition","updateParentHighlight","parentHighlight","bends","removeEnabled","dblClickRemoveEnabled","mergeRemoveEnabled","straightRemoveEnabled","virtualBendsEnabled","virtualBendOpacity","preferHtml","snapToTerminals","manageLabelHandle","abspoints","getSelectionPoints","targetState","createBends","isVirtualBendsEnabled","virtualBends","createVirtualBends","createLabelHandleShape","initBend","isAddPointEvent","isRemovePointEvent","otherCell","isHandleVisible","bend","createHandleShape","removePoint","isHandleEnabled","labelHandleImage","isAddVirtualBendEvent","isTarget","isLabel","clonePreviewState","getSnapToTerminalTolerance","isSnapToTerminalsEvent","snapToPoint","snapToTerminal","getPreviewTerminalState","getPreviewPoints","checkRemove","updatePreviewState","targetConstraint","setPreviewColor","changeTerminalPoint","changePoints","isClone","addPointAt","getHandleFillColor","checkLabelHandle","xn","yn","bn","redrawInnerBends","destroyBends","flipEnabled","doubleClickOrientationResource","createVirtualBend","dblClickHandler","getCursorForBend","getCurrentPoints","pt0","pt1","rpts","straight","bindKey","code","bindShiftKey","bindControlKey","bindControlShiftKey","getFunction","isGraphEvent","boundFunction","ignoreTouchEvents","hideOnHover","setHideOnHover","getStateForEvent","stateSource","resetTimer","restart","keepOnTop","drawHighlight","getStrokeWidth","bindAction","createMenu","conditions","createConditions","addItems","condition","as","enabledCond","addAction","isCell","condNodes","insertFunction","pressed","addActionOption","setMode","addPrototype","ptype","installDropHandler","addVertex","horizontalFlow","edgeGeometry","sprite","loader","askZoomResource","lastSavedResource","currentFileResource","propertiesResource","tasksResource","helpResource","outlineResource","dblClickAction","swimlaneRequired","forcedInserting","templates","defaultEdge","defaultEdgeStyle","defaultGroup","groupBorderSize","filename","postParameterName","escapePostData","urlPost","urlImage","layoutDiagram","swimlaneSpacing","maintainSwimlanes","layoutSwimlanes","cycleAttributeIndex","tasks","tasksWindowImage","tasksTop","help","helpWindowImage","urlHelp","helpWidth","helpHeight","propertiesWidth","propertiesHeight","movePropertiesDialog","validating","isModified","setModified","getUrlImage","showProperties","showTasks","showHelp","showOutline","dec","decode","resetHistory","resetFirstTime","cookie","actionname","addTemplate","template","getTemplate","installDblClickHandler","installUndoHandler","installDrillHandler","installChangeHandler","installInsertHandler","createPopupMenu","createSwimlaneManager","createLayoutManager","swimlaneMgr","layoutMgr","swimlaneLayout","createSwimlaneLayout","diagramLayout","createDiagramLayout","setGraphContainer","rubberband","insertHandler","gs","setToolbarContainer","setStatusContainer","tstamp","toLocaleString","setStatus","setTitleContainer","getTitle","treeLayout","getRootTitle","createGroup","readGraphModel","getUrlPost","writeGraphModel","postDiagram","swapStyles","second","createProperties","isPropertiesVisible","yField","xField","widthField","heightField","texts","okFunction","cancelFunction","createTasks","refreshTasks","frame","modename","consumeCycleAttribute","cycleAttribute","isConstrainedMoving","mxCodecRegistry","codecs","aliases","register","codec","classname","addAlias","codecname","getCodec","mxObjectCodec","objects","idrefs","elements","encodeDefaults","putObject","getObject","updateElements","addElement","Error","reference","into","encodeCell","isCellCodec","decodeCell","restoreStructures","decoder","insertIntoGraph","cloneTemplate","getFieldName","attributename","mapped","getAttributeName","fieldname","isExcluded","isReference","beforeEncode","encodeObject","afterEncode","encodeValue","writeAttribute","writePrimitiveAttribute","writeComplexAttribute","convertAttributeToXml","isBooleanAttribute","convertAttributeFromXml","isNumericAttribute","beforeDecode","decodeNode","afterDecode","decodeAttributes","decodeChildren","decodeAttribute","isIgnoredAttribute","processInclude","decodeChild","getFieldTemplate","addObjectValue","isWrite","mxCellCodec","rootNode","decodeRoot","rootCell","mxModelCodec","mxRootChangeCodec","childRef","mxChildChangeCodec","mxTerminalChangeCodec","mxGenericChangeCodec","variable","mxGraphCodec","mxGraphViewCodec","mxStylesheetCodec","styleNode","getStringValue","mxDefaultKeyHandlerCodec","mxDefaultToolbarCodec","act","inc","mxDefaultPopupMenuCodec","role","decodeTemplates","decodeUi","setMapContainer","mxEditorCodec","stat","macrotask","WebKitMutationObserver","flush","standalone","__e","IE8_DOM_DEFINE","toPrimitive","Attributes","UNSCOPABLES","PromiseCapability","$$resolve","$iterators","wks","TO_STRING_TAG","ArrayValues","DOMIterables","CSSRuleList","CSSStyleDeclaration","CSSValueList","ClientRectList","DOMRectList","DOMStringList","DOMTokenList","DataTransferItemList","FileList","HTMLAllCollection","HTMLCollection","HTMLFormElement","HTMLSelectElement","MediaList","MimeTypeArray","NamedNodeMap","NodeList","PaintRequestList","Plugin","PluginArray","SVGLengthList","SVGNumberList","SVGPathSegList","SVGPointList","SVGStringList","SVGTransformList","SourceBufferList","StyleSheetList","TextTrackCueList","TextTrackList","TouchList","collections","explicit","Collection","promiseCapability","toIObject","toAbsoluteIndex","IS_INCLUDES","$this","fromIndex","addToUnscopables","iterated","Arguments","arrayIndexOf","names","D","forbiddenField"],"mappings":"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","file":"js/chunk-vendors.7a9e934d.js","sourcesContent":["'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","// https://github.com/tc39/proposal-promise-finally\n'use strict';\nvar $export = require('./_export');\nvar core = require('./_core');\nvar global = require('./_global');\nvar speciesConstructor = require('./_species-constructor');\nvar promiseResolve = require('./_promise-resolve');\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","var ctx = require('./_ctx');\nvar invoke = require('./_invoke');\nvar html = require('./_html');\nvar cel = require('./_dom-create');\nvar global = require('./_global');\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (require('./_cof')(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","exports.f = Object.getOwnPropertySymbols;\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar $toString = require('./_function-to-string');\nvar TO_STRING = 'toString';\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if (process.env.NODE_ENV !== 'production' && !config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (process.env.NODE_ENV !== 'production' &&\n    (isUndef(target) || isPrimitive(target))\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && process.env.NODE_ENV !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    // skip validation for weex recycle-list child component props\n    !(false)\n  ) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else if (process.env.NODE_ENV !== 'production') {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (process.env.NODE_ENV !== 'production' && !isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (process.env.NODE_ENV !== 'production' && key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  if (process.env.NODE_ENV !== 'production') {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, null, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production' && name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production' && type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      if (process.env.NODE_ENV !== 'production') {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    if (process.env.NODE_ENV !== 'production') {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (process.env.NODE_ENV !== 'production') {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        process.env.NODE_ENV !== 'test'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if (process.env.NODE_ENV !== 'production' &&\n      process.env.NODE_ENV !== 'test' &&\n      config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nexport default Vue;\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","module.exports = false;\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export = require('./_export');\nvar context = require('./_string-context');\nvar INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","var MATCH = require('./_wks')('match');\nmodule.exports = function (KEY) {\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch (e) {\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch (f) { /* empty */ }\n  } return true;\n};\n","exports.f = {}.propertyIsEnumerable;\n","'use strict';\nvar LIBRARY = require('./_library');\nvar global = require('./_global');\nvar ctx = require('./_ctx');\nvar classof = require('./_classof');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar aFunction = require('./_a-function');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar speciesConstructor = require('./_species-constructor');\nvar task = require('./_task').set;\nvar microtask = require('./_microtask')();\nvar newPromiseCapabilityModule = require('./_new-promise-capability');\nvar perform = require('./_perform');\nvar userAgent = require('./_user-agent');\nvar promiseResolve = require('./_promise-resolve');\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n});\n","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","'use strict';\n// https://github.com/tc39/Array.prototype.includes\nvar $export = require('./_export');\nvar $includes = require('./_array-includes')(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./_add-to-unscopables')('includes');\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar DESCRIPTORS = require('./_descriptors');\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","'use strict';\nvar global = require('./_global');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","(function (root, factory) {\nif (typeof define === 'function' && define.amd) {\ndefine([], factory);\n} else if (typeof module === 'object' && module.exports) {\nmodule.exports = factory();\n} else {\nroot.mxgraph = factory();\n}\n}(this, function () {\nreturn function (opts) {\nfor (var name in opts) { this[name] = opts[name]; }\nvar __mxOutput = {};\n/**\n * Copyright (c) 2006-2017, JGraph Ltd\n * Copyright (c) 2006-2017, Gaudenz Alder\n */\nvar mxClient =\n{\n\t/**\n\t * Class: mxClient\n\t *\n\t * Bootstrapping mechanism for the mxGraph thin client. The production version\n\t * of this file contains all code required to run the mxGraph thin client, as\n\t * well as global constants to identify the browser and operating system in\n\t * use. You may have to load chrome://global/content/contentAreaUtils.js in\n\t * your page to disable certain security restrictions in Mozilla.\n\t *\n\t * Variable: VERSION\n\t *\n\t * Contains the current version of the mxGraph library. The strings that\n\t * communicate versions of mxGraph use the following format.\n\t *\n\t * versionMajor.versionMinor.buildNumber.revisionNumber\n\t *\n\t * Current version is 4.0.2.\n\t */\n\tVERSION: '4.0.2',\n\n\t/**\n\t * Variable: IS_IE\n\t *\n\t * True if the current browser is Internet Explorer 10 or below. Use <mxClient.IS_IE11>\n\t * to detect IE 11.\n\t */\n\tIS_IE: navigator.userAgent.indexOf('MSIE') >= 0,\n\n\t/**\n\t * Variable: IS_IE6\n\t *\n\t * True if the current browser is Internet Explorer 6.x.\n\t */\n\tIS_IE6: navigator.userAgent.indexOf('MSIE 6') >= 0,\n\n\t/**\n\t * Variable: IS_IE11\n\t *\n\t * True if the current browser is Internet Explorer 11.x.\n\t */\n\tIS_IE11: !!navigator.userAgent.match(/Trident\\/7\\./),\n\n\t/**\n\t * Variable: IS_EDGE\n\t *\n\t * True if the current browser is Microsoft Edge.\n\t */\n\tIS_EDGE: !!navigator.userAgent.match(/Edge\\//),\n\n\t/**\n\t * Variable: IS_QUIRKS\n\t *\n\t * True if the current browser is Internet Explorer and it is in quirks mode.\n\t */\n\tIS_QUIRKS: navigator.userAgent.indexOf('MSIE') >= 0 && (document.documentMode == null || document.documentMode == 5),\n\n\t/**\n\t * Variable: IS_EM\n\t *\n\t * True if the browser is IE11 in enterprise mode (IE8 standards mode).\n\t */\n\tIS_EM: 'spellcheck' in document.createElement('textarea') && document.documentMode == 8,\n\n\t/**\n\t * Variable: VML_PREFIX\n\t *\n\t * Prefix for VML namespace in node names. Default is 'v'.\n\t */\n\tVML_PREFIX: 'v',\n\n\t/**\n\t * Variable: OFFICE_PREFIX\n\t *\n\t * Prefix for VML office namespace in node names. Default is 'o'.\n\t */\n\tOFFICE_PREFIX: 'o',\n\n\t/**\n\t * Variable: IS_NS\n\t *\n\t * True if the current browser is Netscape (including Firefox).\n\t */\n  \tIS_NS: navigator.userAgent.indexOf('Mozilla/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('MSIE') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Edge/') < 0,\n\n\t/**\n\t * Variable: IS_OP\n\t *\n\t * True if the current browser is Opera.\n\t */\n  \tIS_OP: navigator.userAgent.indexOf('Opera/') >= 0 ||\n  \t\tnavigator.userAgent.indexOf('OPR/') >= 0,\n\n\t/**\n\t * Variable: IS_OT\n\t *\n\t * True if -o-transform is available as a CSS style, ie for Opera browsers\n\t * based on a Presto engine with version 2.5 or later.\n\t */\n  \tIS_OT: navigator.userAgent.indexOf('Presto/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.4.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.3.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.2.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.1.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/2.0.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Presto/1.') < 0,\n\n\t/**\n\t * Variable: IS_SF\n\t *\n\t * True if the current browser is Safari.\n\t */\n  \tIS_SF: navigator.userAgent.indexOf('AppleWebKit/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('Chrome/') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Edge/') < 0,\n\n\t/**\n\t * Variable: IS_IOS\n\t *\n\t * Returns true if the user agent is an iPad, iPhone or iPod.\n\t */\n  \tIS_IOS: (navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false),\n\n\t/**\n\t * Variable: IS_GC\n\t *\n\t * True if the current browser is Google Chrome.\n\t */\n  \tIS_GC: navigator.userAgent.indexOf('Chrome/') >= 0 &&\n\t\tnavigator.userAgent.indexOf('Edge/') < 0,\n\n\t/**\n\t * Variable: IS_CHROMEAPP\n\t *\n\t * True if the this is running inside a Chrome App.\n\t */\n  \tIS_CHROMEAPP: window.chrome != null && chrome.app != null && chrome.app.runtime != null,\n\n\t/**\n\t * Variable: IS_FF\n\t *\n\t * True if the current browser is Firefox.\n\t */\n  \tIS_FF: navigator.userAgent.indexOf('Firefox/') >= 0,\n\n\t/**\n\t * Variable: IS_MT\n\t *\n\t * True if -moz-transform is available as a CSS style. This is the case\n\t * for all Firefox-based browsers newer than or equal 3, such as Camino,\n\t * Iceweasel, Seamonkey and Iceape.\n\t */\n  \tIS_MT: (navigator.userAgent.indexOf('Firefox/') >= 0 &&\n\t\tnavigator.userAgent.indexOf('Firefox/1.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Firefox/2.') < 0) ||\n  \t\t(navigator.userAgent.indexOf('Iceweasel/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('Iceweasel/1.') < 0 &&\n  \t\tnavigator.userAgent.indexOf('Iceweasel/2.') < 0) ||\n  \t\t(navigator.userAgent.indexOf('SeaMonkey/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('SeaMonkey/1.') < 0) ||\n  \t\t(navigator.userAgent.indexOf('Iceape/') >= 0 &&\n  \t\tnavigator.userAgent.indexOf('Iceape/1.') < 0),\n\n\t/**\n\t * Variable: IS_VML\n\t *\n\t * True if the browser supports VML.\n\t */\n  \tIS_VML: navigator.appName.toUpperCase() == 'MICROSOFT INTERNET EXPLORER',\n\n\t/**\n\t * Variable: IS_SVG\n\t *\n\t * True if the browser supports SVG.\n\t */\n  \tIS_SVG: navigator.appName.toUpperCase() != 'MICROSOFT INTERNET EXPLORER',\n\n\t/**\n\t * Variable: NO_FO\n\t *\n\t * True if foreignObject support is not available. This is the case for\n\t * Opera, older SVG-based browsers and all versions of IE.\n\t */\n  \tNO_FO: !document.createElementNS || document.createElementNS('http://www.w3.org/2000/svg',\n  \t\t'foreignObject') != '[object SVGForeignObjectElement]' || navigator.userAgent.indexOf('Opera/') >= 0,\n\n\t/**\n\t * Variable: IS_WIN\n\t *\n\t * True if the client is a Windows.\n\t */\n  \tIS_WIN: navigator.appVersion.indexOf('Win') > 0,\n\n\t/**\n\t * Variable: IS_MAC\n\t *\n\t * True if the client is a Mac.\n\t */\n  \tIS_MAC: navigator.appVersion.indexOf('Mac') > 0,\n\n\t/**\n\t * Variable: IS_TOUCH\n\t *\n\t * True if this device supports touchstart/-move/-end events (Apple iOS,\n\t * Android, Chromebook and Chrome Browser on touch-enabled devices).\n\t */\n  \tIS_TOUCH: 'ontouchstart' in document.documentElement,\n\n\t/**\n\t * Variable: IS_POINTER\n\t *\n\t * True if this device supports Microsoft pointer events (always false on Macs).\n\t */\n  \tIS_POINTER: window.PointerEvent != null && !(navigator.appVersion.indexOf('Mac') > 0),\n\n\t/**\n\t * Variable: IS_LOCAL\n\t *\n\t * True if the documents location does not start with http:// or https://.\n\t */\n  \tIS_LOCAL: document.location.href.indexOf('http://') < 0 &&\n  \t\t\t  document.location.href.indexOf('https://') < 0,\n\n\t/**\n\t * Variable: defaultBundles\n\t *\n\t * Contains the base names of the default bundles if mxLoadResources is false.\n\t */\n  \tdefaultBundles: [],\n\n\t/**\n\t * Function: isBrowserSupported\n\t *\n\t * Returns true if the current browser is supported, that is, if\n\t * <mxClient.IS_VML> or <mxClient.IS_SVG> is true.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * if (!mxClient.isBrowserSupported())\n\t * {\n\t *   mxUtils.error('Browser is not supported!', 200, false);\n\t * }\n\t * (end)\n\t */\n\tisBrowserSupported: function()\n\t{\n\t\treturn mxClient.IS_VML || mxClient.IS_SVG;\n\t},\n\n\t/**\n\t * Function: link\n\t *\n\t * Adds a link node to the head of the document. Use this\n\t * to add a stylesheet to the page as follows:\n\t *\n\t * (code)\n\t * mxClient.link('stylesheet', filename);\n\t * (end)\n\t *\n\t * where filename is the (relative) URL of the stylesheet. The charset\n\t * is hardcoded to ISO-8859-1 and the type is text/css.\n\t *\n\t * Parameters:\n\t *\n\t * rel - String that represents the rel attribute of the link node.\n\t * href - String that represents the href attribute of the link node.\n\t * doc - Optional parent document of the link node.\n\t * id - unique id for the link element to check if it already exists\n\t */\n\tlink: function(rel, href, doc, id)\n\t{\n\t\tdoc = doc || document;\n\n\t\t// Workaround for Operation Aborted in IE6 if base tag is used in head\n\t\tif (mxClient.IS_IE6)\n\t\t{\n\t\t\tdoc.write('<link rel=\"' + rel + '\" href=\"' + href + '\" charset=\"UTF-8\" type=\"text/css\"/>');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar link = doc.createElement('link');\n\n\t\t\tlink.setAttribute('rel', rel);\n\t\t\tlink.setAttribute('href', href);\n\t\t\tlink.setAttribute('charset', 'UTF-8');\n\t\t\tlink.setAttribute('type', 'text/css');\n\n\t\t\tif (id)\n\t\t\t{\n\t\t\t\tlink.setAttribute('id', id);\n\t\t\t}\n\n\t\t\tvar head = doc.getElementsByTagName('head')[0];\n\t   \t\thead.appendChild(link);\n\t\t}\n\t},\n\n\t/**\n\t * Function: loadResources\n\t *\n\t * Helper method to load the default bundles if mxLoadResources is false.\n\t *\n\t * Parameters:\n\t *\n\t * fn - Function to call after all resources have been loaded.\n\t * lan - Optional string to pass to <mxResources.add>.\n\t */\n\tloadResources: function(fn, lan)\n\t{\n\t\tvar pending = mxClient.defaultBundles.length;\n\n\t\tfunction callback()\n\t\t{\n\t\t\tif (--pending == 0)\n\t\t\t{\n\t\t\t\tfn();\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < mxClient.defaultBundles.length; i++)\n\t\t{\n\t\t\tmxResources.add(mxClient.defaultBundles[i], lan, callback);\n\t\t}\n\t},\n\n\t/**\n\t * Function: include\n\t *\n\t * Dynamically adds a script node to the document header.\n\t *\n\t * In production environments, the includes are resolved in the mxClient.js\n\t * file to reduce the number of requests required for client startup. This\n\t * function should only be used in development environments, but not in\n\t * production systems.\n\t */\n\tinclude: function(src)\n\t{\n\t\tdocument.write('<script src=\"'+src+'\"></script>');\n\t}\n};\n\n/**\n * Variable: mxLoadResources\n *\n * Optional global config variable to toggle loading of the two resource files\n * in <mxGraph> and <mxEditor>. Default is true. NOTE: This is a global variable,\n * not a variable of mxClient. If this is false, you can use <mxClient.loadResources>\n * with its callback to load the default bundles asynchronously.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxLoadResources = false;\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxLoadResources) == 'undefined')\n{\n\tmxLoadResources = true;\n}\n\n/**\n * Variable: mxForceIncludes\n *\n * Optional global config variable to force loading the JavaScript files in\n * development mode. Default is undefined. NOTE: This is a global variable,\n * not a variable of mxClient.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxLoadResources = true;\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxForceIncludes) == 'undefined')\n{\n\tmxForceIncludes = false;\n}\n\n/**\n * Variable: mxResourceExtension\n *\n * Optional global config variable to specify the extension of resource files.\n * Default is true. NOTE: This is a global variable, not a variable of mxClient.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxResourceExtension = '.txt';\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxResourceExtension) == 'undefined')\n{\n\tmxResourceExtension = '.txt';\n}\n\n/**\n * Variable: mxLoadStylesheets\n *\n * Optional global config variable to toggle loading of the CSS files when\n * the library is initialized. Default is true. NOTE: This is a global variable,\n * not a variable of mxClient.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tvar mxLoadStylesheets = false;\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxLoadStylesheets) == 'undefined')\n{\n\tmxLoadStylesheets = true;\n}\n\n/**\n * Variable: basePath\n *\n * Basepath for all URLs in the core without trailing slash. Default is '.'.\n * Set mxBasePath prior to loading the mxClient library as follows to override\n * this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxBasePath = '/path/to/core/directory';\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n *\n * When using a relative path, the path is relative to the URL of the page that\n * contains the assignment. Trailing slashes are automatically removed.\n */\nif (typeof(mxBasePath) != 'undefined' && mxBasePath.length > 0)\n{\n\t// Adds a trailing slash if required\n\tif (mxBasePath.substring(mxBasePath.length - 1) == '/')\n\t{\n\t\tmxBasePath = mxBasePath.substring(0, mxBasePath.length - 1);\n\t}\n\n\tmxClient.basePath = mxBasePath;\n}\nelse\n{\n\tmxClient.basePath = '.';\n}\n\n/**\n * Variable: imageBasePath\n *\n * Basepath for all images URLs in the core without trailing slash. Default is\n * <mxClient.basePath> + '/images'. Set mxImageBasePath prior to loading the\n * mxClient library as follows to override this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxImageBasePath = '/path/to/image/directory';\n * </script>\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\n * (end)\n *\n * When using a relative path, the path is relative to the URL of the page that\n * contains the assignment. Trailing slashes are automatically removed.\n */\nif (typeof(mxImageBasePath) != 'undefined' && mxImageBasePath.length > 0)\n{\n\t// Adds a trailing slash if required\n\tif (mxImageBasePath.substring(mxImageBasePath.length - 1) == '/')\n\t{\n\t\tmxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1);\n\t}\n\n\tmxClient.imageBasePath = mxImageBasePath;\n}\nelse\n{\n\tmxClient.imageBasePath = mxClient.basePath + '/images';\n}\n\n/**\n * Variable: language\n *\n * Defines the language of the client, eg. en for english, de for german etc.\n * The special value 'none' will disable all built-in internationalization and\n * resource loading. See <mxResources.getSpecialBundle> for handling identifiers\n * with and without a dash.\n *\n * Set mxLanguage prior to loading the mxClient library as follows to override\n * this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxLanguage = 'en';\n * </script>\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\n * (end)\n *\n * If internationalization is disabled, then the following variables should be\n * overridden to reflect the current language of the system. These variables are\n * cleared when i18n is disabled.\n * <mxEditor.askZoomResource>, <mxEditor.lastSavedResource>,\n * <mxEditor.currentFileResource>, <mxEditor.propertiesResource>,\n * <mxEditor.tasksResource>, <mxEditor.helpResource>, <mxEditor.outlineResource>,\n * <mxElbowEdgeHandler.doubleClickOrientationResource>, <mxUtils.errorResource>,\n * <mxUtils.closeResource>, <mxGraphSelectionModel.doneResource>,\n * <mxGraphSelectionModel.updatingSelectionResource>, <mxGraphView.doneResource>,\n * <mxGraphView.updatingDocumentResource>, <mxCellRenderer.collapseExpandResource>,\n * <mxGraph.containsValidationErrorsResource> and\n * <mxGraph.alreadyConnectedResource>.\n */\nif (typeof(mxLanguage) != 'undefined' && mxLanguage != null)\n{\n\tmxClient.language = mxLanguage;\n}\nelse\n{\n\tmxClient.language = (mxClient.IS_IE) ? navigator.userLanguage : navigator.language;\n}\n\n/**\n * Variable: defaultLanguage\n *\n * Defines the default language which is used in the common resource files. Any\n * resources for this language will only load the common resource file, but not\n * the language-specific resource file. Default is 'en'.\n *\n * Set mxDefaultLanguage prior to loading the mxClient library as follows to override\n * this setting:\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxDefaultLanguage = 'de';\n * </script>\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\n * (end)\n */\nif (typeof(mxDefaultLanguage) != 'undefined' && mxDefaultLanguage != null)\n{\n\tmxClient.defaultLanguage = mxDefaultLanguage;\n}\nelse\n{\n\tmxClient.defaultLanguage = 'en';\n}\n\n// Adds all required stylesheets and namespaces\nif (mxLoadStylesheets)\n{\n\tmxClient.link('stylesheet', mxClient.basePath + '/css/common.css');\n}\n\n/**\n * Variable: languages\n *\n * Defines the optional array of all supported language extensions. The default\n * language does not have to be part of this list. See\n * <mxResources.isLanguageSupported>.\n *\n * (code)\n * <script type=\"text/javascript\">\n * \t\tmxLanguages = ['de', 'it', 'fr'];\n * </script>\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\n * (end)\n *\n * This is used to avoid unnecessary requests to language files, ie. if a 404\n * will be returned.\n */\nif (typeof(mxLanguages) != 'undefined' && mxLanguages != null)\n{\n\tmxClient.languages = mxLanguages;\n}\n\n// Adds required namespaces, stylesheets and memory handling for older IE browsers\nif (mxClient.IS_VML)\n{\n\tif (mxClient.IS_SVG)\n\t{\n\t\tmxClient.IS_VML = false;\n\t}\n\telse\n\t{\n\t\t// Enables support for IE8 standards mode. Note that this requires all attributes for VML\n\t\t// elements to be set using direct notation, ie. node.attr = value. The use of setAttribute\n\t\t// is not possible.\n\t\tif (document.documentMode == 8)\n\t\t{\n\t\t\tdocument.namespaces.add(mxClient.VML_PREFIX, 'urn:schemas-microsoft-com:vml', '#default#VML');\n\t\t\tdocument.namespaces.add(mxClient.OFFICE_PREFIX, 'urn:schemas-microsoft-com:office:office', '#default#VML');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.namespaces.add(mxClient.VML_PREFIX, 'urn:schemas-microsoft-com:vml');\n\t\t\tdocument.namespaces.add(mxClient.OFFICE_PREFIX, 'urn:schemas-microsoft-com:office:office');\n\t\t}\n\n\t\t// Workaround for limited number of stylesheets in IE (does not work in standards mode)\n\t\tif (mxClient.IS_QUIRKS && document.styleSheets.length >= 30)\n\t\t{\n\t\t\t(function()\n\t\t\t{\n\t\t\t\tvar node = document.createElement('style');\n\t\t\t\tnode.type = 'text/css';\n\t\t\t\tnode.styleSheet.cssText = mxClient.VML_PREFIX + '\\\\:*{behavior:url(#default#VML)}' +\n\t\t        \tmxClient.OFFICE_PREFIX + '\\\\:*{behavior:url(#default#VML)}';\n\t\t        document.getElementsByTagName('head')[0].appendChild(node);\n\t\t\t})();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{behavior:url(#default#VML)}' +\n\t\t    \tmxClient.OFFICE_PREFIX + '\\\\:*{behavior:url(#default#VML)}';\n\t\t}\n\n\t    if (mxLoadStylesheets)\n\t    {\n\t    \tmxClient.link('stylesheet', mxClient.basePath + '/css/explorer.css');\n\t    }\n\t}\n}\n\n// PREPROCESSOR-REMOVE-START\n// If script is loaded via CommonJS, do not write <script> tags to the page\n// for dependencies. These are already included in the build.\nif (mxForceIncludes || !(typeof module === 'object' && module.exports != null))\n{\n// PREPROCESSOR-REMOVE-END\n\tmxClient.include(mxClient.basePath+'/js/util/mxLog.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxObjectIdentity.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxDictionary.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxResources.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxPoint.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxRectangle.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEffects.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUtils.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxConstants.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEventObject.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxMouseEvent.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEventSource.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxEvent.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxXmlRequest.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxClipboard.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxWindow.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxForm.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxImage.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxDivResizer.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxDragSource.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxToolbar.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUndoableEdit.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUndoManager.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxUrlConverter.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxPanningManager.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxPopupMenu.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxAutoSaveManager.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxAnimation.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxMorphing.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxImageBundle.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxImageExport.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxAbstractCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxXmlCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxSvgCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxVmlCanvas2D.js');\n\tmxClient.include(mxClient.basePath+'/js/util/mxGuide.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxShape.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxStencil.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxStencilRegistry.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxMarker.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxActor.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxCloud.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxRectangleShape.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxEllipse.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxDoubleEllipse.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxRhombus.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxPolyline.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxArrow.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxArrowConnector.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxText.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxTriangle.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxHexagon.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxLine.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxImageShape.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxLabel.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxCylinder.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxConnector.js');\n\tmxClient.include(mxClient.basePath+'/js/shape/mxSwimlane.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxGraphLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxStackLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxPartitionLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxCompactTreeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxRadialTreeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxFastOrganicLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxCircleLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxParallelEdgeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxCompositeLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/mxEdgeLabelLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphAbstractHierarchyCell.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphHierarchyNode.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphHierarchyEdge.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxGraphHierarchyModel.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/model/mxSwimlaneModel.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxHierarchicalLayoutStage.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxMedianHybridCrossingReduction.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxMinimumCycleRemover.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxCoordinateAssignment.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/stage/mxSwimlaneOrdering.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/mxHierarchicalLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/layout/hierarchical/mxSwimlaneLayout.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxGraphModel.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxCell.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxGeometry.js');\n\tmxClient.include(mxClient.basePath+'/js/model/mxCellPath.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxPerimeter.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxPrintPreview.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxStylesheet.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellState.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxGraphSelectionModel.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellEditor.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellRenderer.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxEdgeStyle.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxStyleRegistry.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxGraphView.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxGraph.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellOverlay.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxOutline.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxMultiplicity.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxLayoutManager.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxSwimlaneManager.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxTemporaryCellStates.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxCellStatePreview.js');\n\tmxClient.include(mxClient.basePath+'/js/view/mxConnectionConstraint.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxGraphHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxPanningHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxPopupMenuHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxCellMarker.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxSelectionCellsHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxConnectionHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxConstraintHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxRubberband.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxHandle.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxVertexHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxEdgeHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxElbowEdgeHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxEdgeSegmentHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxKeyHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxTooltipHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxCellTracker.js');\n\tmxClient.include(mxClient.basePath+'/js/handler/mxCellHighlight.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxDefaultKeyHandler.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxDefaultPopupMenu.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxDefaultToolbar.js');\n\tmxClient.include(mxClient.basePath+'/js/editor/mxEditor.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxCodecRegistry.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxObjectCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxCellCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxModelCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxRootChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxChildChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxTerminalChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxGenericChangeCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxGraphCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxGraphViewCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxStylesheetCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxDefaultKeyHandlerCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxDefaultToolbarCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxDefaultPopupMenuCodec.js');\n\tmxClient.include(mxClient.basePath+'/js/io/mxEditorCodec.js');\n// PREPROCESSOR-REMOVE-START\n}\n// PREPROCESSOR-REMOVE-END\n\n__mxOutput.mxClient = typeof mxClient !== 'undefined' ? mxClient : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxLog =\n{\n\t/**\n\t * Class: mxLog\n\t *\n\t * A singleton class that implements a simple console.\n\t *\n\t * Variable: consoleName\n\t *\n\t * Specifies the name of the console window. Default is 'Console'.\n\t */\n\tconsoleName: 'Console',\n\n\t/**\n\t * Variable: TRACE\n\t *\n\t * Specified if the output for <enter> and <leave> should be visible in the\n\t * console. Default is false.\n\t */\n\tTRACE: false,\n\n\t/**\n\t * Variable: DEBUG\n\t *\n\t * Specifies if the output for <debug> should be visible in the console.\n\t * Default is true.\n\t */\n\tDEBUG: true,\n\n\t/**\n\t * Variable: WARN\n\t *\n\t * Specifies if the output for <warn> should be visible in the console.\n\t * Default is true.\n\t */\n\tWARN: true,\n\n\t/**\n\t * Variable: buffer\n\t *\n\t * Buffer for pre-initialized content.\n\t */\n\tbuffer: '',\n\n\t/**\n\t * Function: init\n\t *\n\t * Initializes the DOM node for the console. This requires document.body to\n\t * point to a non-null value. This is called from within <setVisible> if the\n\t * log has not yet been initialized.\n\t */\n\tinit: function()\n\t{\n\t\tif (mxLog.window == null && document.body != null)\n\t\t{\n\t\t\tvar title = mxLog.consoleName + ' - mxGraph ' + mxClient.VERSION;\n\n\t\t\t// Creates a table that maintains the layout\n\t\t\tvar table = document.createElement('table');\n\t\t\ttable.setAttribute('width', '100%');\n\t\t\ttable.setAttribute('height', '100%');\n\n\t\t\tvar tbody = document.createElement('tbody');\n\t\t\tvar tr = document.createElement('tr');\n\t\t\tvar td = document.createElement('td');\n\t\t\ttd.style.verticalAlign = 'top';\n\n\t\t\t// Adds the actual console as a textarea\n\t\t\tmxLog.textarea = document.createElement('textarea');\n\t\t\tmxLog.textarea.setAttribute('wrap', 'off');\n\t\t\tmxLog.textarea.setAttribute('readOnly', 'true');\n\t\t\tmxLog.textarea.style.height = '100%';\n\t\t\tmxLog.textarea.style.resize = 'none';\n\t\t\tmxLog.textarea.value = mxLog.buffer;\n\n\t\t\t// Workaround for wrong width in standards mode\n\t\t\tif (mxClient.IS_NS && document.compatMode != 'BackCompat')\n\t\t\t{\n\t\t\t\tmxLog.textarea.style.width = '99%';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxLog.textarea.style.width = '100%';\n\t\t\t}\n\n\t\t\ttd.appendChild(mxLog.textarea);\n\t\t\ttr.appendChild(td);\n\t\t\ttbody.appendChild(tr);\n\n\t\t\t// Creates the container div\n\t\t\ttr = document.createElement('tr');\n\t\t\tmxLog.td = document.createElement('td');\n\t\t\tmxLog.td.style.verticalAlign = 'top';\n\t\t\tmxLog.td.setAttribute('height', '30px');\n\n\t\t\ttr.appendChild(mxLog.td);\n\t\t\ttbody.appendChild(tr);\n\t\t\ttable.appendChild(tbody);\n\n\t\t\t// Adds various debugging buttons\n\t\t\tmxLog.addButton('Info', function (evt)\n\t\t\t{\n\t\t\t\tmxLog.info();\n\t\t\t});\n\n\t\t\tmxLog.addButton('DOM', function (evt)\n\t\t\t{\n\t\t\t\tvar content = mxUtils.getInnerHtml(document.body);\n\t\t\t\tmxLog.debug(content);\n\t\t\t});\n\n\t\t\tmxLog.addButton('Trace', function (evt)\n\t\t\t{\n\t\t\t\tmxLog.TRACE = !mxLog.TRACE;\n\n\t\t\t\tif (mxLog.TRACE)\n\t\t\t\t{\n\t\t\t\t\tmxLog.debug('Tracing enabled');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmxLog.debug('Tracing disabled');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmxLog.addButton('Copy', function (evt)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tmxUtils.copy(mxLog.textarea.value);\n\t\t\t\t}\n\t\t\t\tcatch (err)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.alert(err);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmxLog.addButton('Show', function (evt)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tmxUtils.popup(mxLog.textarea.value);\n\t\t\t\t}\n\t\t\t\tcatch (err)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.alert(err);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmxLog.addButton('Clear', function (evt)\n\t\t\t{\n\t\t\t\tmxLog.textarea.value = '';\n\t\t\t});\n\n\t\t\t// Cross-browser code to get window size\n\t\t\tvar h = 0;\n\t\t\tvar w = 0;\n\n\t\t\tif (typeof(window.innerWidth) === 'number')\n\t\t\t{\n\t\t\t\th = window.innerHeight;\n\t\t\t\tw = window.innerWidth;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\th = (document.documentElement.clientHeight || document.body.clientHeight);\n\t\t\t\tw = document.body.clientWidth;\n\t\t\t}\n\n\t\t\tmxLog.window = new mxWindow(title, table, Math.max(0, w - 320), Math.max(0, h - 210), 300, 160);\n\t\t\tmxLog.window.setMaximizable(true);\n\t\t\tmxLog.window.setScrollable(false);\n\t\t\tmxLog.window.setResizable(true);\n\t\t\tmxLog.window.setClosable(true);\n\t\t\tmxLog.window.destroyOnClose = false;\n\n\t\t\t// Workaround for ignored textarea height in various setups\n\t\t\tif (((mxClient.IS_NS || mxClient.IS_IE) && !mxClient.IS_GC &&\n\t\t\t\t!mxClient.IS_SF && document.compatMode != 'BackCompat') ||\n\t\t\t\tdocument.documentMode == 11)\n\t\t\t{\n\t\t\t\tvar elt = mxLog.window.getElement();\n\n\t\t\t\tvar resizeHandler = function(sender, evt)\n\t\t\t\t{\n\t\t\t\t\tmxLog.textarea.style.height = Math.max(0, elt.offsetHeight - 70) + 'px';\n\t\t\t\t};\n\n\t\t\t\tmxLog.window.addListener(mxEvent.RESIZE_END, resizeHandler);\n\t\t\t\tmxLog.window.addListener(mxEvent.MAXIMIZE, resizeHandler);\n\t\t\t\tmxLog.window.addListener(mxEvent.NORMALIZE, resizeHandler);\n\n\t\t\t\tmxLog.textarea.style.height = '92px';\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: info\n\t *\n\t * Writes the current navigator information to the console.\n\t */\n\tinfo: function()\n\t{\n\t\tmxLog.writeln(mxUtils.toString(navigator));\n\t},\n\n\t/**\n\t * Function: addButton\n\t *\n\t * Adds a button to the console using the given label and function.\n\t */\n\taddButton: function(lab, funct)\n\t{\n\t\tvar button = document.createElement('button');\n\t\tmxUtils.write(button, lab);\n\t\tmxEvent.addListener(button, 'click', funct);\n\t\tmxLog.td.appendChild(button);\n\t},\n\n\t/**\n\t * Function: isVisible\n\t *\n\t * Returns true if the console is visible.\n\t */\n\tisVisible: function()\n\t{\n\t\tif (mxLog.window != null)\n\t\t{\n\t\t\treturn mxLog.window.isVisible();\n\t\t}\n\n\t\treturn false;\n\t},\n\n\n\t/**\n\t * Function: show\n\t *\n\t * Shows the console.\n\t */\n\tshow: function()\n\t{\n\t\tmxLog.setVisible(true);\n\t},\n\n\t/**\n\t * Function: setVisible\n\t *\n\t * Shows or hides the console.\n\t */\n\tsetVisible: function(visible)\n\t{\n\t\tif (mxLog.window == null)\n\t\t{\n\t\t\tmxLog.init();\n\t\t}\n\n\t\tif (mxLog.window != null)\n\t\t{\n\t\t\tmxLog.window.setVisible(visible);\n\t\t}\n\t},\n\n\t/**\n\t * Function: enter\n\t *\n\t * Writes the specified string to the console\n\t * if <TRACE> is true and returns the current\n\t * time in milliseconds.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * mxLog.show();\n\t * var t0 = mxLog.enter('Hello');\n\t * // Do something\n\t * mxLog.leave('World!', t0);\n\t * (end)\n\t */\n\tenter: function(string)\n\t{\n\t\tif (mxLog.TRACE)\n\t\t{\n\t\t\tmxLog.writeln('Entering '+string);\n\n\t\t\treturn new Date().getTime();\n\t\t}\n\t},\n\n\t/**\n\t * Function: leave\n\t *\n\t * Writes the specified string to the console\n\t * if <TRACE> is true and computes the difference\n\t * between the current time and t0 in milliseconds.\n\t * See <enter> for an example.\n\t */\n\tleave: function(string, t0)\n\t{\n\t\tif (mxLog.TRACE)\n\t\t{\n\t\t\tvar dt = (t0 != 0) ? ' ('+(new Date().getTime() - t0)+' ms)' : '';\n\t\t\tmxLog.writeln('Leaving '+string+dt);\n\t\t}\n\t},\n\n\t/**\n\t * Function: debug\n\t *\n\t * Adds all arguments to the console if <DEBUG> is enabled.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * mxLog.show();\n\t * mxLog.debug('Hello, World!');\n\t * (end)\n\t */\n\tdebug: function()\n\t{\n\t\tif (mxLog.DEBUG)\n\t\t{\n\t\t\tmxLog.writeln.apply(this, arguments);\n\t\t}\n\t},\n\n\t/**\n\t * Function: warn\n\t *\n\t * Adds all arguments to the console if <WARN> is enabled.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * mxLog.show();\n\t * mxLog.warn('Hello, World!');\n\t * (end)\n\t */\n\twarn: function()\n\t{\n\t\tif (mxLog.WARN)\n\t\t{\n\t\t\tmxLog.writeln.apply(this, arguments);\n\t\t}\n\t},\n\n\t/**\n\t * Function: write\n\t *\n\t * Adds the specified strings to the console.\n\t */\n\twrite: function()\n\t{\n\t\tvar string = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++)\n\t\t{\n\t\t\tstring += arguments[i];\n\n\t\t\tif (i < arguments.length - 1)\n\t\t\t{\n\t\t\t\tstring += ' ';\n\t\t\t}\n\t\t}\n\n\t\tif (mxLog.textarea != null)\n\t\t{\n\t\t\tmxLog.textarea.value = mxLog.textarea.value + string;\n\n\t\t\t// Workaround for no update in Presto 2.5.22 (Opera 10.5)\n\t\t\tif (navigator.userAgent.indexOf('Presto/2.5') >= 0)\n\t\t\t{\n\t\t\t\tmxLog.textarea.style.visibility = 'hidden';\n\t\t\t\tmxLog.textarea.style.visibility = 'visible';\n\t\t\t}\n\n\t\t\tmxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxLog.buffer += string;\n\t\t}\n\t},\n\n\t/**\n\t * Function: writeln\n\t *\n\t * Adds the specified strings to the console, appending a linefeed at the\n\t * end of each string.\n\t */\n\twriteln: function()\n\t{\n\t\tvar string = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++)\n\t\t{\n\t\t\tstring += arguments[i];\n\n\t\t\tif (i < arguments.length - 1)\n\t\t\t{\n\t\t\t\tstring += ' ';\n\t\t\t}\n\t\t}\n\n\t\tmxLog.write(string + '\\n');\n\t}\n\n};\n\n__mxOutput.mxLog = typeof mxLog !== 'undefined' ? mxLog : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxObjectIdentity =\n{\n\t/**\n\t * Class: mxObjectIdentity\n\t *\n\t * Identity for JavaScript objects and functions. This is implemented using\n\t * a simple incrementing counter which is stored in each object under\n\t * <FIELD_NAME>.\n\t *\n\t * The identity for an object does not change during its lifecycle.\n\t *\n\t * Variable: FIELD_NAME\n\t *\n\t * Name of the field to be used to store the object ID. Default is\n\t * <code>mxObjectId</code>.\n\t */\n\tFIELD_NAME: 'mxObjectId',\n\n\t/**\n\t * Variable: counter\n\t *\n\t * Current counter.\n\t */\n\tcounter: 0,\n\n\t/**\n\t * Function: get\n\t *\n\t * Returns the ID for the given object or function or null if no object\n\t * is specified.\n\t */\n\tget: function(obj)\n\t{\n\t\tif (obj != null)\n\t\t{\n\t\t\tif (obj[mxObjectIdentity.FIELD_NAME] == null)\n\t\t\t{\n\t\t\t\tif (typeof obj === 'object')\n\t\t\t\t{\n\t\t\t\t\tvar ctor = mxUtils.getFunctionName(obj.constructor);\n\t\t\t\t\tobj[mxObjectIdentity.FIELD_NAME] = ctor + '#' + mxObjectIdentity.counter++;\n\t\t\t\t}\n\t\t\t\telse if (typeof obj === 'function')\n\t\t\t\t{\n\t\t\t\t\tobj[mxObjectIdentity.FIELD_NAME] = 'Function#' + mxObjectIdentity.counter++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj[mxObjectIdentity.FIELD_NAME];\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: clear\n\t *\n\t * Deletes the ID from the given object or function.\n\t */\n\tclear: function(obj)\n\t{\n\t\tif (typeof(obj) === 'object' || typeof obj === 'function')\n\t\t{\n\t\t\tdelete obj[mxObjectIdentity.FIELD_NAME];\n\t\t}\n\t}\n\n};\n\n__mxOutput.mxObjectIdentity = typeof mxObjectIdentity !== 'undefined' ? mxObjectIdentity : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDictionary\n *\n * A wrapper class for an associative array with object keys. Note: This\n * implementation uses <mxObjectIdentitiy> to turn object keys into strings.\n *\n * Constructor: mxEventSource\n *\n * Constructs a new dictionary which allows object to be used as keys.\n */\nfunction mxDictionary()\n{\n\tthis.clear();\n};\n\n/**\n * Function: map\n *\n * Stores the (key, value) pairs in this dictionary.\n */\nmxDictionary.prototype.map = null;\n\n/**\n * Function: clear\n *\n * Clears the dictionary.\n */\nmxDictionary.prototype.clear = function()\n{\n\tthis.map = {};\n};\n\n/**\n * Function: get\n *\n * Returns the value for the given key.\n */\nmxDictionary.prototype.get = function(key)\n{\n\tvar id = mxObjectIdentity.get(key);\n\n\treturn this.map[id];\n};\n\n/**\n * Function: put\n *\n * Stores the value under the given key and returns the previous\n * value for that key.\n */\nmxDictionary.prototype.put = function(key, value)\n{\n\tvar id = mxObjectIdentity.get(key);\n\tvar previous = this.map[id];\n\tthis.map[id] = value;\n\n\treturn previous;\n};\n\n/**\n * Function: remove\n *\n * Removes the value for the given key and returns the value that\n * has been removed.\n */\nmxDictionary.prototype.remove = function(key)\n{\n\tvar id = mxObjectIdentity.get(key);\n\tvar previous = this.map[id];\n\tdelete this.map[id];\n\n\treturn previous;\n};\n\n/**\n * Function: getKeys\n *\n * Returns all keys as an array.\n */\nmxDictionary.prototype.getKeys = function()\n{\n\tvar result = [];\n\n\tfor (var key in this.map)\n\t{\n\t\tresult.push(key);\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getValues\n *\n * Returns all values as an array.\n */\nmxDictionary.prototype.getValues = function()\n{\n\tvar result = [];\n\n\tfor (var key in this.map)\n\t{\n\t\tresult.push(this.map[key]);\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: visit\n *\n * Visits all entries in the dictionary using the given function with the\n * following signature: function(key, value) where key is a string and\n * value is an object.\n *\n * Parameters:\n *\n * visitor - A function that takes the key and value as arguments.\n */\nmxDictionary.prototype.visit = function(visitor)\n{\n\tfor (var key in this.map)\n\t{\n\t\tvisitor(key, this.map[key]);\n\t}\n};\n\n__mxOutput.mxDictionary = typeof mxDictionary !== 'undefined' ? mxDictionary : undefined;\n\n/**\n * Copyright (c) 2006-2016, JGraph Ltd\n * Copyright (c) 2006-2016, Gaudenz Alder\n */\nvar mxResources =\n{\n\t/**\n\t * Class: mxResources\n\t *\n\t * Implements internationalization. You can provide any number of\n\t * resource files on the server using the following format for the\n\t * filename: name[-en].properties. The en stands for any lowercase\n\t * 2-character language shortcut (eg. de for german, fr for french).\n\t *\n\t * If the optional language extension is omitted, then the file is used as a\n\t * default resource which is loaded in all cases. If a properties file for a\n\t * specific language exists, then it is used to override the settings in the\n\t * default resource. All entries in the file are of the form key=value. The\n\t * values may then be accessed in code via <get>. Lines without\n\t * equal signs in the properties files are ignored.\n\t *\n\t * Resource files may either be added programmatically using\n\t * <add> or via a resource tag in the UI section of the\n\t * editor configuration file, eg:\n\t *\n\t * (code)\n\t * <mxEditor>\n\t *   <ui>\n\t *     <resource basename=\"examples/resources/mxWorkflow\"/>\n\t * (end)\n\t *\n\t * The above element will load examples/resources/mxWorkflow.properties as well\n\t * as the language specific file for the current language, if it exists.\n\t *\n\t * Values may contain placeholders of the form {1}...{n} where each placeholder\n\t * is replaced with the value of the corresponding array element in the params\n\t * argument passed to <mxResources.get>. The placeholder {1} maps to the first\n\t * element in the array (at index 0).\n\t *\n\t * See <mxClient.language> for more information on specifying the default\n\t * language or disabling all loading of resources.\n\t *\n\t * Lines that start with a # sign will be ignored.\n\t *\n\t * Special characters\n\t *\n\t * To use unicode characters, use the standard notation (eg. \\u8fd1) or %u as a\n\t * prefix (eg. %u20AC will display a Euro sign). For normal hex encoded strings,\n\t * use % as a prefix, eg. %F6 will display a \"o umlaut\" (&ouml;).\n\t *\n\t * See <resourcesEncoded> to disable this. If you disable this, make sure that\n\t * your files are UTF-8 encoded.\n\t *\n\t * Asynchronous loading\n\t *\n\t * By default, the core adds two resource files synchronously at load time.\n\t * To load these files asynchronously, set <mxLoadResources> to false\n\t * before loading mxClient.js and use <mxResources.loadResources> instead.\n\t *\n\t * Variable: resources\n\t *\n\t * Object that maps from keys to values.\n\t */\n\tresources: {},\n\n\t/**\n\t * Variable: extension\n\t *\n\t * Specifies the extension used for language files. Default is <mxResourceExtension>.\n\t */\n\textension: mxResourceExtension,\n\n\t/**\n\t * Variable: resourcesEncoded\n\t *\n\t * Specifies whether or not values in resource files are encoded with \\u or\n\t * percentage. Default is false.\n\t */\n\tresourcesEncoded: false,\n\n\t/**\n\t * Variable: loadDefaultBundle\n\t *\n\t * Specifies if the default file for a given basename should be loaded.\n\t * Default is true.\n\t */\n\tloadDefaultBundle: true,\n\n\t/**\n\t * Variable: loadDefaultBundle\n\t *\n\t * Specifies if the specific language file file for a given basename should\n\t * be loaded. Default is true.\n\t */\n\tloadSpecialBundle: true,\n\n\t/**\n\t * Function: isLanguageSupported\n\t *\n\t * Hook for subclassers to disable support for a given language. This\n\t * implementation returns true if lan is in <mxClient.languages>.\n\t *\n\t * Parameters:\n\t *\n\t * lan - The current language.\n\t */\n\tisLanguageSupported: function(lan)\n\t{\n\t\tif (mxClient.languages != null)\n\t\t{\n\t\t\treturn mxUtils.indexOf(mxClient.languages, lan) >= 0;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Function: getDefaultBundle\n\t *\n\t * Hook for subclassers to return the URL for the special bundle. This\n\t * implementation returns basename + <extension> or null if\n\t * <loadDefaultBundle> is false.\n\t *\n\t * Parameters:\n\t *\n\t * basename - The basename for which the file should be loaded.\n\t * lan - The current language.\n\t */\n\tgetDefaultBundle: function(basename, lan)\n\t{\n\t\tif (mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(lan))\n\t\t{\n\t\t\treturn basename + mxResources.extension;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t/**\n\t * Function: getSpecialBundle\n\t *\n\t * Hook for subclassers to return the URL for the special bundle. This\n\t * implementation returns basename + '_' + lan + <extension> or null if\n\t * <loadSpecialBundle> is false or lan equals <mxClient.defaultLanguage>.\n\t *\n\t * If <mxResources.languages> is not null and <mxClient.language> contains\n\t * a dash, then this method checks if <isLanguageSupported> returns true\n\t * for the full language (including the dash). If that returns false the\n\t * first part of the language (up to the dash) will be tried as an extension.\n\t *\n\t * If <mxResources.language> is null then the first part of the language is\n\t * used to maintain backwards compatibility.\n\t *\n\t * Parameters:\n\t *\n\t * basename - The basename for which the file should be loaded.\n\t * lan - The language for which the file should be loaded.\n\t */\n\tgetSpecialBundle: function(basename, lan)\n\t{\n\t\tif (mxClient.languages == null || !this.isLanguageSupported(lan))\n\t\t{\n\t\t\tvar dash = lan.indexOf('-');\n\n\t\t\tif (dash > 0)\n\t\t\t{\n\t\t\t\tlan = lan.substring(0, dash);\n\t\t\t}\n\t\t}\n\n\t\tif (mxResources.loadSpecialBundle && mxResources.isLanguageSupported(lan) && lan != mxClient.defaultLanguage)\n\t\t{\n\t\t\treturn basename + '_' + lan + mxResources.extension;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t/**\n\t * Function: add\n\t *\n\t * Adds the default and current language properties file for the specified\n\t * basename. Existing keys are overridden as new files are added. If no\n\t * callback is used then the request is synchronous.\n\t *\n\t * Example:\n\t *\n\t * At application startup, additional resources may be\n\t * added using the following code:\n\t *\n\t * (code)\n\t * mxResources.add('resources/editor');\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * basename - The basename for which the file should be loaded.\n\t * lan - The language for which the file should be loaded.\n\t * callback - Optional callback for asynchronous loading.\n\t */\n\tadd: function(basename, lan, callback)\n\t{\n\t\tlan = (lan != null) ? lan : ((mxClient.language != null) ?\n\t\t\tmxClient.language.toLowerCase() : mxConstants.NONE);\n\n\t\tif (lan != mxConstants.NONE)\n\t\t{\n\t\t\tvar defaultBundle = mxResources.getDefaultBundle(basename, lan);\n\t\t\tvar specialBundle = mxResources.getSpecialBundle(basename, lan);\n\n\t\t\tvar loadSpecialBundle = function()\n\t\t\t{\n\t\t\t\tif (specialBundle != null)\n\t\t\t\t{\n\t\t\t\t\tif (callback)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxUtils.get(specialBundle, function(req)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxResources.parse(req.getText());\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}, function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t   \t\tvar req = mxUtils.load(specialBundle);\n\n\t\t\t\t\t   \t\tif (req.isReady())\n\t\t\t\t\t   \t\t{\n\t\t\t\t\t \t   \t\tmxResources.parse(req.getText());\n\t\t\t\t\t   \t\t}\n\t\t\t\t   \t\t}\n\t\t\t\t   \t\tcatch (e)\n\t\t\t\t   \t\t{\n\t\t\t\t   \t\t\t// ignore\n\t\t\t\t\t   \t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (callback != null)\n\t\t\t\t{\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (defaultBundle != null)\n\t\t\t{\n\t\t\t\tif (callback)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.get(defaultBundle, function(req)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxResources.parse(req.getText());\n\t\t\t\t\t\tloadSpecialBundle();\n\t\t\t\t\t}, function()\n\t\t\t\t\t{\n\t\t\t\t\t\tloadSpecialBundle();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t   \t\tvar req = mxUtils.load(defaultBundle);\n\n\t\t\t\t   \t\tif (req.isReady())\n\t\t\t\t   \t\t{\n\t\t\t\t \t   \t\tmxResources.parse(req.getText());\n\t\t\t\t   \t\t}\n\n\t\t\t\t   \t\tloadSpecialBundle();\n\t\t\t\t  \t}\n\t\t\t\t  \tcatch (e)\n\t\t\t\t  \t{\n\t\t\t\t  \t\t// ignore\n\t\t\t\t  \t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Overlays the language specific file (_lan-extension)\n\t\t\t\tloadSpecialBundle();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: parse\n\t *\n\t * Parses the key, value pairs in the specified\n\t * text and stores them as local resources.\n\t */\n\tparse: function(text)\n\t{\n\t\tif (text != null)\n\t\t{\n\t\t\tvar lines = text.split('\\n');\n\n\t\t\tfor (var i = 0; i < lines.length; i++)\n\t\t\t{\n\t\t\t\tif (lines[i].charAt(0) != '#')\n\t\t\t\t{\n\t\t\t\t\tvar index = lines[i].indexOf('=');\n\n\t\t\t\t\tif (index > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar key = lines[i].substring(0, index);\n\t\t\t\t\t\tvar idx = lines[i].length;\n\n\t\t\t\t\t\tif (lines[i].charCodeAt(idx - 1) == 13)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tidx--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar value = lines[i].substring(index + 1, idx);\n\n\t\t\t\t\t\tif (this.resourcesEncoded)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvalue = value.replace(/\\\\(?=u[a-fA-F\\d]{4})/g,\"%\");\n\t\t\t\t\t\t\tmxResources.resources[key] = unescape(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxResources.resources[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: get\n\t *\n\t * Returns the value for the specified resource key.\n\t *\n\t * Example:\n\t * To read the value for 'welomeMessage', use the following:\n\t * (code)\n\t * var result = mxResources.get('welcomeMessage') || '';\n\t * (end)\n\t *\n\t * This would require an entry of the following form in\n\t * one of the English language resource files:\n\t * (code)\n\t * welcomeMessage=Welcome to mxGraph!\n\t * (end)\n\t *\n\t * The part behind the || is the string value to be used if the given\n\t * resource is not available.\n\t *\n\t * Parameters:\n\t *\n\t * key - String that represents the key of the resource to be returned.\n\t * params - Array of the values for the placeholders of the form {1}...{n}\n\t * to be replaced with in the resulting string.\n\t * defaultValue - Optional string that specifies the default return value.\n\t */\n\tget: function(key, params, defaultValue)\n\t{\n\t\tvar value = mxResources.resources[key];\n\n\t\t// Applies the default value if no resource was found\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue;\n\t\t}\n\n\t\t// Replaces the placeholders with the values in the array\n\t\tif (value != null && params != null)\n\t\t{\n\t\t\tvalue = mxResources.replacePlaceholders(value, params);\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: replacePlaceholders\n\t *\n\t * Replaces the given placeholders with the given parameters.\n\t *\n\t * Parameters:\n\t *\n\t * value - String that contains the placeholders.\n\t * params - Array of the values for the placeholders of the form {1}...{n}\n\t * to be replaced with in the resulting string.\n\t */\n\treplacePlaceholders: function(value, params)\n\t{\n\t\tvar result = [];\n\t\tvar index = null;\n\n\t\tfor (var i = 0; i < value.length; i++)\n\t\t{\n\t\t\tvar c = value.charAt(i);\n\n\t\t\tif (c == '{')\n\t\t\t{\n\t\t\t\tindex = '';\n\t\t\t}\n\t\t\telse if (index != null && \tc == '}')\n\t\t\t{\n\t\t\t\tindex = parseInt(index)-1;\n\n\t\t\t\tif (index >= 0 && index < params.length)\n\t\t\t\t{\n\t\t\t\t\tresult.push(params[index]);\n\t\t\t\t}\n\n\t\t\t\tindex = null;\n\t\t\t}\n\t\t\telse if (index != null)\n\t\t\t{\n\t\t\t\tindex += c;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.push(c);\n\t\t\t}\n\t\t}\n\n\t\treturn result.join('');\n\t},\n\n\t/**\n\t * Function: loadResources\n\t *\n\t * Loads all required resources asynchronously. Use this to load the graph and\n\t * editor resources if <mxLoadResources> is false.\n\t *\n\t * Parameters:\n\t *\n\t * callback - Callback function for asynchronous loading.\n\t */\n\tloadResources: function(callback)\n\t{\n\t\tmxResources.add(mxClient.basePath+'/resources/editor', null, function()\n\t\t{\n\t\t\tmxResources.add(mxClient.basePath+'/resources/graph', null, callback);\n\t\t});\n\t}\n\n};\n\n__mxOutput.mxResources = typeof mxResources !== 'undefined' ? mxResources : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPoint\n *\n * Implements a 2-dimensional vector with double precision coordinates.\n *\n * Constructor: mxPoint\n *\n * Constructs a new point for the optional x and y coordinates. If no\n * coordinates are given, then the default values for <x> and <y> are used.\n */\nfunction mxPoint(x, y)\n{\n\tthis.x = (x != null) ? x : 0;\n\tthis.y = (y != null) ? y : 0;\n};\n\n/**\n * Variable: x\n *\n * Holds the x-coordinate of the point. Default is 0.\n */\nmxPoint.prototype.x = null;\n\n/**\n * Variable: y\n *\n * Holds the y-coordinate of the point. Default is 0.\n */\nmxPoint.prototype.y = null;\n\n/**\n * Function: equals\n *\n * Returns true if the given object equals this point.\n */\nmxPoint.prototype.equals = function(obj)\n{\n\treturn obj != null && obj.x == this.x && obj.y == this.y;\n};\n\n/**\n * Function: clone\n *\n * Returns a clone of this <mxPoint>.\n */\nmxPoint.prototype.clone = function()\n{\n\t// Handles subclasses as well\n\treturn mxUtils.clone(this);\n};\n\n__mxOutput.mxPoint = typeof mxPoint !== 'undefined' ? mxPoint : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRectangle\n *\n * Extends <mxPoint> to implement a 2-dimensional rectangle with double\n * precision coordinates.\n *\n * Constructor: mxRectangle\n *\n * Constructs a new rectangle for the optional parameters. If no parameters\n * are given then the respective default values are used.\n */\nfunction mxRectangle(x, y, width, height)\n{\n\tmxPoint.call(this, x, y);\n\n\tthis.width = (width != null) ? width : 0;\n\tthis.height = (height != null) ? height : 0;\n};\n\n/**\n * Extends mxPoint.\n */\nmxRectangle.prototype = new mxPoint();\nmxRectangle.prototype.constructor = mxRectangle;\n\n/**\n * Variable: width\n *\n * Holds the width of the rectangle. Default is 0.\n */\nmxRectangle.prototype.width = null;\n\n/**\n * Variable: height\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxRectangle.prototype.height = null;\n\n/**\n * Function: setRect\n *\n * Sets this rectangle to the specified values\n */\nmxRectangle.prototype.setRect = function(x, y, w, h)\n{\n    this.x = x;\n    this.y = y;\n    this.width = w;\n    this.height = h;\n};\n\n/**\n * Function: getCenterX\n *\n * Returns the x-coordinate of the center point.\n */\nmxRectangle.prototype.getCenterX = function ()\n{\n\treturn this.x + this.width/2;\n};\n\n/**\n * Function: getCenterY\n *\n * Returns the y-coordinate of the center point.\n */\nmxRectangle.prototype.getCenterY = function ()\n{\n\treturn this.y + this.height/2;\n};\n\n/**\n * Function: add\n *\n * Adds the given rectangle to this rectangle.\n */\nmxRectangle.prototype.add = function(rect)\n{\n\tif (rect != null)\n\t{\n\t\tvar minX = Math.min(this.x, rect.x);\n\t\tvar minY = Math.min(this.y, rect.y);\n\t\tvar maxX = Math.max(this.x + this.width, rect.x + rect.width);\n\t\tvar maxY = Math.max(this.y + this.height, rect.y + rect.height);\n\n\t\tthis.x = minX;\n\t\tthis.y = minY;\n\t\tthis.width = maxX - minX;\n\t\tthis.height = maxY - minY;\n\t}\n};\n\n/**\n * Function: intersect\n *\n * Changes this rectangle to where it overlaps with the given rectangle.\n */\nmxRectangle.prototype.intersect = function(rect)\n{\n\tif (rect != null)\n\t{\n\t\tvar r1 = this.x + this.width;\n\t\tvar r2 = rect.x + rect.width;\n\n\t\tvar b1 = this.y + this.height;\n\t\tvar b2 = rect.y + rect.height;\n\n\t\tthis.x = Math.max(this.x, rect.x);\n\t\tthis.y = Math.max(this.y, rect.y);\n\t\tthis.width = Math.min(r1, r2) - this.x;\n\t\tthis.height = Math.min(b1, b2) - this.y;\n\t}\n};\n\n/**\n * Function: grow\n *\n * Grows the rectangle by the given amount, that is, this method subtracts\n * the given amount from the x- and y-coordinates and adds twice the amount\n * to the width and height.\n */\nmxRectangle.prototype.grow = function(amount)\n{\n\tthis.x -= amount;\n\tthis.y -= amount;\n\tthis.width += 2 * amount;\n\tthis.height += 2 * amount;\n};\n\n/**\n * Function: getPoint\n *\n * Returns the top, left corner as a new <mxPoint>.\n */\nmxRectangle.prototype.getPoint = function()\n{\n\treturn new mxPoint(this.x, this.y);\n};\n\n/**\n * Function: rotate90\n *\n * Rotates this rectangle by 90 degree around its center point.\n */\nmxRectangle.prototype.rotate90 = function()\n{\n\tvar t = (this.width - this.height) / 2;\n\tthis.x += t;\n\tthis.y -= t;\n\tvar tmp = this.width;\n\tthis.width = this.height;\n\tthis.height = tmp;\n};\n\n/**\n * Function: equals\n *\n * Returns true if the given object equals this rectangle.\n */\nmxRectangle.prototype.equals = function(obj)\n{\n\treturn obj != null && obj.x == this.x && obj.y == this.y &&\n\t\tobj.width == this.width && obj.height == this.height;\n};\n\n/**\n * Function: fromRectangle\n *\n * Returns a new <mxRectangle> which is a copy of the given rectangle.\n */\nmxRectangle.fromRectangle = function(rect)\n{\n\treturn new mxRectangle(rect.x, rect.y, rect.width, rect.height);\n};\n\n__mxOutput.mxRectangle = typeof mxRectangle !== 'undefined' ? mxRectangle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxEffects =\n{\n\n\t/**\n\t * Class: mxEffects\n\t *\n\t * Provides animation effects.\n\t */\n\n\t/**\n\t * Function: animateChanges\n\t *\n\t * Asynchronous animated move operation. See also: <mxMorphing>.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\n\t * {\n\t *   var changes = evt.getProperty('edit').changes;\n\t *\n\t *   if (changes.length < 10)\n\t *   {\n\t *     mxEffects.animateChanges(graph, changes);\n\t *   }\n\t * });\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> that received the changes.\n\t * changes - Array of changes to be animated.\n\t * done - Optional function argument that is invoked after the\n\t * last step of the animation.\n\t */\n\tanimateChanges: function(graph, changes, done)\n\t{\n\t\tvar maxStep = 10;\n\t\tvar step = 0;\n\n\t\tvar animate = function()\n\t\t{\n\t\t\tvar isRequired = false;\n\n\t\t\tfor (var i = 0; i < changes.length; i++)\n\t\t\t{\n\t\t\t\tvar change = changes[i];\n\n\t\t\t\tif (change instanceof mxGeometryChange ||\n\t\t\t\t\tchange instanceof mxTerminalChange ||\n\t\t\t\t\tchange instanceof mxValueChange ||\n\t\t\t\t\tchange instanceof mxChildChange ||\n\t\t\t\t\tchange instanceof mxStyleChange)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.getView().getState(change.cell || change.child, false);\n\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tisRequired = true;\n\n\t\t\t\t\t\tif (change.constructor != mxGeometryChange || graph.model.isEdge(change.cell))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxUtils.setOpacity(state.shape.node, 100 * step / maxStep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar scale = graph.getView().scale;\n\n\t\t\t\t\t\t\tvar dx = (change.geometry.x - change.previous.x) * scale;\n\t\t\t\t\t\t\tvar dy = (change.geometry.y - change.previous.y) * scale;\n\n\t\t\t\t\t\t\tvar sx = (change.geometry.width - change.previous.width) * scale;\n\t\t\t\t\t\t\tvar sy = (change.geometry.height - change.previous.height) * scale;\n\n\t\t\t\t\t\t\tif (step == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.x -= dx;\n\t\t\t\t\t\t\t\tstate.y -= dy;\n\t\t\t\t\t\t\t\tstate.width -= sx;\n\t\t\t\t\t\t\t\tstate.height -= sy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstate.x += dx / maxStep;\n\t\t\t\t\t\t\t\tstate.y += dy / maxStep;\n\t\t\t\t\t\t\t\tstate.width += sx / maxStep;\n\t\t\t\t\t\t\t\tstate.height += sy / maxStep;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgraph.cellRenderer.redraw(state);\n\n\t\t\t\t\t\t\t// Fades all connected edges and children\n\t\t\t\t\t\t\tmxEffects.cascadeOpacity(graph, change.cell, 100 * step / maxStep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (step < maxStep && isRequired)\n\t\t\t{\n\t\t\t\tstep++;\n\t\t\t\twindow.setTimeout(animate, delay);\n\t\t\t}\n\t\t\telse if (done != null)\n\t\t\t{\n\t\t\t\tdone();\n\t\t\t}\n\t\t};\n\n\t\tvar delay = 30;\n\t\tanimate();\n\t},\n\n\t/**\n\t * Function: cascadeOpacity\n\t *\n\t * Sets the opacity on the given cell and its descendants.\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> that contains the cells.\n\t * cell - <mxCell> to set the opacity for.\n\t * opacity - New value for the opacity in %.\n\t */\n    cascadeOpacity: function(graph, cell, opacity)\n\t{\n\t\t// Fades all children\n\t\tvar childCount = graph.model.getChildCount(cell);\n\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tvar child = graph.model.getChildAt(cell, i);\n\t\t\tvar childState = graph.getView().getState(child);\n\n\t\t\tif (childState != null)\n\t\t\t{\n\t\t\t\tmxUtils.setOpacity(childState.shape.node, opacity);\n\t\t\t\tmxEffects.cascadeOpacity(graph, child, opacity);\n\t\t\t}\n\t\t}\n\n\t\t// Fades all connected edges\n\t\tvar edges = graph.model.getEdges(cell);\n\n\t\tif (edges != null)\n\t\t{\n\t\t\tfor (var i=0; i<edges.length; i++)\n\t\t\t{\n\t\t\t\tvar edgeState = graph.getView().getState(edges[i]);\n\n\t\t\t\tif (edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tmxUtils.setOpacity(edgeState.shape.node, opacity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: fadeOut\n\t *\n\t * Asynchronous fade-out operation.\n\t */\n\tfadeOut: function(node, from, remove, step, delay, isEnabled)\n\t{\n\t\tstep = step || 40;\n\t\tdelay = delay || 30;\n\n\t\tvar opacity = from || 100;\n\n\t\tmxUtils.setOpacity(node, opacity);\n\n\t\tif (isEnabled || isEnabled == null)\n\t\t{\n\t\t\tvar f = function()\n\t\t\t{\n\t\t\t    opacity = Math.max(opacity-step, 0);\n\t\t\t\tmxUtils.setOpacity(node, opacity);\n\n\t\t\t\tif (opacity > 0)\n\t\t\t\t{\n\t\t\t\t\twindow.setTimeout(f, delay);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode.style.visibility = 'hidden';\n\n\t\t\t\t\tif (remove && node.parentNode)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\twindow.setTimeout(f, delay);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.style.visibility = 'hidden';\n\n\t\t\tif (remove && node.parentNode)\n\t\t\t{\n\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t}\n\t\t}\n\t}\n\n};\n\n__mxOutput.mxEffects = typeof mxEffects !== 'undefined' ? mxEffects : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxUtils =\n{\n\t/**\n\t * Class: mxUtils\n\t *\n\t * A singleton class that provides cross-browser helper methods.\n\t * This is a global functionality. To access the functions in this\n\t * class, use the global classname appended by the functionname.\n\t * You may have to load chrome://global/content/contentAreaUtils.js\n\t * to disable certain security restrictions in Mozilla for the <open>,\n\t * <save>, <saveAs> and <copy> function.\n\t *\n\t * For example, the following code displays an error message:\n\t *\n\t * (code)\n\t * mxUtils.error('Browser is not supported!', 200, false);\n\t * (end)\n\t *\n\t * Variable: errorResource\n\t *\n\t * Specifies the resource key for the title of the error window. If the\n\t * resource for this key does not exist then the value is used as\n\t * the title. Default is 'error'.\n\t */\n\terrorResource: (mxClient.language != 'none') ? 'error' : '',\n\n\t/**\n\t * Variable: closeResource\n\t *\n\t * Specifies the resource key for the label of the close button. If the\n\t * resource for this key does not exist then the value is used as\n\t * the label. Default is 'close'.\n\t */\n\tcloseResource: (mxClient.language != 'none') ? 'close' : '',\n\n\t/**\n\t * Variable: errorImage\n\t *\n\t * Defines the image used for error dialogs.\n\t */\n\terrorImage: mxClient.imageBasePath + '/error.gif',\n\n\t/**\n\t * Function: removeCursors\n\t *\n\t * Removes the cursors from the style of the given DOM node and its\n\t * descendants.\n\t *\n\t * Parameters:\n\t *\n\t * element - DOM node to remove the cursor style from.\n\t */\n\tremoveCursors: function(element)\n\t{\n\t\tif (element.style != null)\n\t\t{\n\t\t\telement.style.cursor = '';\n\t\t}\n\n\t\tvar children = element.childNodes;\n\n\t\tif (children != null)\n\t\t{\n\t        var childCount = children.length;\n\n\t        for (var i = 0; i < childCount; i += 1)\n\t        {\n\t            mxUtils.removeCursors(children[i]);\n\t        }\n\t    }\n\t},\n\n\t/**\n\t * Function: getCurrentStyle\n\t *\n\t * Returns the current style of the specified element.\n\t *\n\t * Parameters:\n\t *\n\t * element - DOM node whose current style should be returned.\n\t */\n\tgetCurrentStyle: function()\n\t{\n\t\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode < 9))\n\t\t{\n\t\t\treturn function(element)\n\t\t\t{\n\t\t\t\treturn (element != null) ? element.currentStyle : null;\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(element)\n\t\t\t{\n\t\t\t\treturn (element != null) ?\n\t\t\t\t\twindow.getComputedStyle(element, '') :\n\t\t\t\t\tnull;\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: parseCssNumber\n\t *\n\t * Parses the given CSS numeric value adding handling for the values thin,\n\t * medium and thick (2, 4 and 6).\n\t */\n\tparseCssNumber: function(value)\n\t{\n\t\tif (value == 'thin')\n\t\t{\n\t\t\tvalue = '2';\n\t\t}\n\t\telse if (value == 'medium')\n\t\t{\n\t\t\tvalue = '4';\n\t\t}\n\t\telse if (value == 'thick')\n\t\t{\n\t\t\tvalue = '6';\n\t\t}\n\n\t\tvalue = parseFloat(value);\n\n\t\tif (isNaN(value))\n\t\t{\n\t\t\tvalue = 0;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: setPrefixedStyle\n\t *\n\t * Adds the given style with the standard name and an optional vendor prefix for the current\n\t * browser.\n\t *\n\t * (code)\n\t * mxUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');\n\t * (end)\n\t */\n\tsetPrefixedStyle: function()\n\t{\n\t\tvar prefix = null;\n\n\t\tif (mxClient.IS_OT)\n\t\t{\n\t\t\tprefix = 'O';\n\t\t}\n\t\telse if (mxClient.IS_SF || mxClient.IS_GC)\n\t\t{\n\t\t\tprefix = 'Webkit';\n\t\t}\n\t\telse if (mxClient.IS_MT)\n\t\t{\n\t\t\tprefix = 'Moz';\n\t\t}\n\t\telse if (mxClient.IS_IE && document.documentMode >= 9 && document.documentMode < 10)\n\t\t{\n\t\t\tprefix = 'ms';\n\t\t}\n\n\t\treturn function(style, name, value)\n\t\t{\n\t\t\tstyle[name] = value;\n\n\t\t\tif (prefix != null && name.length > 0)\n\t\t\t{\n\t\t\t\tname = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);\n\t\t\t\tstyle[name] = value;\n\t\t\t}\n\t\t};\n\t}(),\n\n\t/**\n\t * Function: hasScrollbars\n\t *\n\t * Returns true if the overflow CSS property of the given node is either\n\t * scroll or auto.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node whose style should be checked for scrollbars.\n\t */\n\thasScrollbars: function(node)\n\t{\n\t\tvar style = mxUtils.getCurrentStyle(node);\n\n\t\treturn style != null && (style.overflow == 'scroll' || style.overflow == 'auto');\n\t},\n\n\t/**\n\t * Function: bind\n\t *\n\t * Returns a wrapper function that locks the execution scope of the given\n\t * function to the specified scope. Inside funct, the \"this\" keyword\n\t * becomes a reference to that scope.\n\t */\n\tbind: function(scope, funct)\n\t{\n\t\treturn function()\n\t\t{\n\t\t\treturn funct.apply(scope, arguments);\n\t\t};\n\t},\n\n\t/**\n\t * Function: eval\n\t *\n\t * Evaluates the given expression using eval and returns the JavaScript\n\t * object that represents the expression result. Supports evaluation of\n\t * expressions that define functions and returns the function object for\n\t * these expressions.\n\t *\n\t * Parameters:\n\t *\n\t * expr - A string that represents a JavaScript expression.\n\t */\n\teval: function(expr)\n\t{\n\t\tvar result = null;\n\n\t\tif (expr.indexOf('function') >= 0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\teval('var _mxJavaScriptExpression='+expr);\n\t\t\t\tresult = _mxJavaScriptExpression;\n\t\t\t\t// TODO: Use delete here?\n\t\t\t\t_mxJavaScriptExpression = null;\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tmxLog.warn(e.message + ' while evaluating ' + expr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tresult = eval(expr);\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tmxLog.warn(e.message + ' while evaluating ' + expr);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: findNode\n\t *\n\t * Returns the first node where attr equals value.\n\t * This implementation does not use XPath.\n\t */\n\tfindNode: function(node, attr, value)\n\t{\n\t\tif (node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\tvar tmp = node.getAttribute(attr);\n\n\t\t\tif (tmp != null && tmp == value)\n\t\t\t{\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\n\t\tnode = node.firstChild;\n\n\t\twhile (node != null)\n\t\t{\n\t\t\tvar result = mxUtils.findNode(node, attr, value);\n\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tnode = node.nextSibling;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: getFunctionName\n\t *\n\t * Returns the name for the given function.\n\t *\n\t * Parameters:\n\t *\n\t * f - JavaScript object that represents a function.\n\t */\n\tgetFunctionName: function(f)\n\t{\n\t\tvar str = null;\n\n\t\tif (f != null)\n\t\t{\n\t\t\tif (f.name != null)\n\t\t\t{\n\t\t\t\tstr = f.name;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = mxUtils.trim(f.toString());\n\n\t\t\t\tif (/^function\\s/.test(str))\n\t\t\t\t{\n\t\t\t\t\tstr = mxUtils.ltrim(str.substring(9));\n\t\t\t\t\tvar idx2 = str.indexOf('(');\n\n\t\t\t\t\tif (idx2 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstr = str.substring(0, idx2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn str;\n\t},\n\n\t/**\n\t * Function: indexOf\n\t *\n\t * Returns the index of obj in array or -1 if the array does not contain\n\t * the given object.\n\t *\n\t * Parameters:\n\t *\n\t * array - Array to check for the given obj.\n\t * obj - Object to find in the given array.\n\t */\n\tindexOf: function(array, obj)\n\t{\n\t\tif (array != null && obj != null)\n\t\t{\n\t\t\tfor (var i = 0; i < array.length; i++)\n\t\t\t{\n\t\t\t\tif (array[i] == obj)\n\t\t\t\t{\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\t/**\n\t * Function: forEach\n\t *\n\t * Calls the given function for each element of the given array and returns\n\t * the array.\n\t *\n\t * Parameters:\n\t *\n\t * array - Array that contains the elements.\n\t * fn - Function to be called for each object.\n\t */\n\tforEach: function(array, fn)\n\t{\n\t\tif (array != null && fn != null)\n\t\t{\n\t\t\tfor (var i = 0; i < array.length; i++)\n\t\t\t{\n\t\t\t\tfn(array[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn array;\n\t},\n\n\t/**\n\t * Function: remove\n\t *\n\t * Removes all occurrences of the given object in the given array or\n\t * object. If there are multiple occurrences of the object, be they\n\t * associative or as an array entry, all occurrences are removed from\n\t * the array or deleted from the object. By removing the object from\n\t * the array, all elements following the removed element are shifted\n\t * by one step towards the beginning of the array.\n\t *\n\t * The length of arrays is not modified inside this function.\n\t *\n\t * Parameters:\n\t *\n\t * obj - Object to find in the given array.\n\t * array - Array to check for the given obj.\n\t */\n\tremove: function(obj, array)\n\t{\n\t\tvar result = null;\n\n\t\tif (typeof(array) == 'object')\n\t\t{\n\t\t\tvar index = mxUtils.indexOf(array, obj);\n\n\t\t\twhile (index >= 0)\n\t\t\t{\n\t\t\t\tarray.splice(index, 1);\n\t\t\t\tresult = obj;\n\t\t\t\tindex = mxUtils.indexOf(array, obj);\n\t\t\t}\n\t\t}\n\n\t\tfor (var key in array)\n\t\t{\n\t\t\tif (array[key] == obj)\n\t\t\t{\n\t\t\t\tdelete array[key];\n\t\t\t\tresult = obj;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: isNode\n\t *\n\t * Returns true if the given value is an XML node with the node name\n\t * and if the optional attribute has the specified value.\n\t *\n\t * This implementation assumes that the given value is a DOM node if the\n\t * nodeType property is numeric, that is, if isNaN returns false for\n\t * value.nodeType.\n\t *\n\t * Parameters:\n\t *\n\t * value - Object that should be examined as a node.\n\t * nodeName - String that specifies the node name.\n\t * attributeName - Optional attribute name to check.\n\t * attributeValue - Optional attribute value to check.\n\t */\n\t isNode: function(value, nodeName, attributeName, attributeValue)\n\t {\n\t \tif (value != null && !isNaN(value.nodeType) && (nodeName == null ||\n\t \t\tvalue.nodeName.toLowerCase() == nodeName.toLowerCase()))\n \t\t{\n \t\t\treturn attributeName == null ||\n \t\t\t\tvalue.getAttribute(attributeName) == attributeValue;\n \t\t}\n\n\t \treturn false;\n\t },\n\n\t/**\n\t * Function: isAncestorNode\n\t *\n\t * Returns true if the given ancestor is an ancestor of the\n\t * given DOM node in the DOM. This also returns true if the\n\t * child is the ancestor.\n\t *\n\t * Parameters:\n\t *\n\t * ancestor - DOM node that represents the ancestor.\n\t * child - DOM node that represents the child.\n\t */\n\t isAncestorNode: function(ancestor, child)\n\t {\n\t \tvar parent = child;\n\n\t \twhile (parent != null)\n\t \t{\n\t \t\tif (parent == ancestor)\n\t \t\t{\n\t \t\t\treturn true;\n\t \t\t}\n\n\t \t\tparent = parent.parentNode;\n\t \t}\n\n\t \treturn false;\n\t },\n\n\t/**\n\t * Function: getChildNodes\n\t *\n\t * Returns an array of child nodes that are of the given node type.\n\t *\n\t * Parameters:\n\t *\n\t * node - Parent DOM node to return the children from.\n\t * nodeType - Optional node type to return. Default is\n\t * <mxConstants.NODETYPE_ELEMENT>.\n\t */\n\tgetChildNodes: function(node, nodeType)\n\t{\n\t\tnodeType = nodeType || mxConstants.NODETYPE_ELEMENT;\n\n\t\tvar children = [];\n\t\tvar tmp = node.firstChild;\n\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp.nodeType == nodeType)\n\t\t\t{\n\t\t\t\tchildren.push(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\n\n\t\treturn children;\n\t},\n\n\t/**\n\t * Function: importNode\n\t *\n\t * Cross browser implementation for document.importNode. Uses document.importNode\n\t * in all browsers but IE, where the node is cloned by creating a new node and\n\t * copying all attributes and children into it using importNode, recursively.\n\t *\n\t * Parameters:\n\t *\n\t * doc - Document to import the node into.\n\t * node - Node to be imported.\n\t * allChildren - If all children should be imported.\n\t */\n\timportNode: function(doc, node, allChildren)\n\t{\n\t\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode < 10))\n\t\t{\n\t\t\tswitch (node.nodeType)\n\t\t\t{\n\t\t\t\tcase 1: /* element */\n\t\t\t\t{\n\t\t\t\t\tvar newNode = doc.createElement(node.nodeName);\n\n\t\t\t\t\tif (node.attributes && node.attributes.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var i = 0; i < node.attributes.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnewNode.setAttribute(node.attributes[i].nodeName,\n\t\t\t\t\t\t\t\tnode.getAttribute(node.attributes[i].nodeName));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (allChildren && node.childNodes && node.childNodes.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (var i = 0; i < node.childNodes.length; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnewNode.appendChild(mxUtils.importNode(doc, node.childNodes[i], allChildren));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn newNode;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3: /* text */\n\t\t\t    case 4: /* cdata-section */\n\t\t\t    case 8: /* comment */\n\t\t\t    {\n\t\t\t      return doc.createTextNode(node.value);\n\t\t\t      break;\n\t\t\t    }\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn doc.importNode(node, allChildren);\n\t\t}\n\t},\n\n\t/**\n\t * Function: createXmlDocument\n\t *\n\t * Returns a new, empty XML document.\n\t */\n\tcreateXmlDocument: function()\n\t{\n\t\tvar doc = null;\n\n\t\tif (document.implementation && document.implementation.createDocument)\n\t\t{\n\t\t\tdoc = document.implementation.createDocument('', '', null);\n\t\t}\n\t\telse if (window.ActiveXObject)\n\t\t{\n\t\t\tdoc = new ActiveXObject('Microsoft.XMLDOM');\n\t \t}\n\n\t \treturn doc;\n\t},\n\n\t/**\n\t * Function: parseXml\n\t *\n\t * Parses the specified XML string into a new XML document and returns the\n\t * new document.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * var doc = mxUtils.parseXml(\n\t *   '<mxGraphModel><root><MyDiagram id=\"0\"><mxCell/></MyDiagram>'+\n\t *   '<MyLayer id=\"1\"><mxCell parent=\"0\" /></MyLayer><MyObject id=\"2\">'+\n\t *   '<mxCell style=\"strokeColor=blue;fillColor=red\" parent=\"1\" vertex=\"1\">'+\n\t *   '<mxGeometry x=\"10\" y=\"10\" width=\"80\" height=\"30\" as=\"geometry\"/>'+\n\t *   '</mxCell></MyObject></root></mxGraphModel>');\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * xml - String that contains the XML data.\n\t */\n\tparseXml: function()\n\t{\n\t\tif (window.DOMParser)\n\t\t{\n\t\t\treturn function(xml)\n\t\t\t{\n\t\t\t\tvar parser = new DOMParser();\n\n\t\t\t\treturn parser.parseFromString(xml, 'text/xml');\n\t\t\t};\n\t\t}\n\t\telse // IE<=9\n\t\t{\n\t\t\treturn function(xml)\n\t\t\t{\n\t\t\t\tvar result = mxUtils.createXmlDocument();\n\t\t\t\tresult.async = false;\n\t\t\t\t// Workaround for parsing errors with SVG DTD\n\t\t\t\tresult.validateOnParse = false;\n\t\t\t\tresult.resolveExternals = false;\n\t\t\t\tresult.loadXML(xml);\n\n\t\t\t\treturn result;\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: clearSelection\n\t *\n\t * Clears the current selection in the page.\n\t */\n\tclearSelection: function()\n\t{\n\t\tif (document.selection)\n\t\t{\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tdocument.selection.empty();\n\t\t\t};\n\t\t}\n\t\telse if (window.getSelection)\n\t\t{\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tif (window.getSelection().empty)\n\t\t\t\t{\n\t\t\t\t\twindow.getSelection().empty();\n\t\t\t\t}\n\t\t\t\telse if (window.getSelection().removeAllRanges)\n\t\t\t\t{\n\t\t\t\t\twindow.getSelection().removeAllRanges();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function() { };\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: getPrettyXML\n\t *\n\t * Returns a pretty printed string that represents the XML tree for the\n\t * given node. This method should only be used to print XML for reading,\n\t * use <getXml> instead to obtain a string for processing.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node to return the XML for.\n\t * tab - Optional string that specifies the indentation for one level.\n\t * Default is two spaces.\n\t * indent - Optional string that represents the current indentation.\n\t * Default is an empty string.\n\t */\n\tgetPrettyXml: function(node, tab, indent)\n\t{\n\t\tvar result = [];\n\n\t\tif (node != null)\n\t\t{\n\t\t\ttab = tab || '  ';\n\t\t\tindent = indent || '';\n\n\t\t\tif (node.nodeType == mxConstants.NODETYPE_TEXT)\n\t\t\t{\n\t\t\t\tvar value =  mxUtils.trim(mxUtils.getTextContent(node));\n\n\t\t\t\tif (value.length > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(indent + mxUtils.htmlEntities(value) + '\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.push(indent + '<' + node.nodeName);\n\n\t\t\t\t// Creates the string with the node attributes\n\t\t\t\t// and converts all HTML entities in the values\n\t\t\t\tvar attrs = node.attributes;\n\n\t\t\t\tif (attrs != null)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar val = mxUtils.htmlEntities(attrs[i].value);\n\t\t\t\t\t\tresult.push(' ' + attrs[i].nodeName + '=\"' + val + '\"');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Recursively creates the XML string for each\n\t\t\t\t// child nodes and appends it here with an\n\t\t\t\t// indentation\n\t\t\t\tvar tmp = node.firstChild;\n\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tresult.push('>\\n');\n\n\t\t\t\t\twhile (tmp != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(mxUtils.getPrettyXml(tmp, tab, indent + tab));\n\t\t\t\t\t\ttmp = tmp.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.push(indent + '</'+node.nodeName + '>\\n');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult.push('/>\\n');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result.join('');\n\t},\n\n\t/**\n\t * Function: removeWhitespace\n\t *\n\t * Removes the sibling text nodes for the given node that only consists\n\t * of tabs, newlines and spaces.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node whose siblings should be removed.\n\t * before - Optional boolean that specifies the direction of the traversal.\n\t */\n\tremoveWhitespace: function(node, before)\n\t{\n\t\tvar tmp = (before) ? node.previousSibling : node.nextSibling;\n\n\t\twhile (tmp != null && tmp.nodeType == mxConstants.NODETYPE_TEXT)\n\t\t{\n\t\t\tvar next = (before) ? tmp.previousSibling : tmp.nextSibling;\n\t\t\tvar text = mxUtils.getTextContent(tmp);\n\n\t\t\tif (mxUtils.trim(text).length == 0)\n\t\t\t{\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t}\n\n\t\t\ttmp = next;\n\t\t}\n\t},\n\n\t/**\n\t * Function: htmlEntities\n\t *\n\t * Replaces characters (less than, greater than, newlines and quotes) with\n\t * their HTML entities in the given string and returns the result.\n\t *\n\t * Parameters:\n\t *\n\t * s - String that contains the characters to be converted.\n\t * newline - If newlines should be replaced. Default is true.\n\t */\n\thtmlEntities: function(s, newline)\n\t{\n\t\ts = String(s || '');\n\n\t\ts = s.replace(/&/g,'&amp;'); // 38 26\n\t\ts = s.replace(/\"/g,'&quot;'); // 34 22\n\t\ts = s.replace(/\\'/g,'&#39;'); // 39 27\n\t\ts = s.replace(/</g,'&lt;'); // 60 3C\n\t\ts = s.replace(/>/g,'&gt;'); // 62 3E\n\n\t\tif (newline == null || newline)\n\t\t{\n\t\t\ts = s.replace(/\\n/g, '&#xa;');\n\t\t}\n\n\t\treturn s;\n\t},\n\n\t/**\n\t * Function: isVml\n\t *\n\t * Returns true if the given node is in the VML namespace.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node whose tag urn should be checked.\n\t */\n\tisVml: function(node)\n\t{\n\t\treturn node != null && node.tagUrn == 'urn:schemas-microsoft-com:vml';\n\t},\n\n\t/**\n\t * Function: getXml\n\t *\n\t * Returns the XML content of the specified node. For Internet Explorer,\n\t * all \\r\\n\\t[\\t]* are removed from the XML string and the remaining \\r\\n\n\t * are replaced by \\n. All \\n are then replaced with linefeed, or &#xa; if\n\t * no linefeed is defined.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node to return the XML for.\n\t * linefeed - Optional string that linefeeds are converted into. Default is\n\t * &#xa;\n\t */\n\tgetXml: function(node, linefeed)\n\t{\n\t\tvar xml = '';\n\n\t\tif (window.XMLSerializer != null)\n\t\t{\n\t\t\tvar xmlSerializer = new XMLSerializer();\n\t\t\txml = xmlSerializer.serializeToString(node);\n\t\t}\n\t\telse if (node.xml != null)\n\t\t{\n\t\t\txml = node.xml.replace(/\\r\\n\\t[\\t]*/g, '').\n\t\t\t\treplace(/>\\r\\n/g, '>').\n\t\t\t\treplace(/\\r\\n/g, '\\n');\n\t\t}\n\n\t\t// Replaces linefeeds with HTML Entities.\n\t\tlinefeed = linefeed || '&#xa;';\n\t\txml = xml.replace(/\\n/g, linefeed);\n\n\t\treturn xml;\n\t},\n\n\t/**\n\t * Function: extractTextWithWhitespace\n\t *\n\t * Returns the text content of the specified node.\n\t *\n\t * Parameters:\n\t *\n\t * elems - DOM nodes to return the text for.\n\t */\n\textractTextWithWhitespace: function(elems)\n\t{\n\t    // Known block elements for handling linefeeds (list is not complete)\n\t\tvar blocks = ['BLOCKQUOTE', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'OL', 'P', 'PRE', 'TABLE', 'UL'];\n\t\tvar ret = [];\n\n\t\tfunction doExtract(elts)\n\t\t{\n\t\t\t// Single break should be ignored\n\t\t\tif (elts.length == 1 && (elts[0].nodeName == 'BR' ||\n\t\t\t\telts[0].innerHTML == '\\n'))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t    for (var i = 0; i < elts.length; i++)\n\t\t    {\n\t\t        var elem = elts[i];\n\n\t\t\t\t// DIV with a br or linefeed forces a linefeed\n\t\t\t\tif (elem.nodeName == 'BR' || elem.innerHTML == '\\n' ||\n\t\t\t\t\t((elts.length == 1 || i == 0) && (elem.nodeName == 'DIV' &&\n\t\t\t\t\telem.innerHTML.toLowerCase() == '<br>')))\n\t\t    \t{\n\t    \t\t\tret.push('\\n');\n\t\t    \t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t        if (elem.nodeType === 3 || elem.nodeType === 4)\n\t\t\t        {\n\t\t\t        \tif (elem.nodeValue.length > 0)\n\t\t\t        \t{\n\t\t\t        \t\tret.push(elem.nodeValue);\n\t\t\t        \t}\n\t\t\t        }\n\t\t\t        else if (elem.nodeType !== 8 && elem.childNodes.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoExtract(elem.childNodes);\n\t\t\t\t\t}\n\n\t        \t\tif (i < elts.length - 1 && mxUtils.indexOf(blocks, elts[i + 1].nodeName) >= 0)\n\t        \t\t{\n\t        \t\t\tret.push('\\n');\n\t        \t\t}\n\t\t\t\t}\n\t\t    }\n\t\t};\n\n\t\tdoExtract(elems);\n\n\t    return ret.join('');\n\t},\n\n\t/**\n\t * Function: replaceTrailingNewlines\n\t *\n\t * Replaces each trailing newline with the given pattern.\n\t */\n\treplaceTrailingNewlines: function(str, pattern)\n\t{\n\t\t// LATER: Check is this can be done with a regular expression\n\t\tvar postfix = '';\n\n\t\twhile (str.length > 0 && str.charAt(str.length - 1) == '\\n')\n\t\t{\n\t\t\tstr = str.substring(0, str.length - 1);\n\t\t\tpostfix += pattern;\n\t\t}\n\n\t\treturn str + postfix;\n\t},\n\n\t/**\n\t * Function: getTextContent\n\t *\n\t * Returns the text content of the specified node.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node to return the text content for.\n\t */\n\tgetTextContent: function(node)\n\t{\n\t\t// Only IE10-\n\t\tif (mxClient.IS_IE && node.innerText !== undefined)\n\t\t{\n\t\t\treturn node.innerText;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn (node != null) ? node[(node.textContent === undefined) ? 'text' : 'textContent'] : '';\n\t\t}\n\t},\n\n\t/**\n\t * Function: setTextContent\n\t *\n\t * Sets the text content of the specified node.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node to set the text content for.\n\t * text - String that represents the text content.\n\t */\n\tsetTextContent: function(node, text)\n\t{\n\t\tif (node.innerText !== undefined)\n\t\t{\n\t\t\tnode.innerText = text;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode[(node.textContent === undefined) ? 'text' : 'textContent'] = text;\n\t\t}\n\t},\n\n\t/**\n\t * Function: getInnerHtml\n\t *\n\t * Returns the inner HTML for the given node as a string or an empty string\n\t * if no node was specified. The inner HTML is the text representing all\n\t * children of the node, but not the node itself.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node to return the inner HTML for.\n\t */\n\tgetInnerHtml: function()\n\t{\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\treturn node.innerHTML;\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tvar serializer = new XMLSerializer();\n\t\t\t\t\treturn serializer.serializeToString(node);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: getOuterHtml\n\t *\n\t * Returns the outer HTML for the given node as a string or an empty\n\t * string if no node was specified. The outer HTML is the text representing\n\t * all children of the node including the node itself.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node to return the outer HTML for.\n\t */\n\tgetOuterHtml: function()\n\t{\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tif (node.outerHTML != null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn node.outerHTML;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = [];\n\t\t\t\t\t\ttmp.push('<'+node.nodeName);\n\n\t\t\t\t\t\tvar attrs = node.attributes;\n\n\t\t\t\t\t\tif (attrs != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar value = attrs[i].value;\n\n\t\t\t\t\t\t\t\tif (value != null && value.length > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp.push(' ');\n\t\t\t\t\t\t\t\t\ttmp.push(attrs[i].nodeName);\n\t\t\t\t\t\t\t\t\ttmp.push('=\"');\n\t\t\t\t\t\t\t\t\ttmp.push(value);\n\t\t\t\t\t\t\t\t\ttmp.push('\"');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (node.innerHTML.length == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp.push('/>');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttmp.push('>');\n\t\t\t\t\t\t\ttmp.push(node.innerHTML);\n\t\t\t\t\t\t\ttmp.push('</'+node.nodeName+'>');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn tmp.join('');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(node)\n\t\t\t{\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tvar serializer = new XMLSerializer();\n\t\t\t\t\treturn serializer.serializeToString(node);\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: write\n\t *\n\t * Creates a text node for the given string and appends it to the given\n\t * parent. Returns the text node.\n\t *\n\t * Parameters:\n\t *\n\t * parent - DOM node to append the text node to.\n\t * text - String representing the text to be added.\n\t */\n\twrite: function(parent, text)\n\t{\n\t\tvar doc = parent.ownerDocument;\n\t\tvar node = doc.createTextNode(text);\n\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(node);\n\t\t}\n\n\t\treturn node;\n\t},\n\n\t/**\n\t * Function: writeln\n\t *\n\t * Creates a text node for the given string and appends it to the given\n\t * parent with an additional linefeed. Returns the text node.\n\t *\n\t * Parameters:\n\t *\n\t * parent - DOM node to append the text node to.\n\t * text - String representing the text to be added.\n\t */\n\twriteln: function(parent, text)\n\t{\n\t\tvar doc = parent.ownerDocument;\n\t\tvar node = doc.createTextNode(text);\n\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(node);\n\t\t\tparent.appendChild(document.createElement('br'));\n\t\t}\n\n\t\treturn node;\n\t},\n\n\t/**\n\t * Function: br\n\t *\n\t * Appends a linebreak to the given parent and returns the linebreak.\n\t *\n\t * Parameters:\n\t *\n\t * parent - DOM node to append the linebreak to.\n\t */\n\tbr: function(parent, count)\n\t{\n\t\tcount = count || 1;\n\t\tvar br = null;\n\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tif (parent != null)\n\t\t\t{\n\t\t\t\tbr = parent.ownerDocument.createElement('br');\n\t\t\t\tparent.appendChild(br);\n\t\t\t}\n\t\t}\n\n\t\treturn br;\n\t},\n\n\t/**\n\t * Function: button\n\t *\n\t * Returns a new button with the given level and function as an onclick\n\t * event handler.\n\t *\n\t * (code)\n\t * document.body.appendChild(mxUtils.button('Test', function(evt)\n\t * {\n\t *   alert('Hello, World!');\n\t * }));\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * label - String that represents the label of the button.\n\t * funct - Function to be called if the button is pressed.\n\t * doc - Optional document to be used for creating the button. Default is the\n\t * current document.\n\t */\n\tbutton: function(label, funct, doc)\n\t{\n\t\tdoc = (doc != null) ? doc : document;\n\n\t\tvar button = doc.createElement('button');\n\t\tmxUtils.write(button, label);\n\n\t\tmxEvent.addListener(button, 'click', function(evt)\n\t\t{\n\t\t\tfunct(evt);\n\t\t});\n\n\t\treturn button;\n\t},\n\n\t/**\n\t * Function: para\n\t *\n\t * Appends a new paragraph with the given text to the specified parent and\n\t * returns the paragraph.\n\t *\n\t * Parameters:\n\t *\n\t * parent - DOM node to append the text node to.\n\t * text - String representing the text for the new paragraph.\n\t */\n\tpara: function(parent, text)\n\t{\n\t\tvar p = document.createElement('p');\n\t\tmxUtils.write(p, text);\n\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(p);\n\t\t}\n\n\t\treturn p;\n\t},\n\n\t/**\n\t * Function: addTransparentBackgroundFilter\n\t *\n\t * Adds a transparent background to the filter of the given node. This\n\t * background can be used in IE8 standards mode (native IE8 only) to pass\n\t * events through the node.\n\t */\n\taddTransparentBackgroundFilter: function(node)\n\t{\n\t\tnode.style.filter += 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\\'' +\n\t\t\tmxClient.imageBasePath + '/transparent.gif\\', sizingMethod=\\'scale\\')';\n\t},\n\n\t/**\n\t * Function: linkAction\n\t *\n\t * Adds a hyperlink to the specified parent that invokes action on the\n\t * specified editor.\n\t *\n\t * Parameters:\n\t *\n\t * parent - DOM node to contain the new link.\n\t * text - String that is used as the link label.\n\t * editor - <mxEditor> that will execute the action.\n\t * action - String that defines the name of the action to be executed.\n\t * pad - Optional left-padding for the link. Default is 0.\n\t */\n\tlinkAction: function(parent, text, editor, action, pad)\n\t{\n\t\treturn mxUtils.link(parent, text, function()\n\t\t{\n\t\t\teditor.execute(action);\n\t\t}, pad);\n\t},\n\n\t/**\n\t * Function: linkInvoke\n\t *\n\t * Adds a hyperlink to the specified parent that invokes the specified\n\t * function on the editor passing along the specified argument. The\n\t * function name is the name of a function of the editor instance,\n\t * not an action name.\n\t *\n\t * Parameters:\n\t *\n\t * parent - DOM node to contain the new link.\n\t * text - String that is used as the link label.\n\t * editor - <mxEditor> instance to execute the function on.\n\t * functName - String that represents the name of the function.\n\t * arg - Object that represents the argument to the function.\n\t * pad - Optional left-padding for the link. Default is 0.\n\t */\n\tlinkInvoke: function(parent, text, editor, functName, arg, pad)\n\t{\n\t\treturn mxUtils.link(parent, text, function()\n\t\t{\n\t\t\teditor[functName](arg);\n\t\t}, pad);\n\t},\n\n\t/**\n\t * Function: link\n\t *\n\t * Adds a hyperlink to the specified parent and invokes the given function\n\t * when the link is clicked.\n\t *\n\t * Parameters:\n\t *\n\t * parent - DOM node to contain the new link.\n\t * text - String that is used as the link label.\n\t * funct - Function to execute when the link is clicked.\n\t * pad - Optional left-padding for the link. Default is 0.\n\t */\n\tlink: function(parent, text, funct, pad)\n\t{\n\t\tvar a = document.createElement('span');\n\n\t\ta.style.color = 'blue';\n\t\ta.style.textDecoration = 'underline';\n\t\ta.style.cursor = 'pointer';\n\n\t\tif (pad != null)\n\t\t{\n\t\t\ta.style.paddingLeft = pad+'px';\n\t\t}\n\n\t\tmxEvent.addListener(a, 'click', funct);\n\t\tmxUtils.write(a, text);\n\n\t\tif (parent != null)\n\t\t{\n\t\t\tparent.appendChild(a);\n\t\t}\n\n\t\treturn a;\n\t},\n\n\t/**\n\t * Function: getDocumentSize\n\t *\n\t * Returns the client size for the current document as an <mxRectangle>.\n\t */\n\tgetDocumentSize: function()\n\t{\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\n\t\ttry\n\t\t{\n\t\t\treturn new mxRectangle(0, 0, b.clientWidth || d.clientWidth, Math.max(b.clientHeight || 0, d.clientHeight));\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\treturn new mxRectangle();\n\t\t}\n\t},\n\n\t/**\n\t * Function: fit\n\t *\n\t * Makes sure the given node is inside the visible area of the window. This\n\t * is done by setting the left and top in the style.\n\t */\n\tfit: function(node)\n\t{\n\t\tvar ds = mxUtils.getDocumentSize();\n\t\tvar left = parseInt(node.offsetLeft);\n\t\tvar width = parseInt(node.offsetWidth);\n\n\t\tvar offset = mxUtils.getDocumentScrollOrigin(node.ownerDocument);\n\t\tvar sl = offset.x;\n\t\tvar st = offset.y;\n\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\t\tvar right = (sl) + ds.width;\n\n\t\tif (left + width > right)\n\t\t{\n\t\t\tnode.style.left = Math.max(sl, right - width) + 'px';\n\t\t}\n\n\t\tvar top = parseInt(node.offsetTop);\n\t\tvar height = parseInt(node.offsetHeight);\n\n\t\tvar bottom = st + ds.height;\n\n\t\tif (top + height > bottom)\n\t\t{\n\t\t\tnode.style.top = Math.max(st, bottom - height) + 'px';\n\t\t}\n\t},\n\n\t/**\n\t * Function: load\n\t *\n\t * Loads the specified URL *synchronously* and returns the <mxXmlRequest>.\n\t * Throws an exception if the file cannot be loaded. See <mxUtils.get> for\n\t * an asynchronous implementation.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * try\n\t * {\n\t *   var req = mxUtils.load(filename);\n\t *   var root = req.getDocumentElement();\n\t *   // Process XML DOM...\n\t * }\n\t * catch (ex)\n\t * {\n\t *   mxUtils.alert('Cannot load '+filename+': '+ex);\n\t * }\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * url - URL to get the data from.\n\t */\n\tload: function(url)\n\t{\n\t\tvar req = new mxXmlRequest(url, null, 'GET', false);\n\t\treq.send();\n\n\t\treturn req;\n\t},\n\n\t/**\n\t * Function: get\n\t *\n\t * Loads the specified URL *asynchronously* and invokes the given functions\n\t * depending on the request status. Returns the <mxXmlRequest> in use. Both\n\t * functions take the <mxXmlRequest> as the only parameter. See\n\t * <mxUtils.load> for a synchronous implementation.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * mxUtils.get(url, function(req)\n\t * {\n\t *    var node = req.getDocumentElement();\n\t *    // Process XML DOM...\n\t * });\n\t * (end)\n\t *\n\t * So for example, to load a diagram into an existing graph model, the\n\t * following code is used.\n\t *\n\t * (code)\n\t * mxUtils.get(url, function(req)\n\t * {\n\t *   var node = req.getDocumentElement();\n\t *   var dec = new mxCodec(node.ownerDocument);\n\t *   dec.decode(node, graph.getModel());\n\t * });\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * url - URL to get the data from.\n\t * onload - Optional function to execute for a successful response.\n\t * onerror - Optional function to execute on error.\n\t * binary - Optional boolean parameter that specifies if the request is\n\t * binary.\n\t * timeout - Optional timeout in ms before calling ontimeout.\n\t * ontimeout - Optional function to execute on timeout.\n\t */\n\tget: function(url, onload, onerror, binary, timeout, ontimeout)\n\t{\n\t\tvar req = new mxXmlRequest(url, null, 'GET');\n\n\t\tif (binary != null)\n\t\t{\n\t\t\treq.setBinary(binary);\n\t\t}\n\n\t\treq.send(onload, onerror, timeout, ontimeout);\n\n\t\treturn req;\n\t},\n\n\t/**\n\t * Function: getAll\n\t *\n\t * Loads the URLs in the given array *asynchronously* and invokes the given function\n\t * if all requests returned with a valid 2xx status. The error handler is invoked\n\t * once on the first error or invalid response.\n\t *\n\t * Parameters:\n\t *\n\t * urls - Array of URLs to be loaded.\n\t * onload - Callback with array of <mxXmlRequests>.\n\t * onerror - Optional function to execute on error.\n\t */\n\tgetAll: function(urls, onload, onerror)\n\t{\n\t\tvar remain = urls.length;\n\t\tvar result = [];\n\t\tvar errors = 0;\n\t\tvar err = function()\n\t\t{\n\t\t\tif (errors == 0 && onerror != null)\n\t\t\t{\n\t\t\t\tonerror();\n\t\t\t}\n\n\t\t\terrors++;\n\t\t};\n\n\t\tfor (var i = 0; i < urls.length; i++)\n\t\t{\n\t\t\t(function(url, index)\n\t\t\t{\n\t\t\t\tmxUtils.get(url, function(req)\n\t\t\t\t{\n\t\t\t\t\tvar status = req.getStatus();\n\n\t\t\t\t\tif (status < 200 || status > 299)\n\t\t\t\t\t{\n\t\t\t\t\t\terr();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult[index] = req;\n\t\t\t\t\t\tremain--;\n\n\t\t\t\t\t\tif (remain == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tonload(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, err);\n\t\t\t})(urls[i], i);\n\t\t}\n\n\t\tif (remain == 0)\n\t\t{\n\t\t\tonload(result);\n\t\t}\n\t},\n\n\t/**\n\t * Function: post\n\t *\n\t * Posts the specified params to the given URL *asynchronously* and invokes\n\t * the given functions depending on the request status. Returns the\n\t * <mxXmlRequest> in use. Both functions take the <mxXmlRequest> as the\n\t * only parameter. Make sure to use encodeURIComponent for the parameter\n\t * values.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * mxUtils.post(url, 'key=value', function(req)\n\t * {\n\t * \tmxUtils.alert('Ready: '+req.isReady()+' Status: '+req.getStatus());\n\t *  // Process req.getDocumentElement() using DOM API if OK...\n\t * });\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * url - URL to get the data from.\n\t * params - Parameters for the post request.\n\t * onload - Optional function to execute for a successful response.\n\t * onerror - Optional function to execute on error.\n\t */\n\tpost: function(url, params, onload, onerror)\n\t{\n\t\treturn new mxXmlRequest(url, params).send(onload, onerror);\n\t},\n\n\t/**\n\t * Function: submit\n\t *\n\t * Submits the given parameters to the specified URL using\n\t * <mxXmlRequest.simulate> and returns the <mxXmlRequest>.\n\t * Make sure to use encodeURIComponent for the parameter\n\t * values.\n\t *\n\t * Parameters:\n\t *\n\t * url - URL to get the data from.\n\t * params - Parameters for the form.\n\t * doc - Document to create the form in.\n\t * target - Target to send the form result to.\n\t */\n\tsubmit: function(url, params, doc, target)\n\t{\n\t\treturn new mxXmlRequest(url, params).simulate(doc, target);\n\t},\n\n\t/**\n\t * Function: loadInto\n\t *\n\t * Loads the specified URL *asynchronously* into the specified document,\n\t * invoking onload after the document has been loaded. This implementation\n\t * does not use <mxXmlRequest>, but the document.load method.\n\t *\n\t * Parameters:\n\t *\n\t * url - URL to get the data from.\n\t * doc - The document to load the URL into.\n\t * onload - Function to execute when the URL has been loaded.\n\t */\n\tloadInto: function(url, doc, onload)\n\t{\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tdoc.onreadystatechange = function ()\n\t\t\t{\n\t\t\t\tif (doc.readyState == 4)\n\t\t\t\t{\n\t\t\t\t\tonload();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc.addEventListener('load', onload, false);\n\t\t}\n\n\t\tdoc.load(url);\n\t},\n\n\t/**\n\t * Function: getValue\n\t *\n\t * Returns the value for the given key in the given associative array or\n\t * the given default value if the value is null.\n\t *\n\t * Parameters:\n\t *\n\t * array - Associative array that contains the value for the key.\n\t * key - Key whose value should be returned.\n\t * defaultValue - Value to be returned if the value for the given\n\t * key is null.\n\t */\n\tgetValue: function(array, key, defaultValue)\n\t{\n\t\tvar value = (array != null) ? array[key] : null;\n\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: getNumber\n\t *\n\t * Returns the numeric value for the given key in the given associative\n\t * array or the given default value (or 0) if the value is null. The value\n\t * is converted to a numeric value using the Number function.\n\t *\n\t * Parameters:\n\t *\n\t * array - Associative array that contains the value for the key.\n\t * key - Key whose value should be returned.\n\t * defaultValue - Value to be returned if the value for the given\n\t * key is null. Default is 0.\n\t */\n\tgetNumber: function(array, key, defaultValue)\n\t{\n\t\tvar value = (array != null) ? array[key] : null;\n\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue || 0;\n\t\t}\n\n\t\treturn Number(value);\n\t},\n\n\t/**\n\t * Function: getColor\n\t *\n\t * Returns the color value for the given key in the given associative\n\t * array or the given default value if the value is null. If the value\n\t * is <mxConstants.NONE> then null is returned.\n\t *\n\t * Parameters:\n\t *\n\t * array - Associative array that contains the value for the key.\n\t * key - Key whose value should be returned.\n\t * defaultValue - Value to be returned if the value for the given\n\t * key is null. Default is null.\n\t */\n\tgetColor: function(array, key, defaultValue)\n\t{\n\t\tvar value = (array != null) ? array[key] : null;\n\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = defaultValue;\n\t\t}\n\t\telse if (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: clone\n\t *\n\t * Recursively clones the specified object ignoring all fieldnames in the\n\t * given array of transient fields. <mxObjectIdentity.FIELD_NAME> is always\n\t * ignored by this function.\n\t *\n\t * Parameters:\n\t *\n\t * obj - Object to be cloned.\n\t * transients - Optional array of strings representing the fieldname to be\n\t * ignored.\n\t * shallow - Optional boolean argument to specify if a shallow clone should\n\t * be created, that is, one where all object references are not cloned or,\n\t * in other words, one where only atomic (strings, numbers) values are\n\t * cloned. Default is false.\n\t */\n\tclone: function(obj, transients, shallow)\n\t{\n\t\tshallow = (shallow != null) ? shallow : false;\n\t\tvar clone = null;\n\n\t\tif (obj != null && typeof(obj.constructor) == 'function')\n\t\t{\n\t\t\tclone = new obj.constructor();\n\n\t\t    for (var i in obj)\n\t\t    {\n\t\t    \tif (i != mxObjectIdentity.FIELD_NAME && (transients == null ||\n\t\t    \t\tmxUtils.indexOf(transients, i) < 0))\n\t\t    \t{\n\t\t\t    \tif (!shallow && typeof(obj[i]) == 'object')\n\t\t\t    \t{\n\t\t\t            clone[i] = mxUtils.clone(obj[i]);\n\t\t\t        }\n\t\t\t        else\n\t\t\t        {\n\t\t\t            clone[i] = obj[i];\n\t\t\t        }\n\t\t\t\t}\n\t\t    }\n\t\t}\n\n\t    return clone;\n\t},\n\n\t/**\n\t * Function: equalPoints\n\t *\n\t * Compares all mxPoints in the given lists.\n\t *\n\t * Parameters:\n\t *\n\t * a - Array of <mxPoints> to be compared.\n\t * b - Array of <mxPoints> to be compared.\n\t */\n\tequalPoints: function(a, b)\n\t{\n\t\tif ((a == null && b != null) || (a != null && b == null) ||\n\t\t\t(a != null && b != null && a.length != b.length))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if (a != null && b != null)\n\t\t{\n\t\t\tfor (var i = 0; i < a.length; i++)\n\t\t\t{\n\t\t\t\tif (a[i] == b[i] || (a[i] != null && !a[i].equals(b[i])))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Function: equalEntries\n\t *\n\t * Returns true if all properties of the given objects are equal. Values\n\t * with NaN are equal to NaN and unequal to any other value.\n\t *\n\t * Parameters:\n\t *\n\t * a - First object to be compared.\n\t * b - Second object to be compared.\n\t */\n\tequalEntries: function(a, b)\n\t{\n\t\tif ((a == null && b != null) || (a != null && b == null) ||\n\t\t\t(a != null && b != null && a.length != b.length))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if (a != null && b != null)\n\t\t{\n\t\t\t// Counts keys in b to check if all values have been compared\n\t\t\tvar count = 0;\n\n\t\t\tfor (var key in b)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\tfor (var key in a)\n\t\t\t{\n\t\t\t\tcount--\n\n\t\t\t\tif ((!mxUtils.isNaN(a[key]) || !mxUtils.isNaN(b[key])) && a[key] != b[key])\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn count == 0;\n\t},\n\n\t/**\n\t * Function: removeDuplicates\n\t *\n\t * Removes all duplicates from the given array.\n\t */\n\tremoveDuplicates: function(arr)\n\t{\n\t\tvar dict = new mxDictionary();\n\t\tvar result = [];\n\n\t\tfor (var i = 0; i < arr.length; i++)\n\t\t{\n\t\t\tif (!dict.get(arr[i]))\n\t\t\t{\n\t\t\t\tresult.push(arr[i]);\n\t\t\t\tdict.put(arr[i], true);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: isNaN\n\t *\n\t * Returns true if the given value is of type number and isNaN returns true.\n\t */\n\tisNaN: function(value)\n\t{\n\t\treturn typeof(value) == 'number' && isNaN(value);\n\t},\n\n\t/**\n\t * Function: extend\n\t *\n\t * Assigns a copy of the superclass prototype to the subclass prototype.\n\t * Note that this does not call the constructor of the superclass at this\n\t * point, the superclass constructor should be called explicitely in the\n\t * subclass constructor. Below is an example.\n\t *\n\t * (code)\n\t * MyGraph = function(container, model, renderHint, stylesheet)\n\t * {\n\t *   mxGraph.call(this, container, model, renderHint, stylesheet);\n\t * }\n\t *\n\t * mxUtils.extend(MyGraph, mxGraph);\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * ctor - Constructor of the subclass.\n\t * superCtor - Constructor of the superclass.\n\t */\n\textend: function(ctor, superCtor)\n\t{\n\t\tvar f = function() {};\n\t\tf.prototype = superCtor.prototype;\n\n\t\tctor.prototype = new f();\n\t\tctor.prototype.constructor = ctor;\n\t},\n\n\t/**\n\t * Function: toString\n\t *\n\t * Returns a textual representation of the specified object.\n\t *\n\t * Parameters:\n\t *\n\t * obj - Object to return the string representation for.\n\t */\n\ttoString: function(obj)\n\t{\n\t    var output = '';\n\n\t    for (var i in obj)\n\t    {\n\t    \ttry\n\t    \t{\n\t\t\t    if (obj[i] == null)\n\t\t\t    {\n\t\t            output += i + ' = [null]\\n';\n\t\t\t    }\n\t\t\t    else if (typeof(obj[i]) == 'function')\n\t\t\t    {\n\t\t            output += i + ' => [Function]\\n';\n\t\t        }\n\t\t        else if (typeof(obj[i]) == 'object')\n\t\t        {\n\t\t        \tvar ctor = mxUtils.getFunctionName(obj[i].constructor);\n\t\t            output += i + ' => [' + ctor + ']\\n';\n\t\t        }\n\t\t        else\n\t\t        {\n\t\t            output += i + ' = ' + obj[i] + '\\n';\n\t\t        }\n\t    \t}\n\t    \tcatch (e)\n\t    \t{\n\t    \t\toutput += i + '=' + e.message;\n\t    \t}\n\t    }\n\n\t    return output;\n\t},\n\n\t/**\n\t * Function: toRadians\n\t *\n\t * Converts the given degree to radians.\n\t */\n\ttoRadians: function(deg)\n\t{\n\t\treturn Math.PI * deg / 180;\n\t},\n\n\t/**\n\t * Function: toDegree\n\t *\n\t * Converts the given radians to degree.\n\t */\n\ttoDegree: function(rad)\n\t{\n\t\treturn rad * 180 / Math.PI;\n\t},\n\n\t/**\n\t * Function: arcToCurves\n\t *\n\t * Converts the given arc to a series of curves.\n\t */\n\tarcToCurves: function(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y)\n\t{\n\t\tx -= x0;\n\t\ty -= y0;\n\n        if (r1 === 0 || r2 === 0)\n        {\n        \treturn result;\n        }\n\n        var fS = sweepFlag;\n        var psai = angle;\n        r1 = Math.abs(r1);\n        r2 = Math.abs(r2);\n        var ctx = -x / 2;\n        var cty = -y / 2;\n        var cpsi = Math.cos(psai * Math.PI / 180);\n        var spsi = Math.sin(psai * Math.PI / 180);\n        var rxd = cpsi * ctx + spsi * cty;\n        var ryd = -1 * spsi * ctx + cpsi * cty;\n        var rxdd = rxd * rxd;\n        var rydd = ryd * ryd;\n        var r1x = r1 * r1;\n        var r2y = r2 * r2;\n        var lamda = rxdd / r1x + rydd / r2y;\n        var sds;\n\n        if (lamda > 1)\n        {\n        \tr1 = Math.sqrt(lamda) * r1;\n        \tr2 = Math.sqrt(lamda) * r2;\n        \tsds = 0;\n        }\n        else\n        {\n        \tvar seif = 1;\n\n        \tif (largeArcFlag === fS)\n        \t{\n        \t\tseif = -1;\n        \t}\n\n        \tsds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n        }\n\n        var txd = sds * r1 * ryd / r2;\n        var tyd = -1 * sds * r2 * rxd / r1;\n        var tx = cpsi * txd - spsi * tyd + x / 2;\n        var ty = spsi * txd + cpsi * tyd + y / 2;\n        var rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n        var s1 = (rad >= 0) ? rad : 2 * Math.PI + rad;\n        rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n        var dr = (rad >= 0) ? rad : 2 * Math.PI + rad;\n\n        if (fS == 0 && dr > 0)\n        {\n        \tdr -= 2 * Math.PI;\n        }\n        else if (fS != 0 && dr < 0)\n        {\n        \tdr += 2 * Math.PI;\n        }\n\n        var sse = dr * 2 / Math.PI;\n        var seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n        var segr = dr / seg;\n        var t = 8/3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);\n        var cpsir1 = cpsi * r1;\n        var cpsir2 = cpsi * r2;\n        var spsir1 = spsi * r1;\n        var spsir2 = spsi * r2;\n        var mc = Math.cos(s1);\n        var ms = Math.sin(s1);\n        var x2 = -t * (cpsir1 * ms + spsir2 * mc);\n        var y2 = -t * (spsir1 * ms - cpsir2 * mc);\n        var x3 = 0;\n        var y3 = 0;\n\n\t\tvar result = [];\n\n        for (var n = 0; n < seg; ++n)\n        {\n            s1 += segr;\n            mc = Math.cos(s1);\n            ms = Math.sin(s1);\n\n            x3 = cpsir1 * mc - spsir2 * ms + tx;\n            y3 = spsir1 * mc + cpsir2 * ms + ty;\n            var dx = -t * (cpsir1 * ms + spsir2 * mc);\n            var dy = -t * (spsir1 * ms - cpsir2 * mc);\n\n            // CurveTo updates x0, y0 so need to restore it\n            var index = n * 6;\n            result[index] = Number(x2 + x0);\n            result[index + 1] = Number(y2 + y0);\n            result[index + 2] = Number(x3 - dx + x0);\n            result[index + 3] = Number(y3 - dy + y0);\n            result[index + 4] = Number(x3 + x0);\n            result[index + 5] = Number(y3 + y0);\n\n\t\t\tx2 = x3 + dx;\n            y2 = y3 + dy;\n        }\n\n        return result;\n\t},\n\n\t/**\n\t * Function: getBoundingBox\n\t *\n\t * Returns the bounding box for the rotated rectangle.\n\t *\n\t * Parameters:\n\t *\n\t * rect - <mxRectangle> to be rotated.\n\t * angle - Number that represents the angle (in degrees).\n\t * cx - Optional <mxPoint> that represents the rotation center. If no\n\t * rotation center is given then the center of rect is used.\n\t */\n\tgetBoundingBox: function(rect, rotation, cx)\n\t{\n        var result = null;\n\n        if (rect != null && rotation != null && rotation != 0)\n        {\n            var rad = mxUtils.toRadians(rotation);\n            var cos = Math.cos(rad);\n            var sin = Math.sin(rad);\n\n            cx = (cx != null) ? cx : new mxPoint(rect.x + rect.width / 2, rect.y  + rect.height / 2);\n\n            var p1 = new mxPoint(rect.x, rect.y);\n            var p2 = new mxPoint(rect.x + rect.width, rect.y);\n            var p3 = new mxPoint(p2.x, rect.y + rect.height);\n            var p4 = new mxPoint(rect.x, p3.y);\n\n            p1 = mxUtils.getRotatedPoint(p1, cos, sin, cx);\n            p2 = mxUtils.getRotatedPoint(p2, cos, sin, cx);\n            p3 = mxUtils.getRotatedPoint(p3, cos, sin, cx);\n            p4 = mxUtils.getRotatedPoint(p4, cos, sin, cx);\n\n            result = new mxRectangle(p1.x, p1.y, 0, 0);\n            result.add(new mxRectangle(p2.x, p2.y, 0, 0));\n            result.add(new mxRectangle(p3.x, p3.y, 0, 0));\n            result.add(new mxRectangle(p4.x, p4.y, 0, 0));\n        }\n\n        return result;\n\t},\n\n\t/**\n\t * Function: getRotatedPoint\n\t *\n\t * Rotates the given point by the given cos and sin.\n\t */\n\tgetRotatedPoint: function(pt, cos, sin, c)\n\t{\n\t\tc = (c != null) ? c : new mxPoint();\n\t\tvar x = pt.x - c.x;\n\t\tvar y = pt.y - c.y;\n\n\t\tvar x1 = x * cos - y * sin;\n\t\tvar y1 = y * cos + x * sin;\n\n\t\treturn new mxPoint(x1 + c.x, y1 + c.y);\n\t},\n\n\t/**\n\t * Returns an integer mask of the port constraints of the given map\n\t * @param dict the style map to determine the port constraints for\n\t * @param defaultValue Default value to return if the key is undefined.\n\t * @return the mask of port constraint directions\n\t *\n\t * Parameters:\n\t *\n\t * terminal - <mxCelState> that represents the terminal.\n\t * edge - <mxCellState> that represents the edge.\n\t * source - Boolean that specifies if the terminal is the source terminal.\n\t * defaultValue - Default value to be returned.\n\t */\n\tgetPortConstraints: function(terminal, edge, source, defaultValue)\n\t{\n\t\tvar value = mxUtils.getValue(terminal.style, mxConstants.STYLE_PORT_CONSTRAINT,\n\t\t\tmxUtils.getValue(edge.style, (source) ? mxConstants.STYLE_SOURCE_PORT_CONSTRAINT :\n\t\t\t\tmxConstants.STYLE_TARGET_PORT_CONSTRAINT, null));\n\n\t\tif (value == null)\n\t\t{\n\t\t\treturn defaultValue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar directions = value.toString();\n\t\t\tvar returnValue = mxConstants.DIRECTION_MASK_NONE;\n\t\t\tvar constraintRotationEnabled = mxUtils.getValue(terminal.style, mxConstants.STYLE_PORT_CONSTRAINT_ROTATION, 0);\n\t\t\tvar rotation = 0;\n\n\t\t\tif (constraintRotationEnabled == 1)\n\t\t\t{\n\t\t\t\trotation = mxUtils.getValue(terminal.style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t}\n\n\t\t\tvar quad = 0;\n\n\t\t\tif (rotation > 45)\n\t\t\t{\n\t\t\t\tquad = 1;\n\n\t\t\t\tif (rotation >= 135)\n\t\t\t\t{\n\t\t\t\t\tquad = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rotation < -45)\n\t\t\t{\n\t\t\t\tquad = 3;\n\n\t\t\t\tif (rotation <= -135)\n\t\t\t\t{\n\t\t\t\t\tquad = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_NORTH) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_WEST) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_SOUTH) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (directions.indexOf(mxConstants.DIRECTION_EAST) >= 0)\n\t\t\t{\n\t\t\t\tswitch (quad)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\treturnValue |= mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t}\n\t},\n\n\t/**\n\t * Function: reversePortConstraints\n\t *\n\t * Reverse the port constraint bitmask. For example, north | east\n\t * becomes south | west\n\t */\n\treversePortConstraints: function(constraint)\n\t{\n\t\tvar result = 0;\n\n\t\tresult = (constraint & mxConstants.DIRECTION_MASK_WEST) << 3;\n\t\tresult |= (constraint & mxConstants.DIRECTION_MASK_NORTH) << 1;\n\t\tresult |= (constraint & mxConstants.DIRECTION_MASK_SOUTH) >> 1;\n\t\tresult |= (constraint & mxConstants.DIRECTION_MASK_EAST) >> 3;\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: findNearestSegment\n\t *\n\t * Finds the index of the nearest segment on the given cell state for\n\t * the specified coordinate pair.\n\t */\n\tfindNearestSegment: function(state, x, y)\n\t{\n\t\tvar index = -1;\n\n\t\tif (state.absolutePoints.length > 0)\n\t\t{\n\t\t\tvar last = state.absolutePoints[0];\n\t\t\tvar min = null;\n\n\t\t\tfor (var i = 1; i < state.absolutePoints.length; i++)\n\t\t\t{\n\t\t\t\tvar current = state.absolutePoints[i];\n\t\t\t\tvar dist = mxUtils.ptSegDistSq(last.x, last.y,\n\t\t\t\t\tcurrent.x, current.y, x, y);\n\n\t\t\t\tif (min == null || dist < min)\n\t\t\t\t{\n\t\t\t\t\tmin = dist;\n\t\t\t\t\tindex = i - 1;\n\t\t\t\t}\n\n\t\t\t\tlast = current;\n\t\t\t}\n\t\t}\n\n\t\treturn index;\n\t},\n\n\t/**\n\t * Function: getDirectedBounds\n\t *\n\t * Adds the given margins to the given rectangle and rotates and flips the\n\t * rectangle according to the respective styles in style.\n\t */\n\tgetDirectedBounds: function (rect, m, style, flipH, flipV)\n\t{\n\t\tvar d = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\t\tflipH = (flipH != null) ? flipH : mxUtils.getValue(style, mxConstants.STYLE_FLIPH, false);\n\t\tflipV = (flipV != null) ? flipV : mxUtils.getValue(style, mxConstants.STYLE_FLIPV, false);\n\n\t\tm.x = Math.round(Math.max(0, Math.min(rect.width, m.x)));\n\t\tm.y = Math.round(Math.max(0, Math.min(rect.height, m.y)));\n\t\tm.width = Math.round(Math.max(0, Math.min(rect.width, m.width)));\n\t\tm.height = Math.round(Math.max(0, Math.min(rect.height, m.height)));\n\n\t\tif ((flipV && (d == mxConstants.DIRECTION_SOUTH || d == mxConstants.DIRECTION_NORTH)) ||\n\t\t\t(flipH && (d == mxConstants.DIRECTION_EAST || d == mxConstants.DIRECTION_WEST)))\n\t\t{\n\t\t\tvar tmp = m.x;\n\t\t\tm.x = m.width;\n\t\t\tm.width = tmp;\n\t\t}\n\n\t\tif ((flipH && (d == mxConstants.DIRECTION_SOUTH || d == mxConstants.DIRECTION_NORTH)) ||\n\t\t\t(flipV && (d == mxConstants.DIRECTION_EAST || d == mxConstants.DIRECTION_WEST)))\n\t\t{\n\t\t\tvar tmp = m.y;\n\t\t\tm.y = m.height;\n\t\t\tm.height = tmp;\n\t\t}\n\n\t\tvar m2 = mxRectangle.fromRectangle(m);\n\n\t\tif (d == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tm2.y = m.x;\n\t\t\tm2.x = m.height;\n\t\t\tm2.width = m.y;\n\t\t\tm2.height = m.width;\n\t\t}\n\t\telse if (d == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tm2.y = m.height;\n\t\t\tm2.x = m.width;\n\t\t\tm2.width = m.x;\n\t\t\tm2.height = m.y;\n\t\t}\n\t\telse if (d == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tm2.y = m.width;\n\t\t\tm2.x = m.y;\n\t\t\tm2.width = m.height;\n\t\t\tm2.height = m.x;\n\t\t}\n\n\t\treturn new mxRectangle(rect.x + m2.x, rect.y + m2.y, rect.width - m2.width - m2.x, rect.height - m2.height - m2.y);\n\t},\n\n\t/**\n\t * Function: getPerimeterPoint\n\t *\n\t * Returns the intersection between the polygon defined by the array of\n\t * points and the line between center and point.\n\t */\n\tgetPerimeterPoint: function (pts, center, point)\n\t{\n\t\tvar min = null;\n\n\t\tfor (var i = 0; i < pts.length - 1; i++)\n\t\t{\n\t\t\tvar pt = mxUtils.intersection(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y,\n\t\t\t\tcenter.x, center.y, point.x, point.y);\n\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tvar dx = point.x - pt.x;\n\t\t\t\tvar dy = point.y - pt.y;\n\t\t\t\tvar ip = {p: pt, distSq: dy * dy + dx * dx};\n\n\t\t\t\tif (ip != null && (min == null || min.distSq > ip.distSq))\n\t\t\t\t{\n\t\t\t\t\tmin = ip;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (min != null) ? min.p : null;\n\t},\n\n\t/**\n\t * Function: rectangleIntersectsSegment\n\t *\n\t * Returns true if the given rectangle intersects the given segment.\n\t *\n\t * Parameters:\n\t *\n\t * bounds - <mxRectangle> that represents the rectangle.\n\t * p1 - <mxPoint> that represents the first point of the segment.\n\t * p2 - <mxPoint> that represents the second point of the segment.\n\t */\n\trectangleIntersectsSegment: function(bounds, p1, p2)\n\t{\n\t\tvar top = bounds.y;\n\t\tvar left = bounds.x;\n\t\tvar bottom = top + bounds.height;\n\t\tvar right = left + bounds.width;\n\n\t\t// Find min and max X for the segment\n\t\tvar minX = p1.x;\n\t\tvar maxX = p2.x;\n\n\t\tif (p1.x > p2.x)\n\t\t{\n\t\t  minX = p2.x;\n\t\t  maxX = p1.x;\n\t\t}\n\n\t\t// Find the intersection of the segment's and rectangle's x-projections\n\t\tif (maxX > right)\n\t\t{\n\t\t  maxX = right;\n\t\t}\n\n\t\tif (minX < left)\n\t\t{\n\t\t  minX = left;\n\t\t}\n\n\t\tif (minX > maxX) // If their projections do not intersect return false\n\t\t{\n\t\t  return false;\n\t\t}\n\n\t\t// Find corresponding min and max Y for min and max X we found before\n\t\tvar minY = p1.y;\n\t\tvar maxY = p2.y;\n\t\tvar dx = p2.x - p1.x;\n\n\t\tif (Math.abs(dx) > 0.0000001)\n\t\t{\n\t\t  var a = (p2.y - p1.y) / dx;\n\t\t  var b = p1.y - a * p1.x;\n\t\t  minY = a * minX + b;\n\t\t  maxY = a * maxX + b;\n\t\t}\n\n\t\tif (minY > maxY)\n\t\t{\n\t\t  var tmp = maxY;\n\t\t  maxY = minY;\n\t\t  minY = tmp;\n\t\t}\n\n\t\t// Find the intersection of the segment's and rectangle's y-projections\n\t\tif (maxY > bottom)\n\t\t{\n\t\t  maxY = bottom;\n\t\t}\n\n\t\tif (minY < top)\n\t\t{\n\t\t  minY = top;\n\t\t}\n\n\t\tif (minY > maxY) // If Y-projections do not intersect return false\n\t\t{\n\t\t  return false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Function: contains\n\t *\n\t * Returns true if the specified point (x, y) is contained in the given rectangle.\n\t *\n\t * Parameters:\n\t *\n\t * bounds - <mxRectangle> that represents the area.\n\t * x - X-coordinate of the point.\n\t * y - Y-coordinate of the point.\n\t */\n\tcontains: function(bounds, x, y)\n\t{\n\t\treturn (bounds.x <= x && bounds.x + bounds.width >= x &&\n\t\t\t\tbounds.y <= y && bounds.y + bounds.height >= y);\n\t},\n\n\t/**\n\t * Function: intersects\n\t *\n\t * Returns true if the two rectangles intersect.\n\t *\n\t * Parameters:\n\t *\n\t * a - <mxRectangle> to be checked for intersection.\n\t * b - <mxRectangle> to be checked for intersection.\n\t */\n\tintersects: function(a, b)\n\t{\n\t\tvar tw = a.width;\n\t\tvar th = a.height;\n\t\tvar rw = b.width;\n\t\tvar rh = b.height;\n\n\t\tif (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0)\n\t\t{\n\t\t    return false;\n\t\t}\n\n\t\tvar tx = a.x;\n\t\tvar ty = a.y;\n\t\tvar rx = b.x;\n\t\tvar ry = b.y;\n\n\t\trw += rx;\n\t\trh += ry;\n\t\ttw += tx;\n\t\tth += ty;\n\n\t\treturn ((rw < rx || rw > tx) &&\n\t\t\t(rh < ry || rh > ty) &&\n\t\t\t(tw < tx || tw > rx) &&\n\t\t\t(th < ty || th > ry));\n\t},\n\n\t/**\n\t * Function: intersects\n\t *\n\t * Returns true if the two rectangles intersect.\n\t *\n\t * Parameters:\n\t *\n\t * a - <mxRectangle> to be checked for intersection.\n\t * b - <mxRectangle> to be checked for intersection.\n\t */\n\tintersectsHotspot: function(state, x, y, hotspot, min, max)\n\t{\n\t\thotspot = (hotspot != null) ? hotspot : 1;\n\t\tmin = (min != null) ? min : 0;\n\t\tmax = (max != null) ? max : 0;\n\n\t\tif (hotspot > 0)\n\t\t{\n\t\t\tvar cx = state.getCenterX();\n\t\t\tvar cy = state.getCenterY();\n\t\t\tvar w = state.width;\n\t\t\tvar h = state.height;\n\n\t\t\tvar start = mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE) * state.view.scale;\n\n\t\t\tif (start > 0)\n\t\t\t{\n\t\t\t\tif (mxUtils.getValue(state.style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t{\n\t\t\t\t\tcy = state.y + start / 2;\n\t\t\t\t\th = start;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcx = state.x + start / 2;\n\t\t\t\t\tw = start;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw = Math.max(min, w * hotspot);\n\t\t\th = Math.max(min, h * hotspot);\n\n\t\t\tif (max > 0)\n\t\t\t{\n\t\t\t\tw = Math.min(w, max);\n\t\t\t\th = Math.min(h, max);\n\t\t\t}\n\n\t\t\tvar rect = new mxRectangle(cx - w / 2, cy - h / 2, w, h);\n\t\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\tvar cx = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, sin, cx);\n\t\t\t\tx = pt.x;\n\t\t\t\ty = pt.y;\n\t\t\t}\n\n\t\t\treturn mxUtils.contains(rect, x, y);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Function: getOffset\n\t *\n\t * Returns the offset for the specified container as an <mxPoint>. The\n\t * offset is the distance from the top left corner of the container to the\n\t * top left corner of the document.\n\t *\n\t * Parameters:\n\t *\n\t * container - DOM node to return the offset for.\n\t * scollOffset - Optional boolean to add the scroll offset of the document.\n\t * Default is false.\n\t */\n\tgetOffset: function(container, scrollOffset)\n\t{\n\t\tvar offsetLeft = 0;\n\t\tvar offsetTop = 0;\n\n\t\t// Ignores document scroll origin for fixed elements\n\t\tvar fixed = false;\n\t\tvar node = container;\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\n\t\twhile (node != null && node != b && node != d && !fixed)\n\t\t{\n\t\t\tvar style = mxUtils.getCurrentStyle(node);\n\n\t\t\tif (style != null)\n\t\t\t{\n\t\t\t\tfixed = fixed || style.position == 'fixed';\n\t\t\t}\n\n\t\t\tnode = node.parentNode;\n\t\t}\n\n\t\tif (!scrollOffset && !fixed)\n\t\t{\n\t\t\tvar offset = mxUtils.getDocumentScrollOrigin(container.ownerDocument);\n\t\t\toffsetLeft += offset.x;\n\t\t\toffsetTop += offset.y;\n\t\t}\n\n\t\tvar r = container.getBoundingClientRect();\n\n\t\tif (r != null)\n\t\t{\n\t\t\toffsetLeft += r.left;\n\t\t\toffsetTop += r.top;\n\t\t}\n\n\t\treturn new mxPoint(offsetLeft, offsetTop);\n\t},\n\n\t/**\n\t * Function: getDocumentScrollOrigin\n\t *\n\t * Returns the scroll origin of the given document or the current document\n\t * if no document is given.\n\t */\n\tgetDocumentScrollOrigin: function(doc)\n\t{\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\treturn new mxPoint(doc.body.scrollLeft, doc.body.scrollTop);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar wnd = doc.defaultView || doc.parentWindow;\n\n\t\t\tvar x = (wnd != null && window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n\t\t\tvar y = (wnd != null && window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n\n\t\t\treturn new mxPoint(x, y);\n\t\t}\n\t},\n\n\t/**\n\t * Function: getScrollOrigin\n\t *\n\t * Returns the top, left corner of the viewrect as an <mxPoint>.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node whose scroll origin should be returned.\n\t * includeAncestors - Whether the scroll origin of the ancestors should be\n\t * included. Default is false.\n\t * includeDocument - Whether the scroll origin of the document should be\n\t * included. Default is true.\n\t */\n\tgetScrollOrigin: function(node, includeAncestors, includeDocument)\n\t{\n\t\tincludeAncestors = (includeAncestors != null) ? includeAncestors : false;\n\t\tincludeDocument = (includeDocument != null) ? includeDocument : true;\n\n\t\tvar doc = (node != null) ? node.ownerDocument : document;\n\t\tvar b = doc.body;\n\t\tvar d = doc.documentElement;\n\t\tvar result = new mxPoint();\n\t\tvar fixed = false;\n\n\t\twhile (node != null && node != b && node != d)\n\t\t{\n\t\t\tif (!isNaN(node.scrollLeft) && !isNaN(node.scrollTop))\n\t\t\t{\n\t\t\t\tresult.x += node.scrollLeft;\n\t\t\t\tresult.y += node.scrollTop;\n\t\t\t}\n\n\t\t\tvar style = mxUtils.getCurrentStyle(node);\n\n\t\t\tif (style != null)\n\t\t\t{\n\t\t\t\tfixed = fixed || style.position == 'fixed';\n\t\t\t}\n\n\t\t\tnode = (includeAncestors) ? node.parentNode : null;\n\t\t}\n\n\t\tif (!fixed && includeDocument)\n\t\t{\n\t\t\tvar origin = mxUtils.getDocumentScrollOrigin(doc);\n\n\t\t\tresult.x += origin.x;\n\t\t\tresult.y += origin.y;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: convertPoint\n\t *\n\t * Converts the specified point (x, y) using the offset of the specified\n\t * container and returns a new <mxPoint> with the result.\n\t *\n\t * (code)\n\t * var pt = mxUtils.convertPoint(graph.container,\n\t *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * container - DOM node to use for the offset.\n\t * x - X-coordinate of the point to be converted.\n\t * y - Y-coordinate of the point to be converted.\n\t */\n\tconvertPoint: function(container, x, y)\n\t{\n\t\tvar origin = mxUtils.getScrollOrigin(container, false);\n\t\tvar offset = mxUtils.getOffset(container);\n\n\t\toffset.x -= origin.x;\n\t\toffset.y -= origin.y;\n\n\t\treturn new mxPoint(x - offset.x, y - offset.y);\n\t},\n\n\t/**\n\t * Function: ltrim\n\t *\n\t * Strips all whitespaces from the beginning of the string. Without the\n\t * second parameter, this will trim these characters:\n\t *\n\t * - \" \" (ASCII 32 (0x20)), an ordinary space\n\t * - \"\\t\" (ASCII 9 (0x09)), a tab\n\t * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n\t * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n\t * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n\t * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n\t */\n\tltrim: function(str, chars)\n\t{\n\t\tchars = chars || \"\\\\s\";\n\n\t\treturn (str != null) ? str.replace(new RegExp(\"^[\" + chars + \"]+\", \"g\"), \"\") : null;\n\t},\n\n\t/**\n\t * Function: rtrim\n\t *\n\t * Strips all whitespaces from the end of the string. Without the second\n\t * parameter, this will trim these characters:\n\t *\n\t * - \" \" (ASCII 32 (0x20)), an ordinary space\n\t * - \"\\t\" (ASCII 9 (0x09)), a tab\n\t * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n\t * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n\t * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n\t * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n\t */\n\trtrim: function(str, chars)\n\t{\n\t\tchars = chars || \"\\\\s\";\n\n\t\treturn (str != null) ? str.replace(new RegExp(\"[\" + chars + \"]+$\", \"g\"), \"\") : null;\n\t},\n\n\t/**\n\t * Function: trim\n\t *\n\t * Strips all whitespaces from both end of the string.\n\t * Without the second parameter, Javascript function will trim these\n\t * characters:\n\t *\n\t * - \" \" (ASCII 32 (0x20)), an ordinary space\n\t * - \"\\t\" (ASCII 9 (0x09)), a tab\n\t * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\n\t * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\n\t * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\n\t * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\n\t */\n\ttrim: function(str, chars)\n\t{\n\t\treturn mxUtils.ltrim(mxUtils.rtrim(str, chars), chars);\n\t},\n\n\t/**\n\t * Function: isNumeric\n\t *\n\t * Returns true if the specified value is numeric, that is, if it is not\n\t * null, not an empty string, not a HEX number and isNaN returns false.\n\t *\n\t * Parameters:\n\t *\n\t * n - String representing the possibly numeric value.\n\t */\n\tisNumeric: function(n)\n\t{\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n) && (typeof(n) != 'string' || n.toLowerCase().indexOf('0x') < 0);\n\t},\n\n\t/**\n\t * Function: isInteger\n\t *\n\t * Returns true if the given value is an valid integer number.\n\t *\n\t * Parameters:\n\t *\n\t * n - String representing the possibly numeric value.\n\t */\n\tisInteger: function(n)\n\t{\n\t\treturn String(parseInt(n)) === String(n);\n\t},\n\n\t/**\n\t * Function: mod\n\t *\n\t * Returns the remainder of division of n by m. You should use this instead\n\t * of the built-in operation as the built-in operation does not properly\n\t * handle negative numbers.\n\t */\n\tmod: function(n, m)\n\t{\n\t\treturn ((n % m) + m) % m;\n\t},\n\n\t/**\n\t * Function: intersection\n\t *\n\t * Returns the intersection of two lines as an <mxPoint>.\n\t *\n\t * Parameters:\n\t *\n\t * x0 - X-coordinate of the first line's startpoint.\n\t * y0 - X-coordinate of the first line's startpoint.\n\t * x1 - X-coordinate of the first line's endpoint.\n\t * y1 - Y-coordinate of the first line's endpoint.\n\t * x2 - X-coordinate of the second line's startpoint.\n\t * y2 - Y-coordinate of the second line's startpoint.\n\t * x3 - X-coordinate of the second line's endpoint.\n\t * y3 - Y-coordinate of the second line's endpoint.\n\t */\n\tintersection: function (x0, y0, x1, y1, x2, y2, x3, y3)\n\t{\n\t\tvar denom = ((y3 - y2) * (x1 - x0)) - ((x3 - x2) * (y1 - y0));\n\t\tvar nume_a = ((x3 - x2) * (y0 - y2)) - ((y3 - y2) * (x0 - x2));\n\t\tvar nume_b = ((x1 - x0) * (y0 - y2)) - ((y1 - y0) * (x0 - x2));\n\n\t\tvar ua = nume_a / denom;\n\t\tvar ub = nume_b / denom;\n\n\t\tif(ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0)\n\t\t{\n\t\t\t// Get the intersection point\n\t\t\tvar x = x0 + ua * (x1 - x0);\n\t\t\tvar y = y0 + ua * (y1 - y0);\n\n\t\t\treturn new mxPoint(x, y);\n\t\t}\n\n\t\t// No intersection\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: ptSegDistSq\n\t *\n\t * Returns the square distance between a segment and a point. To get the\n\t * distance between a point and a line (with infinite length) use\n\t * <mxUtils.ptLineDist>.\n\t *\n\t * Parameters:\n\t *\n\t * x1 - X-coordinate of the startpoint of the segment.\n\t * y1 - Y-coordinate of the startpoint of the segment.\n\t * x2 - X-coordinate of the endpoint of the segment.\n\t * y2 - Y-coordinate of the endpoint of the segment.\n\t * px - X-coordinate of the point.\n\t * py - Y-coordinate of the point.\n\t */\n\tptSegDistSq: function(x1, y1, x2, y2, px, py)\n    {\n\t\tx2 -= x1;\n\t\ty2 -= y1;\n\n\t\tpx -= x1;\n\t\tpy -= y1;\n\n\t\tvar dotprod = px * x2 + py * y2;\n\t\tvar projlenSq;\n\n\t\tif (dotprod <= 0.0)\n\t\t{\n\t\t    projlenSq = 0.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    px = x2 - px;\n\t\t    py = y2 - py;\n\t\t    dotprod = px * x2 + py * y2;\n\n\t\t    if (dotprod <= 0.0)\n\t\t    {\n\t\t\t\tprojlenSq = 0.0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t\tprojlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n\t\t    }\n\t\t}\n\n\t\tvar lenSq = px * px + py * py - projlenSq;\n\n\t\tif (lenSq < 0)\n\t\t{\n\t\t    lenSq = 0;\n\t\t}\n\n\t\treturn lenSq;\n    },\n\n\t/**\n\t * Function: ptLineDist\n\t *\n\t * Returns the distance between a line defined by two points and a point.\n\t * To get the distance between a point and a segment (with a specific\n\t * length) use <mxUtils.ptSeqDistSq>.\n\t *\n\t * Parameters:\n\t *\n\t * x1 - X-coordinate of point 1 of the line.\n\t * y1 - Y-coordinate of point 1 of the line.\n\t * x2 - X-coordinate of point 1 of the line.\n\t * y2 - Y-coordinate of point 1 of the line.\n\t * px - X-coordinate of the point.\n\t * py - Y-coordinate of the point.\n\t */\n    ptLineDist: function(x1, y1, x2, y2, px, py)\n    {\n\t\treturn Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) /\n\t\t\tMath.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n    },\n\n\t/**\n\t * Function: relativeCcw\n\t *\n\t * Returns 1 if the given point on the right side of the segment, 0 if its\n\t * on the segment, and -1 if the point is on the left side of the segment.\n\t *\n\t * Parameters:\n\t *\n\t * x1 - X-coordinate of the startpoint of the segment.\n\t * y1 - Y-coordinate of the startpoint of the segment.\n\t * x2 - X-coordinate of the endpoint of the segment.\n\t * y2 - Y-coordinate of the endpoint of the segment.\n\t * px - X-coordinate of the point.\n\t * py - Y-coordinate of the point.\n\t */\n\trelativeCcw: function(x1, y1, x2, y2, px, py)\n    {\n\t\tx2 -= x1;\n\t\ty2 -= y1;\n\t\tpx -= x1;\n\t\tpy -= y1;\n\t\tvar ccw = px * y2 - py * x2;\n\n\t\tif (ccw == 0.0)\n\t\t{\n\t\t    ccw = px * x2 + py * y2;\n\n\t\t    if (ccw > 0.0)\n\t\t    {\n\t\t\t\tpx -= x2;\n\t\t\t\tpy -= y2;\n\t\t\t\tccw = px * x2 + py * y2;\n\n\t\t\t\tif (ccw < 0.0)\n\t\t\t\t{\n\t\t\t\t    ccw = 0.0;\n\t\t\t\t}\n\t\t    }\n\t\t}\n\n\t\treturn (ccw < 0.0) ? -1 : ((ccw > 0.0) ? 1 : 0);\n    },\n\n\t/**\n\t * Function: animateChanges\n\t *\n\t * See <mxEffects.animateChanges>. This is for backwards compatibility and\n\t * will be removed later.\n\t */\n\tanimateChanges: function(graph, changes)\n\t{\n\t\t// LATER: Deprecated, remove this function\n    \tmxEffects.animateChanges.apply(this, arguments);\n\t},\n\n\t/**\n\t * Function: cascadeOpacity\n\t *\n\t * See <mxEffects.cascadeOpacity>. This is for backwards compatibility and\n\t * will be removed later.\n\t */\n    cascadeOpacity: function(graph, cell, opacity)\n\t{\n\t\tmxEffects.cascadeOpacity.apply(this, arguments);\n\t},\n\n\t/**\n\t * Function: fadeOut\n\t *\n\t * See <mxEffects.fadeOut>. This is for backwards compatibility and\n\t * will be removed later.\n\t */\n\tfadeOut: function(node, from, remove, step, delay, isEnabled)\n\t{\n\t\tmxEffects.fadeOut.apply(this, arguments);\n\t},\n\n\t/**\n\t * Function: setOpacity\n\t *\n\t * Sets the opacity of the specified DOM node to the given value in %.\n\t *\n\t * Parameters:\n\t *\n\t * node - DOM node to set the opacity for.\n\t * value - Opacity in %. Possible values are between 0 and 100.\n\t */\n\tsetOpacity: function(node, value)\n\t{\n\t\tif (mxUtils.isVml(node))\n\t\t{\n\t    \tif (value >= 100)\n\t    \t{\n\t    \t\tnode.style.filter = '';\n\t    \t}\n\t    \telse\n\t    \t{\n\t    \t\t// TODO: Why is the division by 5 needed in VML?\n\t\t\t    node.style.filter = 'alpha(opacity=' + (value/5) + ')';\n\t    \t}\n\t\t}\n\t\telse if (mxClient.IS_IE && (typeof(document.documentMode) === 'undefined' || document.documentMode < 9))\n\t    {\n\t    \tif (value >= 100)\n\t    \t{\n\t    \t\tnode.style.filter = '';\n\t    \t}\n\t    \telse\n\t    \t{\n\t\t\t    node.style.filter = 'alpha(opacity=' + value + ')';\n\t    \t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    node.style.opacity = (value / 100);\n\t\t}\n\t},\n\n\t/**\n\t * Function: createImage\n\t *\n\t * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in\n\t * quirks mode.\n\t *\n\t * Parameters:\n\t *\n\t * src - URL that points to the image to be displayed.\n\t */\n\tcreateImage: function(src)\n\t{\n        var imageNode = null;\n\n\t\tif (mxClient.IS_IE6 && document.compatMode != 'CSS1Compat')\n\t\t{\n        \timageNode = document.createElement(mxClient.VML_PREFIX + ':image');\n        \timageNode.setAttribute('src', src);\n        \timageNode.style.borderStyle = 'none';\n        }\n\t\telse\n\t\t{\n\t\t\timageNode = document.createElement('img');\n\t\t\timageNode.setAttribute('src', src);\n\t\t\timageNode.setAttribute('border', '0');\n\t\t}\n\n\t\treturn imageNode;\n\t},\n\n\t/**\n\t * Function: sortCells\n\t *\n\t * Sorts the given cells according to the order in the cell hierarchy.\n\t * Ascending is optional and defaults to true.\n\t */\n\tsortCells: function(cells, ascending)\n\t{\n\t\tascending = (ascending != null) ? ascending : true;\n\t\tvar lookup = new mxDictionary();\n\t\tcells.sort(function(o1, o2)\n\t\t{\n\t\t\tvar p1 = lookup.get(o1);\n\n\t\t\tif (p1 == null)\n\t\t\t{\n\t\t\t\tp1 = mxCellPath.create(o1).split(mxCellPath.PATH_SEPARATOR);\n\t\t\t\tlookup.put(o1, p1);\n\t\t\t}\n\n\t\t\tvar p2 = lookup.get(o2);\n\n\t\t\tif (p2 == null)\n\t\t\t{\n\t\t\t\tp2 = mxCellPath.create(o2).split(mxCellPath.PATH_SEPARATOR);\n\t\t\t\tlookup.put(o2, p2);\n\t\t\t}\n\n\t\t\tvar comp = mxCellPath.compare(p1, p2);\n\n\t\t\treturn (comp == 0) ? 0 : (((comp > 0) == ascending) ? 1 : -1);\n\t\t});\n\n\t\treturn cells;\n\t},\n\n\t/**\n\t * Function: getStylename\n\t *\n\t * Returns the stylename in a style of the form [(stylename|key=value);] or\n\t * an empty string if the given style does not contain a stylename.\n\t *\n\t * Parameters:\n\t *\n\t * style - String of the form [(stylename|key=value);].\n\t */\n\tgetStylename: function(style)\n\t{\n\t\tif (style != null)\n\t\t{\n\t\t\tvar pairs = style.split(';');\n\t\t\tvar stylename = pairs[0];\n\n\t\t\tif (stylename.indexOf('=') < 0)\n\t\t\t{\n\t\t\t\treturn stylename;\n\t\t\t}\n\t\t}\n\n\t\treturn '';\n\t},\n\n\t/**\n\t * Function: getStylenames\n\t *\n\t * Returns the stylenames in a style of the form [(stylename|key=value);]\n\t * or an empty array if the given style does not contain any stylenames.\n\t *\n\t * Parameters:\n\t *\n\t * style - String of the form [(stylename|key=value);].\n\t */\n\tgetStylenames: function(style)\n\t{\n\t\tvar result = [];\n\n\t\tif (style != null)\n\t\t{\n\t\t\tvar pairs = style.split(';');\n\n\t\t\tfor (var i = 0; i < pairs.length; i++)\n\t\t\t{\n\t\t\t\tif (pairs[i].indexOf('=') < 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(pairs[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: indexOfStylename\n\t *\n\t * Returns the index of the given stylename in the given style. This\n\t * returns -1 if the given stylename does not occur (as a stylename) in the\n\t * given style, otherwise it returns the index of the first character.\n\t */\n\tindexOfStylename: function(style, stylename)\n\t{\n\t\tif (style != null && stylename != null)\n\t\t{\n\t\t\tvar tokens = style.split(';');\n\t\t\tvar pos = 0;\n\n\t\t\tfor (var i = 0; i < tokens.length; i++)\n\t\t\t{\n\t\t\t\tif (tokens[i] == stylename)\n\t\t\t\t{\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\n\t\t\t\tpos += tokens[i].length + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\t/**\n\t * Function: addStylename\n\t *\n\t * Adds the specified stylename to the given style if it does not already\n\t * contain the stylename.\n\t */\n\taddStylename: function(style, stylename)\n\t{\n\t\tif (mxUtils.indexOfStylename(style, stylename) < 0)\n\t\t{\n\t\t\tif (style == null)\n\t\t\t{\n\t\t\t\tstyle = '';\n\t\t\t}\n\t\t\telse if (style.length > 0 && style.charAt(style.length - 1) != ';')\n\t\t\t{\n\t\t\t\tstyle += ';';\n\t\t\t}\n\n\t\t\tstyle += stylename;\n\t\t}\n\n\t\treturn style;\n\t},\n\n\t/**\n\t * Function: removeStylename\n\t *\n\t * Removes all occurrences of the specified stylename in the given style\n\t * and returns the updated style. Trailing semicolons are not preserved.\n\t */\n\tremoveStylename: function(style, stylename)\n\t{\n\t\tvar result = [];\n\n\t\tif (style != null)\n\t\t{\n\t\t\tvar tokens = style.split(';');\n\n\t\t\tfor (var i = 0; i < tokens.length; i++)\n\t\t\t{\n\t\t\t\tif (tokens[i] != stylename)\n\t\t\t\t{\n\t\t\t\t\tresult.push(tokens[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result.join(';');\n\t},\n\n\t/**\n\t * Function: removeAllStylenames\n\t *\n\t * Removes all stylenames from the given style and returns the updated\n\t * style.\n\t */\n\tremoveAllStylenames: function(style)\n\t{\n\t\tvar result = [];\n\n\t\tif (style != null)\n\t\t{\n\t\t\tvar tokens = style.split(';');\n\n\t\t\tfor (var i = 0; i < tokens.length; i++)\n\t\t\t{\n\t\t\t\t// Keeps the key, value assignments\n\t\t\t\tif (tokens[i].indexOf('=') >= 0)\n\t\t\t\t{\n\t\t\t\t\tresult.push(tokens[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result.join(';');\n\t},\n\n\t/**\n\t * Function: setCellStyles\n\t *\n\t * Assigns the value for the given key in the styles of the given cells, or\n\t * removes the key from the styles if the value is null.\n\t *\n\t * Parameters:\n\t *\n\t * model - <mxGraphModel> to execute the transaction in.\n\t * cells - Array of <mxCells> to be updated.\n\t * key - Key of the style to be changed.\n\t * value - New value for the given key.\n\t */\n\tsetCellStyles: function(model, cells, key, value)\n\t{\n\t\tif (cells != null && cells.length > 0)\n\t\t{\n\t\t\tmodel.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (cells[i] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar style = mxUtils.setStyle(model.getStyle(cells[i]), key, value);\n\t\t\t\t\t\tmodel.setStyle(cells[i], style);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmodel.endUpdate();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: setStyle\n\t *\n\t * Adds or removes the given key, value pair to the style and returns the\n\t * new style. If value is null or zero length then the key is removed from\n\t * the style. This is for cell styles, not for CSS styles.\n\t *\n\t * Parameters:\n\t *\n\t * style - String of the form [(stylename|key=value);].\n\t * key - Key of the style to be changed.\n\t * value - New value for the given key.\n\t */\n\tsetStyle: function(style, key, value)\n\t{\n\t\tvar isValue = value != null && (typeof(value.length) == 'undefined' || value.length > 0);\n\n\t\tif (style == null || style.length == 0)\n\t\t{\n\t\t\tif (isValue)\n\t\t\t{\n\t\t\t\tstyle = key + '=' + value + ';';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (style.substring(0, key.length + 1) == key + '=')\n\t\t\t{\n\t\t\t\tvar next = style.indexOf(';');\n\n\t\t\t\tif (isValue)\n\t\t\t\t{\n\t\t\t\t\tstyle = key + '=' + value + ((next < 0) ? ';' : style.substring(next));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstyle = (next < 0 || next == style.length - 1) ? '' : style.substring(next + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar index = style.indexOf(';' + key + '=');\n\n\t\t\t\tif (index < 0)\n\t\t\t\t{\n\t\t\t\t\tif (isValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sep = (style.charAt(style.length - 1) == ';') ? '' : ';';\n\t\t\t\t\t\tstyle = style + sep + key + '=' + value + ';';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar next = style.indexOf(';', index + 1);\n\n\t\t\t\t\tif (isValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle = style.substring(0, index + 1) + key + '=' + value + ((next < 0) ? ';' : style.substring(next));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle = style.substring(0, index) + ((next < 0) ? ';' : style.substring(next));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn style;\n\t},\n\n\t/**\n\t * Function: setCellStyleFlags\n\t *\n\t * Sets or toggles the flag bit for the given key in the cell's styles.\n\t * If value is null then the flag is toggled.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * var cells = graph.getSelectionCells();\n\t * mxUtils.setCellStyleFlags(graph.model,\n\t * \t\t\tcells,\n\t * \t\t\tmxConstants.STYLE_FONTSTYLE,\n\t * \t\t\tmxConstants.FONT_BOLD);\n\t * (end)\n\t *\n\t * Toggles the bold font style.\n\t *\n\t * Parameters:\n\t *\n\t * model - <mxGraphModel> that contains the cells.\n\t * cells - Array of <mxCells> to change the style for.\n\t * key - Key of the style to be changed.\n\t * flag - Integer for the bit to be changed.\n\t * value - Optional boolean value for the flag.\n\t */\n\tsetCellStyleFlags: function(model, cells, key, flag, value)\n\t{\n\t\tif (cells != null && cells.length > 0)\n\t\t{\n\t\t\tmodel.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (cells[i] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar style = mxUtils.setStyleFlag(\n\t\t\t\t\t\t\tmodel.getStyle(cells[i]),\n\t\t\t\t\t\t\tkey, flag, value);\n\t\t\t\t\t\tmodel.setStyle(cells[i], style);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmodel.endUpdate();\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: setStyleFlag\n\t *\n\t * Sets or removes the given key from the specified style and returns the\n\t * new style. If value is null then the flag is toggled.\n\t *\n\t * Parameters:\n\t *\n\t * style - String of the form [(stylename|key=value);].\n\t * key - Key of the style to be changed.\n\t * flag - Integer for the bit to be changed.\n\t * value - Optional boolean value for the given flag.\n\t */\n\tsetStyleFlag: function(style, key, flag, value)\n\t{\n\t\tif (style == null || style.length == 0)\n\t\t{\n\t\t\tif (value || value == null)\n\t\t\t{\n\t\t\t\tstyle = key+'='+flag;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstyle = key+'=0';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar index = style.indexOf(key+'=');\n\n\t\t\tif (index < 0)\n\t\t\t{\n\t\t\t\tvar sep = (style.charAt(style.length-1) == ';') ? '' : ';';\n\n\t\t\t\tif (value || value == null)\n\t\t\t\t{\n\t\t\t\t\tstyle = style + sep + key + '=' + flag;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstyle = style + sep + key + '=0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar cont = style.indexOf(';', index);\n\t\t\t\tvar tmp = '';\n\n\t\t\t\tif (cont < 0)\n\t\t\t\t{\n\t\t\t\t\ttmp  = style.substring(index+key.length+1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp = style.substring(index+key.length+1, cont);\n\t\t\t\t}\n\n\t\t\t\tif (value == null)\n\t\t\t\t{\n\t\t\t\t\ttmp = parseInt(tmp) ^ flag;\n\t\t\t\t}\n\t\t\t\telse if (value)\n\t\t\t\t{\n\t\t\t\t\ttmp = parseInt(tmp) | flag;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmp = parseInt(tmp) & ~flag;\n\t\t\t\t}\n\n\t\t\t\tstyle = style.substring(0, index) + key + '=' + tmp +\n\t\t\t\t\t((cont >= 0) ? style.substring(cont) : '');\n\t\t\t}\n\t\t}\n\n\t\treturn style;\n\t},\n\n\t/**\n\t * Function: getAlignmentAsPoint\n\t *\n\t * Returns an <mxPoint> that represents the horizontal and vertical alignment\n\t * for numeric computations. X is -0.5 for center, -1 for right and 0 for\n\t * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top\n\t * alignment. Default values for missing arguments is top, left.\n\t */\n\tgetAlignmentAsPoint: function(align, valign)\n\t{\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\n\t\t// Horizontal alignment\n\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t{\n\t\t\tdx = -0.5;\n\t\t}\n\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t{\n\t\t\tdx = -1;\n\t\t}\n\n\t\t// Vertical alignment\n\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t{\n\t\t\tdy = -0.5;\n\t\t}\n\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t{\n\t\t\tdy = -1;\n\t\t}\n\n\t\treturn new mxPoint(dx, dy);\n\t},\n\n\t/**\n\t * Function: getSizeForString\n\t *\n\t * Returns an <mxRectangle> with the size (width and height in pixels) of\n\t * the given string. The string may contain HTML markup. Newlines should be\n\t * converted to <br> before calling this method. The caller is responsible\n\t * for sanitizing the HTML markup.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * var label = graph.getLabel(cell).replace(/\\n/g, \"<br>\");\n\t * var size = graph.getSizeForString(label);\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * text - String whose size should be returned.\n\t * fontSize - Integer that specifies the font size in pixels. Default is\n\t * <mxConstants.DEFAULT_FONTSIZE>.\n\t * fontFamily - String that specifies the name of the font family. Default\n\t * is <mxConstants.DEFAULT_FONTFAMILY>.\n\t * textWidth - Optional width for text wrapping.\n\t */\n\tgetSizeForString: function(text, fontSize, fontFamily, textWidth)\n\t{\n\t\tfontSize = (fontSize != null) ? fontSize : mxConstants.DEFAULT_FONTSIZE;\n\t\tfontFamily = (fontFamily != null) ? fontFamily : mxConstants.DEFAULT_FONTFAMILY;\n\t\tvar div = document.createElement('div');\n\n\t\t// Sets the font size and family\n\t\tdiv.style.fontFamily = fontFamily;\n\t\tdiv.style.fontSize = Math.round(fontSize) + 'px';\n\t\tdiv.style.lineHeight = Math.round(fontSize * mxConstants.LINE_HEIGHT) + 'px';\n\n\t\t// Disables block layout and outside wrapping and hides the div\n\t\tdiv.style.position = 'absolute';\n\t\tdiv.style.visibility = 'hidden';\n\t\tdiv.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\tdiv.style.zoom = '1';\n\n\t\tif (textWidth != null)\n\t\t{\n\t\t\tdiv.style.width = textWidth + 'px';\n\t\t\tdiv.style.whiteSpace = 'normal';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiv.style.whiteSpace = 'nowrap';\n\t\t}\n\n\t\t// Adds the text and inserts into DOM for updating of size\n\t\tdiv.innerHTML = text;\n\t\tdocument.body.appendChild(div);\n\n\t\t// Gets the size and removes from DOM\n\t\tvar size = new mxRectangle(0, 0, div.offsetWidth, div.offsetHeight);\n\t\tdocument.body.removeChild(div);\n\n\t\treturn size;\n\t},\n\n\t/**\n\t * Function: getViewXml\n\t */\n\tgetViewXml: function(graph, scale, cells, x0, y0)\n\t{\n\t\tx0 = (x0 != null) ? x0 : 0;\n\t\ty0 = (y0 != null) ? y0 : 0;\n\t\tscale = (scale != null) ? scale : 1;\n\n\t\tif (cells == null)\n\t\t{\n\t\t\tvar model = graph.getModel();\n\t\t\tcells = [model.getRoot()];\n\t\t}\n\n\t\tvar view = graph.getView();\n\t\tvar result = null;\n\n\t\t// Disables events on the view\n\t\tvar eventsEnabled = view.isEventsEnabled();\n\t\tview.setEventsEnabled(false);\n\n\t\t// Workaround for label bounds not taken into account for image export.\n\t\t// Creates a temporary draw pane which is used for rendering the text.\n\t\t// Text rendering is required for finding the bounds of the labels.\n\t\tvar drawPane = view.drawPane;\n\t\tvar overlayPane = view.overlayPane;\n\n\t\tif (graph.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\tview.drawPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\t\t\tview.canvas.appendChild(view.drawPane);\n\n\t\t\t// Redirects cell overlays into temporary container\n\t\t\tview.overlayPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\t\t\tview.canvas.appendChild(view.overlayPane);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tview.drawPane = view.drawPane.cloneNode(false);\n\t\t\tview.canvas.appendChild(view.drawPane);\n\n\t\t\t// Redirects cell overlays into temporary container\n\t\t\tview.overlayPane = view.overlayPane.cloneNode(false);\n\t\t\tview.canvas.appendChild(view.overlayPane);\n\t\t}\n\n\t\t// Resets the translation\n\t\tvar translate = view.getTranslate();\n\t\tview.translate = new mxPoint(x0, y0);\n\n\t\t// Creates the temporary cell states in the view\n\t\tvar temp = new mxTemporaryCellStates(graph.getView(), scale, cells);\n\n\t\ttry\n\t\t{\n\t\t\tvar enc = new mxCodec();\n\t\t\tresult = enc.encode(graph.getView());\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttemp.destroy();\n\t\t\tview.translate = translate;\n\t\t\tview.canvas.removeChild(view.drawPane);\n\t\t\tview.canvas.removeChild(view.overlayPane);\n\t\t\tview.drawPane = drawPane;\n\t\t\tview.overlayPane = overlayPane;\n\t\t\tview.setEventsEnabled(eventsEnabled);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: getScaleForPageCount\n\t *\n\t * Returns the scale to be used for printing the graph with the given\n\t * bounds across the specifies number of pages with the given format. The\n\t * scale is always computed such that it given the given amount or fewer\n\t * pages in the print output. See <mxPrintPreview> for an example.\n\t *\n\t * Parameters:\n\t *\n\t * pageCount - Specifies the number of pages in the print output.\n\t * graph - <mxGraph> that should be printed.\n\t * pageFormat - Optional <mxRectangle> that specifies the page format.\n\t * Default is <mxConstants.PAGE_FORMAT_A4_PORTRAIT>.\n\t * border - The border along each side of every page.\n\t */\n\tgetScaleForPageCount: function(pageCount, graph, pageFormat, border)\n\t{\n\t\tif (pageCount < 1)\n\t\t{\n\t\t\t// We can't work with less than 1 page, return no scale\n\t\t\t// change\n\t\t\treturn 1;\n\t\t}\n\n\t\tpageFormat = (pageFormat != null) ? pageFormat : mxConstants.PAGE_FORMAT_A4_PORTRAIT;\n\t\tborder = (border != null) ? border : 0;\n\n\t\tvar availablePageWidth = pageFormat.width - (border * 2);\n\t\tvar availablePageHeight = pageFormat.height - (border * 2);\n\n\t\t// Work out the number of pages required if the\n\t\t// graph is not scaled.\n\t\tvar graphBounds = graph.getGraphBounds().clone();\n\t\tvar sc = graph.getView().getScale();\n\t\tgraphBounds.width /= sc;\n\t\tgraphBounds.height /= sc;\n\t\tvar graphWidth = graphBounds.width;\n\t\tvar graphHeight = graphBounds.height;\n\n\t\tvar scale = 1;\n\n\t\t// The ratio of the width/height for each printer page\n\t\tvar pageFormatAspectRatio = availablePageWidth / availablePageHeight;\n\t\t// The ratio of the width/height for the graph to be printer\n\t\tvar graphAspectRatio = graphWidth / graphHeight;\n\n\t\t// The ratio of horizontal pages / vertical pages for this\n\t\t// graph to maintain its aspect ratio on this page format\n\t\tvar pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;\n\n\t\t// Factor the square root of the page count up and down\n\t\t// by the pages aspect ratio to obtain a horizontal and\n\t\t// vertical page count that adds up to the page count\n\t\t// and has the correct aspect ratio\n\t\tvar pageRoot = Math.sqrt(pageCount);\n\t\tvar pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);\n\t\tvar numRowPages = pageRoot * pagesAspectRatioSqrt;\n\t\tvar numColumnPages = pageRoot / pagesAspectRatioSqrt;\n\n\t\t// These value are rarely more than 2 rounding downs away from\n\t\t// a total that meets the page count. In cases of one being less\n\t\t// than 1 page, the other value can be too high and take more iterations\n\t\t// In this case, just change that value to be the page count, since\n\t\t// we know the other value is 1\n\t\tif (numRowPages < 1 && numColumnPages > pageCount)\n\t\t{\n\t\t\tvar scaleChange = numColumnPages / pageCount;\n\t\t\tnumColumnPages = pageCount;\n\t\t\tnumRowPages /= scaleChange;\n\t\t}\n\n\t\tif (numColumnPages < 1 && numRowPages > pageCount)\n\t\t{\n\t\t\tvar scaleChange = numRowPages / pageCount;\n\t\t\tnumRowPages = pageCount;\n\t\t\tnumColumnPages /= scaleChange;\n\t\t}\n\n\t\tvar currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n\n\t\tvar numLoops = 0;\n\n\t\t// Iterate through while the rounded up number of pages comes to\n\t\t// a total greater than the required number\n\t\twhile (currentTotalPages > pageCount)\n\t\t{\n\t\t\t// Round down the page count (rows or columns) that is\n\t\t\t// closest to its next integer down in percentage terms.\n\t\t\t// i.e. Reduce the page total by reducing the total\n\t\t\t// page area by the least possible amount\n\n\t\t\tvar roundRowDownProportion = Math.floor(numRowPages) / numRowPages;\n\t\t\tvar roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;\n\n\t\t\t// If the round down proportion is, work out the proportion to\n\t\t\t// round down to 1 page less\n\t\t\tif (roundRowDownProportion == 1)\n\t\t\t{\n\t\t\t\troundRowDownProportion = Math.floor(numRowPages-1) / numRowPages;\n\t\t\t}\n\t\t\tif (roundColumnDownProportion == 1)\n\t\t\t{\n\t\t\t\troundColumnDownProportion = Math.floor(numColumnPages-1) / numColumnPages;\n\t\t\t}\n\n\t\t\t// Check which rounding down is smaller, but in the case of very small roundings\n\t\t\t// try the other dimension instead\n\t\t\tvar scaleChange = 1;\n\n\t\t\t// Use the higher of the two values\n\t\t\tif (roundRowDownProportion > roundColumnDownProportion)\n\t\t\t{\n\t\t\t\tscaleChange = roundRowDownProportion;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscaleChange = roundColumnDownProportion;\n\t\t\t}\n\n\t\t\tnumRowPages = numRowPages * scaleChange;\n\t\t\tnumColumnPages = numColumnPages * scaleChange;\n\t\t\tcurrentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n\n\t\t\tnumLoops++;\n\n\t\t\tif (numLoops > 10)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Work out the scale from the number of row pages required\n\t\t// The column pages will give the same value\n\t\tvar posterWidth = availablePageWidth * numRowPages;\n\t\tscale = posterWidth / graphWidth;\n\n\t\t// Allow for rounding errors\n\t\treturn scale * 0.99999;\n\t},\n\n\t/**\n\t * Function: show\n\t *\n\t * Copies the styles and the markup from the graph's container into the\n\t * given document and removes all cursor styles. The document is returned.\n\t *\n\t * This function should be called from within the document with the graph.\n\t * If you experience problems with missing stylesheets in IE then try adding\n\t * the domain to the trusted sites.\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> to be copied.\n\t * doc - Document where the new graph is created.\n\t * x0 - X-coordinate of the graph view origin. Default is 0.\n\t * y0 - Y-coordinate of the graph view origin. Default is 0.\n\t * w - Optional width of the graph view.\n\t * h - Optional height of the graph view.\n\t */\n\tshow: function(graph, doc, x0, y0, w, h)\n\t{\n\t\tx0 = (x0 != null) ? x0 : 0;\n\t\ty0 = (y0 != null) ? y0 : 0;\n\n\t\tif (doc == null)\n\t\t{\n\t\t\tvar wnd = window.open();\n\t\t\tdoc = wnd.document;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc.open();\n\t\t}\n\n\t\t// Workaround for missing print output in IE9 standards\n\t\tif (document.documentMode == 9)\n\t\t{\n\t\t\tdoc.writeln('<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"><![endif]-->');\n\t\t}\n\n\t\tvar bounds = graph.getGraphBounds();\n\t\tvar dx = Math.ceil(x0 - bounds.x);\n\t\tvar dy = Math.ceil(y0 - bounds.y);\n\n\t\tif (w == null)\n\t\t{\n\t\t\tw = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);\n\t\t}\n\n\t\tif (h == null)\n\t\t{\n\t\t\th = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);\n\t\t}\n\n\t\t// Needs a special way of creating the page so that no click is required\n\t\t// to refresh the contents after the external CSS styles have been loaded.\n\t\t// To avoid a click or programmatic refresh, the styleSheets[].cssText\n\t\t// property is copied over from the original document.\n\t\tif (mxClient.IS_IE || document.documentMode == 11)\n\t\t{\n\t\t\tvar html = '<html><head>';\n\n\t\t\tvar base = document.getElementsByTagName('base');\n\n\t\t\tfor (var i = 0; i < base.length; i++)\n\t\t\t{\n\t\t\t\thtml += base[i].outerHTML;\n\t\t\t}\n\n\t\t\thtml += '<style>';\n\n\t\t\t// Copies the stylesheets without having to load them again\n\t\t\tfor (var i = 0; i < document.styleSheets.length; i++)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\thtml += document.styleSheets[i].cssText;\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// ignore security exception\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thtml += '</style></head><body style=\"margin:0px;\">';\n\n\t\t\t// Copies the contents of the graph container\n\t\t\thtml += '<div style=\"position:absolute;overflow:hidden;width:' + w + 'px;height:' + h + 'px;\"><div style=\"position:relative;left:' + dx + 'px;top:' + dy + 'px;\">';\n\t\t\thtml += graph.container.innerHTML;\n\t\t\thtml += '</div></div></body><html>';\n\n\t\t\tdoc.writeln(html);\n\t\t\tdoc.close();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoc.writeln('<html><head>');\n\n\t\t\tvar base = document.getElementsByTagName('base');\n\n\t\t\tfor (var i = 0; i < base.length; i++)\n\t\t\t{\n\t\t\t\tdoc.writeln(mxUtils.getOuterHtml(base[i]));\n\t\t\t}\n\n\t\t\tvar links = document.getElementsByTagName('link');\n\n\t\t\tfor (var i = 0; i < links.length; i++)\n\t\t\t{\n\t\t\t\tdoc.writeln(mxUtils.getOuterHtml(links[i]));\n\t\t\t}\n\n\t\t\tvar styles = document.getElementsByTagName('style');\n\n\t\t\tfor (var i = 0; i < styles.length; i++)\n\t\t\t{\n\t\t\t\tdoc.writeln(mxUtils.getOuterHtml(styles[i]));\n\t\t\t}\n\n\t\t\tdoc.writeln('</head><body style=\"margin:0px;\"></body></html>');\n\t\t\tdoc.close();\n\n\t\t\tvar outer = doc.createElement('div');\n\t\t\touter.position = 'absolute';\n\t\t\touter.overflow = 'hidden';\n\t\t\touter.style.width = w + 'px';\n\t\t\touter.style.height = h + 'px';\n\n\t\t\t// Required for HTML labels if foreignObjects are disabled\n\t\t\tvar div = doc.createElement('div');\n\t\t\tdiv.style.position = 'absolute';\n\t\t\tdiv.style.left = dx + 'px';\n\t\t\tdiv.style.top = dy + 'px';\n\n\t\t\tvar node = graph.container.firstChild;\n\t\t\tvar svg = null;\n\n\t\t\twhile (node != null)\n\t\t\t{\n\t\t\t\tvar clone = node.cloneNode(true);\n\n\t\t\t\tif (node == graph.view.drawPane.ownerSVGElement)\n\t\t\t\t{\n\t\t\t\t\touter.appendChild(clone);\n\t\t\t\t\tsvg = clone;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdiv.appendChild(clone);\n\t\t\t\t}\n\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\n\t\t\tdoc.body.appendChild(outer);\n\n\t\t\tif (div.firstChild != null)\n\t\t\t{\n\t\t\t\tdoc.body.appendChild(div);\n\t\t\t}\n\n\t\t\tif (svg != null)\n\t\t\t{\n\t\t\t\tsvg.style.minWidth = '';\n\t\t\t\tsvg.style.minHeight = '';\n\t\t\t\tsvg.firstChild.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\t\t\t}\n\t\t}\n\n\t\tmxUtils.removeCursors(doc.body);\n\n\t\treturn doc;\n\t},\n\n\t/**\n\t * Function: printScreen\n\t *\n\t * Prints the specified graph using a new window and the built-in print\n\t * dialog.\n\t *\n\t * This function should be called from within the document with the graph.\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> to be printed.\n\t */\n\tprintScreen: function(graph)\n\t{\n\t\tvar wnd = window.open();\n\t\tvar bounds = graph.getGraphBounds();\n\t\tmxUtils.show(graph, wnd.document);\n\n\t\tvar print = function()\n\t\t{\n\t\t\twnd.focus();\n\t\t\twnd.print();\n\t\t\twnd.close();\n\t\t};\n\n\t\t// Workaround for Google Chrome which needs a bit of a\n\t\t// delay in order to render the SVG contents\n\t\tif (mxClient.IS_GC)\n\t\t{\n\t\t\twnd.setTimeout(print, 500);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprint();\n\t\t}\n\t},\n\n\t/**\n\t * Function: popup\n\t *\n\t * Shows the specified text content in a new <mxWindow> or a new browser\n\t * window if isInternalWindow is false.\n\t *\n\t * Parameters:\n\t *\n\t * content - String that specifies the text to be displayed.\n\t * isInternalWindow - Optional boolean indicating if an mxWindow should be\n\t * used instead of a new browser window. Default is false.\n\t */\n\tpopup: function(content, isInternalWindow)\n\t{\n\t   \tif (isInternalWindow)\n\t   \t{\n\t\t\tvar div = document.createElement('div');\n\n\t\t\tdiv.style.overflow = 'scroll';\n\t\t\tdiv.style.width = '636px';\n\t\t\tdiv.style.height = '460px';\n\n\t\t\tvar pre = document.createElement('pre');\n\t\t    pre.innerHTML = mxUtils.htmlEntities(content, false).\n\t\t    \treplace(/\\n/g,'<br>').replace(/ /g, '&nbsp;');\n\n\t\t\tdiv.appendChild(pre);\n\n\t\t\tvar w = document.body.clientWidth;\n\t\t\tvar h = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight)\n\t\t\tvar wnd = new mxWindow('Popup Window', div,\n\t\t\t\tw/2-320, h/2-240, 640, 480, false, true);\n\n\t\t\twnd.setClosable(true);\n\t\t\twnd.setVisible(true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Wraps up the XML content in a textarea\n\t\t\tif (mxClient.IS_NS)\n\t\t\t{\n\t\t\t    var wnd = window.open();\n\t\t\t\twnd.document.writeln('<pre>'+mxUtils.htmlEntities(content)+'</pre');\n\t\t\t   \twnd.document.close();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    var wnd = window.open();\n\t\t\t    var pre = wnd.document.createElement('pre');\n\t\t\t    pre.innerHTML = mxUtils.htmlEntities(content, false).\n\t\t\t    \treplace(/\\n/g,'<br>').replace(/ /g, '&nbsp;');\n\t\t\t   \twnd.document.body.appendChild(pre);\n\t\t\t}\n\t   \t}\n\t},\n\n\t/**\n\t * Function: alert\n\t *\n\t * Displayss the given alert in a new dialog. This implementation uses the\n\t * built-in alert function. This is used to display validation errors when\n\t * connections cannot be changed or created.\n\t *\n\t * Parameters:\n\t *\n\t * message - String specifying the message to be displayed.\n\t */\n\talert: function(message)\n\t{\n\t\talert(message);\n\t},\n\n\t/**\n\t * Function: prompt\n\t *\n\t * Displays the given message in a prompt dialog. This implementation uses\n\t * the built-in prompt function.\n\t *\n\t * Parameters:\n\t *\n\t * message - String specifying the message to be displayed.\n\t * defaultValue - Optional string specifying the default value.\n\t */\n\tprompt: function(message, defaultValue)\n\t{\n\t\treturn prompt(message, (defaultValue != null) ? defaultValue : '');\n\t},\n\n\t/**\n\t * Function: confirm\n\t *\n\t * Displays the given message in a confirm dialog. This implementation uses\n\t * the built-in confirm function.\n\t *\n\t * Parameters:\n\t *\n\t * message - String specifying the message to be displayed.\n\t */\n\tconfirm: function(message)\n\t{\n\t\treturn confirm(message);\n\t},\n\n\t/**\n\t * Function: error\n\t *\n\t * Displays the given error message in a new <mxWindow> of the given width.\n\t * If close is true then an additional close button is added to the window.\n\t * The optional icon specifies the icon to be used for the window. Default\n\t * is <mxUtils.errorImage>.\n\t *\n\t * Parameters:\n\t *\n\t * message - String specifying the message to be displayed.\n\t * width - Integer specifying the width of the window.\n\t * close - Optional boolean indicating whether to add a close button.\n\t * icon - Optional icon for the window decoration.\n\t */\n\terror: function(message, width, close, icon)\n\t{\n\t\tvar div = document.createElement('div');\n\t\tdiv.style.padding = '20px';\n\n\t\tvar img = document.createElement('img');\n\t\timg.setAttribute('src', icon || mxUtils.errorImage);\n\t\timg.setAttribute('valign', 'bottom');\n\t\timg.style.verticalAlign = 'middle';\n\t\tdiv.appendChild(img);\n\n\t\tdiv.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n\t\tdiv.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n\t\tdiv.appendChild(document.createTextNode('\\u00a0')); // &nbsp;\n\t\tmxUtils.write(div, message);\n\n\t\tvar w = document.body.clientWidth;\n\t\tvar h = (document.body.clientHeight || document.documentElement.clientHeight);\n\t\tvar warn = new mxWindow(mxResources.get(mxUtils.errorResource) ||\n\t\t\tmxUtils.errorResource, div, (w-width)/2, h/4, width, null,\n\t\t\tfalse, true);\n\n\t\tif (close)\n\t\t{\n\t\t\tmxUtils.br(div);\n\n\t\t\tvar tmp = document.createElement('p');\n\t\t\tvar button = document.createElement('button');\n\n\t\t\tif (mxClient.IS_IE)\n\t\t\t{\n\t\t\t\tbutton.style.cssText = 'float:right';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbutton.setAttribute('style', 'float:right');\n\t\t\t}\n\n\t\t\tmxEvent.addListener(button, 'click', function(evt)\n\t\t\t{\n\t\t\t\twarn.destroy();\n\t\t\t});\n\n\t\t\tmxUtils.write(button, mxResources.get(mxUtils.closeResource) ||\n\t\t\t\tmxUtils.closeResource);\n\n\t\t\ttmp.appendChild(button);\n\t\t\tdiv.appendChild(tmp);\n\n\t\t\tmxUtils.br(div);\n\n\t\t\twarn.setClosable(true);\n\t\t}\n\n\t\twarn.setVisible(true);\n\n\t\treturn warn;\n\t},\n\n\t/**\n\t * Function: makeDraggable\n\t *\n\t * Configures the given DOM element to act as a drag source for the\n\t * specified graph. Returns a a new <mxDragSource>. If\n\t * <mxDragSource.guideEnabled> is enabled then the x and y arguments must\n\t * be used in funct to match the preview location.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * var funct = function(graph, evt, cell, x, y)\n\t * {\n\t *   if (graph.canImportCell(cell))\n\t *   {\n\t *     var parent = graph.getDefaultParent();\n\t *     var vertex = null;\n\t *\n\t *     graph.getModel().beginUpdate();\n\t *     try\n\t *     {\n\t * \t     vertex = graph.insertVertex(parent, null, 'Hello', x, y, 80, 30);\n\t *     }\n\t *     finally\n\t *     {\n\t *       graph.getModel().endUpdate();\n\t *     }\n\t *\n\t *     graph.setSelectionCell(vertex);\n\t *   }\n\t * }\n\t *\n\t * var img = document.createElement('img');\n\t * img.setAttribute('src', 'editors/images/rectangle.gif');\n\t * img.style.position = 'absolute';\n\t * img.style.left = '0px';\n\t * img.style.top = '0px';\n\t * img.style.width = '16px';\n\t * img.style.height = '16px';\n\t *\n\t * var dragImage = img.cloneNode(true);\n\t * dragImage.style.width = '32px';\n\t * dragImage.style.height = '32px';\n\t * mxUtils.makeDraggable(img, graph, funct, dragImage);\n\t * document.body.appendChild(img);\n\t * (end)\n\t *\n\t * Parameters:\n\t *\n\t * element - DOM element to make draggable.\n\t * graphF - <mxGraph> that acts as the drop target or a function that takes a\n\t * mouse event and returns the current <mxGraph>.\n\t * funct - Function to execute on a successful drop.\n\t * dragElement - Optional DOM node to be used for the drag preview.\n\t * dx - Optional horizontal offset between the cursor and the drag\n\t * preview.\n\t * dy - Optional vertical offset between the cursor and the drag\n\t * preview.\n\t * autoscroll - Optional boolean that specifies if autoscroll should be\n\t * used. Default is mxGraph.autoscroll.\n\t * scalePreview - Optional boolean that specifies if the preview element\n\t * should be scaled according to the graph scale. If this is true, then\n\t * the offsets will also be scaled. Default is false.\n\t * highlightDropTargets - Optional boolean that specifies if dropTargets\n\t * should be highlighted. Default is true.\n\t * getDropTarget - Optional function to return the drop target for a given\n\t * location (x, y). Default is mxGraph.getCellAt.\n\t */\n\tmakeDraggable: function(element, graphF, funct, dragElement, dx, dy, autoscroll,\n\t\t\tscalePreview, highlightDropTargets, getDropTarget)\n\t{\n\t\tvar dragSource = new mxDragSource(element, funct);\n\t\tdragSource.dragOffset = new mxPoint((dx != null) ? dx : 0,\n\t\t\t(dy != null) ? dy : mxConstants.TOOLTIP_VERTICAL_OFFSET);\n\t\tdragSource.autoscroll = autoscroll;\n\n\t\t// Cannot enable this by default. This needs to be enabled in the caller\n\t\t// if the funct argument uses the new x- and y-arguments.\n\t\tdragSource.setGuidesEnabled(false);\n\n\t\tif (highlightDropTargets != null)\n\t\t{\n\t\t\tdragSource.highlightDropTargets = highlightDropTargets;\n\t\t}\n\n\t\t// Overrides function to find drop target cell\n\t\tif (getDropTarget != null)\n\t\t{\n\t\t\tdragSource.getDropTarget = getDropTarget;\n\t\t}\n\n\t\t// Overrides function to get current graph\n\t\tdragSource.getGraphForEvent = function(evt)\n\t\t{\n\t\t\treturn (typeof(graphF) == 'function') ? graphF(evt) : graphF;\n\t\t};\n\n\t\t// Translates switches into dragSource customizations\n\t\tif (dragElement != null)\n\t\t{\n\t\t\tdragSource.createDragElement = function()\n\t\t\t{\n\t\t\t\treturn dragElement.cloneNode(true);\n\t\t\t};\n\n\t\t\tif (scalePreview)\n\t\t\t{\n\t\t\t\tdragSource.createPreviewElement = function(graph)\n\t\t\t\t{\n\t\t\t\t\tvar elt = dragElement.cloneNode(true);\n\n\t\t\t\t\tvar w = parseInt(elt.style.width);\n\t\t\t\t\tvar h = parseInt(elt.style.height);\n\t\t\t\t\telt.style.width = Math.round(w * graph.view.scale) + 'px';\n\t\t\t\t\telt.style.height = Math.round(h * graph.view.scale) + 'px';\n\n\t\t\t\t\treturn elt;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn dragSource;\n\t}\n\n};\n\n__mxOutput.mxUtils = typeof mxUtils !== 'undefined' ? mxUtils : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n var mxConstants =\n {\n\t/**\n\t * Class: mxConstants\n\t *\n\t * Defines various global constants.\n\t *\n\t * Variable: DEFAULT_HOTSPOT\n\t *\n\t * Defines the portion of the cell which is to be used as a connectable\n\t * region. Default is 0.3. Possible values are 0 < x <= 1.\n\t */\n\tDEFAULT_HOTSPOT: 0.3,\n\n\t/**\n\t * Variable: MIN_HOTSPOT_SIZE\n\t *\n\t * Defines the minimum size in pixels of the portion of the cell which is\n\t * to be used as a connectable region. Default is 8.\n\t */\n\tMIN_HOTSPOT_SIZE: 8,\n\n\t/**\n\t * Variable: MAX_HOTSPOT_SIZE\n\t *\n\t * Defines the maximum size in pixels of the portion of the cell which is\n\t * to be used as a connectable region. Use 0 for no maximum. Default is 0.\n\t */\n\tMAX_HOTSPOT_SIZE: 0,\n\n\t/**\n\t * Variable: RENDERING_HINT_EXACT\n\t *\n\t * Defines the exact rendering hint.\n\t */\n\tRENDERING_HINT_EXACT: 'exact',\n\n\t/**\n\t * Variable: RENDERING_HINT_FASTER\n\t *\n\t * Defines the faster rendering hint.\n\t */\n\tRENDERING_HINT_FASTER: 'faster',\n\n\t/**\n\t * Variable: RENDERING_HINT_FASTEST\n\t *\n\t * Defines the fastest rendering hint.\n\t */\n\tRENDERING_HINT_FASTEST: 'fastest',\n\n\t/**\n\t * Variable: DIALECT_SVG\n\t *\n\t * Defines the SVG display dialect name.\n\t */\n\tDIALECT_SVG: 'svg',\n\n\t/**\n\t * Variable: DIALECT_VML\n\t *\n\t * Defines the VML display dialect name.\n\t */\n\tDIALECT_VML: 'vml',\n\n\t/**\n\t * Variable: DIALECT_MIXEDHTML\n\t *\n\t * Defines the mixed HTML display dialect name.\n\t */\n\tDIALECT_MIXEDHTML: 'mixedHtml',\n\n\t/**\n\t * Variable: DIALECT_PREFERHTML\n\t *\n\t * Defines the preferred HTML display dialect name.\n\t */\n\tDIALECT_PREFERHTML: 'preferHtml',\n\n\t/**\n\t * Variable: DIALECT_STRICTHTML\n\t *\n\t * Defines the strict HTML display dialect.\n\t */\n\tDIALECT_STRICTHTML: 'strictHtml',\n\n\t/**\n\t * Variable: NS_SVG\n\t *\n\t * Defines the SVG namespace.\n\t */\n\tNS_SVG: 'http://www.w3.org/2000/svg',\n\n\t/**\n\t * Variable: NS_XHTML\n\t *\n\t * Defines the XHTML namespace.\n\t */\n\tNS_XHTML: 'http://www.w3.org/1999/xhtml',\n\n\t/**\n\t * Variable: NS_XLINK\n\t *\n\t * Defines the XLink namespace.\n\t */\n\tNS_XLINK: 'http://www.w3.org/1999/xlink',\n\n\t/**\n\t * Variable: SHADOWCOLOR\n\t *\n\t * Defines the color to be used to draw shadows in shapes and windows.\n\t * Default is gray.\n\t */\n\tSHADOWCOLOR: 'gray',\n\n\t/**\n\t * Variable: VML_SHADOWCOLOR\n\t *\n\t * Used for shadow color in filters where transparency is not supported\n\t * (Microsoft Internet Explorer). Default is gray.\n\t */\n\tVML_SHADOWCOLOR: 'gray',\n\n\t/**\n\t * Variable: SHADOW_OFFSET_X\n\t *\n\t * Specifies the x-offset of the shadow. Default is 2.\n\t */\n\tSHADOW_OFFSET_X: 2,\n\n\t/**\n\t * Variable: SHADOW_OFFSET_Y\n\t *\n\t * Specifies the y-offset of the shadow. Default is 3.\n\t */\n\tSHADOW_OFFSET_Y: 3,\n\n\t/**\n\t * Variable: SHADOW_OPACITY\n\t *\n\t * Defines the opacity for shadows. Default is 1.\n\t */\n\tSHADOW_OPACITY: 1,\n\n\t/**\n\t * Variable: NODETYPE_ELEMENT\n\t *\n\t * DOM node of type ELEMENT.\n\t */\n\tNODETYPE_ELEMENT: 1,\n\n\t/**\n\t * Variable: NODETYPE_ATTRIBUTE\n\t *\n\t * DOM node of type ATTRIBUTE.\n\t */\n\tNODETYPE_ATTRIBUTE: 2,\n\n\t/**\n\t * Variable: NODETYPE_TEXT\n\t *\n\t * DOM node of type TEXT.\n\t */\n\tNODETYPE_TEXT: 3,\n\n\t/**\n\t * Variable: NODETYPE_CDATA\n\t *\n\t * DOM node of type CDATA.\n\t */\n\tNODETYPE_CDATA: 4,\n\n\t/**\n\t * Variable: NODETYPE_ENTITY_REFERENCE\n\t *\n\t * DOM node of type ENTITY_REFERENCE.\n\t */\n\tNODETYPE_ENTITY_REFERENCE: 5,\n\n\t/**\n\t * Variable: NODETYPE_ENTITY\n\t *\n\t * DOM node of type ENTITY.\n\t */\n\tNODETYPE_ENTITY: 6,\n\n\t/**\n\t * Variable: NODETYPE_PROCESSING_INSTRUCTION\n\t *\n\t * DOM node of type PROCESSING_INSTRUCTION.\n\t */\n\tNODETYPE_PROCESSING_INSTRUCTION: 7,\n\n\t/**\n\t * Variable: NODETYPE_COMMENT\n\t *\n\t * DOM node of type COMMENT.\n\t */\n\tNODETYPE_COMMENT: 8,\n\n\t/**\n\t * Variable: NODETYPE_DOCUMENT\n\t *\n\t * DOM node of type DOCUMENT.\n\t */\n\tNODETYPE_DOCUMENT: 9,\n\n\t/**\n\t * Variable: NODETYPE_DOCUMENTTYPE\n\t *\n\t * DOM node of type DOCUMENTTYPE.\n\t */\n\tNODETYPE_DOCUMENTTYPE: 10,\n\n\t/**\n\t * Variable: NODETYPE_DOCUMENT_FRAGMENT\n\t *\n\t * DOM node of type DOCUMENT_FRAGMENT.\n\t */\n\tNODETYPE_DOCUMENT_FRAGMENT: 11,\n\n\t/**\n\t * Variable: NODETYPE_NOTATION\n\t *\n\t * DOM node of type NOTATION.\n\t */\n\tNODETYPE_NOTATION: 12,\n\n\t/**\n\t * Variable: TOOLTIP_VERTICAL_OFFSET\n\t *\n\t * Defines the vertical offset for the tooltip.\n\t * Default is 16.\n\t */\n\tTOOLTIP_VERTICAL_OFFSET: 16,\n\n\t/**\n\t * Variable: DEFAULT_VALID_COLOR\n\t *\n\t * Specifies the default valid color. Default is #0000FF.\n\t */\n\tDEFAULT_VALID_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: DEFAULT_INVALID_COLOR\n\t *\n\t * Specifies the default invalid color. Default is #FF0000.\n\t */\n\tDEFAULT_INVALID_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: OUTLINE_HIGHLIGHT_COLOR\n\t *\n\t * Specifies the default highlight color for shape outlines.\n\t * Default is #0000FF. This is used in <mxEdgeHandler>.\n\t */\n\tOUTLINE_HIGHLIGHT_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: OUTLINE_HIGHLIGHT_COLOR\n\t *\n\t * Defines the strokewidth to be used for shape outlines.\n\t * Default is 5. This is used in <mxEdgeHandler>.\n\t */\n\tOUTLINE_HIGHLIGHT_STROKEWIDTH: 5,\n\n\t/**\n\t * Variable: HIGHLIGHT_STROKEWIDTH\n\t *\n\t * Defines the strokewidth to be used for the highlights.\n\t * Default is 3.\n\t */\n\tHIGHLIGHT_STROKEWIDTH: 3,\n\n\t/**\n\t * Variable: CONSTRAINT_HIGHLIGHT_SIZE\n\t *\n\t * Size of the constraint highlight (in px). Default is 2.\n\t */\n\tHIGHLIGHT_SIZE: 2,\n\n\t/**\n\t * Variable: HIGHLIGHT_OPACITY\n\t *\n\t * Opacity (in %) used for the highlights (including outline).\n\t * Default is 100.\n\t */\n\tHIGHLIGHT_OPACITY: 100,\n\n\t/**\n\t * Variable: CURSOR_MOVABLE_VERTEX\n\t *\n\t * Defines the cursor for a movable vertex. Default is 'move'.\n\t */\n\tCURSOR_MOVABLE_VERTEX: 'move',\n\n\t/**\n\t * Variable: CURSOR_MOVABLE_EDGE\n\t *\n\t * Defines the cursor for a movable edge. Default is 'move'.\n\t */\n\tCURSOR_MOVABLE_EDGE: 'move',\n\n\t/**\n\t * Variable: CURSOR_LABEL_HANDLE\n\t *\n\t * Defines the cursor for a movable label. Default is 'default'.\n\t */\n\tCURSOR_LABEL_HANDLE: 'default',\n\n\t/**\n\t * Variable: CURSOR_TERMINAL_HANDLE\n\t *\n\t * Defines the cursor for a terminal handle. Default is 'pointer'.\n\t */\n\tCURSOR_TERMINAL_HANDLE: 'pointer',\n\n\t/**\n\t * Variable: CURSOR_BEND_HANDLE\n\t *\n\t * Defines the cursor for a movable bend. Default is 'crosshair'.\n\t */\n\tCURSOR_BEND_HANDLE: 'crosshair',\n\n\t/**\n\t * Variable: CURSOR_VIRTUAL_BEND_HANDLE\n\t *\n\t * Defines the cursor for a movable bend. Default is 'crosshair'.\n\t */\n\tCURSOR_VIRTUAL_BEND_HANDLE: 'crosshair',\n\n\t/**\n\t * Variable: CURSOR_CONNECT\n\t *\n\t * Defines the cursor for a connectable state. Default is 'pointer'.\n\t */\n\tCURSOR_CONNECT: 'pointer',\n\n\t/**\n\t * Variable: HIGHLIGHT_COLOR\n\t *\n\t * Defines the color to be used for the cell highlighting.\n\t * Use 'none' for no color. Default is #00FF00.\n\t */\n\tHIGHLIGHT_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: TARGET_HIGHLIGHT_COLOR\n\t *\n\t * Defines the color to be used for highlighting a target cell for a new\n\t * or changed connection. Note that this may be either a source or\n\t * target terminal in the graph. Use 'none' for no color.\n\t * Default is #0000FF.\n\t */\n\tCONNECT_TARGET_COLOR: '#0000FF',\n\n\t/**\n\t * Variable: INVALID_CONNECT_TARGET_COLOR\n\t *\n\t * Defines the color to be used for highlighting a invalid target cells\n\t * for a new or changed connections. Note that this may be either a source\n\t * or target terminal in the graph. Use 'none' for no color. Default is\n\t * #FF0000.\n\t */\n\tINVALID_CONNECT_TARGET_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: DROP_TARGET_COLOR\n\t *\n\t * Defines the color to be used for the highlighting target parent cells\n\t * (for drag and drop). Use 'none' for no color. Default is #0000FF.\n\t */\n\tDROP_TARGET_COLOR: '#0000FF',\n\n\t/**\n\t * Variable: VALID_COLOR\n\t *\n\t * Defines the color to be used for the coloring valid connection\n\t * previews. Use 'none' for no color. Default is #FF0000.\n\t */\n\tVALID_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: INVALID_COLOR\n\t *\n\t * Defines the color to be used for the coloring invalid connection\n\t * previews. Use 'none' for no color. Default is #FF0000.\n\t */\n\tINVALID_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: EDGE_SELECTION_COLOR\n\t *\n\t * Defines the color to be used for the selection border of edges. Use\n\t * 'none' for no color. Default is #00FF00.\n\t */\n\tEDGE_SELECTION_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: VERTEX_SELECTION_COLOR\n\t *\n\t * Defines the color to be used for the selection border of vertices. Use\n\t * 'none' for no color. Default is #00FF00.\n\t */\n\tVERTEX_SELECTION_COLOR: '#00FF00',\n\n\t/**\n\t * Variable: VERTEX_SELECTION_STROKEWIDTH\n\t *\n\t * Defines the strokewidth to be used for vertex selections.\n\t * Default is 1.\n\t */\n\tVERTEX_SELECTION_STROKEWIDTH: 1,\n\n\t/**\n\t * Variable: EDGE_SELECTION_STROKEWIDTH\n\t *\n\t * Defines the strokewidth to be used for edge selections.\n\t * Default is 1.\n\t */\n\tEDGE_SELECTION_STROKEWIDTH: 1,\n\n\t/**\n\t * Variable: SELECTION_DASHED\n\t *\n\t * Defines the dashed state to be used for the vertex selection\n\t * border. Default is true.\n\t */\n\tVERTEX_SELECTION_DASHED: true,\n\n\t/**\n\t * Variable: SELECTION_DASHED\n\t *\n\t * Defines the dashed state to be used for the edge selection\n\t * border. Default is true.\n\t */\n\tEDGE_SELECTION_DASHED: true,\n\n\t/**\n\t * Variable: GUIDE_COLOR\n\t *\n\t * Defines the color to be used for the guidelines in mxGraphHandler.\n\t * Default is #FF0000.\n\t */\n\tGUIDE_COLOR: '#FF0000',\n\n\t/**\n\t * Variable: GUIDE_STROKEWIDTH\n\t *\n\t * Defines the strokewidth to be used for the guidelines in mxGraphHandler.\n\t * Default is 1.\n\t */\n\tGUIDE_STROKEWIDTH: 1,\n\n\t/**\n\t * Variable: OUTLINE_COLOR\n\t *\n\t * Defines the color to be used for the outline rectangle\n\t * border.  Use 'none' for no color. Default is #0099FF.\n\t */\n\tOUTLINE_COLOR: '#0099FF',\n\n\t/**\n\t * Variable: OUTLINE_STROKEWIDTH\n\t *\n\t * Defines the strokewidth to be used for the outline rectangle\n\t * stroke width. Default is 3.\n\t */\n\tOUTLINE_STROKEWIDTH: (mxClient.IS_IE) ? 2 : 3,\n\n\t/**\n\t * Variable: HANDLE_SIZE\n\t *\n\t * Defines the default size for handles. Default is 6.\n\t */\n\tHANDLE_SIZE: 6,\n\n\t/**\n\t * Variable: LABEL_HANDLE_SIZE\n\t *\n\t * Defines the default size for label handles. Default is 4.\n\t */\n\tLABEL_HANDLE_SIZE: 4,\n\n\t/**\n\t * Variable: HANDLE_FILLCOLOR\n\t *\n\t * Defines the color to be used for the handle fill color. Use 'none' for\n\t * no color. Default is #00FF00 (green).\n\t */\n\tHANDLE_FILLCOLOR: '#00FF00',\n\n\t/**\n\t * Variable: HANDLE_STROKECOLOR\n\t *\n\t * Defines the color to be used for the handle stroke color. Use 'none' for\n\t * no color. Default is black.\n\t */\n\tHANDLE_STROKECOLOR: 'black',\n\n\t/**\n\t * Variable: LABEL_HANDLE_FILLCOLOR\n\t *\n\t * Defines the color to be used for the label handle fill color. Use 'none'\n\t * for no color. Default is yellow.\n\t */\n\tLABEL_HANDLE_FILLCOLOR: 'yellow',\n\n\t/**\n\t * Variable: CONNECT_HANDLE_FILLCOLOR\n\t *\n\t * Defines the color to be used for the connect handle fill color. Use\n\t * 'none' for no color. Default is #0000FF (blue).\n\t */\n\tCONNECT_HANDLE_FILLCOLOR: '#0000FF',\n\n\t/**\n\t * Variable: LOCKED_HANDLE_FILLCOLOR\n\t *\n\t * Defines the color to be used for the locked handle fill color. Use\n\t * 'none' for no color. Default is #FF0000 (red).\n\t */\n\tLOCKED_HANDLE_FILLCOLOR: '#FF0000',\n\n\t/**\n\t * Variable: OUTLINE_HANDLE_FILLCOLOR\n\t *\n\t * Defines the color to be used for the outline sizer fill color. Use\n\t * 'none' for no color. Default is #00FFFF.\n\t */\n\tOUTLINE_HANDLE_FILLCOLOR: '#00FFFF',\n\n\t/**\n\t * Variable: OUTLINE_HANDLE_STROKECOLOR\n\t *\n\t * Defines the color to be used for the outline sizer stroke color. Use\n\t * 'none' for no color. Default is #0033FF.\n\t */\n\tOUTLINE_HANDLE_STROKECOLOR: '#0033FF',\n\n\t/**\n\t * Variable: DEFAULT_FONTFAMILY\n\t *\n\t * Defines the default family for all fonts. Default is Arial,Helvetica.\n\t */\n\tDEFAULT_FONTFAMILY: 'Arial,Helvetica',\n\n\t/**\n\t * Variable: DEFAULT_FONTSIZE\n\t *\n\t * Defines the default size (in px). Default is 11.\n\t */\n\tDEFAULT_FONTSIZE: 11,\n\n\t/**\n\t * Variable: DEFAULT_TEXT_DIRECTION\n\t *\n\t * Defines the default value for the <STYLE_TEXT_DIRECTION> if no value is\n\t * defined for it in the style. Default value is an empty string which means\n\t * the default system setting is used and no direction is set.\n\t */\n\tDEFAULT_TEXT_DIRECTION: '',\n\n\t/**\n\t * Variable: LINE_HEIGHT\n\t *\n\t * Defines the default line height for text labels. Default is 1.2.\n\t */\n\tLINE_HEIGHT: 1.2,\n\n\t/**\n\t * Variable: WORD_WRAP\n\t *\n\t * Defines the CSS value for the word-wrap property. Default is \"normal\".\n\t * Change this to \"break-word\" to allow long words to be able to be broken\n\t * and wrap onto the next line.\n\t */\n\tWORD_WRAP: 'normal',\n\n\t/**\n\t * Variable: ABSOLUTE_LINE_HEIGHT\n\t *\n\t * Specifies if absolute line heights should be used (px) in CSS. Default\n\t * is false. Set this to true for backwards compatibility.\n\t */\n\tABSOLUTE_LINE_HEIGHT: false,\n\n\t/**\n\t * Variable: DEFAULT_FONTSTYLE\n\t *\n\t * Defines the default style for all fonts. Default is 0. This can be set\n\t * to any combination of font styles as follows.\n\t *\n\t * (code)\n\t * mxConstants.DEFAULT_FONTSTYLE = mxConstants.FONT_BOLD | mxConstants.FONT_ITALIC;\n\t * (end)\n\t */\n\tDEFAULT_FONTSTYLE: 0,\n\n\t/**\n\t * Variable: DEFAULT_STARTSIZE\n\t *\n\t * Defines the default start size for swimlanes. Default is 40.\n\t */\n\tDEFAULT_STARTSIZE: 40,\n\n\t/**\n\t * Variable: DEFAULT_MARKERSIZE\n\t *\n\t * Defines the default size for all markers. Default is 6.\n\t */\n\tDEFAULT_MARKERSIZE: 6,\n\n\t/**\n\t * Variable: DEFAULT_IMAGESIZE\n\t *\n\t * Defines the default width and height for images used in the\n\t * label shape. Default is 24.\n\t */\n\tDEFAULT_IMAGESIZE: 24,\n\n\t/**\n\t * Variable: ENTITY_SEGMENT\n\t *\n\t * Defines the length of the horizontal segment of an Entity Relation.\n\t * This can be overridden using <mxConstants.STYLE_SEGMENT> style.\n\t * Default is 30.\n\t */\n\tENTITY_SEGMENT: 30,\n\n\t/**\n\t * Variable: RECTANGLE_ROUNDING_FACTOR\n\t *\n\t * Defines the rounding factor for rounded rectangles in percent between\n\t * 0 and 1. Values should be smaller than 0.5. Default is 0.15.\n\t */\n\tRECTANGLE_ROUNDING_FACTOR: 0.15,\n\n\t/**\n\t * Variable: LINE_ARCSIZE\n\t *\n\t * Defines the size of the arcs for rounded edges. Default is 20.\n\t */\n\tLINE_ARCSIZE: 20,\n\n\t/**\n\t * Variable: ARROW_SPACING\n\t *\n\t * Defines the spacing between the arrow shape and its terminals. Default is 0.\n\t */\n\tARROW_SPACING: 0,\n\n\t/**\n\t * Variable: ARROW_WIDTH\n\t *\n\t * Defines the width of the arrow shape. Default is 30.\n\t */\n\tARROW_WIDTH: 30,\n\n\t/**\n\t * Variable: ARROW_SIZE\n\t *\n\t * Defines the size of the arrowhead in the arrow shape. Default is 30.\n\t */\n\tARROW_SIZE: 30,\n\n\t/**\n\t * Variable: PAGE_FORMAT_A4_PORTRAIT\n\t *\n\t * Defines the rectangle for the A4 portrait page format. The dimensions\n\t * of this page format are 826x1169 pixels.\n\t */\n\tPAGE_FORMAT_A4_PORTRAIT: new mxRectangle(0, 0, 827, 1169),\n\n\t/**\n\t * Variable: PAGE_FORMAT_A4_PORTRAIT\n\t *\n\t * Defines the rectangle for the A4 portrait page format. The dimensions\n\t * of this page format are 826x1169 pixels.\n\t */\n\tPAGE_FORMAT_A4_LANDSCAPE: new mxRectangle(0, 0, 1169, 827),\n\n\t/**\n\t * Variable: PAGE_FORMAT_LETTER_PORTRAIT\n\t *\n\t * Defines the rectangle for the Letter portrait page format. The\n\t * dimensions of this page format are 850x1100 pixels.\n\t */\n\tPAGE_FORMAT_LETTER_PORTRAIT: new mxRectangle(0, 0, 850, 1100),\n\n\t/**\n\t * Variable: PAGE_FORMAT_LETTER_PORTRAIT\n\t *\n\t * Defines the rectangle for the Letter portrait page format. The dimensions\n\t * of this page format are 850x1100 pixels.\n\t */\n\tPAGE_FORMAT_LETTER_LANDSCAPE: new mxRectangle(0, 0, 1100, 850),\n\n\t/**\n\t * Variable: NONE\n\t *\n\t * Defines the value for none. Default is \"none\".\n\t */\n\tNONE: 'none',\n\n\t/**\n\t * Variable: STYLE_PERIMETER\n\t *\n\t * Defines the key for the perimeter style. This is a function that defines\n\t * the perimeter around a particular shape. Possible values are the\n\t * functions defined in <mxPerimeter>. Alternatively, the constants in this\n\t * class that start with \"PERIMETER_\" may be used to access\n\t * perimeter styles in <mxStyleRegistry>. Value is \"perimeter\".\n\t */\n\tSTYLE_PERIMETER: 'perimeter',\n\n\t/**\n\t * Variable: STYLE_SOURCE_PORT\n\t *\n\t * Defines the ID of the cell that should be used for computing the\n\t * perimeter point of the source for an edge. This allows for graphically\n\t * connecting to a cell while keeping the actual terminal of the edge.\n\t * Value is \"sourcePort\".\n\t */\n\tSTYLE_SOURCE_PORT: 'sourcePort',\n\n\t/**\n\t * Variable: STYLE_TARGET_PORT\n\t *\n\t * Defines the ID of the cell that should be used for computing the\n\t * perimeter point of the target for an edge. This allows for graphically\n\t * connecting to a cell while keeping the actual terminal of the edge.\n\t * Value is \"targetPort\".\n\t */\n\tSTYLE_TARGET_PORT: 'targetPort',\n\n\t/**\n\t * Variable: STYLE_PORT_CONSTRAINT\n\t *\n\t * Defines the direction(s) that edges are allowed to connect to cells in.\n\t * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH,\n\t * DIRECTION_EAST\" and \"DIRECTION_WEST\". Value is\n\t * \"portConstraint\".\n\t */\n\tSTYLE_PORT_CONSTRAINT: 'portConstraint',\n\n\t/**\n\t * Variable: STYLE_PORT_CONSTRAINT_ROTATION\n\t *\n\t * Define whether port constraint directions are rotated with vertex\n\t * rotation. 0 (default) causes port constraints to remain absolute,\n\t * relative to the graph, 1 causes the constraints to rotate with\n\t * the vertex. Value is \"portConstraintRotation\".\n\t */\n\tSTYLE_PORT_CONSTRAINT_ROTATION: 'portConstraintRotation',\n\n\t/**\n\t * Variable: STYLE_SOURCE_PORT_CONSTRAINT\n\t *\n\t * Defines the direction(s) that edges are allowed to connect to sources in.\n\t * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST\"\n\t * and \"DIRECTION_WEST\". Value is \"sourcePortConstraint\".\n\t */\n\tSTYLE_SOURCE_PORT_CONSTRAINT: 'sourcePortConstraint',\n\n\t/**\n\t * Variable: STYLE_TARGET_PORT_CONSTRAINT\n\t *\n\t * Defines the direction(s) that edges are allowed to connect to targets in.\n\t * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH, DIRECTION_EAST\"\n\t * and \"DIRECTION_WEST\". Value is \"targetPortConstraint\".\n\t */\n\tSTYLE_TARGET_PORT_CONSTRAINT: 'targetPortConstraint',\n\n\t/**\n\t * Variable: STYLE_OPACITY\n\t *\n\t * Defines the key for the opacity style. The type of the value is\n\t * numeric and the possible range is 0-100. Value is \"opacity\".\n\t */\n\tSTYLE_OPACITY: 'opacity',\n\n\t/**\n\t * Variable: STYLE_FILL_OPACITY\n\t *\n\t * Defines the key for the fill opacity style. The type of the value is\n\t * numeric and the possible range is 0-100. Value is \"fillOpacity\".\n\t */\n\tSTYLE_FILL_OPACITY: 'fillOpacity',\n\n\t/**\n\t * Variable: STYLE_STROKE_OPACITY\n\t *\n\t * Defines the key for the stroke opacity style. The type of the value is\n\t * numeric and the possible range is 0-100. Value is \"strokeOpacity\".\n\t */\n\tSTYLE_STROKE_OPACITY: 'strokeOpacity',\n\n\t/**\n\t * Variable: STYLE_TEXT_OPACITY\n\t *\n\t * Defines the key for the text opacity style. The type of the value is\n\t * numeric and the possible range is 0-100. Value is \"textOpacity\".\n\t */\n\tSTYLE_TEXT_OPACITY: 'textOpacity',\n\n\t/**\n\t * Variable: STYLE_TEXT_DIRECTION\n\t *\n\t * Defines the key for the text direction style. Possible values are\n\t * \"TEXT_DIRECTION_DEFAULT, TEXT_DIRECTION_AUTO, TEXT_DIRECTION_LTR\"\n\t * and \"TEXT_DIRECTION_RTL\". Value is \"textDirection\".\n\t * The default value for the style is defined in <DEFAULT_TEXT_DIRECTION>.\n\t * It is used is no value is defined for this key in a given style. This is\n\t * an experimental style that is currently ignored in the backends.\n\t */\n\tSTYLE_TEXT_DIRECTION: 'textDirection',\n\n\t/**\n\t * Variable: STYLE_OVERFLOW\n\t *\n\t * Defines the key for the overflow style. Possible values are 'visible',\n\t * 'hidden', 'fill' and 'width'. The default value is 'visible'. This value\n\t * specifies how overlapping vertex labels are handled. A value of\n\t * 'visible' will show the complete label. A value of 'hidden' will clip\n\t * the label so that it does not overlap the vertex bounds. A value of\n\t * 'fill' will use the vertex bounds and a value of 'width' will use the\n\t * the vertex width for the label. See <mxGraph.isLabelClipped>. Note that\n\t * the vertical alignment is ignored for overflow fill and for horizontal\n\t * alignment, left should be used to avoid pixel offsets in Internet Explorer\n\t * 11 and earlier or if foreignObjects are disabled. Value is \"overflow\".\n\t */\n\tSTYLE_OVERFLOW: 'overflow',\n\n\t/**\n\t * Variable: STYLE_ORTHOGONAL\n\t *\n\t * Defines if the connection points on either end of the edge should be\n\t * computed so that the edge is vertical or horizontal if possible and\n\t * if the point is not at a fixed location. Default is false. This is\n\t * used in <mxGraph.isOrthogonal>, which also returns true if the edgeStyle\n\t * of the edge is an elbow or entity. Value is \"orthogonal\".\n\t */\n\tSTYLE_ORTHOGONAL: 'orthogonal',\n\n\t/**\n\t * Variable: STYLE_EXIT_X\n\t *\n\t * Defines the key for the horizontal relative coordinate connection point\n\t * of an edge with its source terminal. Value is \"exitX\".\n\t */\n\tSTYLE_EXIT_X: 'exitX',\n\n\t/**\n\t * Variable: STYLE_EXIT_Y\n\t *\n\t * Defines the key for the vertical relative coordinate connection point\n\t * of an edge with its source terminal. Value is \"exitY\".\n\t */\n\tSTYLE_EXIT_Y: 'exitY',\n\n\n\t/**\n\t* Variable: STYLE_EXIT_DX\n\t*\n\t* Defines the key for the horizontal offset of the connection point\n\t* of an edge with its source terminal. Value is \"exitDx\".\n\t*/\n\tSTYLE_EXIT_DX: 'exitDx',\n\n\t/**\n\t* Variable: STYLE_EXIT_DY\n\t*\n\t* Defines the key for the vertical offset of the connection point\n\t* of an edge with its source terminal. Value is \"exitDy\".\n\t*/\n\tSTYLE_EXIT_DY: 'exitDy',\n\n\t/**\n\t * Variable: STYLE_EXIT_PERIMETER\n\t *\n\t * Defines if the perimeter should be used to find the exact entry point\n\t * along the perimeter of the source. Possible values are 0 (false) and\n\t * 1 (true). Default is 1 (true). Value is \"exitPerimeter\".\n\t */\n\tSTYLE_EXIT_PERIMETER: 'exitPerimeter',\n\n\t/**\n\t * Variable: STYLE_ENTRY_X\n\t *\n\t * Defines the key for the horizontal relative coordinate connection point\n\t * of an edge with its target terminal. Value is \"entryX\".\n\t */\n\tSTYLE_ENTRY_X: 'entryX',\n\n\t/**\n\t * Variable: STYLE_ENTRY_Y\n\t *\n\t * Defines the key for the vertical relative coordinate connection point\n\t * of an edge with its target terminal. Value is \"entryY\".\n\t */\n\tSTYLE_ENTRY_Y: 'entryY',\n\n\t/**\n\t * Variable: STYLE_ENTRY_DX\n\t *\n\t* Defines the key for the horizontal offset of the connection point\n\t* of an edge with its target terminal. Value is \"entryDx\".\n\t*/\n\tSTYLE_ENTRY_DX: 'entryDx',\n\n\t/**\n\t * Variable: STYLE_ENTRY_DY\n\t *\n\t* Defines the key for the vertical offset of the connection point\n\t* of an edge with its target terminal. Value is \"entryDy\".\n\t*/\n\tSTYLE_ENTRY_DY: 'entryDy',\n\n\t/**\n\t * Variable: STYLE_ENTRY_PERIMETER\n\t *\n\t * Defines if the perimeter should be used to find the exact entry point\n\t * along the perimeter of the target. Possible values are 0 (false) and\n\t * 1 (true). Default is 1 (true). Value is \"entryPerimeter\".\n\t */\n\tSTYLE_ENTRY_PERIMETER: 'entryPerimeter',\n\n\t/**\n\t * Variable: STYLE_WHITE_SPACE\n\t *\n\t * Defines the key for the white-space style. Possible values are 'nowrap'\n\t * and 'wrap'. The default value is 'nowrap'. This value specifies how\n\t * white-space inside a HTML vertex label should be handled. A value of\n\t * 'nowrap' means the text will never wrap to the next line until a\n\t * linefeed is encountered. A value of 'wrap' means text will wrap when\n\t * necessary. This style is only used for HTML labels.\n\t * See <mxGraph.isWrapping>. Value is \"whiteSpace\".\n\t */\n\tSTYLE_WHITE_SPACE: 'whiteSpace',\n\n\t/**\n\t * Variable: STYLE_ROTATION\n\t *\n\t * Defines the key for the rotation style. The type of the value is\n\t * numeric and the possible range is 0-360. Value is \"rotation\".\n\t */\n\tSTYLE_ROTATION: 'rotation',\n\n\t/**\n\t * Variable: STYLE_FILLCOLOR\n\t *\n\t * Defines the key for the fill color. Possible values are all HTML color\n\t * names or HEX codes, as well as special keywords such as 'swimlane,\n\t * 'inherit' or 'indicated' to use the color code of a related cell or the\n\t * indicator shape. Value is \"fillColor\".\n\t */\n\tSTYLE_FILLCOLOR: 'fillColor',\n\n\t/**\n\t * Variable: STYLE_POINTER_EVENTS\n\t *\n\t * Specifies if pointer events should be fired on transparent backgrounds.\n\t * This style is currently only supported in <mxRectangleShape>. Default\n\t * is true. Value is \"pointerEvents\". This is typically set to\n\t * false in groups where the transparent part should allow any underlying\n\t * cells to be clickable.\n\t */\n\tSTYLE_POINTER_EVENTS: 'pointerEvents',\n\n\t/**\n\t * Variable: STYLE_SWIMLANE_FILLCOLOR\n\t *\n\t * Defines the key for the fill color of the swimlane background. Possible\n\t * values are all HTML color names or HEX codes. Default is no background.\n\t * Value is \"swimlaneFillColor\".\n\t */\n\tSTYLE_SWIMLANE_FILLCOLOR: 'swimlaneFillColor',\n\n\t/**\n\t * Variable: STYLE_MARGIN\n\t *\n\t * Defines the key for the margin between the ellipses in the double ellipse shape.\n\t * Possible values are all positive numbers. Value is \"margin\".\n\t */\n\tSTYLE_MARGIN: 'margin',\n\n\t/**\n\t * Variable: STYLE_GRADIENTCOLOR\n\t *\n\t * Defines the key for the gradient color. Possible values are all HTML color\n\t * names or HEX codes, as well as special keywords such as 'swimlane,\n\t * 'inherit' or 'indicated' to use the color code of a related cell or the\n\t * indicator shape. This is ignored if no fill color is defined. Value is\n\t * \"gradientColor\".\n\t */\n\tSTYLE_GRADIENTCOLOR: 'gradientColor',\n\n\t/**\n\t * Variable: STYLE_GRADIENT_DIRECTION\n\t *\n\t * Defines the key for the gradient direction. Possible values are\n\t * <DIRECTION_EAST>, <DIRECTION_WEST>, <DIRECTION_NORTH> and\n\t * <DIRECTION_SOUTH>. Default is <DIRECTION_SOUTH>. Generally, and by\n\t * default in mxGraph, gradient painting is done from the value of\n\t * <STYLE_FILLCOLOR> to the value of <STYLE_GRADIENTCOLOR>. Taking the\n\t * example of <DIRECTION_NORTH>, this means <STYLE_FILLCOLOR> color at the\n\t * bottom of paint pattern and <STYLE_GRADIENTCOLOR> at top, with a\n\t * gradient in-between. Value is \"gradientDirection\".\n\t */\n\tSTYLE_GRADIENT_DIRECTION: 'gradientDirection',\n\n\t/**\n\t * Variable: STYLE_STROKECOLOR\n\t *\n\t * Defines the key for the strokeColor style. Possible values are all HTML\n\t * color names or HEX codes, as well as special keywords such as 'swimlane,\n\t * 'inherit', 'indicated' to use the color code of a related cell or the\n\t * indicator shape or 'none' for no color. Value is \"strokeColor\".\n\t */\n\tSTYLE_STROKECOLOR: 'strokeColor',\n\n\t/**\n\t * Variable: STYLE_SEPARATORCOLOR\n\t *\n\t * Defines the key for the separatorColor style. Possible values are all\n\t * HTML color names or HEX codes. This style is only used for\n\t * <SHAPE_SWIMLANE> shapes. Value is \"separatorColor\".\n\t */\n\tSTYLE_SEPARATORCOLOR: 'separatorColor',\n\n\t/**\n\t * Variable: STYLE_STROKEWIDTH\n\t *\n\t * Defines the key for the strokeWidth style. The type of the value is\n\t * numeric and the possible range is any non-negative value larger or equal\n\t * to 1. The value defines the stroke width in pixels. Note: To hide a\n\t * stroke use strokeColor none. Value is \"strokeWidth\".\n\t */\n\tSTYLE_STROKEWIDTH: 'strokeWidth',\n\n\t/**\n\t * Variable: STYLE_ALIGN\n\t *\n\t * Defines the key for the align style. Possible values are <ALIGN_LEFT>,\n\t * <ALIGN_CENTER> and <ALIGN_RIGHT>. This value defines how the lines of\n\t * the label are horizontally aligned. <ALIGN_LEFT> mean label text lines\n\t * are aligned to left of the label bounds, <ALIGN_RIGHT> to the right of\n\t * the label bounds and <ALIGN_CENTER> means the center of the text lines\n\t * are aligned in the center of the label bounds. Note this value doesn't\n\t * affect the positioning of the overall label bounds relative to the\n\t * vertex, to move the label bounds horizontally, use\n\t * <STYLE_LABEL_POSITION>. Value is \"align\".\n\t */\n\tSTYLE_ALIGN: 'align',\n\n\t/**\n\t * Variable: STYLE_VERTICAL_ALIGN\n\t *\n\t * Defines the key for the verticalAlign style. Possible values are\n\t * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. This value defines how\n\t * the lines of the label are vertically aligned. <ALIGN_TOP> means the\n\t * topmost label text line is aligned against the top of the label bounds,\n\t * <ALIGN_BOTTOM> means the bottom-most label text line is aligned against\n\t * the bottom of the label bounds and <ALIGN_MIDDLE> means there is equal\n\t * spacing between the topmost text label line and the top of the label\n\t * bounds and the bottom-most text label line and the bottom of the label\n\t * bounds. Note this value doesn't affect the positioning of the overall\n\t * label bounds relative to the vertex, to move the label bounds\n\t * vertically, use <STYLE_VERTICAL_LABEL_POSITION>. Value is \"verticalAlign\".\n\t */\n\tSTYLE_VERTICAL_ALIGN: 'verticalAlign',\n\n\t/**\n\t * Variable: STYLE_LABEL_WIDTH\n\t *\n\t * Defines the key for the width of the label if the label position is not\n\t * center. Value is \"labelWidth\".\n\t */\n\tSTYLE_LABEL_WIDTH: 'labelWidth',\n\n\t/**\n\t * Variable: STYLE_LABEL_POSITION\n\t *\n\t * Defines the key for the horizontal label position of vertices. Possible\n\t * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>. Default is\n\t * <ALIGN_CENTER>. The label align defines the position of the label\n\t * relative to the cell. <ALIGN_LEFT> means the entire label bounds is\n\t * placed completely just to the left of the vertex, <ALIGN_RIGHT> means\n\t * adjust to the right and <ALIGN_CENTER> means the label bounds are\n\t * vertically aligned with the bounds of the vertex. Note this value\n\t * doesn't affect the positioning of label within the label bounds, to move\n\t * the label horizontally within the label bounds, use <STYLE_ALIGN>.\n\t * Value is \"labelPosition\".\n\t */\n\tSTYLE_LABEL_POSITION: 'labelPosition',\n\n\t/**\n\t * Variable: STYLE_VERTICAL_LABEL_POSITION\n\t *\n\t * Defines the key for the vertical label position of vertices. Possible\n\t * values are <ALIGN_TOP>, <ALIGN_BOTTOM> and <ALIGN_MIDDLE>. Default is\n\t * <ALIGN_MIDDLE>. The label align defines the position of the label\n\t * relative to the cell. <ALIGN_TOP> means the entire label bounds is\n\t * placed completely just on the top of the vertex, <ALIGN_BOTTOM> means\n\t * adjust on the bottom and <ALIGN_MIDDLE> means the label bounds are\n\t * horizontally aligned with the bounds of the vertex. Note this value\n\t * doesn't affect the positioning of label within the label bounds, to move\n\t * the label vertically within the label bounds, use\n\t * <STYLE_VERTICAL_ALIGN>. Value is \"verticalLabelPosition\".\n\t */\n\tSTYLE_VERTICAL_LABEL_POSITION: 'verticalLabelPosition',\n\n\t/**\n\t * Variable: STYLE_IMAGE_ASPECT\n\t *\n\t * Defines the key for the image aspect style. Possible values are 0 (do\n\t * not preserve aspect) or 1 (keep aspect). This is only used in\n\t * <mxImageShape>. Default is 1. Value is \"imageAspect\".\n\t */\n\tSTYLE_IMAGE_ASPECT: 'imageAspect',\n\n\t/**\n\t * Variable: STYLE_IMAGE_ALIGN\n\t *\n\t * Defines the key for the align style. Possible values are <ALIGN_LEFT>,\n\t * <ALIGN_CENTER> and <ALIGN_RIGHT>. The value defines how any image in the\n\t * vertex label is aligned horizontally within the label bounds of a\n\t * <SHAPE_LABEL> shape. Value is \"imageAlign\".\n\t */\n\tSTYLE_IMAGE_ALIGN: 'imageAlign',\n\n\t/**\n\t * Variable: STYLE_IMAGE_VERTICAL_ALIGN\n\t *\n\t * Defines the key for the verticalAlign style. Possible values are\n\t * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. The value defines how\n\t * any image in the vertex label is aligned vertically within the label\n\t * bounds of a <SHAPE_LABEL> shape. Value is \"imageVerticalAlign\".\n\t */\n\tSTYLE_IMAGE_VERTICAL_ALIGN: 'imageVerticalAlign',\n\n\t/**\n\t * Variable: STYLE_GLASS\n\t *\n\t * Defines the key for the glass style. Possible values are 0 (disabled) and\n\t * 1(enabled). The default value is 0. This is used in <mxLabel>. Value is\n\t * \"glass\".\n\t */\n\tSTYLE_GLASS: 'glass',\n\n\t/**\n\t * Variable: STYLE_IMAGE\n\t *\n\t * Defines the key for the image style. Possible values are any image URL,\n\t * the type of the value is String. This is the path to the image that is\n\t * to be displayed within the label of a vertex. Data URLs should use the\n\t * following format: data:image/png,xyz where xyz is the base64 encoded\n\t * data (without the \"base64\"-prefix). Note that Data URLs are only\n\t * supported in modern browsers. Value is \"image\".\n\t */\n\tSTYLE_IMAGE: 'image',\n\n\t/**\n\t * Variable: STYLE_IMAGE_WIDTH\n\t *\n\t * Defines the key for the imageWidth style. The type of this value is\n\t * int, the value is the image width in pixels and must be greater than 0.\n\t * Value is \"imageWidth\".\n\t */\n\tSTYLE_IMAGE_WIDTH: 'imageWidth',\n\n\t/**\n\t * Variable: STYLE_IMAGE_HEIGHT\n\t *\n\t * Defines the key for the imageHeight style. The type of this value is\n\t * int, the value is the image height in pixels and must be greater than 0.\n\t * Value is \"imageHeight\".\n\t */\n\tSTYLE_IMAGE_HEIGHT: 'imageHeight',\n\n\t/**\n\t * Variable: STYLE_IMAGE_BACKGROUND\n\t *\n\t * Defines the key for the image background color. This style is only used\n\t * in <mxImageShape>. Possible values are all HTML color names or HEX\n\t * codes. Value is \"imageBackground\".\n\t */\n\tSTYLE_IMAGE_BACKGROUND: 'imageBackground',\n\n\t/**\n\t * Variable: STYLE_IMAGE_BORDER\n\t *\n\t * Defines the key for the image border color. This style is only used in\n\t * <mxImageShape>. Possible values are all HTML color names or HEX codes.\n\t * Value is \"imageBorder\".\n\t */\n\tSTYLE_IMAGE_BORDER: 'imageBorder',\n\n\t/**\n\t * Variable: STYLE_FLIPH\n\t *\n\t * Defines the key for the horizontal image flip. This style is only used\n\t * in <mxImageShape>. Possible values are 0 and 1. Default is 0. Value is\n\t * \"flipH\".\n\t */\n\tSTYLE_FLIPH: 'flipH',\n\n\t/**\n\t * Variable: STYLE_FLIPV\n\t *\n\t * Defines the key for the vertical flip. Possible values are 0 and 1.\n\t * Default is 0. Value is \"flipV\".\n\t */\n\tSTYLE_FLIPV: 'flipV',\n\n\t/**\n\t * Variable: STYLE_NOLABEL\n\t *\n\t * Defines the key for the noLabel style. If this is true then no label is\n\t * visible for a given cell. Possible values are true or false (1 or 0).\n\t * Default is false. Value is \"noLabel\".\n\t */\n\tSTYLE_NOLABEL: 'noLabel',\n\n\t/**\n\t * Variable: STYLE_NOEDGESTYLE\n\t *\n\t * Defines the key for the noEdgeStyle style. If this is true then no edge\n\t * style is applied for a given edge. Possible values are true or false\n\t * (1 or 0). Default is false. Value is \"noEdgeStyle\".\n\t */\n\tSTYLE_NOEDGESTYLE: 'noEdgeStyle',\n\n\t/**\n\t * Variable: STYLE_LABEL_BACKGROUNDCOLOR\n\t *\n\t * Defines the key for the label background color. Possible values are all\n\t * HTML color names or HEX codes. Value is \"labelBackgroundColor\".\n\t */\n\tSTYLE_LABEL_BACKGROUNDCOLOR: 'labelBackgroundColor',\n\n\t/**\n\t * Variable: STYLE_LABEL_BORDERCOLOR\n\t *\n\t * Defines the key for the label border color. Possible values are all\n\t * HTML color names or HEX codes. Value is \"labelBorderColor\".\n\t */\n\tSTYLE_LABEL_BORDERCOLOR: 'labelBorderColor',\n\n\t/**\n\t * Variable: STYLE_LABEL_PADDING\n\t *\n\t * Defines the key for the label padding, ie. the space between the label\n\t * border and the label. Value is \"labelPadding\".\n\t */\n\tSTYLE_LABEL_PADDING: 'labelPadding',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_SHAPE\n\t *\n\t * Defines the key for the indicator shape used within an <mxLabel>.\n\t * Possible values are all SHAPE_* constants or the names of any new\n\t * shapes. The indicatorShape has precedence over the indicatorImage.\n\t * Value is \"indicatorShape\".\n\t */\n\tSTYLE_INDICATOR_SHAPE: 'indicatorShape',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_IMAGE\n\t *\n\t * Defines the key for the indicator image used within an <mxLabel>.\n\t * Possible values are all image URLs. The indicatorShape has\n\t * precedence over the indicatorImage. Value is \"indicatorImage\".\n\t */\n\tSTYLE_INDICATOR_IMAGE: 'indicatorImage',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_COLOR\n\t *\n\t * Defines the key for the indicatorColor style. Possible values are all\n\t * HTML color names or HEX codes, as well as the special 'swimlane' keyword\n\t * to refer to the color of the parent swimlane if one exists. Value is\n\t * \"indicatorColor\".\n\t */\n\tSTYLE_INDICATOR_COLOR: 'indicatorColor',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_STROKECOLOR\n\t *\n\t * Defines the key for the indicator stroke color in <mxLabel>.\n\t * Possible values are all color codes. Value is \"indicatorStrokeColor\".\n\t */\n\tSTYLE_INDICATOR_STROKECOLOR: 'indicatorStrokeColor',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_GRADIENTCOLOR\n\t *\n\t * Defines the key for the indicatorGradientColor style. Possible values\n\t * are all HTML color names or HEX codes. This style is only supported in\n\t * <SHAPE_LABEL> shapes. Value is \"indicatorGradientColor\".\n\t */\n\tSTYLE_INDICATOR_GRADIENTCOLOR: 'indicatorGradientColor',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_SPACING\n\t *\n\t * The defines the key for the spacing between the label and the\n\t * indicator in <mxLabel>. Possible values are in pixels. Value is\n\t * \"indicatorSpacing\".\n\t */\n\tSTYLE_INDICATOR_SPACING: 'indicatorSpacing',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_WIDTH\n\t *\n\t * Defines the key for the indicator width. Possible values start at 0 (in\n\t * pixels). Value is \"indicatorWidth\".\n\t */\n\tSTYLE_INDICATOR_WIDTH: 'indicatorWidth',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_HEIGHT\n\t *\n\t * Defines the key for the indicator height. Possible values start at 0 (in\n\t * pixels). Value is \"indicatorHeight\".\n\t */\n\tSTYLE_INDICATOR_HEIGHT: 'indicatorHeight',\n\n\t/**\n\t * Variable: STYLE_INDICATOR_DIRECTION\n\t *\n\t * Defines the key for the indicatorDirection style. The direction style is\n\t * used to specify the direction of certain shapes (eg. <mxTriangle>).\n\t * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,\n\t * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"indicatorDirection\".\n\t */\n\tSTYLE_INDICATOR_DIRECTION: 'indicatorDirection',\n\n\t/**\n\t * Variable: STYLE_SHADOW\n\t *\n\t * Defines the key for the shadow style. The type of the value is Boolean.\n\t * Value is \"shadow\".\n\t */\n\tSTYLE_SHADOW: 'shadow',\n\n\t/**\n\t * Variable: STYLE_SEGMENT\n\t *\n\t * Defines the key for the segment style. The type of this value is float\n\t * and the value represents the size of the horizontal segment of the\n\t * entity relation style. Default is ENTITY_SEGMENT. Value is \"segment\".\n\t */\n\tSTYLE_SEGMENT: 'segment',\n\n\t/**\n\t * Variable: STYLE_ENDARROW\n\t *\n\t * Defines the key for the end arrow marker. Possible values are all\n\t * constants with an ARROW-prefix. This is only used in <mxConnector>.\n\t * Value is \"endArrow\".\n\t *\n\t * Example:\n\t * (code)\n\t * style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;\n\t * (end)\n\t */\n\tSTYLE_ENDARROW: 'endArrow',\n\n\t/**\n\t * Variable: STYLE_STARTARROW\n\t *\n\t * Defines the key for the start arrow marker. Possible values are all\n\t * constants with an ARROW-prefix. This is only used in <mxConnector>.\n\t * See <STYLE_ENDARROW>. Value is \"startArrow\".\n\t */\n\tSTYLE_STARTARROW: 'startArrow',\n\n\t/**\n\t * Variable: STYLE_ENDSIZE\n\t *\n\t * Defines the key for the endSize style. The type of this value is numeric\n\t * and the value represents the size of the end marker in pixels. Value is\n\t * \"endSize\".\n\t */\n\tSTYLE_ENDSIZE: 'endSize',\n\n\t/**\n\t * Variable: STYLE_STARTSIZE\n\t *\n\t * Defines the key for the startSize style. The type of this value is\n\t * numeric and the value represents the size of the start marker or the\n\t * size of the swimlane title region depending on the shape it is used for.\n\t * Value is \"startSize\".\n\t */\n\tSTYLE_STARTSIZE: 'startSize',\n\n\t/**\n\t * Variable: STYLE_SWIMLANE_LINE\n\t *\n\t * Defines the key for the swimlaneLine style. This style specifies whether\n\t * the line between the title regio of a swimlane should be visible. Use 0\n\t * for hidden or 1 (default) for visible. Value is \"swimlaneLine\".\n\t */\n\tSTYLE_SWIMLANE_LINE: 'swimlaneLine',\n\n\t/**\n\t * Variable: STYLE_ENDFILL\n\t *\n\t * Defines the key for the endFill style. Use 0 for no fill or 1 (default)\n\t * for fill. (This style is only exported via <mxImageExport>.) Value is\n\t * \"endFill\".\n\t */\n\tSTYLE_ENDFILL: 'endFill',\n\n\t/**\n\t * Variable: STYLE_STARTFILL\n\t *\n\t * Defines the key for the startFill style. Use 0 for no fill or 1 (default)\n\t * for fill. (This style is only exported via <mxImageExport>.) Value is\n\t * \"startFill\".\n\t */\n\tSTYLE_STARTFILL: 'startFill',\n\n\t/**\n\t * Variable: STYLE_DASHED\n\t *\n\t * Defines the key for the dashed style. Use 0 (default) for non-dashed or 1\n\t * for dashed. Value is \"dashed\".\n\t */\n\tSTYLE_DASHED: 'dashed',\n\n\t/**\n\t * Defines the key for the dashed pattern style in SVG and image exports.\n\t * The type of this value is a space separated list of numbers that specify\n\t * a custom-defined dash pattern. Dash styles are defined in terms of the\n\t * length of the dash (the drawn part of the stroke) and the length of the\n\t * space between the dashes. The lengths are relative to the line width: a\n\t * length of \"1\" is equal to the line width. VML ignores this style and\n\t * uses dashStyle instead as defined in the VML specification. This style\n\t * is only used in the <mxConnector> shape. Value is \"dashPattern\".\n\t */\n\tSTYLE_DASH_PATTERN: 'dashPattern',\n\n\t/**\n\t * Variable: STYLE_FIX_DASH\n\t *\n\t * Defines the key for the fixDash style. Use 0 (default) for dash patterns\n\t * that depend on the linewidth and 1 for dash patterns that ignore the\n\t * line width. Value is \"fixDash\".\n\t */\n\tSTYLE_FIX_DASH: 'fixDash',\n\n\t/**\n\t * Variable: STYLE_ROUNDED\n\t *\n\t * Defines the key for the rounded style. The type of this value is\n\t * Boolean. For edges this determines whether or not joins between edges\n\t * segments are smoothed to a rounded finish. For vertices that have the\n\t * rectangle shape, this determines whether or not the rectangle is\n\t * rounded. Use 0 (default) for non-rounded or 1 for rounded. Value is\n\t * \"rounded\".\n\t */\n\tSTYLE_ROUNDED: 'rounded',\n\n\t/**\n\t * Variable: STYLE_CURVED\n\t *\n\t * Defines the key for the curved style. The type of this value is\n\t * Boolean. It is only applicable for connector shapes. Use 0 (default)\n\t * for non-curved or 1 for curved. Value is \"curved\".\n\t */\n\tSTYLE_CURVED: 'curved',\n\n\t/**\n\t * Variable: STYLE_ARCSIZE\n\t *\n\t * Defines the rounding factor for a rounded rectangle in percent (without\n\t * the percent sign). Possible values are between 0 and 100. If this value\n\t * is not specified then RECTANGLE_ROUNDING_FACTOR * 100 is used. For\n\t * edges, this defines the absolute size of rounded corners in pixels. If\n\t * this values is not specified then LINE_ARCSIZE is used.\n\t * (This style is only exported via <mxImageExport>.) Value is \"arcSize\".\n\t */\n\tSTYLE_ARCSIZE: 'arcSize',\n\n\t/**\n\t * Variable: STYLE_ABSOLUTE_ARCSIZE\n\t *\n\t * Defines the key for the absolute arc size style. This specifies if\n\t * arcSize for rectangles is abolute or relative. Possible values are 1\n\t * and 0 (default). Value is \"absoluteArcSize\".\n\t */\n\tSTYLE_ABSOLUTE_ARCSIZE: 'absoluteArcSize',\n\n\t/**\n\t * Variable: STYLE_SOURCE_PERIMETER_SPACING\n\t *\n\t * Defines the key for the source perimeter spacing. The type of this value\n\t * is numeric. This is the distance between the source connection point of\n\t * an edge and the perimeter of the source vertex in pixels. This style\n\t * only applies to edges. Value is \"sourcePerimeterSpacing\".\n\t */\n\tSTYLE_SOURCE_PERIMETER_SPACING: 'sourcePerimeterSpacing',\n\n\t/**\n\t * Variable: STYLE_TARGET_PERIMETER_SPACING\n\t *\n\t * Defines the key for the target perimeter spacing. The type of this value\n\t * is numeric. This is the distance between the target connection point of\n\t * an edge and the perimeter of the target vertex in pixels. This style\n\t * only applies to edges. Value is \"targetPerimeterSpacing\".\n\t */\n\tSTYLE_TARGET_PERIMETER_SPACING: 'targetPerimeterSpacing',\n\n\t/**\n\t * Variable: STYLE_PERIMETER_SPACING\n\t *\n\t * Defines the key for the perimeter spacing. This is the distance between\n\t * the connection point and the perimeter in pixels. When used in a vertex\n\t * style, this applies to all incoming edges to floating ports (edges that\n\t * terminate on the perimeter of the vertex). When used in an edge style,\n\t * this spacing applies to the source and target separately, if they\n\t * terminate in floating ports (on the perimeter of the vertex). Value is\n\t * \"perimeterSpacing\".\n\t */\n\tSTYLE_PERIMETER_SPACING: 'perimeterSpacing',\n\n\t/**\n\t * Variable: STYLE_SPACING\n\t *\n\t * Defines the key for the spacing. The value represents the spacing, in\n\t * pixels, added to each side of a label in a vertex (style applies to\n\t * vertices only). Value is \"spacing\".\n\t */\n\tSTYLE_SPACING: 'spacing',\n\n\t/**\n\t * Variable: STYLE_SPACING_TOP\n\t *\n\t * Defines the key for the spacingTop style. The value represents the\n\t * spacing, in pixels, added to the top side of a label in a vertex (style\n\t * applies to vertices only). Value is \"spacingTop\".\n\t */\n\tSTYLE_SPACING_TOP: 'spacingTop',\n\n\t/**\n\t * Variable: STYLE_SPACING_LEFT\n\t *\n\t * Defines the key for the spacingLeft style. The value represents the\n\t * spacing, in pixels, added to the left side of a label in a vertex (style\n\t * applies to vertices only). Value is \"spacingLeft\".\n\t */\n\tSTYLE_SPACING_LEFT: 'spacingLeft',\n\n\t/**\n\t * Variable: STYLE_SPACING_BOTTOM\n\t *\n\t * Defines the key for the spacingBottom style The value represents the\n\t * spacing, in pixels, added to the bottom side of a label in a vertex\n\t * (style applies to vertices only). Value is \"spacingBottom\".\n\t */\n\tSTYLE_SPACING_BOTTOM: 'spacingBottom',\n\n\t/**\n\t * Variable: STYLE_SPACING_RIGHT\n\t *\n\t * Defines the key for the spacingRight style The value represents the\n\t * spacing, in pixels, added to the right side of a label in a vertex (style\n\t * applies to vertices only). Value is \"spacingRight\".\n\t */\n\tSTYLE_SPACING_RIGHT: 'spacingRight',\n\n\t/**\n\t * Variable: STYLE_HORIZONTAL\n\t *\n\t * Defines the key for the horizontal style. Possible values are\n\t * true or false. This value only applies to vertices. If the <STYLE_SHAPE>\n\t * is \"SHAPE_SWIMLANE\" a value of false indicates that the\n\t * swimlane should be drawn vertically, true indicates to draw it\n\t * horizontally. If the shape style does not indicate that this vertex is a\n\t * swimlane, this value affects only whether the label is drawn\n\t * horizontally or vertically. Value is \"horizontal\".\n\t */\n\tSTYLE_HORIZONTAL: 'horizontal',\n\n\t/**\n\t * Variable: STYLE_DIRECTION\n\t *\n\t * Defines the key for the direction style. The direction style is used\n\t * to specify the direction of certain shapes (eg. <mxTriangle>).\n\t * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,\n\t * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"direction\".\n\t */\n\tSTYLE_DIRECTION: 'direction',\n\n\t/**\n\t * Variable: STYLE_ANCHOR_POINT_DIRECTION\n\t *\n\t * Defines the key for the anchorPointDirection style. The defines if the\n\t * direction style should be taken into account when computing the fixed\n\t * point location for connected edges. Default is 1 (yes). Set this to 0\n\t * to ignore the direction style for fixed connection points. Value is\n\t * \"anchorPointDirection\".\n\t */\n\tSTYLE_ANCHOR_POINT_DIRECTION: 'anchorPointDirection',\n\n\t/**\n\t * Variable: STYLE_ELBOW\n\t *\n\t * Defines the key for the elbow style. Possible values are\n\t * <ELBOW_HORIZONTAL> and <ELBOW_VERTICAL>. Default is <ELBOW_HORIZONTAL>.\n\t * This defines how the three segment orthogonal edge style leaves its\n\t * terminal vertices. The vertical style leaves the terminal vertices at\n\t * the top and bottom sides. Value is \"elbow\".\n\t */\n\tSTYLE_ELBOW: 'elbow',\n\n\t/**\n\t * Variable: STYLE_FONTCOLOR\n\t *\n\t * Defines the key for the fontColor style. Possible values are all HTML\n\t * color names or HEX codes. Value is \"fontColor\".\n\t */\n\tSTYLE_FONTCOLOR: 'fontColor',\n\n\t/**\n\t * Variable: STYLE_FONTFAMILY\n\t *\n\t * Defines the key for the fontFamily style. Possible values are names such\n\t * as Arial; Dialog; Verdana; Times New Roman. The value is of type String.\n\t * Value is fontFamily.\n\t */\n\tSTYLE_FONTFAMILY: 'fontFamily',\n\n\t/**\n\t * Variable: STYLE_FONTSIZE\n\t *\n\t * Defines the key for the fontSize style (in px). The type of the value\n\t * is int. Value is \"fontSize\".\n\t */\n\tSTYLE_FONTSIZE: 'fontSize',\n\n\t/**\n\t * Variable: STYLE_FONTSTYLE\n\t *\n\t * Defines the key for the fontStyle style. Values may be any logical AND\n\t * (sum) of <FONT_BOLD>, <FONT_ITALIC> and <FONT_UNDERLINE>.\n\t * The type of the value is int. Value is \"fontStyle\".\n\t */\n\tSTYLE_FONTSTYLE: 'fontStyle',\n\n\t/**\n\t * Variable: STYLE_ASPECT\n\t *\n\t * Defines the key for the aspect style. Possible values are empty or fixed.\n\t * If fixed is used then the aspect ratio of the cell will be maintained\n\t * when resizing. Default is empty. Value is \"aspect\".\n\t */\n\tSTYLE_ASPECT: 'aspect',\n\n\t/**\n\t * Variable: STYLE_AUTOSIZE\n\t *\n\t * Defines the key for the autosize style. This specifies if a cell should be\n\t * resized automatically if the value has changed. Possible values are 0 or 1.\n\t * Default is 0. See <mxGraph.isAutoSizeCell>. This is normally combined with\n\t * <STYLE_RESIZABLE> to disable manual sizing. Value is \"autosize\".\n\t */\n\tSTYLE_AUTOSIZE: 'autosize',\n\n\t/**\n\t * Variable: STYLE_FOLDABLE\n\t *\n\t * Defines the key for the foldable style. This specifies if a cell is foldable\n\t * using a folding icon. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellFoldable>. Value is \"foldable\".\n\t */\n\tSTYLE_FOLDABLE: 'foldable',\n\n\t/**\n\t * Variable: STYLE_EDITABLE\n\t *\n\t * Defines the key for the editable style. This specifies if the value of\n\t * a cell can be edited using the in-place editor. Possible values are 0 or\n\t * 1. Default is 1. See <mxGraph.isCellEditable>. Value is \"editable\".\n\t */\n\tSTYLE_EDITABLE: 'editable',\n\n\t/**\n\t * Variable: STYLE_BACKGROUND_OUTLINE\n\t *\n\t * Defines the key for the backgroundOutline style. This specifies if a\n\t * only the background of a cell should be painted when it is highlighted.\n\t * Possible values are 0 or 1. Default is 0. Value is \"backgroundOutline\".\n\t */\n\tSTYLE_BACKGROUND_OUTLINE: 'backgroundOutline',\n\n\t/**\n\t * Variable: STYLE_BENDABLE\n\t *\n\t * Defines the key for the bendable style. This specifies if the control\n\t * points of an edge can be moved. Possible values are 0 or 1. Default is\n\t * 1. See <mxGraph.isCellBendable>. Value is \"bendable\".\n\t */\n\tSTYLE_BENDABLE: 'bendable',\n\n\t/**\n\t * Variable: STYLE_MOVABLE\n\t *\n\t * Defines the key for the movable style. This specifies if a cell can\n\t * be moved. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellMovable>. Value is \"movable\".\n\t */\n\tSTYLE_MOVABLE: 'movable',\n\n\t/**\n\t * Variable: STYLE_RESIZABLE\n\t *\n\t * Defines the key for the resizable style. This specifies if a cell can\n\t * be resized. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellResizable>. Value is \"resizable\".\n\t */\n\tSTYLE_RESIZABLE: 'resizable',\n\n\t/**\n\t * Variable: STYLE_RESIZE_WIDTH\n\t *\n\t * Defines the key for the resizeWidth style. This specifies if a cell's\n\t * width is resized if the parent is resized. If this is 1 then the width\n\t * will be resized even if the cell's geometry is relative. If this is 0\n\t * then the cell's width will not be resized. Default is not defined. Value\n\t * is \"resizeWidth\".\n\t */\n\tSTYLE_RESIZE_WIDTH: 'resizeWidth',\n\n\t/**\n\t * Variable: STYLE_RESIZE_WIDTH\n\t *\n\t * Defines the key for the resizeHeight style. This specifies if a cell's\n\t * height if resize if the parent is resized. If this is 1 then the height\n\t * will be resized even if the cell's geometry is relative. If this is 0\n\t * then the cell's height will not be resized. Default is not defined. Value\n\t * is \"resizeHeight\".\n\t */\n\tSTYLE_RESIZE_HEIGHT: 'resizeHeight',\n\n\t/**\n\t * Variable: STYLE_ROTATABLE\n\t *\n\t * Defines the key for the rotatable style. This specifies if a cell can\n\t * be rotated. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellRotatable>. Value is \"rotatable\".\n\t */\n\tSTYLE_ROTATABLE: 'rotatable',\n\n\t/**\n\t * Variable: STYLE_CLONEABLE\n\t *\n\t * Defines the key for the cloneable style. This specifies if a cell can\n\t * be cloned. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellCloneable>. Value is \"cloneable\".\n\t */\n\tSTYLE_CLONEABLE: 'cloneable',\n\n\t/**\n\t * Variable: STYLE_DELETABLE\n\t *\n\t * Defines the key for the deletable style. This specifies if a cell can be\n\t * deleted. Possible values are 0 or 1. Default is 1. See\n\t * <mxGraph.isCellDeletable>. Value is \"deletable\".\n\t */\n\tSTYLE_DELETABLE: 'deletable',\n\n\t/**\n\t * Variable: STYLE_SHAPE\n\t *\n\t * Defines the key for the shape. Possible values are all constants with\n\t * a SHAPE-prefix or any newly defined shape names. Value is \"shape\".\n\t */\n\tSTYLE_SHAPE: 'shape',\n\n\t/**\n\t * Variable: STYLE_EDGE\n\t *\n\t * Defines the key for the edge style. Possible values are the functions\n\t * defined in <mxEdgeStyle>. Value is \"edgeStyle\".\n\t */\n\tSTYLE_EDGE: 'edgeStyle',\n\n\t/**\n\t * Variable: STYLE_JETTY_SIZE\n\t *\n\t * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\n\t * Default is 10. Possible values are all numeric values or \"auto\".\n\t * Jetty size is the minimum length of the orthogonal segment before\n\t * it attaches to a shape.\n\t * Value is \"jettySize\".\n\t */\n\tSTYLE_JETTY_SIZE: 'jettySize',\n\n\t/**\n\t * Variable: STYLE_SOURCE_JETTY_SIZE\n\t *\n\t * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\n\t * Default is 10. Possible values are numeric values or \"auto\". This has\n\t * precedence over <STYLE_JETTY_SIZE>. Value is \"sourceJettySize\".\n\t */\n\tSTYLE_SOURCE_JETTY_SIZE: 'sourceJettySize',\n\n\t/**\n\t * Variable: targetJettySize\n\t *\n\t * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\n\t * Default is 10. Possible values are numeric values or \"auto\". This has\n\t * precedence over <STYLE_JETTY_SIZE>. Value is \"targetJettySize\".\n\t */\n\tSTYLE_TARGET_JETTY_SIZE: 'targetJettySize',\n\n\t/**\n\t * Variable: STYLE_LOOP\n\t *\n\t * Defines the key for the loop style. Possible values are the functions\n\t * defined in <mxEdgeStyle>. Value is \"loopStyle\". Default is\n\t * <mxGraph.defaultLoopStylean>.\n\t */\n\tSTYLE_LOOP: 'loopStyle',\n\n\t/**\n\t * Variable: STYLE_ORTHOGONAL_LOOP\n\t *\n\t * Defines the key for the orthogonal loop style. Possible values are 0 and\n\t * 1. Default is 0. Value is \"orthogonalLoop\". Use this style to specify\n\t * if loops with no waypoints and defined anchor points should be routed\n\t * using <STYLE_LOOP> or not routed.\n\t */\n\tSTYLE_ORTHOGONAL_LOOP: 'orthogonalLoop',\n\n\t/**\n\t * Variable: STYLE_ROUTING_CENTER_X\n\t *\n\t * Defines the key for the horizontal routing center. Possible values are\n\t * between -0.5 and 0.5. This is the relative offset from the center used\n\t * for connecting edges. The type of this value is numeric. Value is\n\t * \"routingCenterX\".\n\t */\n\tSTYLE_ROUTING_CENTER_X: 'routingCenterX',\n\n\t/**\n\t * Variable: STYLE_ROUTING_CENTER_Y\n\t *\n\t * Defines the key for the vertical routing center. Possible values are\n\t * between -0.5 and 0.5. This is the relative offset from the center used\n\t * for connecting edges. The type of this value is numeric. Value is\n\t * \"routingCenterY\".\n\t */\n\tSTYLE_ROUTING_CENTER_Y: 'routingCenterY',\n\n\t/**\n\t * Variable: FONT_BOLD\n\t *\n\t * Constant for bold fonts. Default is 1.\n\t */\n\tFONT_BOLD: 1,\n\n\t/**\n\t * Variable: FONT_ITALIC\n\t *\n\t * Constant for italic fonts. Default is 2.\n\t */\n\tFONT_ITALIC: 2,\n\n\t/**\n\t * Variable: FONT_UNDERLINE\n\t *\n\t * Constant for underlined fonts. Default is 4.\n\t */\n\tFONT_UNDERLINE: 4,\n\n\t/**\n\t * Variable: SHAPE_RECTANGLE\n\t *\n\t * Name under which <mxRectangleShape> is registered in <mxCellRenderer>.\n\t * Default is rectangle.\n\t */\n\tSHAPE_RECTANGLE: 'rectangle',\n\n\t/**\n\t * Variable: SHAPE_ELLIPSE\n\t *\n\t * Name under which <mxEllipse> is registered in <mxCellRenderer>.\n\t * Default is ellipse.\n\t */\n\tSHAPE_ELLIPSE: 'ellipse',\n\n\t/**\n\t * Variable: SHAPE_DOUBLE_ELLIPSE\n\t *\n\t * Name under which <mxDoubleEllipse> is registered in <mxCellRenderer>.\n\t * Default is doubleEllipse.\n\t */\n\tSHAPE_DOUBLE_ELLIPSE: 'doubleEllipse',\n\n\t/**\n\t * Variable: SHAPE_RHOMBUS\n\t *\n\t * Name under which <mxRhombus> is registered in <mxCellRenderer>.\n\t * Default is rhombus.\n\t */\n\tSHAPE_RHOMBUS: 'rhombus',\n\n\t/**\n\t * Variable: SHAPE_LINE\n\t *\n\t * Name under which <mxLine> is registered in <mxCellRenderer>.\n\t * Default is line.\n\t */\n\tSHAPE_LINE: 'line',\n\n\t/**\n\t * Variable: SHAPE_IMAGE\n\t *\n\t * Name under which <mxImageShape> is registered in <mxCellRenderer>.\n\t * Default is image.\n\t */\n\tSHAPE_IMAGE: 'image',\n\n\t/**\n\t * Variable: SHAPE_ARROW\n\t *\n\t * Name under which <mxArrow> is registered in <mxCellRenderer>.\n\t * Default is arrow.\n\t */\n\tSHAPE_ARROW: 'arrow',\n\n\t/**\n\t * Variable: SHAPE_ARROW_CONNECTOR\n\t *\n\t * Name under which <mxArrowConnector> is registered in <mxCellRenderer>.\n\t * Default is arrowConnector.\n\t */\n\tSHAPE_ARROW_CONNECTOR: 'arrowConnector',\n\n\t/**\n\t * Variable: SHAPE_LABEL\n\t *\n\t * Name under which <mxLabel> is registered in <mxCellRenderer>.\n\t * Default is label.\n\t */\n\tSHAPE_LABEL: 'label',\n\n\t/**\n\t * Variable: SHAPE_CYLINDER\n\t *\n\t * Name under which <mxCylinder> is registered in <mxCellRenderer>.\n\t * Default is cylinder.\n\t */\n\tSHAPE_CYLINDER: 'cylinder',\n\n\t/**\n\t * Variable: SHAPE_SWIMLANE\n\t *\n\t * Name under which <mxSwimlane> is registered in <mxCellRenderer>.\n\t * Default is swimlane.\n\t */\n\tSHAPE_SWIMLANE: 'swimlane',\n\n\t/**\n\t * Variable: SHAPE_CONNECTOR\n\t *\n\t * Name under which <mxConnector> is registered in <mxCellRenderer>.\n\t * Default is connector.\n\t */\n\tSHAPE_CONNECTOR: 'connector',\n\n\t/**\n\t * Variable: SHAPE_ACTOR\n\t *\n\t * Name under which <mxActor> is registered in <mxCellRenderer>.\n\t * Default is actor.\n\t */\n\tSHAPE_ACTOR: 'actor',\n\n\t/**\n\t * Variable: SHAPE_CLOUD\n\t *\n\t * Name under which <mxCloud> is registered in <mxCellRenderer>.\n\t * Default is cloud.\n\t */\n\tSHAPE_CLOUD: 'cloud',\n\n\t/**\n\t * Variable: SHAPE_TRIANGLE\n\t *\n\t * Name under which <mxTriangle> is registered in <mxCellRenderer>.\n\t * Default is triangle.\n\t */\n\tSHAPE_TRIANGLE: 'triangle',\n\n\t/**\n\t * Variable: SHAPE_HEXAGON\n\t *\n\t * Name under which <mxHexagon> is registered in <mxCellRenderer>.\n\t * Default is hexagon.\n\t */\n\tSHAPE_HEXAGON: 'hexagon',\n\n\t/**\n\t * Variable: ARROW_CLASSIC\n\t *\n\t * Constant for classic arrow markers.\n\t */\n\tARROW_CLASSIC: 'classic',\n\n\t/**\n\t * Variable: ARROW_CLASSIC_THIN\n\t *\n\t * Constant for thin classic arrow markers.\n\t */\n\tARROW_CLASSIC_THIN: 'classicThin',\n\n\t/**\n\t * Variable: ARROW_BLOCK\n\t *\n\t * Constant for block arrow markers.\n\t */\n\tARROW_BLOCK: 'block',\n\n\t/**\n\t * Variable: ARROW_BLOCK_THIN\n\t *\n\t * Constant for thin block arrow markers.\n\t */\n\tARROW_BLOCK_THIN: 'blockThin',\n\n\t/**\n\t * Variable: ARROW_OPEN\n\t *\n\t * Constant for open arrow markers.\n\t */\n\tARROW_OPEN: 'open',\n\n\t/**\n\t * Variable: ARROW_OPEN_THIN\n\t *\n\t * Constant for thin open arrow markers.\n\t */\n\tARROW_OPEN_THIN: 'openThin',\n\n\t/**\n\t * Variable: ARROW_OVAL\n\t *\n\t * Constant for oval arrow markers.\n\t */\n\tARROW_OVAL: 'oval',\n\n\t/**\n\t * Variable: ARROW_DIAMOND\n\t *\n\t * Constant for diamond arrow markers.\n\t */\n\tARROW_DIAMOND: 'diamond',\n\n\t/**\n\t * Variable: ARROW_DIAMOND_THIN\n\t *\n\t * Constant for thin diamond arrow markers.\n\t */\n\tARROW_DIAMOND_THIN: 'diamondThin',\n\n\t/**\n\t * Variable: ALIGN_LEFT\n\t *\n\t * Constant for left horizontal alignment. Default is left.\n\t */\n\tALIGN_LEFT: 'left',\n\n\t/**\n\t * Variable: ALIGN_CENTER\n\t *\n\t * Constant for center horizontal alignment. Default is center.\n\t */\n\tALIGN_CENTER: 'center',\n\n\t/**\n\t * Variable: ALIGN_RIGHT\n\t *\n\t * Constant for right horizontal alignment. Default is right.\n\t */\n\tALIGN_RIGHT: 'right',\n\n\t/**\n\t * Variable: ALIGN_TOP\n\t *\n\t * Constant for top vertical alignment. Default is top.\n\t */\n\tALIGN_TOP: 'top',\n\n\t/**\n\t * Variable: ALIGN_MIDDLE\n\t *\n\t * Constant for middle vertical alignment. Default is middle.\n\t */\n\tALIGN_MIDDLE: 'middle',\n\n\t/**\n\t * Variable: ALIGN_BOTTOM\n\t *\n\t * Constant for bottom vertical alignment. Default is bottom.\n\t */\n\tALIGN_BOTTOM: 'bottom',\n\n\t/**\n\t * Variable: DIRECTION_NORTH\n\t *\n\t * Constant for direction north. Default is north.\n\t */\n\tDIRECTION_NORTH: 'north',\n\n\t/**\n\t * Variable: DIRECTION_SOUTH\n\t *\n\t * Constant for direction south. Default is south.\n\t */\n\tDIRECTION_SOUTH: 'south',\n\n\t/**\n\t * Variable: DIRECTION_EAST\n\t *\n\t * Constant for direction east. Default is east.\n\t */\n\tDIRECTION_EAST: 'east',\n\n\t/**\n\t * Variable: DIRECTION_WEST\n\t *\n\t * Constant for direction west. Default is west.\n\t */\n\tDIRECTION_WEST: 'west',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_DEFAULT\n\t *\n\t * Constant for text direction default. Default is an empty string. Use\n\t * this value to use the default text direction of the operating system.\n\t */\n\tTEXT_DIRECTION_DEFAULT: '',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_AUTO\n\t *\n\t * Constant for text direction automatic. Default is auto. Use this value\n\t * to find the direction for a given text with <mxText.getAutoDirection>.\n\t */\n\tTEXT_DIRECTION_AUTO: 'auto',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_LTR\n\t *\n\t * Constant for text direction left to right. Default is ltr. Use this\n\t * value for left to right text direction.\n\t */\n\tTEXT_DIRECTION_LTR: 'ltr',\n\n\t/**\n\t * Variable: TEXT_DIRECTION_RTL\n\t *\n\t * Constant for text direction right to left. Default is rtl. Use this\n\t * value for right to left text direction.\n\t */\n\tTEXT_DIRECTION_RTL: 'rtl',\n\n\t/**\n\t * Variable: DIRECTION_MASK_NONE\n\t *\n\t * Constant for no direction.\n\t */\n\tDIRECTION_MASK_NONE: 0,\n\n\t/**\n\t * Variable: DIRECTION_MASK_WEST\n\t *\n\t * Bitwise mask for west direction.\n\t */\n\tDIRECTION_MASK_WEST: 1,\n\n\t/**\n\t * Variable: DIRECTION_MASK_NORTH\n\t *\n\t * Bitwise mask for north direction.\n\t */\n\tDIRECTION_MASK_NORTH: 2,\n\n\t/**\n\t * Variable: DIRECTION_MASK_SOUTH\n\t *\n\t * Bitwise mask for south direction.\n\t */\n\tDIRECTION_MASK_SOUTH: 4,\n\n\t/**\n\t * Variable: DIRECTION_MASK_EAST\n\t *\n\t * Bitwise mask for east direction.\n\t */\n\tDIRECTION_MASK_EAST: 8,\n\n\t/**\n\t * Variable: DIRECTION_MASK_ALL\n\t *\n\t * Bitwise mask for all directions.\n\t */\n\tDIRECTION_MASK_ALL: 15,\n\n\t/**\n\t * Variable: ELBOW_VERTICAL\n\t *\n\t * Constant for elbow vertical. Default is horizontal.\n\t */\n\tELBOW_VERTICAL: 'vertical',\n\n\t/**\n\t * Variable: ELBOW_HORIZONTAL\n\t *\n\t * Constant for elbow horizontal. Default is horizontal.\n\t */\n\tELBOW_HORIZONTAL: 'horizontal',\n\n\t/**\n\t * Variable: EDGESTYLE_ELBOW\n\t *\n\t * Name of the elbow edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_ELBOW: 'elbowEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_ENTITY_RELATION\n\t *\n\t * Name of the entity relation edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_ENTITY_RELATION: 'entityRelationEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_LOOP\n\t *\n\t * Name of the loop edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_LOOP: 'loopEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_SIDETOSIDE\n\t *\n\t * Name of the side to side edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_SIDETOSIDE: 'sideToSideEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_TOPTOBOTTOM\n\t *\n\t * Name of the top to bottom edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_TOPTOBOTTOM: 'topToBottomEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_ORTHOGONAL\n\t *\n\t * Name of the generic orthogonal edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_ORTHOGONAL: 'orthogonalEdgeStyle',\n\n\t/**\n\t * Variable: EDGESTYLE_SEGMENT\n\t *\n\t * Name of the generic segment edge style. Can be used as a string value\n\t * for the STYLE_EDGE style.\n\t */\n\tEDGESTYLE_SEGMENT: 'segmentEdgeStyle',\n\n\t/**\n\t * Variable: PERIMETER_ELLIPSE\n\t *\n\t * Name of the ellipse perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_ELLIPSE: 'ellipsePerimeter',\n\n\t/**\n\t * Variable: PERIMETER_RECTANGLE\n\t *\n\t * Name of the rectangle perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_RECTANGLE: 'rectanglePerimeter',\n\n\t/**\n\t * Variable: PERIMETER_RHOMBUS\n\t *\n\t * Name of the rhombus perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_RHOMBUS: 'rhombusPerimeter',\n\n\t/**\n\t * Variable: PERIMETER_HEXAGON\n\t *\n\t * Name of the hexagon perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_HEXAGON: 'hexagonPerimeter',\n\n\t/**\n\t * Variable: PERIMETER_TRIANGLE\n\t *\n\t * Name of the triangle perimeter. Can be used as a string value\n\t * for the STYLE_PERIMETER style.\n\t */\n\tPERIMETER_TRIANGLE: 'trianglePerimeter'\n\n};\n\n__mxOutput.mxConstants = typeof mxConstants !== 'undefined' ? mxConstants : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEventObject\n *\n * The mxEventObject is a wrapper for all properties of a single event.\n * Additionally, it also offers functions to consume the event and check if it\n * was consumed as follows:\n *\n * (code)\n * evt.consume();\n * INV: evt.isConsumed() == true\n * (end)\n *\n * Constructor: mxEventObject\n *\n * Constructs a new event object with the specified name. An optional\n * sequence of key, value pairs can be appended to define properties.\n *\n * Example:\n *\n * (code)\n * new mxEventObject(\"eventName\", key1, val1, .., keyN, valN)\n * (end)\n */\nfunction mxEventObject(name)\n{\n\tthis.name = name;\n\tthis.properties = [];\n\n\tfor (var i = 1; i < arguments.length; i += 2)\n\t{\n\t\tif (arguments[i + 1] != null)\n\t\t{\n\t\t\tthis.properties[arguments[i]] = arguments[i + 1];\n\t\t}\n\t}\n};\n\n/**\n * Variable: name\n *\n * Holds the name.\n */\nmxEventObject.prototype.name = null;\n\n/**\n * Variable: properties\n *\n * Holds the properties as an associative array.\n */\nmxEventObject.prototype.properties = null;\n\n/**\n * Variable: consumed\n *\n * Holds the consumed state. Default is false.\n */\nmxEventObject.prototype.consumed = false;\n\n/**\n * Function: getName\n *\n * Returns <name>.\n */\nmxEventObject.prototype.getName = function()\n{\n\treturn this.name;\n};\n\n/**\n * Function: getProperties\n *\n * Returns <properties>.\n */\nmxEventObject.prototype.getProperties = function()\n{\n\treturn this.properties;\n};\n\n/**\n * Function: getProperty\n *\n * Returns the property for the given key.\n */\nmxEventObject.prototype.getProperty = function(key)\n{\n\treturn this.properties[key];\n};\n\n/**\n * Function: isConsumed\n *\n * Returns true if the event has been consumed.\n */\nmxEventObject.prototype.isConsumed = function()\n{\n\treturn this.consumed;\n};\n\n/**\n * Function: consume\n *\n * Consumes the event.\n */\nmxEventObject.prototype.consume = function()\n{\n\tthis.consumed = true;\n};\n\n__mxOutput.mxEventObject = typeof mxEventObject !== 'undefined' ? mxEventObject : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMouseEvent\n *\n * Base class for all mouse events in mxGraph. A listener for this event should\n * implement the following methods:\n *\n * (code)\n * graph.addMouseListener(\n * {\n *   mouseDown: function(sender, evt)\n *   {\n *     mxLog.debug('mouseDown');\n *   },\n *   mouseMove: function(sender, evt)\n *   {\n *     mxLog.debug('mouseMove');\n *   },\n *   mouseUp: function(sender, evt)\n *   {\n *     mxLog.debug('mouseUp');\n *   }\n * });\n * (end)\n *\n * Constructor: mxMouseEvent\n *\n * Constructs a new event object for the given arguments.\n *\n * Parameters:\n *\n * evt - Native mouse event.\n * state - Optional <mxCellState> under the mouse.\n *\n */\nfunction mxMouseEvent(evt, state)\n{\n\tthis.evt = evt;\n\tthis.state = state;\n\tthis.sourceState = state;\n};\n\n/**\n * Variable: consumed\n *\n * Holds the consumed state of this event.\n */\nmxMouseEvent.prototype.consumed = false;\n\n/**\n * Variable: evt\n *\n * Holds the inner event object.\n */\nmxMouseEvent.prototype.evt = null;\n\n/**\n * Variable: graphX\n *\n * Holds the x-coordinate of the event in the graph. This value is set in\n * <mxGraph.fireMouseEvent>.\n */\nmxMouseEvent.prototype.graphX = null;\n\n/**\n * Variable: graphY\n *\n * Holds the y-coordinate of the event in the graph. This value is set in\n * <mxGraph.fireMouseEvent>.\n */\nmxMouseEvent.prototype.graphY = null;\n\n/**\n * Variable: state\n *\n * Holds the optional <mxCellState> associated with this event.\n */\nmxMouseEvent.prototype.state = null;\n\n/**\n * Variable: sourceState\n *\n * Holds the <mxCellState> that was passed to the constructor. This can be\n * different from <state> depending on the result of <mxGraph.getEventState>.\n */\nmxMouseEvent.prototype.sourceState = null;\n\n/**\n * Function: getEvent\n *\n * Returns <evt>.\n */\nmxMouseEvent.prototype.getEvent = function()\n{\n\treturn this.evt;\n};\n\n/**\n * Function: getSource\n *\n * Returns the target DOM element using <mxEvent.getSource> for <evt>.\n */\nmxMouseEvent.prototype.getSource = function()\n{\n\treturn mxEvent.getSource(this.evt);\n};\n\n/**\n * Function: isSource\n *\n * Returns true if the given <mxShape> is the source of <evt>.\n */\nmxMouseEvent.prototype.isSource = function(shape)\n{\n\tif (shape != null)\n\t{\n\t\treturn mxUtils.isAncestorNode(shape.node, this.getSource());\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getX\n *\n * Returns <evt.clientX>.\n */\nmxMouseEvent.prototype.getX = function()\n{\n\treturn mxEvent.getClientX(this.getEvent());\n};\n\n/**\n * Function: getY\n *\n * Returns <evt.clientY>.\n */\nmxMouseEvent.prototype.getY = function()\n{\n\treturn mxEvent.getClientY(this.getEvent());\n};\n\n/**\n * Function: getGraphX\n *\n * Returns <graphX>.\n */\nmxMouseEvent.prototype.getGraphX = function()\n{\n\treturn this.graphX;\n};\n\n/**\n * Function: getGraphY\n *\n * Returns <graphY>.\n */\nmxMouseEvent.prototype.getGraphY = function()\n{\n\treturn this.graphY;\n};\n\n/**\n * Function: getState\n *\n * Returns <state>.\n */\nmxMouseEvent.prototype.getState = function()\n{\n\treturn this.state;\n};\n\n/**\n * Function: getCell\n *\n * Returns the <mxCell> in <state> is not null.\n */\nmxMouseEvent.prototype.getCell = function()\n{\n\tvar state = this.getState();\n\n\tif (state != null)\n\t{\n\t\treturn state.cell;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: isPopupTrigger\n *\n * Returns true if the event is a popup trigger.\n */\nmxMouseEvent.prototype.isPopupTrigger = function()\n{\n\treturn mxEvent.isPopupTrigger(this.getEvent());\n};\n\n/**\n * Function: isConsumed\n *\n * Returns <consumed>.\n */\nmxMouseEvent.prototype.isConsumed = function()\n{\n\treturn this.consumed;\n};\n\n/**\n * Function: consume\n *\n * Sets <consumed> to true and invokes preventDefault on the native event\n * if such a method is defined. This is used mainly to avoid the cursor from\n * being changed to a text cursor in Webkit. You can use the preventDefault\n * flag to disable this functionality.\n *\n * Parameters:\n *\n * preventDefault - Specifies if the native event should be canceled. Default\n * is true.\n */\nmxMouseEvent.prototype.consume = function(preventDefault)\n{\n\tpreventDefault = (preventDefault != null) ? preventDefault : mxEvent.isMouseEvent(this.evt);\n\n\tif (preventDefault && this.evt.preventDefault)\n\t{\n\t\tthis.evt.preventDefault();\n\t}\n\n\t// Workaround for images being dragged in IE\n\t// Does not change returnValue in Opera\n\tif (mxClient.IS_IE)\n\t{\n\t\tthis.evt.returnValue = true;\n\t}\n\n\t// Sets local consumed state\n\tthis.consumed = true;\n};\n\n__mxOutput.mxMouseEvent = typeof mxMouseEvent !== 'undefined' ? mxMouseEvent : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEventSource\n *\n * Base class for objects that dispatch named events. To create a subclass that\n * inherits from mxEventSource, the following code is used.\n *\n * (code)\n * function MyClass() { };\n *\n * MyClass.prototype = new mxEventSource();\n * MyClass.prototype.constructor = MyClass;\n * (end)\n *\n * Known Subclasses:\n *\n * <mxGraphModel>, <mxGraph>, <mxGraphView>, <mxEditor>, <mxCellOverlay>,\n * <mxToolbar>, <mxWindow>\n *\n * Constructor: mxEventSource\n *\n * Constructs a new event source.\n */\nfunction mxEventSource(eventSource)\n{\n\tthis.setEventSource(eventSource);\n};\n\n/**\n * Variable: eventListeners\n *\n * Holds the event names and associated listeners in an array. The array\n * contains the event name followed by the respective listener for each\n * registered listener.\n */\nmxEventSource.prototype.eventListeners = null;\n\n/**\n * Variable: eventsEnabled\n *\n * Specifies if events can be fired. Default is true.\n */\nmxEventSource.prototype.eventsEnabled = true;\n\n/**\n * Variable: eventSource\n *\n * Optional source for events. Default is null.\n */\nmxEventSource.prototype.eventSource = null;\n\n/**\n * Function: isEventsEnabled\n *\n * Returns <eventsEnabled>.\n */\nmxEventSource.prototype.isEventsEnabled = function()\n{\n\treturn this.eventsEnabled;\n};\n\n/**\n * Function: setEventsEnabled\n *\n * Sets <eventsEnabled>.\n */\nmxEventSource.prototype.setEventsEnabled = function(value)\n{\n\tthis.eventsEnabled = value;\n};\n\n/**\n * Function: getEventSource\n *\n * Returns <eventSource>.\n */\nmxEventSource.prototype.getEventSource = function()\n{\n\treturn this.eventSource;\n};\n\n/**\n * Function: setEventSource\n *\n * Sets <eventSource>.\n */\nmxEventSource.prototype.setEventSource = function(value)\n{\n\tthis.eventSource = value;\n};\n\n/**\n * Function: addListener\n *\n * Binds the specified function to the given event name. If no event name\n * is given, then the listener is registered for all events.\n *\n * The parameters of the listener are the sender and an <mxEventObject>.\n */\nmxEventSource.prototype.addListener = function(name, funct)\n{\n\tif (this.eventListeners == null)\n\t{\n\t\tthis.eventListeners = [];\n\t}\n\n\tthis.eventListeners.push(name);\n\tthis.eventListeners.push(funct);\n};\n\n/**\n * Function: removeListener\n *\n * Removes all occurrences of the given listener from <eventListeners>.\n */\nmxEventSource.prototype.removeListener = function(funct)\n{\n\tif (this.eventListeners != null)\n\t{\n\t\tvar i = 0;\n\n\t\twhile (i < this.eventListeners.length)\n\t\t{\n\t\t\tif (this.eventListeners[i+1] == funct)\n\t\t\t{\n\t\t\t\tthis.eventListeners.splice(i, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: fireEvent\n *\n * Dispatches the given event to the listeners which are registered for\n * the event. The sender argument is optional. The current execution scope\n * (\"this\") is used for the listener invocation (see <mxUtils.bind>).\n *\n * Example:\n *\n * (code)\n * fireEvent(new mxEventObject(\"eventName\", key1, val1, .., keyN, valN))\n * (end)\n *\n * Parameters:\n *\n * evt - <mxEventObject> that represents the event.\n * sender - Optional sender to be passed to the listener. Default value is\n * the return value of <getEventSource>.\n */\nmxEventSource.prototype.fireEvent = function(evt, sender)\n{\n\tif (this.eventListeners != null && this.isEventsEnabled())\n\t{\n\t\tif (evt == null)\n\t\t{\n\t\t\tevt = new mxEventObject();\n\t\t}\n\n\t\tif (sender == null)\n\t\t{\n\t\t\tsender = this.getEventSource();\n\t\t}\n\n\t\tif (sender == null)\n\t\t{\n\t\t\tsender = this;\n\t\t}\n\n\t\tvar args = [sender, evt];\n\n\t\tfor (var i = 0; i < this.eventListeners.length; i += 2)\n\t\t{\n\t\t\tvar listen = this.eventListeners[i];\n\n\t\t\tif (listen == null || listen == evt.getName())\n\t\t\t{\n\t\t\t\tthis.eventListeners[i+1].apply(this, args);\n\t\t\t}\n\t\t}\n\t}\n};\n\n__mxOutput.mxEventSource = typeof mxEventSource !== 'undefined' ? mxEventSource : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxEvent =\n{\n\n\t/**\n\t * Class: mxEvent\n\t *\n\t * Cross-browser DOM event support. For internal event handling,\n\t * <mxEventSource> and the graph event dispatch loop in <mxGraph> are used.\n\t *\n\t * Memory Leaks:\n\t *\n\t * Use this class for adding and removing listeners to/from DOM nodes. The\n\t * <removeAllListeners> function is provided to remove all listeners that\n\t * have been added using <addListener>. The function should be invoked when\n\t * the last reference is removed in the JavaScript code, typically when the\n\t * referenced DOM node is removed from the DOM.\n\t *\n\t * Function: addListener\n\t *\n\t * Binds the function to the specified event on the given element. Use\n\t * <mxUtils.bind> in order to bind the \"this\" keyword inside the function\n\t * to a given execution scope.\n\t */\n\taddListener: function()\n\t{\n\t\tvar updateListenerList = function(element, eventName, funct)\n\t\t{\n\t\t\tif (element.mxListenerList == null)\n\t\t\t{\n\t\t\t\telement.mxListenerList = [];\n\t\t\t}\n\n\t\t\tvar entry = {name: eventName, f: funct};\n\t\t\telement.mxListenerList.push(entry);\n\t\t};\n\n\t\tif (window.addEventListener)\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.addEventListener(eventName, funct, false);\n\t\t\t\tupdateListenerList(element, eventName, funct);\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.attachEvent('on' + eventName, funct);\n\t\t\t\tupdateListenerList(element, eventName, funct);\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: removeListener\n\t *\n\t * Removes the specified listener from the given element.\n\t */\n\tremoveListener: function()\n\t{\n\t\tvar updateListener = function(element, eventName, funct)\n\t\t{\n\t\t\tif (element.mxListenerList != null)\n\t\t\t{\n\t\t\t\tvar listenerCount = element.mxListenerList.length;\n\n\t\t\t\tfor (var i = 0; i < listenerCount; i++)\n\t\t\t\t{\n\t\t\t\t\tvar entry = element.mxListenerList[i];\n\n\t\t\t\t\tif (entry.f == funct)\n\t\t\t\t\t{\n\t\t\t\t\t\telement.mxListenerList.splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (element.mxListenerList.length == 0)\n\t\t\t\t{\n\t\t\t\t\telement.mxListenerList = null;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (window.removeEventListener)\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.removeEventListener(eventName, funct, false);\n\t\t\t\tupdateListener(element, eventName, funct);\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn function(element, eventName, funct)\n\t\t\t{\n\t\t\t\telement.detachEvent('on' + eventName, funct);\n\t\t\t\tupdateListener(element, eventName, funct);\n\t\t\t};\n\t\t}\n\t}(),\n\n\t/**\n\t * Function: removeAllListeners\n\t *\n\t * Removes all listeners from the given element.\n\t */\n\tremoveAllListeners: function(element)\n\t{\n\t\tvar list = element.mxListenerList;\n\n\t\tif (list != null)\n\t\t{\n\t\t\twhile (list.length > 0)\n\t\t\t{\n\t\t\t\tvar entry = list[0];\n\t\t\t\tmxEvent.removeListener(element, entry.name, entry.f);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: addGestureListeners\n\t *\n\t * Adds the given listeners for touch, mouse and/or pointer events. If\n\t * <mxClient.IS_POINTER> is true then pointer events will be registered,\n\t * else the respective mouse events will be registered. If <mxClient.IS_POINTER>\n\t * is false and <mxClient.IS_TOUCH> is true then the respective touch events\n\t * will be registered as well as the mouse events.\n\t */\n\taddGestureListeners: function(node, startListener, moveListener, endListener)\n\t{\n\t\tif (startListener != null)\n\t\t{\n\t\t\tmxEvent.addListener(node, (mxClient.IS_POINTER) ? 'pointerdown' : 'mousedown', startListener);\n\t\t}\n\n\t\tif (moveListener != null)\n\t\t{\n\t\t\tmxEvent.addListener(node, (mxClient.IS_POINTER) ? 'pointermove' : 'mousemove', moveListener);\n\t\t}\n\n\t\tif (endListener != null)\n\t\t{\n\t\t\tmxEvent.addListener(node, (mxClient.IS_POINTER) ? 'pointerup' : 'mouseup', endListener);\n\t\t}\n\n\t\tif (!mxClient.IS_POINTER && mxClient.IS_TOUCH)\n\t\t{\n\t\t\tif (startListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(node, 'touchstart', startListener);\n\t\t\t}\n\n\t\t\tif (moveListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(node, 'touchmove', moveListener);\n\t\t\t}\n\n\t\t\tif (endListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(node, 'touchend', endListener);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: removeGestureListeners\n\t *\n\t * Removes the given listeners from mousedown, mousemove, mouseup and the\n\t * respective touch events if <mxClient.IS_TOUCH> is true.\n\t */\n\tremoveGestureListeners: function(node, startListener, moveListener, endListener)\n\t{\n\t\tif (startListener != null)\n\t\t{\n\t\t\tmxEvent.removeListener(node, (mxClient.IS_POINTER) ? 'pointerdown' : 'mousedown', startListener);\n\t\t}\n\n\t\tif (moveListener != null)\n\t\t{\n\t\t\tmxEvent.removeListener(node, (mxClient.IS_POINTER) ? 'pointermove' : 'mousemove', moveListener);\n\t\t}\n\n\t\tif (endListener != null)\n\t\t{\n\t\t\tmxEvent.removeListener(node, (mxClient.IS_POINTER) ? 'pointerup' : 'mouseup', endListener);\n\t\t}\n\n\t\tif (!mxClient.IS_POINTER && mxClient.IS_TOUCH)\n\t\t{\n\t\t\tif (startListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeListener(node, 'touchstart', startListener);\n\t\t\t}\n\n\t\t\tif (moveListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeListener(node, 'touchmove', moveListener);\n\t\t\t}\n\n\t\t\tif (endListener != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeListener(node, 'touchend', endListener);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: redirectMouseEvents\n\t *\n\t * Redirects the mouse events from the given DOM node to the graph dispatch\n\t * loop using the event and given state as event arguments. State can\n\t * either be an instance of <mxCellState> or a function that returns an\n\t * <mxCellState>. The down, move, up and dblClick arguments are optional\n\t * functions that take the trigger event as arguments and replace the\n\t * default behaviour.\n\t */\n\tredirectMouseEvents: function(node, graph, state, down, move, up, dblClick)\n\t{\n\t\tvar getState = function(evt)\n\t\t{\n\t\t\treturn (typeof(state) == 'function') ? state(evt) : state;\n\t\t};\n\n\t\tmxEvent.addGestureListeners(node, function (evt)\n\t\t{\n\t\t\tif (down != null)\n\t\t\t{\n\t\t\t\tdown(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t},\n\t\tfunction (evt)\n\t\t{\n\t\t\tif (move != null)\n\t\t\t{\n\t\t\t\tmove(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t},\n\t\tfunction (evt)\n\t\t{\n\t\t\tif (up != null)\n\t\t\t{\n\t\t\t\tup(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t});\n\n\t\tmxEvent.addListener(node, 'dblclick', function (evt)\n\t\t{\n\t\t\tif (dblClick != null)\n\t\t\t{\n\t\t\t\tdblClick(evt);\n\t\t\t}\n\t\t\telse if (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tvar tmp = getState(evt);\n\t\t\t\tgraph.dblClick(evt, (tmp != null) ? tmp.cell : null);\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Function: release\n\t *\n\t * Removes the known listeners from the given DOM node and its descendants.\n\t *\n\t * Parameters:\n\t *\n\t * element - DOM node to remove the listeners from.\n\t */\n\trelease: function(element)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (element != null)\n\t\t\t{\n\t\t\t\tmxEvent.removeAllListeners(element);\n\n\t\t\t\tvar children = element.childNodes;\n\n\t\t\t\tif (children != null)\n\t\t\t\t{\n\t\t\t        var childCount = children.length;\n\n\t\t\t        for (var i = 0; i < childCount; i += 1)\n\t\t\t        {\n\t\t\t        \tmxEvent.release(children[i]);\n\t\t\t        }\n\t\t\t    }\n\t\t\t}\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\t// ignores errors as this is typically called in cleanup code\n\t\t}\n\t},\n\n\t/**\n\t * Function: addMouseWheelListener\n\t *\n\t * Installs the given function as a handler for mouse wheel events. The\n\t * function has two arguments: the mouse event and a boolean that specifies\n\t * if the wheel was moved up or down.\n\t *\n\t * This has been tested with IE 6 and 7, Firefox (all versions), Opera and\n\t * Safari. It does currently not work on Safari for Mac.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * mxEvent.addMouseWheelListener(function (evt, up)\n\t * {\n\t *   mxLog.show();\n\t *   mxLog.debug('mouseWheel: up='+up);\n\t * });\n\t *(end)\n\t *\n\t * Parameters:\n\t *\n\t * funct - Handler function that takes the event argument and a boolean up\n\t * argument for the mousewheel direction.\n\t * target - Target for installing the listener in Google Chrome. See\n\t * https://www.chromestatus.com/features/6662647093133312.\n\t */\n\taddMouseWheelListener: function(funct, target)\n\t{\n\t\tif (funct != null)\n\t\t{\n\t\t\tvar wheelHandler = function(evt)\n\t\t\t{\n\t\t\t\t// IE does not give an event object but the\n\t\t\t\t// global event object is the mousewheel event\n\t\t\t\t// at this point in time.\n\t\t\t\tif (evt == null)\n\t\t\t\t{\n\t\t\t\t\tevt = window.event;\n\t\t\t\t}\n\n\t\t\t\tvar delta = 0;\n\n\t\t\t\tif (mxClient.IS_FF)\n\t\t\t\t{\n\t\t\t\t\tdelta = -evt.detail / 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelta = evt.wheelDelta / 120;\n\t\t\t\t}\n\n\t\t\t\t// Handles the event using the given function\n\t\t\t\tif (delta != 0)\n\t\t\t\t{\n\t\t\t\t\tfunct(evt, delta > 0);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Webkit has NS event API, but IE event name and details\n\t\t\tif (mxClient.IS_NS && document.documentMode == null)\n\t\t\t{\n\t\t\t\tvar eventName = (mxClient.IS_SF || mxClient.IS_GC) ? 'mousewheel' : 'DOMMouseScroll';\n\t\t\t\tmxEvent.addListener((mxClient.IS_GC && target != null) ? target : window,\n\t\t\t\t\teventName, wheelHandler);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxEvent.addListener(document, 'mousewheel', wheelHandler);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: disableContextMenu\n\t *\n\t * Disables the context menu for the given element.\n\t */\n\tdisableContextMenu: function(element)\n\t{\n\t\tmxEvent.addListener(element, 'contextmenu', function(evt)\n\t\t{\n\t\t\tif (evt.preventDefault)\n\t\t\t{\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t},\n\n\t/**\n\t * Function: getSource\n\t *\n\t * Returns the event's target or srcElement depending on the browser.\n\t */\n\tgetSource: function(evt)\n\t{\n\t\treturn (evt.srcElement != null) ? evt.srcElement : evt.target;\n\t},\n\n\t/**\n\t * Function: isConsumed\n\t *\n\t * Returns true if the event has been consumed using <consume>.\n\t */\n\tisConsumed: function(evt)\n\t{\n\t\treturn evt.isConsumed != null && evt.isConsumed;\n\t},\n\n\t/**\n\t * Function: isTouchEvent\n\t *\n\t * Returns true if the event was generated using a touch device (not a pen or mouse).\n\t */\n\tisTouchEvent: function(evt)\n\t{\n\t\treturn (evt.pointerType != null) ? (evt.pointerType == 'touch' || evt.pointerType ===\n\t\t\tevt.MSPOINTER_TYPE_TOUCH) : ((evt.mozInputSource != null) ?\n\t\t\t\t\tevt.mozInputSource == 5 : evt.type.indexOf('touch') == 0);\n\t},\n\n\t/**\n\t * Function: isPenEvent\n\t *\n\t * Returns true if the event was generated using a pen (not a touch device or mouse).\n\t */\n\tisPenEvent: function(evt)\n\t{\n\t\treturn (evt.pointerType != null) ? (evt.pointerType == 'pen' || evt.pointerType ===\n\t\t\tevt.MSPOINTER_TYPE_PEN) : ((evt.mozInputSource != null) ?\n\t\t\t\t\tevt.mozInputSource == 2 : evt.type.indexOf('pen') == 0);\n\t},\n\n\t/**\n\t * Function: isMultiTouchEvent\n\t *\n\t * Returns true if the event was generated using a touch device (not a pen or mouse).\n\t */\n\tisMultiTouchEvent: function(evt)\n\t{\n\t\treturn (evt.type != null && evt.type.indexOf('touch') == 0 && evt.touches != null && evt.touches.length > 1);\n\t},\n\n\t/**\n\t * Function: isMouseEvent\n\t *\n\t * Returns true if the event was generated using a mouse (not a pen or touch device).\n\t */\n\tisMouseEvent: function(evt)\n\t{\n\t\treturn (evt.pointerType != null) ? (evt.pointerType == 'mouse' || evt.pointerType ===\n\t\t\tevt.MSPOINTER_TYPE_MOUSE) : ((evt.mozInputSource != null) ?\n\t\t\t\tevt.mozInputSource == 1 : evt.type.indexOf('mouse') == 0);\n\t},\n\n\t/**\n\t * Function: isLeftMouseButton\n\t *\n\t * Returns true if the left mouse button is pressed for the given event.\n\t * To check if a button is pressed during a mouseMove you should use the\n\t * <mxGraph.isMouseDown> property. Note that this returns true in Firefox\n\t * for control+left-click on the Mac.\n\t */\n\tisLeftMouseButton: function(evt)\n\t{\n\t\t// Special case for mousemove and mousedown we check the buttons\n\t\t// if it exists because which is 0 even if no button is pressed\n\t\tif ('buttons' in evt && (evt.type == 'mousedown' || evt.type == 'mousemove'))\n\t\t{\n\t\t\treturn evt.buttons == 1;\n\t\t}\n\t\telse if ('which' in evt)\n\t\t{\n\t        return evt.which === 1;\n\t    }\n\t\telse\n\t\t{\n\t        return evt.button === 1;\n\t    }\n\t},\n\n\t/**\n\t * Function: isMiddleMouseButton\n\t *\n\t * Returns true if the middle mouse button is pressed for the given event.\n\t * To check if a button is pressed during a mouseMove you should use the\n\t * <mxGraph.isMouseDown> property.\n\t */\n\tisMiddleMouseButton: function(evt)\n\t{\n\t\tif ('which' in evt)\n\t\t{\n\t        return evt.which === 2;\n\t    }\n\t\telse\n\t\t{\n\t        return evt.button === 4;\n\t    }\n\t},\n\n\t/**\n\t * Function: isRightMouseButton\n\t *\n\t * Returns true if the right mouse button was pressed. Note that this\n\t * button might not be available on some systems. For handling a popup\n\t * trigger <isPopupTrigger> should be used.\n\t */\n\tisRightMouseButton: function(evt)\n\t{\n\t\tif ('which' in evt)\n\t\t{\n\t        return evt.which === 3;\n\t    }\n\t\telse\n\t\t{\n\t        return evt.button === 2;\n\t    }\n\t},\n\n\t/**\n\t * Function: isPopupTrigger\n\t *\n\t * Returns true if the event is a popup trigger. This implementation\n\t * returns true if the right button or the left button and control was\n\t * pressed on a Mac.\n\t */\n\tisPopupTrigger: function(evt)\n\t{\n\t\treturn mxEvent.isRightMouseButton(evt) || (mxClient.IS_MAC && mxEvent.isControlDown(evt) &&\n\t\t\t!mxEvent.isShiftDown(evt) && !mxEvent.isMetaDown(evt) && !mxEvent.isAltDown(evt));\n\t},\n\n\t/**\n\t * Function: isShiftDown\n\t *\n\t * Returns true if the shift key is pressed for the given event.\n\t */\n\tisShiftDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.shiftKey : false;\n\t},\n\n\t/**\n\t * Function: isAltDown\n\t *\n\t * Returns true if the alt key is pressed for the given event.\n\t */\n\tisAltDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.altKey : false;\n\t},\n\n\t/**\n\t * Function: isControlDown\n\t *\n\t * Returns true if the control key is pressed for the given event.\n\t */\n\tisControlDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.ctrlKey : false;\n\t},\n\n\t/**\n\t * Function: isMetaDown\n\t *\n\t * Returns true if the meta key is pressed for the given event.\n\t */\n\tisMetaDown: function(evt)\n\t{\n\t\treturn (evt != null) ? evt.metaKey : false;\n\t},\n\n\t/**\n\t * Function: getMainEvent\n\t *\n\t * Returns the touch or mouse event that contains the mouse coordinates.\n\t */\n\tgetMainEvent: function(e)\n\t{\n\t\tif ((e.type == 'touchstart' || e.type == 'touchmove') && e.touches != null && e.touches[0] != null)\n\t\t{\n\t\t\te = e.touches[0];\n\t\t}\n\t\telse if (e.type == 'touchend' && e.changedTouches != null && e.changedTouches[0] != null)\n\t\t{\n\t\t\te = e.changedTouches[0];\n\t\t}\n\n\t\treturn e;\n\t},\n\n\t/**\n\t * Function: getClientX\n\t *\n\t * Returns true if the meta key is pressed for the given event.\n\t */\n\tgetClientX: function(e)\n\t{\n\t\treturn mxEvent.getMainEvent(e).clientX;\n\t},\n\n\t/**\n\t * Function: getClientY\n\t *\n\t * Returns true if the meta key is pressed for the given event.\n\t */\n\tgetClientY: function(e)\n\t{\n\t\treturn mxEvent.getMainEvent(e).clientY;\n\t},\n\n\t/**\n\t * Function: consume\n\t *\n\t * Consumes the given event.\n\t *\n\t * Parameters:\n\t *\n\t * evt - Native event to be consumed.\n\t * preventDefault - Optional boolean to prevent the default for the event.\n\t * Default is true.\n\t * stopPropagation - Option boolean to stop event propagation. Default is\n\t * true.\n\t */\n\tconsume: function(evt, preventDefault, stopPropagation)\n\t{\n\t\tpreventDefault = (preventDefault != null) ? preventDefault : true;\n\t\tstopPropagation = (stopPropagation != null) ? stopPropagation : true;\n\n\t\tif (preventDefault)\n\t\t{\n\t\t\tif (evt.preventDefault)\n\t\t\t{\n\t\t\t\tif (stopPropagation)\n\t\t\t\t{\n\t\t\t\t\tevt.stopPropagation();\n\t\t\t\t}\n\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t\telse if (stopPropagation)\n\t\t\t{\n\t\t\t\tevt.cancelBubble = true;\n\t\t\t}\n\t\t}\n\n\t\t// Opera\n\t\tevt.isConsumed = true;\n\n\t\t// Other browsers\n\t\tif (!evt.preventDefault)\n\t\t{\n\t\t\tevt.returnValue = false;\n\t\t}\n\t},\n\n\t//\n\t// Special handles in mouse events\n\t//\n\n\t/**\n\t * Variable: LABEL_HANDLE\n\t *\n\t * Index for the label handle in an mxMouseEvent. This should be a negative\n\t * value that does not interfere with any possible handle indices. Default\n\t * is -1.\n\t */\n\tLABEL_HANDLE: -1,\n\n\t/**\n\t * Variable: ROTATION_HANDLE\n\t *\n\t * Index for the rotation handle in an mxMouseEvent. This should be a\n\t * negative value that does not interfere with any possible handle indices.\n\t * Default is -2.\n\t */\n\tROTATION_HANDLE: -2,\n\n\t/**\n\t * Variable: CUSTOM_HANDLE\n\t *\n\t * Start index for the custom handles in an mxMouseEvent. This should be a\n\t * negative value and is the start index which is decremented for each\n\t * custom handle. Default is -100.\n\t */\n\tCUSTOM_HANDLE: -100,\n\n\t/**\n\t * Variable: VIRTUAL_HANDLE\n\t *\n\t * Start index for the virtual handles in an mxMouseEvent. This should be a\n\t * negative value and is the start index which is decremented for each\n\t * virtual handle. Default is -100000. This assumes that there are no more\n\t * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.\n\t *\n\t */\n\tVIRTUAL_HANDLE: -100000,\n\n\t//\n\t// Event names\n\t//\n\n\t/**\n\t * Variable: MOUSE_DOWN\n\t *\n\t * Specifies the event name for mouseDown.\n\t */\n\tMOUSE_DOWN: 'mouseDown',\n\n\t/**\n\t * Variable: MOUSE_MOVE\n\t *\n\t * Specifies the event name for mouseMove.\n\t */\n\tMOUSE_MOVE: 'mouseMove',\n\n\t/**\n\t * Variable: MOUSE_UP\n\t *\n\t * Specifies the event name for mouseUp.\n\t */\n\tMOUSE_UP: 'mouseUp',\n\n\t/**\n\t * Variable: ACTIVATE\n\t *\n\t * Specifies the event name for activate.\n\t */\n\tACTIVATE: 'activate',\n\n\t/**\n\t * Variable: RESIZE_START\n\t *\n\t * Specifies the event name for resizeStart.\n\t */\n\tRESIZE_START: 'resizeStart',\n\n\t/**\n\t * Variable: RESIZE\n\t *\n\t * Specifies the event name for resize.\n\t */\n\tRESIZE: 'resize',\n\n\t/**\n\t * Variable: RESIZE_END\n\t *\n\t * Specifies the event name for resizeEnd.\n\t */\n\tRESIZE_END: 'resizeEnd',\n\n\t/**\n\t * Variable: MOVE_START\n\t *\n\t * Specifies the event name for moveStart.\n\t */\n\tMOVE_START: 'moveStart',\n\n\t/**\n\t * Variable: MOVE\n\t *\n\t * Specifies the event name for move.\n\t */\n\tMOVE: 'move',\n\n\t/**\n\t * Variable: MOVE_END\n\t *\n\t * Specifies the event name for moveEnd.\n\t */\n\tMOVE_END: 'moveEnd',\n\n\t/**\n\t * Variable: PAN_START\n\t *\n\t * Specifies the event name for panStart.\n\t */\n\tPAN_START: 'panStart',\n\n\t/**\n\t * Variable: PAN\n\t *\n\t * Specifies the event name for pan.\n\t */\n\tPAN: 'pan',\n\n\t/**\n\t * Variable: PAN_END\n\t *\n\t * Specifies the event name for panEnd.\n\t */\n\tPAN_END: 'panEnd',\n\n\t/**\n\t * Variable: MINIMIZE\n\t *\n\t * Specifies the event name for minimize.\n\t */\n\tMINIMIZE: 'minimize',\n\n\t/**\n\t * Variable: NORMALIZE\n\t *\n\t * Specifies the event name for normalize.\n\t */\n\tNORMALIZE: 'normalize',\n\n\t/**\n\t * Variable: MAXIMIZE\n\t *\n\t * Specifies the event name for maximize.\n\t */\n\tMAXIMIZE: 'maximize',\n\n\t/**\n\t * Variable: HIDE\n\t *\n\t * Specifies the event name for hide.\n\t */\n\tHIDE: 'hide',\n\n\t/**\n\t * Variable: SHOW\n\t *\n\t * Specifies the event name for show.\n\t */\n\tSHOW: 'show',\n\n\t/**\n\t * Variable: CLOSE\n\t *\n\t * Specifies the event name for close.\n\t */\n\tCLOSE: 'close',\n\n\t/**\n\t * Variable: DESTROY\n\t *\n\t * Specifies the event name for destroy.\n\t */\n\tDESTROY: 'destroy',\n\n\t/**\n\t * Variable: REFRESH\n\t *\n\t * Specifies the event name for refresh.\n\t */\n\tREFRESH: 'refresh',\n\n\t/**\n\t * Variable: SIZE\n\t *\n\t * Specifies the event name for size.\n\t */\n\tSIZE: 'size',\n\n\t/**\n\t * Variable: SELECT\n\t *\n\t * Specifies the event name for select.\n\t */\n\tSELECT: 'select',\n\n\t/**\n\t * Variable: FIRED\n\t *\n\t * Specifies the event name for fired.\n\t */\n\tFIRED: 'fired',\n\n\t/**\n\t * Variable: FIRE_MOUSE_EVENT\n\t *\n\t * Specifies the event name for fireMouseEvent.\n\t */\n\tFIRE_MOUSE_EVENT: 'fireMouseEvent',\n\n\t/**\n\t * Variable: GESTURE\n\t *\n\t * Specifies the event name for gesture.\n\t */\n\tGESTURE: 'gesture',\n\n\t/**\n\t * Variable: TAP_AND_HOLD\n\t *\n\t * Specifies the event name for tapAndHold.\n\t */\n\tTAP_AND_HOLD: 'tapAndHold',\n\n\t/**\n\t * Variable: GET\n\t *\n\t * Specifies the event name for get.\n\t */\n\tGET: 'get',\n\n\t/**\n\t * Variable: RECEIVE\n\t *\n\t * Specifies the event name for receive.\n\t */\n\tRECEIVE: 'receive',\n\n\t/**\n\t * Variable: CONNECT\n\t *\n\t * Specifies the event name for connect.\n\t */\n\tCONNECT: 'connect',\n\n\t/**\n\t * Variable: DISCONNECT\n\t *\n\t * Specifies the event name for disconnect.\n\t */\n\tDISCONNECT: 'disconnect',\n\n\t/**\n\t * Variable: SUSPEND\n\t *\n\t * Specifies the event name for suspend.\n\t */\n\tSUSPEND: 'suspend',\n\n\t/**\n\t * Variable: RESUME\n\t *\n\t * Specifies the event name for suspend.\n\t */\n\tRESUME: 'resume',\n\n\t/**\n\t * Variable: MARK\n\t *\n\t * Specifies the event name for mark.\n\t */\n\tMARK: 'mark',\n\n\t/**\n\t * Variable: ROOT\n\t *\n\t * Specifies the event name for root.\n\t */\n\tROOT: 'root',\n\n\t/**\n\t * Variable: POST\n\t *\n\t * Specifies the event name for post.\n\t */\n\tPOST: 'post',\n\n\t/**\n\t * Variable: OPEN\n\t *\n\t * Specifies the event name for open.\n\t */\n\tOPEN: 'open',\n\n\t/**\n\t * Variable: SAVE\n\t *\n\t * Specifies the event name for open.\n\t */\n\tSAVE: 'save',\n\n\t/**\n\t * Variable: BEFORE_ADD_VERTEX\n\t *\n\t * Specifies the event name for beforeAddVertex.\n\t */\n\tBEFORE_ADD_VERTEX: 'beforeAddVertex',\n\n\t/**\n\t * Variable: ADD_VERTEX\n\t *\n\t * Specifies the event name for addVertex.\n\t */\n\tADD_VERTEX: 'addVertex',\n\n\t/**\n\t * Variable: AFTER_ADD_VERTEX\n\t *\n\t * Specifies the event name for afterAddVertex.\n\t */\n\tAFTER_ADD_VERTEX: 'afterAddVertex',\n\n\t/**\n\t * Variable: DONE\n\t *\n\t * Specifies the event name for done.\n\t */\n\tDONE: 'done',\n\n\t/**\n\t * Variable: EXECUTE\n\t *\n\t * Specifies the event name for execute.\n\t */\n\tEXECUTE: 'execute',\n\n\t/**\n\t * Variable: EXECUTED\n\t *\n\t * Specifies the event name for executed.\n\t */\n\tEXECUTED: 'executed',\n\n\t/**\n\t * Variable: BEGIN_UPDATE\n\t *\n\t * Specifies the event name for beginUpdate.\n\t */\n\tBEGIN_UPDATE: 'beginUpdate',\n\n\t/**\n\t * Variable: START_EDIT\n\t *\n\t * Specifies the event name for startEdit.\n\t */\n\tSTART_EDIT: 'startEdit',\n\n\t/**\n\t * Variable: END_UPDATE\n\t *\n\t * Specifies the event name for endUpdate.\n\t */\n\tEND_UPDATE: 'endUpdate',\n\n\t/**\n\t * Variable: END_EDIT\n\t *\n\t * Specifies the event name for endEdit.\n\t */\n\tEND_EDIT: 'endEdit',\n\n\t/**\n\t * Variable: BEFORE_UNDO\n\t *\n\t * Specifies the event name for beforeUndo.\n\t */\n\tBEFORE_UNDO: 'beforeUndo',\n\n\t/**\n\t * Variable: UNDO\n\t *\n\t * Specifies the event name for undo.\n\t */\n\tUNDO: 'undo',\n\n\t/**\n\t * Variable: REDO\n\t *\n\t * Specifies the event name for redo.\n\t */\n\tREDO: 'redo',\n\n\t/**\n\t * Variable: CHANGE\n\t *\n\t * Specifies the event name for change.\n\t */\n\tCHANGE: 'change',\n\n\t/**\n\t * Variable: NOTIFY\n\t *\n\t * Specifies the event name for notify.\n\t */\n\tNOTIFY: 'notify',\n\n\t/**\n\t * Variable: LAYOUT_CELLS\n\t *\n\t * Specifies the event name for layoutCells.\n\t */\n\tLAYOUT_CELLS: 'layoutCells',\n\n\t/**\n\t * Variable: CLICK\n\t *\n\t * Specifies the event name for click.\n\t */\n\tCLICK: 'click',\n\n\t/**\n\t * Variable: SCALE\n\t *\n\t * Specifies the event name for scale.\n\t */\n\tSCALE: 'scale',\n\n\t/**\n\t * Variable: TRANSLATE\n\t *\n\t * Specifies the event name for translate.\n\t */\n\tTRANSLATE: 'translate',\n\n\t/**\n\t * Variable: SCALE_AND_TRANSLATE\n\t *\n\t * Specifies the event name for scaleAndTranslate.\n\t */\n\tSCALE_AND_TRANSLATE: 'scaleAndTranslate',\n\n\t/**\n\t * Variable: UP\n\t *\n\t * Specifies the event name for up.\n\t */\n\tUP: 'up',\n\n\t/**\n\t * Variable: DOWN\n\t *\n\t * Specifies the event name for down.\n\t */\n\tDOWN: 'down',\n\n\t/**\n\t * Variable: ADD\n\t *\n\t * Specifies the event name for add.\n\t */\n\tADD: 'add',\n\n\t/**\n\t * Variable: REMOVE\n\t *\n\t * Specifies the event name for remove.\n\t */\n\tREMOVE: 'remove',\n\n\t/**\n\t * Variable: CLEAR\n\t *\n\t * Specifies the event name for clear.\n\t */\n\tCLEAR: 'clear',\n\n\t/**\n\t * Variable: ADD_CELLS\n\t *\n\t * Specifies the event name for addCells.\n\t */\n\tADD_CELLS: 'addCells',\n\n\t/**\n\t * Variable: CELLS_ADDED\n\t *\n\t * Specifies the event name for cellsAdded.\n\t */\n\tCELLS_ADDED: 'cellsAdded',\n\n\t/**\n\t * Variable: MOVE_CELLS\n\t *\n\t * Specifies the event name for moveCells.\n\t */\n\tMOVE_CELLS: 'moveCells',\n\n\t/**\n\t * Variable: CELLS_MOVED\n\t *\n\t * Specifies the event name for cellsMoved.\n\t */\n\tCELLS_MOVED: 'cellsMoved',\n\n\t/**\n\t * Variable: RESIZE_CELLS\n\t *\n\t * Specifies the event name for resizeCells.\n\t */\n\tRESIZE_CELLS: 'resizeCells',\n\n\t/**\n\t * Variable: CELLS_RESIZED\n\t *\n\t * Specifies the event name for cellsResized.\n\t */\n\tCELLS_RESIZED: 'cellsResized',\n\n\t/**\n\t * Variable: TOGGLE_CELLS\n\t *\n\t * Specifies the event name for toggleCells.\n\t */\n\tTOGGLE_CELLS: 'toggleCells',\n\n\t/**\n\t * Variable: CELLS_TOGGLED\n\t *\n\t * Specifies the event name for cellsToggled.\n\t */\n\tCELLS_TOGGLED: 'cellsToggled',\n\n\t/**\n\t * Variable: ORDER_CELLS\n\t *\n\t * Specifies the event name for orderCells.\n\t */\n\tORDER_CELLS: 'orderCells',\n\n\t/**\n\t * Variable: CELLS_ORDERED\n\t *\n\t * Specifies the event name for cellsOrdered.\n\t */\n\tCELLS_ORDERED: 'cellsOrdered',\n\n\t/**\n\t * Variable: REMOVE_CELLS\n\t *\n\t * Specifies the event name for removeCells.\n\t */\n\tREMOVE_CELLS: 'removeCells',\n\n\t/**\n\t * Variable: CELLS_REMOVED\n\t *\n\t * Specifies the event name for cellsRemoved.\n\t */\n\tCELLS_REMOVED: 'cellsRemoved',\n\n\t/**\n\t * Variable: GROUP_CELLS\n\t *\n\t * Specifies the event name for groupCells.\n\t */\n\tGROUP_CELLS: 'groupCells',\n\n\t/**\n\t * Variable: UNGROUP_CELLS\n\t *\n\t * Specifies the event name for ungroupCells.\n\t */\n\tUNGROUP_CELLS: 'ungroupCells',\n\n\t/**\n\t * Variable: REMOVE_CELLS_FROM_PARENT\n\t *\n\t * Specifies the event name for removeCellsFromParent.\n\t */\n\tREMOVE_CELLS_FROM_PARENT: 'removeCellsFromParent',\n\n\t/**\n\t * Variable: FOLD_CELLS\n\t *\n\t * Specifies the event name for foldCells.\n\t */\n\tFOLD_CELLS: 'foldCells',\n\n\t/**\n\t * Variable: CELLS_FOLDED\n\t *\n\t * Specifies the event name for cellsFolded.\n\t */\n\tCELLS_FOLDED: 'cellsFolded',\n\n\t/**\n\t * Variable: ALIGN_CELLS\n\t *\n\t * Specifies the event name for alignCells.\n\t */\n\tALIGN_CELLS: 'alignCells',\n\n\t/**\n\t * Variable: LABEL_CHANGED\n\t *\n\t * Specifies the event name for labelChanged.\n\t */\n\tLABEL_CHANGED: 'labelChanged',\n\n\t/**\n\t * Variable: CONNECT_CELL\n\t *\n\t * Specifies the event name for connectCell.\n\t */\n\tCONNECT_CELL: 'connectCell',\n\n\t/**\n\t * Variable: CELL_CONNECTED\n\t *\n\t * Specifies the event name for cellConnected.\n\t */\n\tCELL_CONNECTED: 'cellConnected',\n\n\t/**\n\t * Variable: SPLIT_EDGE\n\t *\n\t * Specifies the event name for splitEdge.\n\t */\n\tSPLIT_EDGE: 'splitEdge',\n\n\t/**\n\t * Variable: FLIP_EDGE\n\t *\n\t * Specifies the event name for flipEdge.\n\t */\n\tFLIP_EDGE: 'flipEdge',\n\n\t/**\n\t * Variable: START_EDITING\n\t *\n\t * Specifies the event name for startEditing.\n\t */\n\tSTART_EDITING: 'startEditing',\n\n\t/**\n\t * Variable: EDITING_STARTED\n\t *\n\t * Specifies the event name for editingStarted.\n\t */\n\tEDITING_STARTED: 'editingStarted',\n\n\t/**\n\t * Variable: EDITING_STOPPED\n\t *\n\t * Specifies the event name for editingStopped.\n\t */\n\tEDITING_STOPPED: 'editingStopped',\n\n\t/**\n\t * Variable: ADD_OVERLAY\n\t *\n\t * Specifies the event name for addOverlay.\n\t */\n\tADD_OVERLAY: 'addOverlay',\n\n\t/**\n\t * Variable: REMOVE_OVERLAY\n\t *\n\t * Specifies the event name for removeOverlay.\n\t */\n\tREMOVE_OVERLAY: 'removeOverlay',\n\n\t/**\n\t * Variable: UPDATE_CELL_SIZE\n\t *\n\t * Specifies the event name for updateCellSize.\n\t */\n\tUPDATE_CELL_SIZE: 'updateCellSize',\n\n\t/**\n\t * Variable: ESCAPE\n\t *\n\t * Specifies the event name for escape.\n\t */\n\tESCAPE: 'escape',\n\n\t/**\n\t * Variable: DOUBLE_CLICK\n\t *\n\t * Specifies the event name for doubleClick.\n\t */\n\tDOUBLE_CLICK: 'doubleClick',\n\n\t/**\n\t * Variable: START\n\t *\n\t * Specifies the event name for start.\n\t */\n\tSTART: 'start',\n\n\t/**\n\t * Variable: RESET\n\t *\n\t * Specifies the event name for reset.\n\t */\n\tRESET: 'reset'\n\n};\n\n__mxOutput.mxEvent = typeof mxEvent !== 'undefined' ? mxEvent : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxXmlRequest\n *\n * XML HTTP request wrapper. See also: <mxUtils.get>, <mxUtils.post> and\n * <mxUtils.load>. This class provides a cross-browser abstraction for Ajax\n * requests.\n *\n * Encoding:\n *\n * For encoding parameter values, the built-in encodeURIComponent JavaScript\n * method must be used. For automatic encoding of post data in <mxEditor> the\n * <mxEditor.escapePostData> switch can be set to true (default). The encoding\n * will be carried out using the conte type of the page. That is, the page\n * containting the editor should contain a meta tag in the header, eg.\n * <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n *\n * Example:\n *\n * (code)\n * var onload = function(req)\n * {\n *   mxUtils.alert(req.getDocumentElement());\n * }\n *\n * var onerror = function(req)\n * {\n *   mxUtils.alert('Error');\n * }\n * new mxXmlRequest(url, 'key=value').send(onload, onerror);\n * (end)\n *\n * Sends an asynchronous POST request to the specified URL.\n *\n * Example:\n *\n * (code)\n * var req = new mxXmlRequest(url, 'key=value', 'POST', false);\n * req.send();\n * mxUtils.alert(req.getDocumentElement());\n * (end)\n *\n * Sends a synchronous POST request to the specified URL.\n *\n * Example:\n *\n * (code)\n * var encoder = new mxCodec();\n * var result = encoder.encode(graph.getModel());\n * var xml = encodeURIComponent(mxUtils.getXml(result));\n * new mxXmlRequest(url, 'xml='+xml).send();\n * (end)\n *\n * Sends an encoded graph model to the specified URL using xml as the\n * parameter name. The parameter can then be retrieved in C# as follows:\n *\n * (code)\n * string xml = HttpUtility.UrlDecode(context.Request.Params[\"xml\"]);\n * (end)\n *\n * Or in Java as follows:\n *\n * (code)\n * String xml = URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\");\n * (end)\n *\n * Note that the linefeeds should only be replaced if the XML is\n * processed in Java, for example when creating an image.\n *\n * Constructor: mxXmlRequest\n *\n * Constructs an XML HTTP request.\n *\n * Parameters:\n *\n * url - Target URL of the request.\n * params - Form encoded parameters to send with a POST request.\n * method - String that specifies the request method. Possible values are\n * POST and GET. Default is POST.\n * async - Boolean specifying if an asynchronous request should be used.\n * Default is true.\n * username - String specifying the username to be used for the request.\n * password - String specifying the password to be used for the request.\n */\nfunction mxXmlRequest(url, params, method, async, username, password)\n{\n\tthis.url = url;\n\tthis.params = params;\n\tthis.method = method || 'POST';\n\tthis.async = (async != null) ? async : true;\n\tthis.username = username;\n\tthis.password = password;\n};\n\n/**\n * Variable: url\n *\n * Holds the target URL of the request.\n */\nmxXmlRequest.prototype.url = null;\n\n/**\n * Variable: params\n *\n * Holds the form encoded data for the POST request.\n */\nmxXmlRequest.prototype.params = null;\n\n/**\n * Variable: method\n *\n * Specifies the request method. Possible values are POST and GET. Default\n * is POST.\n */\nmxXmlRequest.prototype.method = null;\n\n/**\n * Variable: async\n *\n * Boolean indicating if the request is asynchronous.\n */\nmxXmlRequest.prototype.async = null;\n\n/**\n * Variable: binary\n *\n * Boolean indicating if the request is binary. This option is ignored in IE.\n * In all other browsers the requested mime type is set to\n * text/plain; charset=x-user-defined. Default is false.\n */\nmxXmlRequest.prototype.binary = false;\n\n/**\n * Variable: withCredentials\n *\n * Specifies if withCredentials should be used in HTML5-compliant browsers. Default is\n * false.\n */\nmxXmlRequest.prototype.withCredentials = false;\n\n/**\n * Variable: username\n *\n * Specifies the username to be used for authentication.\n */\nmxXmlRequest.prototype.username = null;\n\n/**\n * Variable: password\n *\n * Specifies the password to be used for authentication.\n */\nmxXmlRequest.prototype.password = null;\n\n/**\n * Variable: request\n *\n * Holds the inner, browser-specific request object.\n */\nmxXmlRequest.prototype.request = null;\n\n/**\n * Variable: decodeSimulateValues\n *\n * Specifies if request values should be decoded as URIs before setting the\n * textarea value in <simulate>. Defaults to false for backwards compatibility,\n * to avoid another decode on the server this should be set to true.\n */\nmxXmlRequest.prototype.decodeSimulateValues = false;\n\n/**\n * Function: isBinary\n *\n * Returns <binary>.\n */\nmxXmlRequest.prototype.isBinary = function()\n{\n\treturn this.binary;\n};\n\n/**\n * Function: setBinary\n *\n * Sets <binary>.\n */\nmxXmlRequest.prototype.setBinary = function(value)\n{\n\tthis.binary = value;\n};\n\n/**\n * Function: getText\n *\n * Returns the response as a string.\n */\nmxXmlRequest.prototype.getText = function()\n{\n\treturn this.request.responseText;\n};\n\n/**\n * Function: isReady\n *\n * Returns true if the response is ready.\n */\nmxXmlRequest.prototype.isReady = function()\n{\n\treturn this.request.readyState == 4;\n};\n\n/**\n * Function: getDocumentElement\n *\n * Returns the document element of the response XML document.\n */\nmxXmlRequest.prototype.getDocumentElement = function()\n{\n\tvar doc = this.getXml();\n\n\tif (doc != null)\n\t{\n\t\treturn doc.documentElement;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getXml\n *\n * Returns the response as an XML document. Use <getDocumentElement> to get\n * the document element of the XML document.\n */\nmxXmlRequest.prototype.getXml = function()\n{\n\tvar xml = this.request.responseXML;\n\n\t// Handles missing response headers in IE, the first condition handles\n\t// the case where responseXML is there, but using its nodes leads to\n\t// type errors in the mxCellCodec when putting the nodes into a new\n\t// document. This happens in IE9 standards mode and with XML user\n\t// objects only, as they are used directly as values in cells.\n\tif (document.documentMode >= 9 || xml == null || xml.documentElement == null)\n\t{\n\t\txml = mxUtils.parseXml(this.request.responseText);\n\t}\n\n\treturn xml;\n};\n\n/**\n * Function: getText\n *\n * Returns the response as a string.\n */\nmxXmlRequest.prototype.getText = function()\n{\n\treturn this.request.responseText;\n};\n\n/**\n * Function: getStatus\n *\n * Returns the status as a number, eg. 404 for \"Not found\" or 200 for \"OK\".\n * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be cought.\n */\nmxXmlRequest.prototype.getStatus = function()\n{\n\treturn this.request.status;\n};\n\n/**\n * Function: create\n *\n * Creates and returns the inner <request> object.\n */\nmxXmlRequest.prototype.create = function()\n{\n\tif (window.XMLHttpRequest)\n\t{\n\t\treturn function()\n\t\t{\n\t\t\tvar req = new XMLHttpRequest();\n\n\t\t\t// TODO: Check for overrideMimeType required here?\n\t\t\tif (this.isBinary() && req.overrideMimeType)\n\t\t\t{\n\t\t\t\treq.overrideMimeType('text/plain; charset=x-user-defined');\n\t\t\t}\n\n\t\t\treturn req;\n\t\t};\n\t}\n\telse if (typeof(ActiveXObject) != 'undefined')\n\t{\n\t\treturn function()\n\t\t{\n\t\t\t// TODO: Implement binary option\n\t\t\treturn new ActiveXObject('Microsoft.XMLHTTP');\n\t\t};\n\t}\n}();\n\n/**\n * Function: send\n *\n * Send the <request> to the target URL using the specified functions to\n * process the response asychronously.\n *\n * Note: Due to technical limitations, onerror is currently ignored.\n *\n * Parameters:\n *\n * onload - Function to be invoked if a successful response was received.\n * onerror - Function to be called on any error.\n * timeout - Optional timeout in ms before calling ontimeout.\n * ontimeout - Optional function to execute on timeout.\n */\nmxXmlRequest.prototype.send = function(onload, onerror, timeout, ontimeout)\n{\n\tthis.request = this.create();\n\n\tif (this.request != null)\n\t{\n\t\tif (onload != null)\n\t\t{\n\t\t\tthis.request.onreadystatechange = mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tif (this.isReady())\n\t\t\t\t{\n\t\t\t\t\tonload(this);\n\t\t\t\t\tthis.request.onreadystatechaange = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.request.open(this.method, this.url, this.async,\n\t\t\tthis.username, this.password);\n\t\tthis.setRequestHeaders(this.request, this.params);\n\n\t\tif (window.XMLHttpRequest && this.withCredentials)\n\t\t{\n\t\t\tthis.request.withCredentials = 'true';\n\t\t}\n\n\t\tif (!mxClient.IS_QUIRKS && (document.documentMode == null || document.documentMode > 9) &&\n\t\t\twindow.XMLHttpRequest && timeout != null && ontimeout != null)\n\t\t{\n\t\t\tthis.request.timeout = timeout;\n\t\t\tthis.request.ontimeout = ontimeout;\n\t\t}\n\n\t\tthis.request.send(this.params);\n\t}\n};\n\n/**\n * Function: setRequestHeaders\n *\n * Sets the headers for the given request and parameters. This sets the\n * content-type to application/x-www-form-urlencoded if any params exist.\n *\n * Example:\n *\n * (code)\n * request.setRequestHeaders = function(request, params)\n * {\n *   if (params != null)\n *   {\n *     request.setRequestHeader('Content-Type',\n *             'multipart/form-data');\n *     request.setRequestHeader('Content-Length',\n *             params.length);\n *   }\n * };\n * (end)\n *\n * Use the code above before calling <send> if you require a\n * multipart/form-data request.\n */\nmxXmlRequest.prototype.setRequestHeaders = function(request, params)\n{\n\tif (params != null)\n\t{\n\t\trequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n\t}\n};\n\n/**\n * Function: simulate\n *\n * Creates and posts a request to the given target URL using a dynamically\n * created form inside the given document.\n *\n * Parameters:\n *\n * docs - Document that contains the form element.\n * target - Target to send the form result to.\n */\nmxXmlRequest.prototype.simulate = function(doc, target)\n{\n\tdoc = doc || document;\n\tvar old = null;\n\n\tif (doc == document)\n\t{\n\t\told = window.onbeforeunload;\n\t\twindow.onbeforeunload = null;\n\t}\n\n\tvar form = doc.createElement('form');\n\tform.setAttribute('method', this.method);\n\tform.setAttribute('action', this.url);\n\n\tif (target != null)\n\t{\n\t\tform.setAttribute('target', target);\n\t}\n\n\tform.style.display = 'none';\n\tform.style.visibility = 'hidden';\n\n\tvar pars = (this.params.indexOf('&') > 0) ?\n\t\tthis.params.split('&') :\n\t\tthis.params.split();\n\n\t// Adds the parameters as textareas to the form\n\tfor (var i=0; i<pars.length; i++)\n\t{\n\t\tvar pos = pars[i].indexOf('=');\n\n\t\tif (pos > 0)\n\t\t{\n\t\t\tvar name = pars[i].substring(0, pos);\n\t\t\tvar value = pars[i].substring(pos+1);\n\n\t\t\tif (this.decodeSimulateValues)\n\t\t\t{\n\t\t\t\tvalue = decodeURIComponent(value);\n\t\t\t}\n\n\t\t\tvar textarea = doc.createElement('textarea');\n\t\t\ttextarea.setAttribute('wrap', 'off');\n\t\t\ttextarea.setAttribute('name', name);\n\t\t\tmxUtils.write(textarea, value);\n\t\t\tform.appendChild(textarea);\n\t\t}\n\t}\n\n\tdoc.body.appendChild(form);\n\tform.submit();\n\n\tif (form.parentNode != null)\n\t{\n\t\tform.parentNode.removeChild(form);\n\t}\n\n\tif (old != null)\n\t{\n\t\twindow.onbeforeunload = old;\n\t}\n};\n\n__mxOutput.mxXmlRequest = typeof mxXmlRequest !== 'undefined' ? mxXmlRequest : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxClipboard =\n{\n\t/**\n\t * Class: mxClipboard\n\t *\n\t * Singleton that implements a clipboard for graph cells.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * mxClipboard.copy(graph);\n\t * mxClipboard.paste(graph2);\n\t * (end)\n\t *\n\t * This copies the selection cells from the graph to the clipboard and\n\t * pastes them into graph2.\n\t *\n\t * For fine-grained control of the clipboard data the <mxGraph.canExportCell>\n\t * and <mxGraph.canImportCell> functions can be overridden.\n\t *\n\t * To restore previous parents for pasted cells, the implementation for\n\t * <copy> and <paste> can be changed as follows.\n\t *\n\t * (code)\n\t * mxClipboard.copy = function(graph, cells)\n\t * {\n\t *   cells = cells || graph.getSelectionCells();\n\t *   var result = graph.getExportableCells(cells);\n\t *\n\t *   mxClipboard.parents = new Object();\n\t *\n\t *   for (var i = 0; i < result.length; i++)\n\t *   {\n\t *     mxClipboard.parents[i] = graph.model.getParent(cells[i]);\n\t *   }\n\t *\n\t *   mxClipboard.insertCount = 1;\n\t *   mxClipboard.setCells(graph.cloneCells(result));\n\t *\n\t *   return result;\n\t * };\n\t *\n\t * mxClipboard.paste = function(graph)\n\t * {\n\t *   if (!mxClipboard.isEmpty())\n\t *   {\n\t *     var cells = graph.getImportableCells(mxClipboard.getCells());\n\t *     var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;\n\t *     var parent = graph.getDefaultParent();\n\t *\n\t *     graph.model.beginUpdate();\n\t *     try\n\t *     {\n\t *       for (var i = 0; i < cells.length; i++)\n\t *       {\n\t *         var tmp = (mxClipboard.parents != null && graph.model.contains(mxClipboard.parents[i])) ?\n\t *              mxClipboard.parents[i] : parent;\n\t *         cells[i] = graph.importCells([cells[i]], delta, delta, tmp)[0];\n\t *       }\n\t *     }\n\t *     finally\n\t *     {\n\t *       graph.model.endUpdate();\n\t *     }\n\t *\n\t *     // Increments the counter and selects the inserted cells\n\t *     mxClipboard.insertCount++;\n\t *     graph.setSelectionCells(cells);\n\t *   }\n\t * };\n\t * (end)\n\t *\n\t * Variable: STEPSIZE\n\t *\n\t * Defines the step size to offset the cells after each paste operation.\n\t * Default is 10.\n\t */\n\tSTEPSIZE: 10,\n\n\t/**\n\t * Variable: insertCount\n\t *\n\t * Counts the number of times the clipboard data has been inserted.\n\t */\n\tinsertCount: 1,\n\n\t/**\n\t * Variable: cells\n\t *\n\t * Holds the array of <mxCells> currently in the clipboard.\n\t */\n\tcells: null,\n\n\t/**\n\t * Function: setCells\n\t *\n\t * Sets the cells in the clipboard. Fires a <mxEvent.CHANGE> event.\n\t */\n\tsetCells: function(cells)\n\t{\n\t\tmxClipboard.cells = cells;\n\t},\n\n\t/**\n\t * Function: getCells\n\t *\n\t * Returns  the cells in the clipboard.\n\t */\n\tgetCells: function()\n\t{\n\t\treturn mxClipboard.cells;\n\t},\n\n\t/**\n\t * Function: isEmpty\n\t *\n\t * Returns true if the clipboard currently has not data stored.\n\t */\n\tisEmpty: function()\n\t{\n\t\treturn mxClipboard.getCells() == null;\n\t},\n\n\t/**\n\t * Function: cut\n\t *\n\t * Cuts the given array of <mxCells> from the specified graph.\n\t * If cells is null then the selection cells of the graph will\n\t * be used. Returns the cells that have been cut from the graph.\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> that contains the cells to be cut.\n\t * cells - Optional array of <mxCells> to be cut.\n\t */\n\tcut: function(graph, cells)\n\t{\n\t\tcells = mxClipboard.copy(graph, cells);\n\t\tmxClipboard.insertCount = 0;\n\t\tmxClipboard.removeCells(graph, cells);\n\n\t\treturn cells;\n\t},\n\n\t/**\n\t * Function: removeCells\n\t *\n\t * Hook to remove the given cells from the given graph after\n\t * a cut operation.\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> that contains the cells to be cut.\n\t * cells - Array of <mxCells> to be cut.\n\t */\n\tremoveCells: function(graph, cells)\n\t{\n\t\tgraph.removeCells(cells);\n\t},\n\n\t/**\n\t * Function: copy\n\t *\n\t * Copies the given array of <mxCells> from the specified\n\t * graph to <cells>. Returns the original array of cells that has\n\t * been cloned. Descendants of cells in the array are ignored.\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> that contains the cells to be copied.\n\t * cells - Optional array of <mxCells> to be copied.\n\t */\n\tcopy: function(graph, cells)\n\t{\n\t\tcells = cells || graph.getSelectionCells();\n\t\tvar result = graph.getExportableCells(graph.model.getTopmostCells(cells));\n\t\tmxClipboard.insertCount = 1;\n\t\tmxClipboard.setCells(graph.cloneCells(result));\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: paste\n\t *\n\t * Pastes the <cells> into the specified graph restoring\n\t * the relation to <parents>, if possible. If the parents\n\t * are no longer in the graph or invisible then the\n\t * cells are added to the graph's default or into the\n\t * swimlane under the cell's new location if one exists.\n\t * The cells are added to the graph using <mxGraph.importCells>\n\t * and returned.\n\t *\n\t * Parameters:\n\t *\n\t * graph - <mxGraph> to paste the <cells> into.\n\t */\n\tpaste: function(graph)\n\t{\n\t\tvar cells = null;\n\n\t\tif (!mxClipboard.isEmpty())\n\t\t{\n\t\t\tcells = graph.getImportableCells(mxClipboard.getCells());\n\t\t\tvar delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;\n\t\t\tvar parent = graph.getDefaultParent();\n\t\t\tcells = graph.importCells(cells, delta, delta, parent);\n\n\t\t\t// Increments the counter and selects the inserted cells\n\t\t\tmxClipboard.insertCount++;\n\t\t\tgraph.setSelectionCells(cells);\n\t\t}\n\n\t\treturn cells;\n\t}\n\n};\n\n__mxOutput.mxClipboard = typeof mxClipboard !== 'undefined' ? mxClipboard : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxWindow\n *\n * Basic window inside a document.\n *\n * Examples:\n *\n * Creating a simple window.\n *\n * (code)\n * var tb = document.createElement('div');\n * var wnd = new mxWindow('Title', tb, 100, 100, 200, 200, true, true);\n * wnd.setVisible(true);\n * (end)\n *\n * Creating a window that contains an iframe.\n *\n * (code)\n * var frame = document.createElement('iframe');\n * frame.setAttribute('width', '192px');\n * frame.setAttribute('height', '172px');\n * frame.setAttribute('src', 'http://www.example.com/');\n * frame.style.backgroundColor = 'white';\n *\n * var w = document.body.clientWidth;\n * var h = (document.body.clientHeight || document.documentElement.clientHeight);\n * var wnd = new mxWindow('Title', frame, (w-200)/2, (h-200)/3, 200, 200);\n * wnd.setVisible(true);\n * (end)\n *\n * To limit the movement of a window, eg. to keep it from being moved beyond\n * the top, left corner the following method can be overridden (recommended):\n *\n * (code)\n * wnd.setLocation = function(x, y)\n * {\n *   x = Math.max(0, x);\n *   y = Math.max(0, y);\n *   mxWindow.prototype.setLocation.apply(this, arguments);\n * };\n * (end)\n *\n * Or the following event handler can be used:\n *\n * (code)\n * wnd.addListener(mxEvent.MOVE, function(e)\n * {\n *   wnd.setLocation(Math.max(0, wnd.getX()), Math.max(0, wnd.getY()));\n * });\n * (end)\n *\n * To keep a window inside the current window:\n *\n * (code)\n * mxEvent.addListener(window, 'resize', mxUtils.bind(this, function()\n * {\n *   var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n *   var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n *\n *   var x = this.window.getX();\n *   var y = this.window.getY();\n *\n *   if (x + this.window.table.clientWidth > iw)\n *   {\n *     x = Math.max(0, iw - this.window.table.clientWidth);\n *   }\n *\n *   if (y + this.window.table.clientHeight > ih)\n *   {\n *     y = Math.max(0, ih - this.window.table.clientHeight);\n *   }\n *\n *   if (this.window.getX() != x || this.window.getY() != y)\n *   {\n *     this.window.setLocation(x, y);\n *   }\n * }));\n * (end)\n *\n * Event: mxEvent.MOVE_START\n *\n * Fires before the window is moved. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.MOVE\n *\n * Fires while the window is being moved. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * Event: mxEvent.MOVE_END\n *\n * Fires after the window is moved. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.RESIZE_START\n *\n * Fires before the window is resized. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.RESIZE\n *\n * Fires while the window is being resized. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * Event: mxEvent.RESIZE_END\n *\n * Fires after the window is resized. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.MAXIMIZE\n *\n * Fires after the window is maximized. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * Event: mxEvent.MINIMIZE\n *\n * Fires after the window is minimized. The <code>event</code> property\n * contains the corresponding mouse event.\n *\n * Event: mxEvent.NORMALIZE\n *\n * Fires after the window is normalized, that is, it returned from\n * maximized or minimized state. The <code>event</code> property contains the\n * corresponding mouse event.\n *\n * Event: mxEvent.ACTIVATE\n *\n * Fires after a window is activated. The <code>previousWindow</code> property\n * contains the previous window. The event sender is the active window.\n *\n * Event: mxEvent.SHOW\n *\n * Fires after the window is shown. This event has no properties.\n *\n * Event: mxEvent.HIDE\n *\n * Fires after the window is hidden. This event has no properties.\n *\n * Event: mxEvent.CLOSE\n *\n * Fires before the window is closed. The <code>event</code> property contains\n * the corresponding mouse event.\n *\n * Event: mxEvent.DESTROY\n *\n * Fires before the window is destroyed. This event has no properties.\n *\n * Constructor: mxWindow\n *\n * Constructs a new window with the given dimension and title to display\n * the specified content. The window elements use the given style as a\n * prefix for the classnames of the respective window elements, namely,\n * the window title and window pane. The respective postfixes are appended\n * to the given stylename as follows:\n *\n *   style - Base style for the window.\n *   style+Title - Style for the window title.\n *   style+Pane - Style for the window pane.\n *\n * The default value for style is mxWindow, resulting in the following\n * classnames for the window elements: mxWindow, mxWindowTitle and\n * mxWindowPane.\n *\n * If replaceNode is given then the window replaces the given DOM node in\n * the document.\n *\n * Parameters:\n *\n * title - String that represents the title of the new window.\n * content - DOM node that is used as the window content.\n * x - X-coordinate of the window location.\n * y - Y-coordinate of the window location.\n * width - Width of the window.\n * height - Optional height of the window. Default is to match the height\n * of the content at the specified width.\n * minimizable - Optional boolean indicating if the window is minimizable.\n * Default is true.\n * movable - Optional boolean indicating if the window is movable. Default\n * is true.\n * replaceNode - Optional DOM node that the window should replace.\n * style - Optional base classname for the window elements. Default is\n * mxWindow.\n */\nfunction mxWindow(title, content, x, y, width, height, minimizable, movable, replaceNode, style)\n{\n\tif (content != null)\n\t{\n\t\tminimizable = (minimizable != null) ? minimizable : true;\n\t\tthis.content = content;\n\t\tthis.init(x, y, width, height, style);\n\n\t\tthis.installMaximizeHandler();\n\t\tthis.installMinimizeHandler();\n\t\tthis.installCloseHandler();\n\t\tthis.setMinimizable(minimizable);\n\t\tthis.setTitle(title);\n\n\t\tif (movable == null || movable)\n\t\t{\n\t\t\tthis.installMoveHandler();\n\t\t}\n\n\t\tif (replaceNode != null && replaceNode.parentNode != null)\n\t\t{\n\t\t\treplaceNode.parentNode.replaceChild(this.div, replaceNode);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.body.appendChild(this.div);\n\t\t}\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxWindow.prototype = new mxEventSource();\nmxWindow.prototype.constructor = mxWindow;\n\n/**\n * Variable: closeImage\n *\n * URL of the image to be used for the close icon in the titlebar.\n */\nmxWindow.prototype.closeImage = mxClient.imageBasePath + '/close.gif';\n\n/**\n * Variable: minimizeImage\n *\n * URL of the image to be used for the minimize icon in the titlebar.\n */\nmxWindow.prototype.minimizeImage = mxClient.imageBasePath + '/minimize.gif';\n\n/**\n * Variable: normalizeImage\n *\n * URL of the image to be used for the normalize icon in the titlebar.\n */\nmxWindow.prototype.normalizeImage = mxClient.imageBasePath + '/normalize.gif';\n\n/**\n * Variable: maximizeImage\n *\n * URL of the image to be used for the maximize icon in the titlebar.\n */\nmxWindow.prototype.maximizeImage = mxClient.imageBasePath + '/maximize.gif';\n\n/**\n * Variable: normalizeImage\n *\n * URL of the image to be used for the resize icon.\n */\nmxWindow.prototype.resizeImage = mxClient.imageBasePath + '/resize.gif';\n\n/**\n * Variable: visible\n *\n * Boolean flag that represents the visible state of the window.\n */\nmxWindow.prototype.visible = false;\n\n/**\n * Variable: minimumSize\n *\n * <mxRectangle> that specifies the minimum width and height of the window.\n * Default is (50, 40).\n */\nmxWindow.prototype.minimumSize = new mxRectangle(0, 0, 50, 40);\n\n/**\n * Variable: destroyOnClose\n *\n * Specifies if the window should be destroyed when it is closed. If this\n * is false then the window is hidden using <setVisible>. Default is true.\n */\nmxWindow.prototype.destroyOnClose = true;\n\n/**\n * Variable: contentHeightCorrection\n *\n * Defines the correction factor for computing the height of the contentWrapper.\n * Default is 6 for IE 7/8 standards mode and 2 for all other browsers and modes.\n */\nmxWindow.prototype.contentHeightCorrection = (document.documentMode == 8 || document.documentMode == 7) ? 6 : 2;\n\n/**\n * Variable: title\n *\n * Reference to the DOM node (TD) that contains the title.\n */\nmxWindow.prototype.title = null;\n\n/**\n * Variable: content\n *\n * Reference to the DOM node that represents the window content.\n */\nmxWindow.prototype.content = null;\n\n/**\n * Function: init\n *\n * Initializes the DOM tree that represents the window.\n */\nmxWindow.prototype.init = function(x, y, width, height, style)\n{\n\tstyle = (style != null) ? style : 'mxWindow';\n\n\tthis.div = document.createElement('div');\n\tthis.div.className = style;\n\n\tthis.div.style.left = x + 'px';\n\tthis.div.style.top = y + 'px';\n\tthis.table = document.createElement('table');\n\tthis.table.className = style;\n\n\t// Disables built-in pan and zoom in IE10 and later\n\tif (mxClient.IS_POINTER)\n\t{\n\t\tthis.div.style.touchAction = 'none';\n\t}\n\n\t// Workaround for table size problems in FF\n\tif (width != null)\n\t{\n\t\tif (!mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tthis.div.style.width = width + 'px';\n\t\t}\n\n\t\tthis.table.style.width = width + 'px';\n\t}\n\n\tif (height != null)\n\t{\n\t\tif (!mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tthis.div.style.height = height + 'px';\n\t\t}\n\n\t\tthis.table.style.height = height + 'px';\n\t}\n\n\t// Creates title row\n\tvar tbody = document.createElement('tbody');\n\tvar tr = document.createElement('tr');\n\n\tthis.title = document.createElement('td');\n\tthis.title.className = style + 'Title';\n\n\tthis.buttons = document.createElement('div');\n\tthis.buttons.style.position = 'absolute';\n\tthis.buttons.style.display = 'inline-block';\n\tthis.buttons.style.right = '4px';\n\tthis.buttons.style.top = '5px';\n\tthis.title.appendChild(this.buttons);\n\n\ttr.appendChild(this.title);\n\ttbody.appendChild(tr);\n\n\t// Creates content row and table cell\n\ttr = document.createElement('tr');\n\tthis.td = document.createElement('td');\n\tthis.td.className = style + 'Pane';\n\n\tif (document.documentMode == 7)\n\t{\n\t\tthis.td.style.height = '100%';\n\t}\n\n\tthis.contentWrapper = document.createElement('div');\n\tthis.contentWrapper.className = style + 'Pane';\n\tthis.contentWrapper.style.width = '100%';\n\tthis.contentWrapper.appendChild(this.content);\n\n\t// Workaround for div around div restricts height\n\t// of inner div if outerdiv has hidden overflow\n\tif (mxClient.IS_QUIRKS || this.content.nodeName.toUpperCase() != 'DIV')\n\t{\n\t\tthis.contentWrapper.style.height = '100%';\n\t}\n\n\t// Puts all content into the DOM\n\tthis.td.appendChild(this.contentWrapper);\n\ttr.appendChild(this.td);\n\ttbody.appendChild(tr);\n\tthis.table.appendChild(tbody);\n\tthis.div.appendChild(this.table);\n\n\t// Puts the window on top of other windows when clicked\n\tvar activator = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.activate();\n\t});\n\n\tmxEvent.addGestureListeners(this.title, activator);\n\tmxEvent.addGestureListeners(this.table, activator);\n\n\tthis.hide();\n};\n\n/**\n * Function: setTitle\n *\n * Sets the window title to the given string. HTML markup inside the title\n * will be escaped.\n */\nmxWindow.prototype.setTitle = function(title)\n{\n\t// Removes all text content nodes (normally just one)\n\tvar child = this.title.firstChild;\n\n\twhile (child != null)\n\t{\n\t\tvar next = child.nextSibling;\n\n\t\tif (child.nodeType == mxConstants.NODETYPE_TEXT)\n\t\t{\n\t\t\tchild.parentNode.removeChild(child);\n\t\t}\n\n\t\tchild = next;\n\t}\n\n\tmxUtils.write(this.title, title || '');\n\tthis.title.appendChild(this.buttons);\n};\n\n/**\n * Function: setScrollable\n *\n * Sets if the window contents should be scrollable.\n */\nmxWindow.prototype.setScrollable = function(scrollable)\n{\n\t// Workaround for hang in Presto 2.5.22 (Opera 10.5)\n\tif (navigator.userAgent.indexOf('Presto/2.5') < 0)\n\t{\n\t\tif (scrollable)\n\t\t{\n\t\t\tthis.contentWrapper.style.overflow = 'auto';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.contentWrapper.style.overflow = 'hidden';\n\t\t}\n\t}\n};\n\n/**\n * Function: activate\n *\n * Puts the window on top of all other windows.\n */\nmxWindow.prototype.activate = function()\n{\n\tif (mxWindow.activeWindow != this)\n\t{\n\t\tvar style = mxUtils.getCurrentStyle(this.getElement());\n\t\tvar index = (style != null) ? style.zIndex : 3;\n\n\t\tif (mxWindow.activeWindow)\n\t\t{\n\t\t\tvar elt = mxWindow.activeWindow.getElement();\n\n\t\t\tif (elt != null && elt.style != null)\n\t\t\t{\n\t\t\t\telt.style.zIndex = index;\n\t\t\t}\n\t\t}\n\n\t\tvar previousWindow = mxWindow.activeWindow;\n\t\tthis.getElement().style.zIndex = parseInt(index) + 1;\n\t\tmxWindow.activeWindow = this;\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ACTIVATE, 'previousWindow', previousWindow));\n\t}\n};\n\n/**\n * Function: getElement\n *\n * Returuns the outermost DOM node that makes up the window.\n */\nmxWindow.prototype.getElement = function()\n{\n\treturn this.div;\n};\n\n/**\n * Function: fit\n *\n * Makes sure the window is inside the client area of the window.\n */\nmxWindow.prototype.fit = function()\n{\n\tmxUtils.fit(this.div);\n};\n\n/**\n * Function: isResizable\n *\n * Returns true if the window is resizable.\n */\nmxWindow.prototype.isResizable = function()\n{\n\tif (this.resize != null)\n\t{\n\t\treturn this.resize.style.display != 'none';\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: setResizable\n *\n * Sets if the window should be resizable. To avoid interference with some\n * built-in features of IE10 and later, the use of the following code is\n * recommended if there are resizable <mxWindow>s in the page:\n *\n * (code)\n * if (mxClient.IS_POINTER)\n * {\n *   document.body.style.msTouchAction = 'none';\n * }\n * (end)\n */\nmxWindow.prototype.setResizable = function(resizable)\n{\n\tif (resizable)\n\t{\n\t\tif (this.resize == null)\n\t\t{\n\t\t\tthis.resize = document.createElement('img');\n\t\t\tthis.resize.style.position = 'absolute';\n\t\t\tthis.resize.style.bottom = '2px';\n\t\t\tthis.resize.style.right = '2px';\n\n\t\t\tthis.resize.setAttribute('src', this.resizeImage);\n\t\t\tthis.resize.style.cursor = 'nw-resize';\n\n\t\t\tvar startX = null;\n\t\t\tvar startY = null;\n\t\t\tvar width = null;\n\t\t\tvar height = null;\n\n\t\t\tvar start = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\t// LATER: pointerdown starting on border of resize does start\n\t\t\t\t// the drag operation but does not fire consecutive events via\n\t\t\t\t// one of the listeners below (does pan instead).\n\t\t\t\t// Workaround: document.body.style.msTouchAction = 'none'\n\t\t\t\tthis.activate();\n\t\t\t\tstartX = mxEvent.getClientX(evt);\n\t\t\t\tstartY = mxEvent.getClientY(evt);\n\t\t\t\twidth = this.div.offsetWidth;\n\t\t\t\theight = this.div.offsetHeight;\n\n\t\t\t\tmxEvent.addGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE_START, 'event', evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\n\t\t\t// Adds a temporary pair of listeners to intercept\n\t\t\t// the gesture event in the document\n\t\t\tvar dragHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (startX != null && startY != null)\n\t\t\t\t{\n\t\t\t\t\tvar dx = mxEvent.getClientX(evt) - startX;\n\t\t\t\t\tvar dy = mxEvent.getClientY(evt) - startY;\n\n\t\t\t\t\tthis.setSize(width + dx, height + dy);\n\n\t\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE, 'event', evt));\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar dropHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (startX != null && startY != null)\n\t\t\t\t{\n\t\t\t\t\tstartX = null;\n\t\t\t\t\tstartY = null;\n\t\t\t\t\tmxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE_END, 'event', evt));\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmxEvent.addGestureListeners(this.resize, start, dragHandler, dropHandler);\n\t\t\tthis.div.appendChild(this.resize);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.resize.style.display = 'inline';\n\t\t}\n\t}\n\telse if (this.resize != null)\n\t{\n\t\tthis.resize.style.display = 'none';\n\t}\n};\n\n/**\n * Function: setSize\n *\n * Sets the size of the window.\n */\nmxWindow.prototype.setSize = function(width, height)\n{\n\twidth = Math.max(this.minimumSize.width, width);\n\theight = Math.max(this.minimumSize.height, height);\n\n\t// Workaround for table size problems in FF\n\tif (!mxClient.IS_QUIRKS)\n\t{\n\t\tthis.div.style.width =  width + 'px';\n\t\tthis.div.style.height = height + 'px';\n\t}\n\n\tthis.table.style.width =  width + 'px';\n\tthis.table.style.height = height + 'px';\n\n\tif (!mxClient.IS_QUIRKS)\n\t{\n\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t}\n};\n\n/**\n * Function: setMinimizable\n *\n * Sets if the window is minimizable.\n */\nmxWindow.prototype.setMinimizable = function(minimizable)\n{\n\tthis.minimize.style.display = (minimizable) ? '' : 'none';\n};\n\n/**\n * Function: getMinimumSize\n *\n * Returns an <mxRectangle> that specifies the size for the minimized window.\n * A width or height of 0 means keep the existing width or height. This\n * implementation returns the height of the window title and keeps the width.\n */\nmxWindow.prototype.getMinimumSize = function()\n{\n\treturn new mxRectangle(0, 0, 0, this.title.offsetHeight);\n};\n\n/**\n * Function: installMinimizeHandler\n *\n * Installs the event listeners required for minimizing the window.\n */\nmxWindow.prototype.installMinimizeHandler = function()\n{\n\tthis.minimize = document.createElement('img');\n\n\tthis.minimize.setAttribute('src', this.minimizeImage);\n\tthis.minimize.setAttribute('title', 'Minimize');\n\tthis.minimize.style.cursor = 'pointer';\n\tthis.minimize.style.marginLeft = '2px';\n\tthis.minimize.style.display = 'none';\n\n\tthis.buttons.appendChild(this.minimize);\n\n\tvar minimized = false;\n\tvar maxDisplay = null;\n\tvar height = null;\n\n\tvar funct = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.activate();\n\n\t\tif (!minimized)\n\t\t{\n\t\t\tminimized = true;\n\n\t\t\tthis.minimize.setAttribute('src', this.normalizeImage);\n\t\t\tthis.minimize.setAttribute('title', 'Normalize');\n\t\t\tthis.contentWrapper.style.display = 'none';\n\t\t\tmaxDisplay = this.maximize.style.display;\n\n\t\t\tthis.maximize.style.display = 'none';\n\t\t\theight = this.table.style.height;\n\n\t\t\tvar minSize = this.getMinimumSize();\n\n\t\t\tif (minSize.height > 0)\n\t\t\t{\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.height = minSize.height + 'px';\n\t\t\t\t}\n\n\t\t\t\tthis.table.style.height = minSize.height + 'px';\n\t\t\t}\n\n\t\t\tif (minSize.width > 0)\n\t\t\t{\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.width = minSize.width + 'px';\n\t\t\t\t}\n\n\t\t\t\tthis.table.style.width = minSize.width + 'px';\n\t\t\t}\n\n\t\t\tif (this.resize != null)\n\t\t\t{\n\t\t\t\tthis.resize.style.visibility = 'hidden';\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MINIMIZE, 'event', evt));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tminimized = false;\n\n\t\t\tthis.minimize.setAttribute('src', this.minimizeImage);\n\t\t\tthis.minimize.setAttribute('title', 'Minimize');\n\t\t\tthis.contentWrapper.style.display = ''; // default\n\t\t\tthis.maximize.style.display = maxDisplay;\n\n\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\tthis.div.style.height = height;\n\t\t\t}\n\n\t\t\tthis.table.style.height = height;\n\n\t\t\tif (this.resize != null)\n\t\t\t{\n\t\t\t\tthis.resize.style.visibility = '';\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.NORMALIZE, 'event', evt));\n\t\t}\n\n\t\tmxEvent.consume(evt);\n\t});\n\n\tmxEvent.addGestureListeners(this.minimize, funct);\n};\n\n/**\n * Function: setMaximizable\n *\n * Sets if the window is maximizable.\n */\nmxWindow.prototype.setMaximizable = function(maximizable)\n{\n\tthis.maximize.style.display = (maximizable) ? '' : 'none';\n};\n\n/**\n * Function: installMaximizeHandler\n *\n * Installs the event listeners required for maximizing the window.\n */\nmxWindow.prototype.installMaximizeHandler = function()\n{\n\tthis.maximize = document.createElement('img');\n\n\tthis.maximize.setAttribute('src', this.maximizeImage);\n\tthis.maximize.setAttribute('title', 'Maximize');\n\tthis.maximize.style.cursor = 'default';\n\tthis.maximize.style.marginLeft = '2px';\n\tthis.maximize.style.cursor = 'pointer';\n\tthis.maximize.style.display = 'none';\n\n\tthis.buttons.appendChild(this.maximize);\n\n\tvar maximized = false;\n\tvar x = null;\n\tvar y = null;\n\tvar height = null;\n\tvar width = null;\n\tvar minDisplay = null;\n\n\tvar funct = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.activate();\n\n\t\tif (this.maximize.style.display != 'none')\n\t\t{\n\t\t\tif (!maximized)\n\t\t\t{\n\t\t\t\tmaximized = true;\n\n\t\t\t\tthis.maximize.setAttribute('src', this.normalizeImage);\n\t\t\t\tthis.maximize.setAttribute('title', 'Normalize');\n\t\t\t\tthis.contentWrapper.style.display = '';\n\t\t\t\tminDisplay = this.minimize.style.display;\n\t\t\t\tthis.minimize.style.display = 'none';\n\n\t\t\t\t// Saves window state\n\t\t\t\tx = parseInt(this.div.style.left);\n\t\t\t\ty = parseInt(this.div.style.top);\n\t\t\t\theight = this.table.style.height;\n\t\t\t\twidth = this.table.style.width;\n\n\t\t\t\tthis.div.style.left = '0px';\n\t\t\t\tthis.div.style.top = '0px';\n\t\t\t\tvar docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);\n\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.width = (document.body.clientWidth - 2) + 'px';\n\t\t\t\t\tthis.div.style.height = (docHeight - 2) + 'px';\n\t\t\t\t}\n\n\t\t\t\tthis.table.style.width = (document.body.clientWidth - 2) + 'px';\n\t\t\t\tthis.table.style.height = (docHeight - 2) + 'px';\n\n\t\t\t\tif (this.resize != null)\n\t\t\t\t{\n\t\t\t\t\tthis.resize.style.visibility = 'hidden';\n\t\t\t\t}\n\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tvar style = mxUtils.getCurrentStyle(this.contentWrapper);\n\n\t\t\t\t\tif (style.overflow == 'auto' || this.resize != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\t\t\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MAXIMIZE, 'event', evt));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmaximized = false;\n\n\t\t\t\tthis.maximize.setAttribute('src', this.maximizeImage);\n\t\t\t\tthis.maximize.setAttribute('title', 'Maximize');\n\t\t\t\tthis.contentWrapper.style.display = '';\n\t\t\t\tthis.minimize.style.display = minDisplay;\n\n\t\t\t\t// Restores window state\n\t\t\t\tthis.div.style.left = x+'px';\n\t\t\t\tthis.div.style.top = y+'px';\n\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tthis.div.style.height = height;\n\t\t\t\t\tthis.div.style.width = width;\n\n\t\t\t\t\tvar style = mxUtils.getCurrentStyle(this.contentWrapper);\n\n\t\t\t\t\tif (style.overflow == 'auto' || this.resize != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\t\t\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.table.style.height = height;\n\t\t\t\tthis.table.style.width = width;\n\n\t\t\t\tif (this.resize != null)\n\t\t\t\t{\n\t\t\t\t\tthis.resize.style.visibility = '';\n\t\t\t\t}\n\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.NORMALIZE, 'event', evt));\n\t\t\t}\n\n\t\t\tmxEvent.consume(evt);\n\t\t}\n\t});\n\n\tmxEvent.addGestureListeners(this.maximize, funct);\n\tmxEvent.addListener(this.title, 'dblclick', funct);\n};\n\n/**\n * Function: installMoveHandler\n *\n * Installs the event listeners required for moving the window.\n */\nmxWindow.prototype.installMoveHandler = function()\n{\n\tthis.title.style.cursor = 'move';\n\n\tmxEvent.addGestureListeners(this.title,\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tvar startX = mxEvent.getClientX(evt);\n\t\t\tvar startY = mxEvent.getClientY(evt);\n\t\t\tvar x = this.getX();\n\t\t\tvar y = this.getY();\n\n\t\t\t// Adds a temporary pair of listeners to intercept\n\t\t\t// the gesture event in the document\n\t\t\tvar dragHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tvar dx = mxEvent.getClientX(evt) - startX;\n\t\t\t\tvar dy = mxEvent.getClientY(evt) - startY;\n\t\t\t\tthis.setLocation(x + dx, y + dy);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE, 'event', evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\n\t\t\tvar dropHandler = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tmxEvent.removeGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE_END, 'event', evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\n\t\t\tmxEvent.addGestureListeners(document, null, dragHandler, dropHandler);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE_START, 'event', evt));\n\t\t\tmxEvent.consume(evt);\n\t\t}));\n\n\t// Disables built-in pan and zoom in IE10 and later\n\tif (mxClient.IS_POINTER)\n\t{\n\t\tthis.title.style.touchAction = 'none';\n\t}\n};\n\n/**\n * Function: setLocation\n *\n * Sets the upper, left corner of the window.\n */\n mxWindow.prototype.setLocation = function(x, y)\n {\n\tthis.div.style.left = x + 'px';\n\tthis.div.style.top = y + 'px';\n };\n\n/**\n * Function: getX\n *\n * Returns the current position on the x-axis.\n */\nmxWindow.prototype.getX = function()\n{\n\treturn parseInt(this.div.style.left);\n};\n\n/**\n * Function: getY\n *\n * Returns the current position on the y-axis.\n */\nmxWindow.prototype.getY = function()\n{\n\treturn parseInt(this.div.style.top);\n};\n\n/**\n * Function: installCloseHandler\n *\n * Adds the <closeImage> as a new image node in <closeImg> and installs the\n * <close> event.\n */\nmxWindow.prototype.installCloseHandler = function()\n{\n\tthis.closeImg = document.createElement('img');\n\n\tthis.closeImg.setAttribute('src', this.closeImage);\n\tthis.closeImg.setAttribute('title', 'Close');\n\tthis.closeImg.style.marginLeft = '2px';\n\tthis.closeImg.style.cursor = 'pointer';\n\tthis.closeImg.style.display = 'none';\n\n\tthis.buttons.appendChild(this.closeImg);\n\n\tmxEvent.addGestureListeners(this.closeImg,\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CLOSE, 'event', evt));\n\n\t\t\tif (this.destroyOnClose)\n\t\t\t{\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.setVisible(false);\n\t\t\t}\n\n\t\t\tmxEvent.consume(evt);\n\t\t}));\n};\n\n/**\n * Function: setImage\n *\n * Sets the image associated with the window.\n *\n * Parameters:\n *\n * image - URL of the image to be used.\n */\nmxWindow.prototype.setImage = function(image)\n{\n\tthis.image = document.createElement('img');\n\tthis.image.setAttribute('src', image);\n\tthis.image.setAttribute('align', 'left');\n\tthis.image.style.marginRight = '4px';\n\tthis.image.style.marginLeft = '0px';\n\tthis.image.style.marginTop = '-2px';\n\n\tthis.title.insertBefore(this.image, this.title.firstChild);\n};\n\n/**\n * Function: setClosable\n *\n * Sets the image associated with the window.\n *\n * Parameters:\n *\n * closable - Boolean specifying if the window should be closable.\n */\nmxWindow.prototype.setClosable = function(closable)\n{\n\tthis.closeImg.style.display = (closable) ? '' : 'none';\n};\n\n/**\n * Function: isVisible\n *\n * Returns true if the window is visible.\n */\nmxWindow.prototype.isVisible = function()\n{\n\tif (this.div != null)\n\t{\n\t\treturn this.div.style.display != 'none';\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: setVisible\n *\n * Shows or hides the window depending on the given flag.\n *\n * Parameters:\n *\n * visible - Boolean indicating if the window should be made visible.\n */\nmxWindow.prototype.setVisible = function(visible)\n{\n\tif (this.div != null && this.isVisible() != visible)\n\t{\n\t\tif (visible)\n\t\t{\n\t\t\tthis.show();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.hide();\n\t\t}\n\t}\n};\n\n/**\n * Function: show\n *\n * Shows the window.\n */\nmxWindow.prototype.show = function()\n{\n\tthis.div.style.display = '';\n\tthis.activate();\n\n\tvar style = mxUtils.getCurrentStyle(this.contentWrapper);\n\n\tif (!mxClient.IS_QUIRKS && (style.overflow == 'auto' || this.resize != null) &&\n\t\tthis.contentWrapper.style.display != 'none')\n\t{\n\t\tthis.contentWrapper.style.height = (this.div.offsetHeight -\n\t\t\t\tthis.title.offsetHeight - this.contentHeightCorrection) + 'px';\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.SHOW));\n};\n\n/**\n * Function: hide\n *\n * Hides the window.\n */\nmxWindow.prototype.hide = function()\n{\n\tthis.div.style.display = 'none';\n\tthis.fireEvent(new mxEventObject(mxEvent.HIDE));\n};\n\n/**\n * Function: destroy\n *\n * Destroys the window and removes all associated resources. Fires a\n * <destroy> event prior to destroying the window.\n */\nmxWindow.prototype.destroy = function()\n{\n\tthis.fireEvent(new mxEventObject(mxEvent.DESTROY));\n\n\tif (this.div != null)\n\t{\n\t\tmxEvent.release(this.div);\n\t\tthis.div.parentNode.removeChild(this.div);\n\t\tthis.div = null;\n\t}\n\n\tthis.title = null;\n\tthis.content = null;\n\tthis.contentWrapper = null;\n};\n\n__mxOutput.mxWindow = typeof mxWindow !== 'undefined' ? mxWindow : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxForm\n *\n * A simple class for creating HTML forms.\n *\n * Constructor: mxForm\n *\n * Creates a HTML table using the specified classname.\n */\nfunction mxForm(className)\n{\n\tthis.table = document.createElement('table');\n\tthis.table.className = className;\n\tthis.body = document.createElement('tbody');\n\n\tthis.table.appendChild(this.body);\n};\n\n/**\n * Variable: table\n *\n * Holds the DOM node that represents the table.\n */\nmxForm.prototype.table = null;\n\n/**\n * Variable: body\n *\n * Holds the DOM node that represents the tbody (table body). New rows\n * can be added to this object using DOM API.\n */\nmxForm.prototype.body = false;\n\n/**\n * Function: getTable\n *\n * Returns the table that contains this form.\n */\nmxForm.prototype.getTable = function()\n{\n\treturn this.table;\n};\n\n/**\n * Function: addButtons\n *\n * Helper method to add an OK and Cancel button using the respective\n * functions.\n */\nmxForm.prototype.addButtons = function(okFunct, cancelFunct)\n{\n\tvar tr = document.createElement('tr');\n\tvar td = document.createElement('td');\n\ttr.appendChild(td);\n\ttd = document.createElement('td');\n\n\t// Adds the ok button\n\tvar button = document.createElement('button');\n\tmxUtils.write(button, mxResources.get('ok') || 'OK');\n\ttd.appendChild(button);\n\n\tmxEvent.addListener(button, 'click', function()\n\t{\n\t\tokFunct();\n\t});\n\n\t// Adds the cancel button\n\tbutton = document.createElement('button');\n\tmxUtils.write(button, mxResources.get('cancel') || 'Cancel');\n\ttd.appendChild(button);\n\n\tmxEvent.addListener(button, 'click', function()\n\t{\n\t\tcancelFunct();\n\t});\n\n\ttr.appendChild(td);\n\tthis.body.appendChild(tr);\n};\n\n/**\n * Function: addText\n *\n * Adds an input for the given name, type and value and returns it.\n */\nmxForm.prototype.addText = function(name, value, type)\n{\n\tvar input = document.createElement('input');\n\n\tinput.setAttribute('type', type || 'text');\n\tinput.value = value;\n\n\treturn this.addField(name, input);\n};\n\n/**\n * Function: addCheckbox\n *\n * Adds a checkbox for the given name and value and returns the textfield.\n */\nmxForm.prototype.addCheckbox = function(name, value)\n{\n\tvar input = document.createElement('input');\n\n\tinput.setAttribute('type', 'checkbox');\n\tthis.addField(name, input);\n\n\t// IE can only change the checked value if the input is inside the DOM\n\tif (value)\n\t{\n\t\tinput.checked = true;\n\t}\n\n\treturn input;\n};\n\n/**\n * Function: addTextarea\n *\n * Adds a textarea for the given name and value and returns the textarea.\n */\nmxForm.prototype.addTextarea = function(name, value, rows)\n{\n\tvar input = document.createElement('textarea');\n\n\tif (mxClient.IS_NS)\n\t{\n\t\trows--;\n\t}\n\n\tinput.setAttribute('rows', rows || 2);\n\tinput.value = value;\n\n\treturn this.addField(name, input);\n};\n\n/**\n * Function: addCombo\n *\n * Adds a combo for the given name and returns the combo.\n */\nmxForm.prototype.addCombo = function(name, isMultiSelect, size)\n{\n\tvar select = document.createElement('select');\n\n\tif (size != null)\n\t{\n\t\tselect.setAttribute('size', size);\n\t}\n\n\tif (isMultiSelect)\n\t{\n\t\tselect.setAttribute('multiple', 'true');\n\t}\n\n\treturn this.addField(name, select);\n};\n\n/**\n * Function: addOption\n *\n * Adds an option for the given label to the specified combo.\n */\nmxForm.prototype.addOption = function(combo, label, value, isSelected)\n{\n\tvar option = document.createElement('option');\n\n\tmxUtils.writeln(option, label);\n\toption.setAttribute('value', value);\n\n\tif (isSelected)\n\t{\n\t\toption.setAttribute('selected', isSelected);\n\t}\n\n\tcombo.appendChild(option);\n};\n\n/**\n * Function: addField\n *\n * Adds a new row with the name and the input field in two columns and\n * returns the given input.\n */\nmxForm.prototype.addField = function(name, input)\n{\n\tvar tr = document.createElement('tr');\n\tvar td = document.createElement('td');\n\tmxUtils.write(td, name);\n\ttr.appendChild(td);\n\n\ttd = document.createElement('td');\n\ttd.appendChild(input);\n\ttr.appendChild(td);\n\tthis.body.appendChild(tr);\n\n\treturn input;\n};\n\n__mxOutput.mxForm = typeof mxForm !== 'undefined' ? mxForm : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImage\n *\n * Encapsulates the URL, width and height of an image.\n *\n * Constructor: mxImage\n *\n * Constructs a new image.\n */\nfunction mxImage(src, width, height)\n{\n\tthis.src = src;\n\tthis.width = width;\n\tthis.height = height;\n};\n\n/**\n * Variable: src\n *\n * String that specifies the URL of the image.\n */\nmxImage.prototype.src = null;\n\n/**\n * Variable: width\n *\n * Integer that specifies the width of the image.\n */\nmxImage.prototype.width = null;\n\n/**\n * Variable: height\n *\n * Integer that specifies the height of the image.\n */\nmxImage.prototype.height = null;\n\n__mxOutput.mxImage = typeof mxImage !== 'undefined' ? mxImage : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDivResizer\n *\n * Maintains the size of a div element in Internet Explorer. This is a\n * workaround for the right and bottom style being ignored in IE.\n *\n * If you need a div to cover the scrollwidth and -height of a document,\n * then you can use this class as follows:\n *\n * (code)\n * var resizer = new mxDivResizer(background);\n * resizer.getDocumentHeight = function()\n * {\n *   return document.body.scrollHeight;\n * }\n * resizer.getDocumentWidth = function()\n * {\n *   return document.body.scrollWidth;\n * }\n * resizer.resize();\n * (end)\n *\n * Constructor: mxDivResizer\n *\n * Constructs an object that maintains the size of a div\n * element when the window is being resized. This is only\n * required for Internet Explorer as it ignores the respective\n * stylesheet information for DIV elements.\n *\n * Parameters:\n *\n * div - Reference to the DOM node whose size should be maintained.\n * container - Optional Container that contains the div. Default is the\n * window.\n */\nfunction mxDivResizer(div, container)\n{\n\tif (div.nodeName.toLowerCase() == 'div')\n\t{\n\t\tif (container == null)\n\t\t{\n\t\t\tcontainer = window;\n\t\t}\n\n\t\tthis.div = div;\n\t\tvar style = mxUtils.getCurrentStyle(div);\n\n\t\tif (style != null)\n\t\t{\n\t\t\tthis.resizeWidth = style.width == 'auto';\n\t\t\tthis.resizeHeight = style.height == 'auto';\n\t\t}\n\n\t\tmxEvent.addListener(container, 'resize',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (!this.handlingResize)\n\t\t\t\t{\n\t\t\t\t\tthis.handlingResize = true;\n\t\t\t\t\tthis.resize();\n\t\t\t\t\tthis.handlingResize = false;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tthis.resize();\n\t}\n};\n\n/**\n * Function: resizeWidth\n *\n * Boolean specifying if the width should be updated.\n */\nmxDivResizer.prototype.resizeWidth = true;\n\n/**\n * Function: resizeHeight\n *\n * Boolean specifying if the height should be updated.\n */\nmxDivResizer.prototype.resizeHeight = true;\n\n/**\n * Function: handlingResize\n *\n * Boolean specifying if the width should be updated.\n */\nmxDivResizer.prototype.handlingResize = false;\n\n/**\n * Function: resize\n *\n * Updates the style of the DIV after the window has been resized.\n */\nmxDivResizer.prototype.resize = function()\n{\n\tvar w = this.getDocumentWidth();\n\tvar h = this.getDocumentHeight();\n\n\tvar l = parseInt(this.div.style.left);\n\tvar r = parseInt(this.div.style.right);\n\tvar t = parseInt(this.div.style.top);\n\tvar b = parseInt(this.div.style.bottom);\n\n\tif (this.resizeWidth &&\n\t\t!isNaN(l) &&\n\t\t!isNaN(r) &&\n\t\tl >= 0 &&\n\t\tr >= 0 &&\n\t\tw - r - l > 0)\n\t{\n\t\tthis.div.style.width = (w - r - l)+'px';\n\t}\n\n\tif (this.resizeHeight &&\n\t\t!isNaN(t) &&\n\t\t!isNaN(b) &&\n\t\tt >= 0 &&\n\t\tb >= 0 &&\n\t\th - t - b > 0)\n\t{\n\t\tthis.div.style.height = (h - t - b)+'px';\n\t}\n};\n\n/**\n * Function: getDocumentWidth\n *\n * Hook for subclassers to return the width of the document (without\n * scrollbars).\n */\nmxDivResizer.prototype.getDocumentWidth = function()\n{\n\treturn document.body.clientWidth;\n};\n\n/**\n * Function: getDocumentHeight\n *\n * Hook for subclassers to return the height of the document (without\n * scrollbars).\n */\nmxDivResizer.prototype.getDocumentHeight = function()\n{\n\treturn document.body.clientHeight;\n};\n\n__mxOutput.mxDivResizer = typeof mxDivResizer !== 'undefined' ? mxDivResizer : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDragSource\n *\n * Wrapper to create a drag source from a DOM element so that the element can\n * be dragged over a graph and dropped into the graph as a new cell.\n *\n * Problem is that in the dropHandler the current preview location is not\n * available, so the preview and the dropHandler must match.\n *\n * Constructor: mxDragSource\n *\n * Constructs a new drag source for the given element.\n */\nfunction mxDragSource(element, dropHandler)\n{\n\tthis.element = element;\n\tthis.dropHandler = dropHandler;\n\n\t// Handles a drag gesture on the element\n\tmxEvent.addGestureListeners(element, mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.mouseDown(evt);\n\t}));\n\n\t// Prevents native drag and drop\n\tmxEvent.addListener(element, 'dragstart', function(evt)\n\t{\n\t\tmxEvent.consume(evt);\n\t});\n\n\tthis.eventConsumer = function(sender, evt)\n\t{\n\t\tvar evtName = evt.getProperty('eventName');\n\t\tvar me = evt.getProperty('event');\n\n\t\tif (evtName != mxEvent.MOUSE_DOWN)\n\t\t{\n\t\t\tme.consume();\n\t\t}\n\t};\n};\n\n/**\n * Variable: element\n *\n * Reference to the DOM node which was made draggable.\n */\nmxDragSource.prototype.element = null;\n\n/**\n * Variable: dropHandler\n *\n * Holds the DOM node that is used to represent the drag preview. If this is\n * null then the source element will be cloned and used for the drag preview.\n */\nmxDragSource.prototype.dropHandler = null;\n\n/**\n * Variable: dragOffset\n *\n * <mxPoint> that specifies the offset of the <dragElement>. Default is null.\n */\nmxDragSource.prototype.dragOffset = null;\n\n/**\n * Variable: dragElement\n *\n * Holds the DOM node that is used to represent the drag preview. If this is\n * null then the source element will be cloned and used for the drag preview.\n */\nmxDragSource.prototype.dragElement = null;\n\n/**\n * Variable: previewElement\n *\n * Optional <mxRectangle> that specifies the unscaled size of the preview.\n */\nmxDragSource.prototype.previewElement = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if this drag source is enabled. Default is true.\n */\nmxDragSource.prototype.enabled = true;\n\n/**\n * Variable: currentGraph\n *\n * Reference to the <mxGraph> that is the current drop target.\n */\nmxDragSource.prototype.currentGraph = null;\n\n/**\n * Variable: currentDropTarget\n *\n * Holds the current drop target under the mouse.\n */\nmxDragSource.prototype.currentDropTarget = null;\n\n/**\n * Variable: currentPoint\n *\n * Holds the current drop location.\n */\nmxDragSource.prototype.currentPoint = null;\n\n/**\n * Variable: currentGuide\n *\n * Holds an <mxGuide> for the <currentGraph> if <dragPreview> is not null.\n */\nmxDragSource.prototype.currentGuide = null;\n\n/**\n * Variable: currentGuide\n *\n * Holds an <mxGuide> for the <currentGraph> if <dragPreview> is not null.\n */\nmxDragSource.prototype.currentHighlight = null;\n\n/**\n * Variable: autoscroll\n *\n * Specifies if the graph should scroll automatically. Default is true.\n */\nmxDragSource.prototype.autoscroll = true;\n\n/**\n * Variable: guidesEnabled\n *\n * Specifies if <mxGuide> should be enabled. Default is true.\n */\nmxDragSource.prototype.guidesEnabled = true;\n\n/**\n * Variable: gridEnabled\n *\n * Specifies if the grid should be allowed. Default is true.\n */\nmxDragSource.prototype.gridEnabled = true;\n\n/**\n * Variable: highlightDropTargets\n *\n * Specifies if drop targets should be highlighted. Default is true.\n */\nmxDragSource.prototype.highlightDropTargets = true;\n\n/**\n * Variable: dragElementZIndex\n *\n * ZIndex for the drag element. Default is 100.\n */\nmxDragSource.prototype.dragElementZIndex = 100;\n\n/**\n * Variable: dragElementOpacity\n *\n * Opacity of the drag element in %. Default is 70.\n */\nmxDragSource.prototype.dragElementOpacity = 70;\n\n/**\n * Variable: checkEventSource\n *\n * Whether the event source should be checked in <graphContainerEvent>. Default\n * is true.\n */\nmxDragSource.prototype.checkEventSource = true;\n\n/**\n * Function: isEnabled\n *\n * Returns <enabled>.\n */\nmxDragSource.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Sets <enabled>.\n */\nmxDragSource.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isGuidesEnabled\n *\n * Returns <guidesEnabled>.\n */\nmxDragSource.prototype.isGuidesEnabled = function()\n{\n\treturn this.guidesEnabled;\n};\n\n/**\n * Function: setGuidesEnabled\n *\n * Sets <guidesEnabled>.\n */\nmxDragSource.prototype.setGuidesEnabled = function(value)\n{\n\tthis.guidesEnabled = value;\n};\n\n/**\n * Function: isGridEnabled\n *\n * Returns <gridEnabled>.\n */\nmxDragSource.prototype.isGridEnabled = function()\n{\n\treturn this.gridEnabled;\n};\n\n/**\n * Function: setGridEnabled\n *\n * Sets <gridEnabled>.\n */\nmxDragSource.prototype.setGridEnabled = function(value)\n{\n\tthis.gridEnabled = value;\n};\n\n/**\n * Function: getGraphForEvent\n *\n * Returns the graph for the given mouse event. This implementation returns\n * null.\n */\nmxDragSource.prototype.getGraphForEvent = function(evt)\n{\n\treturn null;\n};\n\n/**\n * Function: getDropTarget\n *\n * Returns the drop target for the given graph and coordinates. This\n * implementation uses <mxGraph.getCellAt>.\n */\nmxDragSource.prototype.getDropTarget = function(graph, x, y, evt)\n{\n\treturn graph.getCellAt(x, y);\n};\n\n/**\n * Function: createDragElement\n *\n * Creates and returns a clone of the <dragElementPrototype> or the <element>\n * if the former is not defined.\n */\nmxDragSource.prototype.createDragElement = function(evt)\n{\n\treturn this.element.cloneNode(true);\n};\n\n/**\n * Function: createPreviewElement\n *\n * Creates and returns an element which can be used as a preview in the given\n * graph.\n */\nmxDragSource.prototype.createPreviewElement = function(graph)\n{\n\treturn null;\n};\n\n/**\n * Function: isActive\n *\n * Returns true if this drag source is active.\n */\nmxDragSource.prototype.isActive = function()\n{\n\treturn this.mouseMoveHandler != null;\n};\n\n/**\n * Function: reset\n *\n * Stops and removes everything and restores the state of the object.\n */\nmxDragSource.prototype.reset = function()\n{\n\tif (this.currentGraph != null)\n\t{\n\t\tthis.dragExit(this.currentGraph);\n\t\tthis.currentGraph = null;\n\t}\n\n\tthis.removeDragElement();\n\tthis.removeListeners();\n\tthis.stopDrag();\n};\n\n/**\n * Function: mouseDown\n *\n * Returns the drop target for the given graph and coordinates. This\n * implementation uses <mxGraph.getCellAt>.\n *\n * To ignore popup menu events for a drag source, this function can be\n * overridden as follows.\n *\n * (code)\n * var mouseDown = dragSource.mouseDown;\n *\n * dragSource.mouseDown = function(evt)\n * {\n *   if (!mxEvent.isPopupTrigger(evt))\n *   {\n *     mouseDown.apply(this, arguments);\n *   }\n * };\n * (end)\n */\nmxDragSource.prototype.mouseDown = function(evt)\n{\n\tif (this.enabled && !mxEvent.isConsumed(evt) && this.mouseMoveHandler == null)\n\t{\n\t\tthis.startDrag(evt);\n\t\tthis.mouseMoveHandler = mxUtils.bind(this, this.mouseMove);\n\t\tthis.mouseUpHandler = mxUtils.bind(this, this.mouseUp);\n\t\tmxEvent.addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n\n\t\tif (mxClient.IS_TOUCH && !mxEvent.isMouseEvent(evt))\n\t\t{\n\t\t\tthis.eventSource = mxEvent.getSource(evt);\n\t\t\tmxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n\t\t}\n\t}\n};\n\n/**\n * Function: startDrag\n *\n * Creates the <dragElement> using <createDragElement>.\n */\nmxDragSource.prototype.startDrag = function(evt)\n{\n\tthis.dragElement = this.createDragElement(evt);\n\tthis.dragElement.style.position = 'absolute';\n\tthis.dragElement.style.zIndex = this.dragElementZIndex;\n\tmxUtils.setOpacity(this.dragElement, this.dragElementOpacity);\n\n\tif (this.checkEventSource && mxClient.IS_SVG)\n\t{\n\t\tthis.dragElement.style.pointerEvents = 'none';\n\t}\n};\n\n/**\n * Function: stopDrag\n *\n * Invokes <removeDragElement>.\n */\nmxDragSource.prototype.stopDrag = function()\n{\n\t// LATER: This used to have a mouse event. If that is still needed we need to add another\n\t// final call to the DnD protocol to add a cleanup step in the case of escape press, which\n\t// is not associated with a mouse event and which currently calles this method.\n\tthis.removeDragElement();\n};\n\n/**\n * Function: removeDragElement\n *\n * Removes and destroys the <dragElement>.\n */\nmxDragSource.prototype.removeDragElement = function()\n{\n\tif (this.dragElement != null)\n\t{\n\t\tif (this.dragElement.parentNode != null)\n\t\t{\n\t\t\tthis.dragElement.parentNode.removeChild(this.dragElement);\n\t\t}\n\n\t\tthis.dragElement = null;\n\t}\n};\n\n/**\n * Function: getElementForEvent\n *\n * Returns the topmost element under the given event.\n */\nmxDragSource.prototype.getElementForEvent = function(evt)\n{\n\treturn ((mxEvent.isTouchEvent(evt) || mxEvent.isPenEvent(evt)) ?\n\t\t\tdocument.elementFromPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt)) :\n\t\t\t\tmxEvent.getSource(evt));\n};\n\n/**\n * Function: graphContainsEvent\n *\n * Returns true if the given graph contains the given event.\n */\nmxDragSource.prototype.graphContainsEvent = function(graph, evt)\n{\n\tvar x = mxEvent.getClientX(evt);\n\tvar y = mxEvent.getClientY(evt);\n\tvar offset = mxUtils.getOffset(graph.container);\n\tvar origin = mxUtils.getScrollOrigin();\n\tvar elt = this.getElementForEvent(evt);\n\n\tif (this.checkEventSource)\n\t{\n\t\twhile (elt != null && elt != graph.container)\n\t\t{\n\t\t\telt = elt.parentNode;\n\t\t}\n\t}\n\n\t// Checks if event is inside the bounds of the graph container\n\treturn elt != null && x >= offset.x - origin.x && y >= offset.y - origin.y &&\n\t\tx <= offset.x - origin.x + graph.container.offsetWidth &&\n\t\ty <= offset.y - origin.y + graph.container.offsetHeight;\n};\n\n/**\n * Function: mouseMove\n *\n * Gets the graph for the given event using <getGraphForEvent>, updates the\n * <currentGraph>, calling <dragEnter> and <dragExit> on the new and old graph,\n * respectively, and invokes <dragOver> if <currentGraph> is not null.\n */\nmxDragSource.prototype.mouseMove = function(evt)\n{\n\tvar graph = this.getGraphForEvent(evt);\n\n\t// Checks if event is inside the bounds of the graph container\n\tif (graph != null && !this.graphContainsEvent(graph, evt))\n\t{\n\t\tgraph = null;\n\t}\n\n\tif (graph != this.currentGraph)\n\t{\n\t\tif (this.currentGraph != null)\n\t\t{\n\t\t\tthis.dragExit(this.currentGraph, evt);\n\t\t}\n\n\t\tthis.currentGraph = graph;\n\n\t\tif (this.currentGraph != null)\n\t\t{\n\t\t\tthis.dragEnter(this.currentGraph, evt);\n\t\t}\n\t}\n\n\tif (this.currentGraph != null)\n\t{\n\t\tthis.dragOver(this.currentGraph, evt);\n\t}\n\n\tif (this.dragElement != null && (this.previewElement == null || this.previewElement.style.visibility != 'visible'))\n\t{\n\t\tvar x = mxEvent.getClientX(evt);\n\t\tvar y = mxEvent.getClientY(evt);\n\n\t\tif (this.dragElement.parentNode == null)\n\t\t{\n\t\t\tdocument.body.appendChild(this.dragElement);\n\t\t}\n\n\t\tthis.dragElement.style.visibility = 'visible';\n\n\t\tif (this.dragOffset != null)\n\t\t{\n\t\t\tx += this.dragOffset.x;\n\t\t\ty += this.dragOffset.y;\n\t\t}\n\n\t\tvar offset = mxUtils.getDocumentScrollOrigin(document);\n\n\t\tthis.dragElement.style.left = (x + offset.x) + 'px';\n\t\tthis.dragElement.style.top = (y + offset.y) + 'px';\n\t}\n\telse if (this.dragElement != null)\n\t{\n\t\tthis.dragElement.style.visibility = 'hidden';\n\t}\n\n\tmxEvent.consume(evt);\n};\n\n/**\n * Function: mouseUp\n *\n * Processes the mouse up event and invokes <drop>, <dragExit> and <stopDrag>\n * as required.\n */\nmxDragSource.prototype.mouseUp = function(evt)\n{\n\tif (this.currentGraph != null)\n\t{\n\t\tif (this.currentPoint != null && (this.previewElement == null ||\n\t\t\tthis.previewElement.style.visibility != 'hidden'))\n\t\t{\n\t\t\tvar scale = this.currentGraph.view.scale;\n\t\t\tvar tr = this.currentGraph.view.translate;\n\t\t\tvar x = this.currentPoint.x / scale - tr.x;\n\t\t\tvar y = this.currentPoint.y / scale - tr.y;\n\n\t\t\tthis.drop(this.currentGraph, evt, this.currentDropTarget, x, y);\n\t\t}\n\n\t\tthis.dragExit(this.currentGraph);\n\t\tthis.currentGraph = null;\n\t}\n\n\tthis.stopDrag();\n\tthis.removeListeners();\n\n\tmxEvent.consume(evt);\n};\n\n/**\n * Function: removeListeners\n *\n * Actives the given graph as a drop target.\n */\nmxDragSource.prototype.removeListeners = function()\n{\n\tif (this.eventSource != null)\n\t{\n\t\tmxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n\t\tthis.eventSource = null;\n\t}\n\n\tmxEvent.removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n\tthis.mouseMoveHandler = null;\n\tthis.mouseUpHandler = null;\n};\n\n/**\n * Function: dragEnter\n *\n * Actives the given graph as a drop target.\n */\nmxDragSource.prototype.dragEnter = function(graph, evt)\n{\n\tgraph.isMouseDown = true;\n\tgraph.isMouseTrigger = mxEvent.isMouseEvent(evt);\n\tthis.previewElement = this.createPreviewElement(graph);\n\n\tif (this.previewElement != null && this.checkEventSource && mxClient.IS_SVG)\n\t{\n\t\tthis.previewElement.style.pointerEvents = 'none';\n\t}\n\n\t// Guide is only needed if preview element is used\n\tif (this.isGuidesEnabled() && this.previewElement != null)\n\t{\n\t\tthis.currentGuide = new mxGuide(graph, graph.graphHandler.getGuideStates());\n\t}\n\n\tif (this.highlightDropTargets)\n\t{\n\t\tthis.currentHighlight = new mxCellHighlight(graph, mxConstants.DROP_TARGET_COLOR);\n\t}\n\n\t// Consumes all events in the current graph before they are fired\n\tgraph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.eventConsumer);\n};\n\n/**\n * Function: dragExit\n *\n * Deactivates the given graph as a drop target.\n */\nmxDragSource.prototype.dragExit = function(graph, evt)\n{\n\tthis.currentDropTarget = null;\n\tthis.currentPoint = null;\n\tgraph.isMouseDown = false;\n\n\t// Consumes all events in the current graph before they are fired\n\tgraph.removeListener(this.eventConsumer);\n\n\tif (this.previewElement != null)\n\t{\n\t\tif (this.previewElement.parentNode != null)\n\t\t{\n\t\t\tthis.previewElement.parentNode.removeChild(this.previewElement);\n\t\t}\n\n\t\tthis.previewElement = null;\n\t}\n\n\tif (this.currentGuide != null)\n\t{\n\t\tthis.currentGuide.destroy();\n\t\tthis.currentGuide = null;\n\t}\n\n\tif (this.currentHighlight != null)\n\t{\n\t\tthis.currentHighlight.destroy();\n\t\tthis.currentHighlight = null;\n\t}\n};\n\n/**\n * Function: dragOver\n *\n * Implements autoscroll, updates the <currentPoint>, highlights any drop\n * targets and updates the preview.\n */\nmxDragSource.prototype.dragOver = function(graph, evt)\n{\n\tvar offset = mxUtils.getOffset(graph.container);\n\tvar origin = mxUtils.getScrollOrigin(graph.container);\n\tvar x = mxEvent.getClientX(evt) - offset.x + origin.x - graph.panDx;\n\tvar y = mxEvent.getClientY(evt) - offset.y + origin.y - graph.panDy;\n\n\tif (graph.autoScroll && (this.autoscroll == null || this.autoscroll))\n\t{\n\t\tgraph.scrollPointToVisible(x, y, graph.autoExtend);\n\t}\n\n\t// Highlights the drop target under the mouse\n\tif (this.currentHighlight != null && graph.isDropEnabled())\n\t{\n\t\tthis.currentDropTarget = this.getDropTarget(graph, x, y, evt);\n\t\tvar state = graph.getView().getState(this.currentDropTarget);\n\t\tthis.currentHighlight.highlight(state);\n\t}\n\n\t// Updates the location of the preview\n\tif (this.previewElement != null)\n\t{\n\t\tif (this.previewElement.parentNode == null)\n\t\t{\n\t\t\tgraph.container.appendChild(this.previewElement);\n\n\t\t\tthis.previewElement.style.zIndex = '3';\n\t\t\tthis.previewElement.style.position = 'absolute';\n\t\t}\n\n\t\tvar gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);\n\t\tvar hideGuide = true;\n\n\t\t// Grid and guides\n\t\tif (this.currentGuide != null && this.currentGuide.isEnabledForEvent(evt))\n\t\t{\n\t\t\t// LATER: HTML preview appears smaller than SVG preview\n\t\t\tvar w = parseInt(this.previewElement.style.width);\n\t\t\tvar h = parseInt(this.previewElement.style.height);\n\t\t\tvar bounds = new mxRectangle(0, 0, w, h);\n\t\t\tvar delta = new mxPoint(x, y);\n\t\t\tdelta = this.currentGuide.move(bounds, delta, gridEnabled, true);\n\t\t\thideGuide = false;\n\t\t\tx = delta.x;\n\t\t\ty = delta.y;\n\t\t}\n\t\telse if (gridEnabled)\n\t\t{\n\t\t\tvar scale = graph.view.scale;\n\t\t\tvar tr = graph.view.translate;\n\t\t\tvar off = graph.gridSize / 2;\n\t\t\tx = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;\n\t\t\ty = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;\n\t\t}\n\n\t\tif (this.currentGuide != null && hideGuide)\n\t\t{\n\t\t\tthis.currentGuide.hide();\n\t\t}\n\n\t\tif (this.previewOffset != null)\n\t\t{\n\t\t\tx += this.previewOffset.x;\n\t\t\ty += this.previewOffset.y;\n\t\t}\n\n\t\tthis.previewElement.style.left = Math.round(x) + 'px';\n\t\tthis.previewElement.style.top = Math.round(y) + 'px';\n\t\tthis.previewElement.style.visibility = 'visible';\n\t}\n\n\tthis.currentPoint = new mxPoint(x, y);\n};\n\n/**\n * Function: drop\n *\n * Returns the drop target for the given graph and coordinates. This\n * implementation uses <mxGraph.getCellAt>.\n */\nmxDragSource.prototype.drop = function(graph, evt, dropTarget, x, y)\n{\n\tthis.dropHandler.apply(this, arguments);\n\n\t// Had to move this to after the insert because it will\n\t// affect the scrollbars of the window in IE to try and\n\t// make the complete container visible.\n\t// LATER: Should be made optional.\n\tif (graph.container.style.visibility != 'hidden')\n\t{\n\t\tgraph.container.focus();\n\t}\n};\n\n__mxOutput.mxDragSource = typeof mxDragSource !== 'undefined' ? mxDragSource : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxToolbar\n *\n * Creates a toolbar inside a given DOM node. The toolbar may contain icons,\n * buttons and combo boxes.\n *\n * Event: mxEvent.SELECT\n *\n * Fires when an item was selected in the toolbar. The <code>function</code>\n * property contains the function that was selected in <selectMode>.\n *\n * Constructor: mxToolbar\n *\n * Constructs a toolbar in the specified container.\n *\n * Parameters:\n *\n * container - DOM node that contains the toolbar.\n */\nfunction mxToolbar(container)\n{\n\tthis.container = container;\n};\n\n/**\n * Extends mxEventSource.\n */\nmxToolbar.prototype = new mxEventSource();\nmxToolbar.prototype.constructor = mxToolbar;\n\n/**\n * Variable: container\n *\n * Reference to the DOM nodes that contains the toolbar.\n */\nmxToolbar.prototype.container = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxToolbar.prototype.enabled = true;\n\n/**\n * Variable: noReset\n *\n * Specifies if <resetMode> requires a forced flag of true for resetting\n * the current mode in the toolbar. Default is false. This is set to true\n * if the toolbar item is double clicked to avoid a reset after a single\n * use of the item.\n */\nmxToolbar.prototype.noReset = false;\n\n/**\n * Variable: updateDefaultMode\n *\n * Boolean indicating if the default mode should be the last selected\n * switch mode or the first inserted switch mode. Default is true, that\n * is the last selected switch mode is the default mode. The default mode\n * is the mode to be selected after a reset of the toolbar. If this is\n * false, then the default mode is the first inserted mode item regardless\n * of what was last selected. Otherwise, the selected item after a reset is\n * the previously selected item.\n */\nmxToolbar.prototype.updateDefaultMode = true;\n\n/**\n * Function: addItem\n *\n * Adds the given function as an image with the specified title and icon\n * and returns the new image node.\n *\n * Parameters:\n *\n * title - Optional string that is used as the tooltip.\n * icon - Optional URL of the image to be used. If no URL is given, then a\n * button is created.\n * funct - Function to execute on a mouse click.\n * pressedIcon - Optional URL of the pressed image. Default is a gray\n * background.\n * style - Optional style classname. Default is mxToolbarItem.\n * factoryMethod - Optional factory method for popup menu, eg.\n * function(menu, evt, cell) { menu.addItem('Hello, World!'); }\n */\nmxToolbar.prototype.addItem = function(title, icon, funct, pressedIcon, style, factoryMethod)\n{\n\tvar img = document.createElement((icon != null) ? 'img' : 'button');\n\tvar initialClassName = style || ((factoryMethod != null) ?\n\t\t\t'mxToolbarMode' : 'mxToolbarItem');\n\timg.className = initialClassName;\n\timg.setAttribute('src', icon);\n\n\tif (title != null)\n\t{\n\t\tif (icon != null)\n\t\t{\n\t\t\timg.setAttribute('title', title);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxUtils.write(img, title);\n\t\t}\n\t}\n\n\tthis.container.appendChild(img);\n\n\t// Invokes the function on a click on the toolbar item\n\tif (funct != null)\n\t{\n\t\tmxEvent.addListener(img, 'click', funct);\n\n\t\tif (mxClient.IS_TOUCH)\n\t\t{\n\t\t\tmxEvent.addListener(img, 'touchend', funct);\n\t\t}\n\t}\n\n\tvar mouseHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (pressedIcon != null)\n\t\t{\n\t\t\timg.setAttribute('src', icon);\n\t\t}\n\t\telse\n\t\t{\n\t\t\timg.style.backgroundColor = '';\n\t\t}\n\t});\n\n\t// Highlights the toolbar item with a gray background\n\t// while it is being clicked with the mouse\n\tmxEvent.addGestureListeners(img, mxUtils.bind(this, function(evt)\n\t{\n\t\tif (pressedIcon != null)\n\t\t{\n\t\t\timg.setAttribute('src', pressedIcon);\n\t\t}\n\t\telse\n\t\t{\n\t\t\timg.style.backgroundColor = 'gray';\n\t\t}\n\n\t\t// Popup Menu\n\t\tif (factoryMethod != null)\n\t\t{\n\t\t\tif (this.menu == null)\n\t\t\t{\n\t\t\t\tthis.menu = new mxPopupMenu();\n\t\t\t\tthis.menu.init();\n\t\t\t}\n\n\t\t\tvar last = this.currentImg;\n\n\t\t\tif (this.menu.isMenuShowing())\n\t\t\t{\n\t\t\t\tthis.menu.hideMenu();\n\t\t\t}\n\n\t\t\tif (last != img)\n\t\t\t{\n\t\t\t\t// Redirects factory method to local factory method\n\t\t\t\tthis.currentImg = img;\n\t\t\t\tthis.menu.factoryMethod = factoryMethod;\n\n\t\t\t\tvar point = new mxPoint(\n\t\t\t\t\timg.offsetLeft,\n\t\t\t\t\timg.offsetTop + img.offsetHeight);\n\t\t\t\tthis.menu.popup(point.x, point.y, null, evt);\n\n\t\t\t\t// Sets and overrides to restore classname\n\t\t\t\tif (this.menu.isMenuShowing())\n\t\t\t\t{\n\t\t\t\t\timg.className = initialClassName + 'Selected';\n\n\t\t\t\t\tthis.menu.hideMenu = function()\n\t\t\t\t\t{\n\t\t\t\t\t\tmxPopupMenu.prototype.hideMenu.apply(this);\n\t\t\t\t\t\timg.className = initialClassName;\n\t\t\t\t\t\tthis.currentImg = null;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}), null, mouseHandler);\n\n\tmxEvent.addListener(img, 'mouseout', mouseHandler);\n\n\treturn img;\n};\n\n/**\n * Function: addCombo\n *\n * Adds and returns a new SELECT element using the given style. The element\n * is placed inside a DIV with the mxToolbarComboContainer style classname.\n *\n * Parameters:\n *\n * style - Optional style classname. Default is mxToolbarCombo.\n */\nmxToolbar.prototype.addCombo = function(style)\n{\n\tvar div = document.createElement('div');\n\tdiv.style.display = 'inline';\n\tdiv.className = 'mxToolbarComboContainer';\n\n\tvar select = document.createElement('select');\n\tselect.className = style || 'mxToolbarCombo';\n\tdiv.appendChild(select);\n\n\tthis.container.appendChild(div);\n\n\treturn select;\n};\n\n/**\n * Function: addCombo\n *\n * Adds and returns a new SELECT element using the given title as the\n * default element. The selection is reset to this element after each\n * change.\n *\n * Parameters:\n *\n * title - String that specifies the title of the default element.\n * style - Optional style classname. Default is mxToolbarCombo.\n */\nmxToolbar.prototype.addActionCombo = function(title, style)\n{\n\tvar select = document.createElement('select');\n\tselect.className = style || 'mxToolbarCombo';\n\tthis.addOption(select, title, null);\n\n\tmxEvent.addListener(select, 'change', function(evt)\n\t{\n\t\tvar value = select.options[select.selectedIndex];\n\t\tselect.selectedIndex = 0;\n\n\t\tif (value.funct != null)\n\t\t{\n\t\t\tvalue.funct(evt);\n\t\t}\n\t});\n\n\tthis.container.appendChild(select);\n\n\treturn select;\n};\n\n/**\n * Function: addOption\n *\n * Adds and returns a new OPTION element inside the given SELECT element.\n * If the given value is a function then it is stored in the option's funct\n * field.\n *\n * Parameters:\n *\n * combo - SELECT element that will contain the new entry.\n * title - String that specifies the title of the option.\n * value - Specifies the value associated with this option.\n */\nmxToolbar.prototype.addOption = function(combo, title, value)\n{\n\tvar option = document.createElement('option');\n\tmxUtils.writeln(option, title);\n\n\tif (typeof(value) == 'function')\n\t{\n\t\toption.funct = value;\n\t}\n\telse\n\t{\n\t\toption.setAttribute('value', value);\n\t}\n\n\tcombo.appendChild(option);\n\n\treturn option;\n};\n\n/**\n * Function: addSwitchMode\n *\n * Adds a new selectable item to the toolbar. Only one switch mode item may\n * be selected at a time. The currently selected item is the default item\n * after a reset of the toolbar.\n */\nmxToolbar.prototype.addSwitchMode = function(title, icon, funct, pressedIcon, style)\n{\n\tvar img = document.createElement('img');\n\timg.initialClassName = style || 'mxToolbarMode';\n\timg.className = img.initialClassName;\n\timg.setAttribute('src', icon);\n\timg.altIcon = pressedIcon;\n\n\tif (title != null)\n\t{\n\t\timg.setAttribute('title', title);\n\t}\n\n\tmxEvent.addListener(img, 'click', mxUtils.bind(this, function(evt)\n\t{\n\t\tvar tmp = this.selectedMode.altIcon;\n\n\t\tif (tmp != null)\n\t\t{\n\t\t\tthis.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n\t\t\tthis.selectedMode.setAttribute('src', tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.selectedMode.className = this.selectedMode.initialClassName;\n\t\t}\n\n\t\tif (this.updateDefaultMode)\n\t\t{\n\t\t\tthis.defaultMode = img;\n\t\t}\n\n\t\tthis.selectedMode = img;\n\n\t\tvar tmp = img.altIcon;\n\n\t\tif (tmp != null)\n\t\t{\n\t\t\timg.altIcon = img.getAttribute('src');\n\t\t\timg.setAttribute('src', tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\timg.className = img.initialClassName+'Selected';\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.SELECT));\n\t\tfunct();\n\t}));\n\n\tthis.container.appendChild(img);\n\n\tif (this.defaultMode == null)\n\t{\n\t\tthis.defaultMode = img;\n\n\t\t// Function should fire only once so\n\t\t// do not pass it with the select event\n\t\tthis.selectMode(img);\n\t\tfunct();\n\t}\n\n\treturn img;\n};\n\n/**\n * Function: addMode\n *\n * Adds a new item to the toolbar. The selection is typically reset after\n * the item has been consumed, for example by adding a new vertex to the\n * graph. The reset is not carried out if the item is double clicked.\n *\n * The function argument uses the following signature: funct(evt, cell) where\n * evt is the native mouse event and cell is the cell under the mouse.\n */\nmxToolbar.prototype.addMode = function(title, icon, funct, pressedIcon, style, toggle)\n{\n\ttoggle = (toggle != null) ? toggle : true;\n\tvar img = document.createElement((icon != null) ? 'img' : 'button');\n\n\timg.initialClassName = style || 'mxToolbarMode';\n\timg.className = img.initialClassName;\n\timg.setAttribute('src', icon);\n\timg.altIcon = pressedIcon;\n\n\tif (title != null)\n\t{\n\t\timg.setAttribute('title', title);\n\t}\n\n\tif (this.enabled && toggle)\n\t{\n\t\tmxEvent.addListener(img, 'click', mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.selectMode(img, funct);\n\t\t\tthis.noReset = false;\n\t\t}));\n\n\t\tmxEvent.addListener(img, 'dblclick', mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.selectMode(img, funct);\n\t\t\tthis.noReset = true;\n\t\t}));\n\n\t\tif (this.defaultMode == null)\n\t\t{\n\t\t\tthis.defaultMode = img;\n\t\t\tthis.defaultFunction = funct;\n\t\t\tthis.selectMode(img, funct);\n\t\t}\n\t}\n\n\tthis.container.appendChild(img);\n\n\treturn img;\n};\n\n/**\n * Function: selectMode\n *\n * Resets the state of the previously selected mode and displays the given\n * DOM node as selected. This function fires a select event with the given\n * function as a parameter.\n */\nmxToolbar.prototype.selectMode = function(domNode, funct)\n{\n\tif (this.selectedMode != domNode)\n\t{\n\t\tif (this.selectedMode != null)\n\t\t{\n\t\t\tvar tmp = this.selectedMode.altIcon;\n\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tthis.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n\t\t\t\tthis.selectedMode.setAttribute('src', tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.selectedMode.className = this.selectedMode.initialClassName;\n\t\t\t}\n\t\t}\n\n\t\tthis.selectedMode = domNode;\n\t\tvar tmp = this.selectedMode.altIcon;\n\n\t\tif (tmp != null)\n\t\t{\n\t\t\tthis.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n\t\t\tthis.selectedMode.setAttribute('src', tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.selectedMode.className = this.selectedMode.initialClassName+'Selected';\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.SELECT, \"function\", funct));\n\t}\n};\n\n/**\n * Function: resetMode\n *\n * Selects the default mode and resets the state of the previously selected\n * mode.\n */\nmxToolbar.prototype.resetMode = function(forced)\n{\n\tif ((forced || !this.noReset) && this.selectedMode != this.defaultMode)\n\t{\n\t\t// The last selected switch mode will be activated\n\t\t// so the function was already executed and is\n\t\t// no longer required here\n\t\tthis.selectMode(this.defaultMode, this.defaultFunction);\n\t}\n};\n\n/**\n * Function: addSeparator\n *\n * Adds the specifies image as a separator.\n *\n * Parameters:\n *\n * icon - URL of the separator icon.\n */\nmxToolbar.prototype.addSeparator = function(icon)\n{\n\treturn this.addItem(null, icon, null);\n};\n\n/**\n * Function: addBreak\n *\n * Adds a break to the container.\n */\nmxToolbar.prototype.addBreak = function()\n{\n\tmxUtils.br(this.container);\n};\n\n/**\n * Function: addLine\n *\n * Adds a horizontal line to the container.\n */\nmxToolbar.prototype.addLine = function()\n{\n\tvar hr = document.createElement('hr');\n\n\thr.style.marginRight = '6px';\n\thr.setAttribute('size', '1');\n\n\tthis.container.appendChild(hr);\n};\n\n/**\n * Function: destroy\n *\n * Removes the toolbar and all its associated resources.\n */\nmxToolbar.prototype.destroy = function ()\n{\n\tmxEvent.release(this.container);\n\tthis.container = null;\n\tthis.defaultMode = null;\n\tthis.defaultFunction = null;\n\tthis.selectedMode = null;\n\n\tif (this.menu != null)\n\t{\n\t\tthis.menu.destroy();\n\t}\n};\n\n__mxOutput.mxToolbar = typeof mxToolbar !== 'undefined' ? mxToolbar : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxUndoableEdit\n *\n * Implements a composite undoable edit. Here is an example for a custom change\n * which gets executed via the model:\n *\n * (code)\n * function CustomChange(model, name)\n * {\n *   this.model = model;\n *   this.name = name;\n *   this.previous = name;\n * };\n *\n * CustomChange.prototype.execute = function()\n * {\n *   var tmp = this.model.name;\n *   this.model.name = this.previous;\n *   this.previous = tmp;\n * };\n *\n * var name = prompt('Enter name');\n * graph.model.execute(new CustomChange(graph.model, name));\n * (end)\n *\n * Event: mxEvent.EXECUTED\n *\n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\n * The <code>change</code> property contains the change that was executed.\n *\n * Event: mxEvent.START_EDIT\n *\n * Fires before a set of changes will be executed in <undo> or <redo>.\n * This event contains no properties.\n *\n * Event: mxEvent.END_EDIT\n *\n * Fires after a set of changeswas executed in <undo> or <redo>.\n * This event contains no properties.\n *\n * Constructor: mxUndoableEdit\n *\n * Constructs a new undoable edit for the given source.\n */\nfunction mxUndoableEdit(source, significant)\n{\n\tthis.source = source;\n\tthis.changes = [];\n\tthis.significant = (significant != null) ? significant : true;\n};\n\n/**\n * Variable: source\n *\n * Specifies the source of the edit.\n */\nmxUndoableEdit.prototype.source = null;\n\n/**\n * Variable: changes\n *\n * Array that contains the changes that make up this edit. The changes are\n * expected to either have an undo and redo function, or an execute\n * function. Default is an empty array.\n */\nmxUndoableEdit.prototype.changes = null;\n\n/**\n * Variable: significant\n *\n * Specifies if the undoable change is significant.\n * Default is true.\n */\nmxUndoableEdit.prototype.significant = null;\n\n/**\n * Variable: undone\n *\n * Specifies if this edit has been undone. Default is false.\n */\nmxUndoableEdit.prototype.undone = false;\n\n/**\n * Variable: redone\n *\n * Specifies if this edit has been redone. Default is false.\n */\nmxUndoableEdit.prototype.redone = false;\n\n/**\n * Function: isEmpty\n *\n * Returns true if the this edit contains no changes.\n */\nmxUndoableEdit.prototype.isEmpty = function()\n{\n\treturn this.changes.length == 0;\n};\n\n/**\n * Function: isSignificant\n *\n * Returns <significant>.\n */\nmxUndoableEdit.prototype.isSignificant = function()\n{\n\treturn this.significant;\n};\n\n/**\n * Function: add\n *\n * Adds the specified change to this edit. The change is an object that is\n * expected to either have an undo and redo, or an execute function.\n */\nmxUndoableEdit.prototype.add = function(change)\n{\n\tthis.changes.push(change);\n};\n\n/**\n * Function: notify\n *\n * Hook to notify any listeners of the changes after an <undo> or <redo>\n * has been carried out. This implementation is empty.\n */\nmxUndoableEdit.prototype.notify = function() { };\n\n/**\n * Function: die\n *\n * Hook to free resources after the edit has been removed from the command\n * history. This implementation is empty.\n */\nmxUndoableEdit.prototype.die = function() { };\n\n/**\n * Function: undo\n *\n * Undoes all changes in this edit.\n */\nmxUndoableEdit.prototype.undo = function()\n{\n\tif (!this.undone)\n\t{\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));\n\t\tvar count = this.changes.length;\n\n\t\tfor (var i = count - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar change = this.changes[i];\n\n\t\t\tif (change.execute != null)\n\t\t\t{\n\t\t\t\tchange.execute();\n\t\t\t}\n\t\t\telse if (change.undo != null)\n\t\t\t{\n\t\t\t\tchange.undo();\n\t\t\t}\n\n\t\t\t// New global executed event\n\t\t\tthis.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', change));\n\t\t}\n\n\t\tthis.undone = true;\n\t\tthis.redone = false;\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));\n\t}\n\n\tthis.notify();\n};\n\n/**\n * Function: redo\n *\n * Redoes all changes in this edit.\n */\nmxUndoableEdit.prototype.redo = function()\n{\n\tif (!this.redone)\n\t{\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.START_EDIT));\n\t\tvar count = this.changes.length;\n\n\t\tfor (var i = 0; i < count; i++)\n\t\t{\n\t\t\tvar change = this.changes[i];\n\n\t\t\tif (change.execute != null)\n\t\t\t{\n\t\t\t\tchange.execute();\n\t\t\t}\n\t\t\telse if (change.redo != null)\n\t\t\t{\n\t\t\t\tchange.redo();\n\t\t\t}\n\n\t\t\t// New global executed event\n\t\t\tthis.source.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', change));\n\t\t}\n\n\t\tthis.undone = false;\n\t\tthis.redone = true;\n\t\tthis.source.fireEvent(new mxEventObject(mxEvent.END_EDIT));\n\t}\n\n\tthis.notify();\n};\n\n__mxOutput.mxUndoableEdit = typeof mxUndoableEdit !== 'undefined' ? mxUndoableEdit : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxUndoManager\n *\n * Implements a command history. When changing the graph model, an\n * <mxUndoableChange> object is created at the start of the transaction (when\n * model.beginUpdate is called). All atomic changes are then added to this\n * object until the last model.endUpdate call, at which point the\n * <mxUndoableEdit> is dispatched in an event, and added to the history inside\n * <mxUndoManager>. This is done by an event listener in\n * <mxEditor.installUndoHandler>.\n *\n * Each atomic change of the model is represented by an object (eg.\n * <mxRootChange>, <mxChildChange>, <mxTerminalChange> etc) which contains the\n * complete undo information. The <mxUndoManager> also listens to the\n * <mxGraphView> and stores it's changes to the current root as insignificant\n * undoable changes, so that drilling (step into, step up) is undone.\n *\n * This means when you execute an atomic change on the model, then change the\n * current root on the view and click undo, the change of the root will be\n * undone together with the change of the model so that the display represents\n * the state at which the model was changed. However, these changes are not\n * transmitted for sharing as they do not represent a state change.\n *\n * Example:\n *\n * When adding an undo manager to a graph, make sure to add it\n * to the model and the view as well to maintain a consistent\n * display across multiple undo/redo steps.\n *\n * (code)\n * var undoManager = new mxUndoManager();\n * var listener = function(sender, evt)\n * {\n *   undoManager.undoableEditHappened(evt.getProperty('edit'));\n * };\n * graph.getModel().addListener(mxEvent.UNDO, listener);\n * graph.getView().addListener(mxEvent.UNDO, listener);\n * (end)\n *\n * The code creates a function that informs the undoManager\n * of an undoable edit and binds it to the undo event of\n * <mxGraphModel> and <mxGraphView> using\n * <mxEventSource.addListener>.\n *\n * Event: mxEvent.CLEAR\n *\n * Fires after <clear> was invoked. This event has no properties.\n *\n * Event: mxEvent.UNDO\n *\n * Fires afer a significant edit was undone in <undo>. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was undone.\n *\n * Event: mxEvent.REDO\n *\n * Fires afer a significant edit was redone in <redo>. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was redone.\n *\n * Event: mxEvent.ADD\n *\n * Fires after an undoable edit was added to the history. The <code>edit</code>\n * property contains the <mxUndoableEdit> that was added.\n *\n * Constructor: mxUndoManager\n *\n * Constructs a new undo manager with the given history size. If no history\n * size is given, then a default size of 100 steps is used.\n */\nfunction mxUndoManager(size)\n{\n\tthis.size = (size != null) ? size : 100;\n\tthis.clear();\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUndoManager.prototype = new mxEventSource();\nmxUndoManager.prototype.constructor = mxUndoManager;\n\n/**\n * Variable: size\n *\n * Maximum command history size. 0 means unlimited history. Default is\n * 100.\n */\nmxUndoManager.prototype.size = null;\n\n/**\n * Variable: history\n *\n * Array that contains the steps of the command history.\n */\nmxUndoManager.prototype.history = null;\n\n/**\n * Variable: indexOfNextAdd\n *\n * Index of the element to be added next.\n */\nmxUndoManager.prototype.indexOfNextAdd = 0;\n\n/**\n * Function: isEmpty\n *\n * Returns true if the history is empty.\n */\nmxUndoManager.prototype.isEmpty = function()\n{\n\treturn this.history.length == 0;\n};\n\n/**\n * Function: clear\n *\n * Clears the command history.\n */\nmxUndoManager.prototype.clear = function()\n{\n\tthis.history = [];\n\tthis.indexOfNextAdd = 0;\n\tthis.fireEvent(new mxEventObject(mxEvent.CLEAR));\n};\n\n/**\n * Function: canUndo\n *\n * Returns true if an undo is possible.\n */\nmxUndoManager.prototype.canUndo = function()\n{\n\treturn this.indexOfNextAdd > 0;\n};\n\n/**\n * Function: undo\n *\n * Undoes the last change.\n */\nmxUndoManager.prototype.undo = function()\n{\n    while (this.indexOfNextAdd > 0)\n    {\n        var edit = this.history[--this.indexOfNextAdd];\n        edit.undo();\n\n\t\tif (edit.isSignificant())\n        {\n        \tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n            break;\n        }\n    }\n};\n\n/**\n * Function: canRedo\n *\n * Returns true if a redo is possible.\n */\nmxUndoManager.prototype.canRedo = function()\n{\n\treturn this.indexOfNextAdd < this.history.length;\n};\n\n/**\n * Function: redo\n *\n * Redoes the last change.\n */\nmxUndoManager.prototype.redo = function()\n{\n    var n = this.history.length;\n\n    while (this.indexOfNextAdd < n)\n    {\n        var edit =  this.history[this.indexOfNextAdd++];\n        edit.redo();\n\n        if (edit.isSignificant())\n        {\n        \tthis.fireEvent(new mxEventObject(mxEvent.REDO, 'edit', edit));\n            break;\n        }\n    }\n};\n\n/**\n * Function: undoableEditHappened\n *\n * Method to be called to add new undoable edits to the <history>.\n */\nmxUndoManager.prototype.undoableEditHappened = function(undoableEdit)\n{\n\tthis.trim();\n\n\tif (this.size > 0 &&\n\t\tthis.size == this.history.length)\n\t{\n\t\tthis.history.shift();\n\t}\n\n\tthis.history.push(undoableEdit);\n\tthis.indexOfNextAdd = this.history.length;\n\tthis.fireEvent(new mxEventObject(mxEvent.ADD, 'edit', undoableEdit));\n};\n\n/**\n * Function: trim\n *\n * Removes all pending steps after <indexOfNextAdd> from the history,\n * invoking die on each edit. This is called from <undoableEditHappened>.\n */\nmxUndoManager.prototype.trim = function()\n{\n\tif (this.history.length > this.indexOfNextAdd)\n\t{\n\t\tvar edits = this.history.splice(this.indexOfNextAdd,\n\t\t\tthis.history.length - this.indexOfNextAdd);\n\n\t\tfor (var i = 0; i < edits.length; i++)\n\t\t{\n\t\t\tedits[i].die();\n\t\t}\n\t}\n};\n\n__mxOutput.mxUndoManager = typeof mxUndoManager !== 'undefined' ? mxUndoManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxUrlConverter\n *\n * Converts relative and absolute URLs to absolute URLs with protocol and domain.\n */\nvar mxUrlConverter = function()\n{\n\t// Empty constructor\n};\n\n/**\n * Variable: enabled\n *\n * Specifies if the converter is enabled. Default is true.\n */\nmxUrlConverter.prototype.enabled = true;\n\n/**\n * Variable: baseUrl\n *\n * Specifies the base URL to be used as a prefix for relative URLs.\n */\nmxUrlConverter.prototype.baseUrl = null;\n\n/**\n * Variable: baseDomain\n *\n * Specifies the base domain to be used as a prefix for absolute URLs.\n */\nmxUrlConverter.prototype.baseDomain = null;\n\n/**\n * Function: updateBaseUrl\n *\n * Private helper function to update the base URL.\n */\nmxUrlConverter.prototype.updateBaseUrl = function()\n{\n\tthis.baseDomain = location.protocol + '//' + location.host;\n\tthis.baseUrl = this.baseDomain + location.pathname;\n\tvar tmp = this.baseUrl.lastIndexOf('/');\n\n\t// Strips filename etc\n\tif (tmp > 0)\n\t{\n\t\tthis.baseUrl = this.baseUrl.substring(0, tmp + 1);\n\t}\n};\n\n/**\n * Function: isEnabled\n *\n * Returns <enabled>.\n */\nmxUrlConverter.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Sets <enabled>.\n */\nmxUrlConverter.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: getBaseUrl\n *\n * Returns <baseUrl>.\n */\nmxUrlConverter.prototype.getBaseUrl = function()\n{\n\treturn this.baseUrl;\n};\n\n/**\n * Function: setBaseUrl\n *\n * Sets <baseUrl>.\n */\nmxUrlConverter.prototype.setBaseUrl = function(value)\n{\n\tthis.baseUrl = value;\n};\n\n/**\n * Function: getBaseDomain\n *\n * Returns <baseDomain>.\n */\nmxUrlConverter.prototype.getBaseDomain = function()\n{\n\treturn this.baseDomain;\n},\n\n/**\n * Function: setBaseDomain\n *\n * Sets <baseDomain>.\n */\nmxUrlConverter.prototype.setBaseDomain = function(value)\n{\n\tthis.baseDomain = value;\n},\n\n/**\n * Function: isRelativeUrl\n *\n * Returns true if the given URL is relative.\n */\nmxUrlConverter.prototype.isRelativeUrl = function(url)\n{\n\treturn url.substring(0, 2) != '//' && url.substring(0, 7) != 'http://' &&\n\t\turl.substring(0, 8) != 'https://' && url.substring(0, 10) != 'data:image' &&\n\t\turl.substring(0, 7) != 'file://';\n};\n\n/**\n * Function: convert\n *\n * Converts the given URL to an absolute URL with protol and domain.\n * Relative URLs are first converted to absolute URLs.\n */\nmxUrlConverter.prototype.convert = function(url)\n{\n\tif (this.isEnabled() && this.isRelativeUrl(url))\n\t{\n\t\tif (this.getBaseUrl() == null)\n\t\t{\n\t\t\tthis.updateBaseUrl();\n\t\t}\n\n\t\tif (url.charAt(0) == '/')\n\t\t{\n\t\t\turl = this.getBaseDomain() + url;\n\t\t}\n\t\telse\n\t\t{\n\t\t\turl = this.getBaseUrl() + url;\n\t\t}\n\t}\n\n\treturn url;\n};\n\n__mxOutput.mxUrlConverter = typeof mxUrlConverter !== 'undefined' ? mxUrlConverter : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPanningManager\n *\n * Implements a handler for panning.\n */\nfunction mxPanningManager(graph)\n{\n\tthis.thread = null;\n\tthis.active = false;\n\tthis.tdx = 0;\n\tthis.tdy = 0;\n\tthis.t0x = 0;\n\tthis.t0y = 0;\n\tthis.dx = 0;\n\tthis.dy = 0;\n\tthis.scrollbars = false;\n\tthis.scrollLeft = 0;\n\tthis.scrollTop = 0;\n\n\tthis.mouseListener =\n\t{\n\t    mouseDown: function(sender, me) { },\n\t    mouseMove: function(sender, me) { },\n\t    mouseUp: mxUtils.bind(this, function(sender, me)\n\t    {\n\t    \tif (this.active)\n\t    \t{\n\t    \t\tthis.stop();\n\t    \t}\n\t    })\n\t};\n\n\tgraph.addMouseListener(this.mouseListener);\n\n\tthis.mouseUpListener = mxUtils.bind(this, function()\n\t{\n\t    \tif (this.active)\n\t    \t{\n\t    \t\tthis.stop();\n\t    \t}\n\t});\n\n\t// Stops scrolling on every mouseup anywhere in the document\n\tmxEvent.addListener(document, 'mouseup', this.mouseUpListener);\n\n\tvar createThread = mxUtils.bind(this, function()\n\t{\n\t    \tthis.scrollbars = mxUtils.hasScrollbars(graph.container);\n\t    \tthis.scrollLeft = graph.container.scrollLeft;\n\t    \tthis.scrollTop = graph.container.scrollTop;\n\n\t    \treturn window.setInterval(mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.tdx -= this.dx;\n\t\t\tthis.tdy -= this.dy;\n\n\t\t\tif (this.scrollbars)\n\t\t\t{\n\t\t\t\tvar left = -graph.container.scrollLeft - Math.ceil(this.dx);\n\t\t\t\tvar top = -graph.container.scrollTop - Math.ceil(this.dy);\n\t\t\t\tgraph.panGraph(left, top);\n\t\t\t\tgraph.panDx = this.scrollLeft - graph.container.scrollLeft;\n\t\t\t\tgraph.panDy = this.scrollTop - graph.container.scrollTop;\n\t\t\t\tgraph.fireEvent(new mxEventObject(mxEvent.PAN));\n\t\t\t\t// TODO: Implement graph.autoExtend\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgraph.panGraph(this.getDx(), this.getDy());\n\t\t\t}\n\t\t}), this.delay);\n\t});\n\n\tthis.isActive = function()\n\t{\n\t\treturn active;\n\t};\n\n\tthis.getDx = function()\n\t{\n\t\treturn Math.round(this.tdx);\n\t};\n\n\tthis.getDy = function()\n\t{\n\t\treturn Math.round(this.tdy);\n\t};\n\n\tthis.start = function()\n\t{\n\t\tthis.t0x = graph.view.translate.x;\n\t\tthis.t0y = graph.view.translate.y;\n\t\tthis.active = true;\n\t};\n\n\tthis.panTo = function(x, y, w, h)\n\t{\n\t\tif (!this.active)\n\t\t{\n\t\t\tthis.start();\n\t\t}\n\n    \tthis.scrollLeft = graph.container.scrollLeft;\n    \tthis.scrollTop = graph.container.scrollTop;\n\n\t\tw = (w != null) ? w : 0;\n\t\th = (h != null) ? h : 0;\n\n\t\tvar c = graph.container;\n\t\tthis.dx = x + w - c.scrollLeft - c.clientWidth;\n\n\t\tif (this.dx < 0 && Math.abs(this.dx) < this.border)\n\t\t{\n\t\t\tthis.dx = this.border + this.dx;\n\t\t}\n\t\telse if (this.handleMouseOut)\n\t\t{\n\t\t\tthis.dx = Math.max(this.dx, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.dx = 0;\n\t\t}\n\n\t\tif (this.dx == 0)\n\t\t{\n\t\t\tthis.dx = x - c.scrollLeft;\n\n\t\t\tif (this.dx > 0 && this.dx < this.border)\n\t\t\t{\n\t\t\t\tthis.dx = this.dx - this.border;\n\t\t\t}\n\t\t\telse if (this.handleMouseOut)\n\t\t\t{\n\t\t\t\tthis.dx = Math.min(0, this.dx);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.dx = 0;\n\t\t\t}\n\t\t}\n\n\t\tthis.dy = y + h - c.scrollTop - c.clientHeight;\n\n\t\tif (this.dy < 0 && Math.abs(this.dy) < this.border)\n\t\t{\n\t\t\tthis.dy = this.border + this.dy;\n\t\t}\n\t\telse if (this.handleMouseOut)\n\t\t{\n\t\t\tthis.dy = Math.max(this.dy, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.dy = 0;\n\t\t}\n\n\t\tif (this.dy == 0)\n\t\t{\n\t\t\tthis.dy = y - c.scrollTop;\n\n\t\t\tif (this.dy > 0 && this.dy < this.border)\n\t\t\t{\n\t\t\t\tthis.dy = this.dy - this.border;\n\t\t\t}\n\t\t\telse if (this.handleMouseOut)\n\t\t\t{\n\t\t\t\tthis.dy = Math.min(0, this.dy);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.dy = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (this.dx != 0 || this.dy != 0)\n\t\t{\n\t\t\tthis.dx *= this.damper;\n\t\t\tthis.dy *= this.damper;\n\n\t\t\tif (this.thread == null)\n\t\t\t{\n\t\t\t\tthis.thread = createThread();\n\t\t\t}\n\t\t}\n\t\telse if (this.thread != null)\n\t\t{\n\t\t\twindow.clearInterval(this.thread);\n\t\t\tthis.thread = null;\n\t\t}\n\t};\n\n\tthis.stop = function()\n\t{\n\t\tif (this.active)\n\t\t{\n\t\t\tthis.active = false;\n\n\t\t\tif (this.thread != null)\n\t    \t{\n\t\t\t\twindow.clearInterval(this.thread);\n\t\t\t\tthis.thread = null;\n\t    \t}\n\n\t\t\tthis.tdx = 0;\n\t\t\tthis.tdy = 0;\n\n\t\t\tif (!this.scrollbars)\n\t\t\t{\n\t\t\t\tvar px = graph.panDx;\n\t\t\t\tvar py = graph.panDy;\n\n\t\t    \tif (px != 0 || py != 0)\n\t\t    \t{\n\t\t    \t\tgraph.panGraph(0, 0);\n\t\t\t    \tgraph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);\n\t\t    \t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgraph.panDx = 0;\n\t\t\t\tgraph.panDy = 0;\n\t\t\t\tgraph.fireEvent(new mxEventObject(mxEvent.PAN));\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.destroy = function()\n\t{\n\t\tgraph.removeMouseListener(this.mouseListener);\n\t\tmxEvent.removeListener(document, 'mouseup', this.mouseUpListener);\n\t};\n};\n\n/**\n * Variable: damper\n *\n * Damper value for the panning. Default is 1/6.\n */\nmxPanningManager.prototype.damper = 1/6;\n\n/**\n * Variable: delay\n *\n * Delay in milliseconds for the panning. Default is 10.\n */\nmxPanningManager.prototype.delay = 10;\n\n/**\n * Variable: handleMouseOut\n *\n * Specifies if mouse events outside of the component should be handled. Default is true.\n */\nmxPanningManager.prototype.handleMouseOut = true;\n\n/**\n * Variable: border\n *\n * Border to handle automatic panning inside the component. Default is 0 (disabled).\n */\nmxPanningManager.prototype.border = 0;\n\n__mxOutput.mxPanningManager = typeof mxPanningManager !== 'undefined' ? mxPanningManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPopupMenu\n *\n * Basic popup menu. To add a vertical scrollbar to a given submenu, the\n * following code can be used.\n *\n * (code)\n * var mxPopupMenuShowMenu = mxPopupMenu.prototype.showMenu;\n * mxPopupMenu.prototype.showMenu = function()\n * {\n *   mxPopupMenuShowMenu.apply(this, arguments);\n *\n *   this.div.style.overflowY = 'auto';\n *   this.div.style.overflowX = 'hidden';\n *   this.div.style.maxHeight = '160px';\n * };\n * (end)\n *\n * Constructor: mxPopupMenu\n *\n * Constructs a popupmenu.\n *\n * Event: mxEvent.SHOW\n *\n * Fires after the menu has been shown in <popup>.\n */\nfunction mxPopupMenu(factoryMethod)\n{\n\tthis.factoryMethod = factoryMethod;\n\n\tif (factoryMethod != null)\n\t{\n\t\tthis.init();\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxPopupMenu.prototype = new mxEventSource();\nmxPopupMenu.prototype.constructor = mxPopupMenu;\n\n/**\n * Variable: submenuImage\n *\n * URL of the image to be used for the submenu icon.\n */\nmxPopupMenu.prototype.submenuImage = mxClient.imageBasePath + '/submenu.gif';\n\n/**\n * Variable: zIndex\n *\n * Specifies the zIndex for the popupmenu and its shadow. Default is 1006.\n */\nmxPopupMenu.prototype.zIndex = 10006;\n\n/**\n * Variable: factoryMethod\n *\n * Function that is used to create the popup menu. The function takes the\n * current panning handler, the <mxCell> under the mouse and the mouse\n * event that triggered the call as arguments.\n */\nmxPopupMenu.prototype.factoryMethod = null;\n\n/**\n * Variable: useLeftButtonForPopup\n *\n * Specifies if popupmenus should be activated by clicking the left mouse\n * button. Default is false.\n */\nmxPopupMenu.prototype.useLeftButtonForPopup = false;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxPopupMenu.prototype.enabled = true;\n\n/**\n * Variable: itemCount\n *\n * Contains the number of times <addItem> has been called for a new menu.\n */\nmxPopupMenu.prototype.itemCount = 0;\n\n/**\n * Variable: autoExpand\n *\n * Specifies if submenus should be expanded on mouseover. Default is false.\n */\nmxPopupMenu.prototype.autoExpand = false;\n\n/**\n * Variable: smartSeparators\n *\n * Specifies if separators should only be added if a menu item follows them.\n * Default is false.\n */\nmxPopupMenu.prototype.smartSeparators = false;\n\n/**\n * Variable: labels\n *\n * Specifies if any labels should be visible. Default is true.\n */\nmxPopupMenu.prototype.labels = true;\n\n/**\n * Function: init\n *\n * Initializes the shapes required for this vertex handler.\n */\nmxPopupMenu.prototype.init = function()\n{\n\t// Adds the inner table\n\tthis.table = document.createElement('table');\n\tthis.table.className = 'mxPopupMenu';\n\n\tthis.tbody = document.createElement('tbody');\n\tthis.table.appendChild(this.tbody);\n\n\t// Adds the outer div\n\tthis.div = document.createElement('div');\n\tthis.div.className = 'mxPopupMenu';\n\tthis.div.style.display = 'inline';\n\tthis.div.style.zIndex = this.zIndex;\n\tthis.div.appendChild(this.table);\n\n\t// Disables the context menu on the outer div\n\tmxEvent.disableContextMenu(this.div);\n};\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxPopupMenu.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n */\nmxPopupMenu.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isPopupTrigger\n *\n * Returns true if the given event is a popupmenu trigger for the optional\n * given cell.\n *\n * Parameters:\n *\n * me - <mxMouseEvent> that represents the mouse event.\n */\nmxPopupMenu.prototype.isPopupTrigger = function(me)\n{\n\treturn me.isPopupTrigger() || (this.useLeftButtonForPopup && mxEvent.isLeftMouseButton(me.getEvent()));\n};\n\n/**\n * Function: addItem\n *\n * Adds the given item to the given parent item. If no parent item is specified\n * then the item is added to the top-level menu. The return value may be used\n * as the parent argument, ie. as a submenu item. The return value is the table\n * row that represents the item.\n *\n * Paramters:\n *\n * title - String that represents the title of the menu item.\n * image - Optional URL for the image icon.\n * funct - Function associated that takes a mouseup or touchend event.\n * parent - Optional item returned by <addItem>.\n * iconCls - Optional string that represents the CSS class for the image icon.\n * IconsCls is ignored if image is given.\n * enabled - Optional boolean indicating if the item is enabled. Default is true.\n * active - Optional boolean indicating if the menu should implement any event handling.\n * Default is true.\n */\nmxPopupMenu.prototype.addItem = function(title, image, funct, parent, iconCls, enabled, active)\n{\n\tparent = parent || this;\n\tthis.itemCount++;\n\n\t// Smart separators only added if element contains items\n\tif (parent.willAddSeparator)\n\t{\n\t\tif (parent.containsItems)\n\t\t{\n\t\t\tthis.addSeparator(parent, true);\n\t\t}\n\n\t\tparent.willAddSeparator = false;\n\t}\n\n\tparent.containsItems = true;\n\tvar tr = document.createElement('tr');\n\ttr.className = 'mxPopupMenuItem';\n\tvar col1 = document.createElement('td');\n\tcol1.className = 'mxPopupMenuIcon';\n\n\t// Adds the given image into the first column\n\tif (image != null)\n\t{\n\t\tvar img = document.createElement('img');\n\t\timg.src = image;\n\t\tcol1.appendChild(img);\n\t}\n\telse if (iconCls != null)\n\t{\n\t\tvar div = document.createElement('div');\n\t\tdiv.className = iconCls;\n\t\tcol1.appendChild(div);\n\t}\n\n\ttr.appendChild(col1);\n\n\tif (this.labels)\n\t{\n\t\tvar col2 = document.createElement('td');\n\t\tcol2.className = 'mxPopupMenuItem' +\n\t\t\t((enabled != null && !enabled) ? ' mxDisabled' : '');\n\n\t\tmxUtils.write(col2, title);\n\t\tcol2.align = 'left';\n\t\ttr.appendChild(col2);\n\n\t\tvar col3 = document.createElement('td');\n\t\tcol3.className = 'mxPopupMenuItem' +\n\t\t\t((enabled != null && !enabled) ? ' mxDisabled' : '');\n\t\tcol3.style.paddingRight = '6px';\n\t\tcol3.style.textAlign = 'right';\n\n\t\ttr.appendChild(col3);\n\n\t\tif (parent.div == null)\n\t\t{\n\t\t\tthis.createSubmenu(parent);\n\t\t}\n\t}\n\n\tparent.tbody.appendChild(tr);\n\n\tif (active != false && enabled != false)\n\t{\n\t\tvar currentSelection = null;\n\n\t\tmxEvent.addGestureListeners(tr,\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tthis.eventReceiver = tr;\n\n\t\t\t\tif (parent.activeRow != tr && parent.activeRow != parent)\n\t\t\t\t{\n\t\t\t\t\tif (parent.activeRow != null && parent.activeRow.div.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.hideSubmenu(parent);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tr.div != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.showSubmenu(parent, tr);\n\t\t\t\t\t\tparent.activeRow = tr;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Workaround for lost current selection in page because of focus in IE\n\t\t\t\tif (document.selection != null && (mxClient.IS_QUIRKS || document.documentMode == 8))\n\t\t\t\t{\n\t\t\t\t\tcurrentSelection = document.selection.createRange();\n\t\t\t\t}\n\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (parent.activeRow != tr && parent.activeRow != parent)\n\t\t\t\t{\n\t\t\t\t\tif (parent.activeRow != null && parent.activeRow.div.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.hideSubmenu(parent);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.autoExpand && tr.div != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.showSubmenu(parent, tr);\n\t\t\t\t\t\tparent.activeRow = tr;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Sets hover style because TR in IE doesn't have hover\n\t\t\t\ttr.className = 'mxPopupMenuItemHover';\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\t// EventReceiver avoids clicks on a submenu item\n\t\t\t\t// which has just been shown in the mousedown\n\t\t\t\tif (this.eventReceiver == tr)\n\t\t\t\t{\n\t\t\t\t\tif (parent.activeRow != tr)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.hideMenu();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround for lost current selection in page because of focus in IE\n\t\t\t\t\tif (currentSelection != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Workaround for \"unspecified error\" in IE8 standards\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentSelection.select();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentSelection = null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (funct != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfunct(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.eventReceiver = null;\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t})\n\t\t);\n\n\t\t// Resets hover style because TR in IE doesn't have hover\n\t\tmxEvent.addListener(tr, 'mouseout',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\ttr.className = 'mxPopupMenuItem';\n\t\t\t})\n\t\t);\n\t}\n\n\treturn tr;\n};\n\n/**\n * Adds a checkmark to the given menuitem.\n */\nmxPopupMenu.prototype.addCheckmark = function(item, img)\n{\n\tvar td = item.firstChild.nextSibling;\n\ttd.style.backgroundImage = 'url(\\'' + img + '\\')';\n\ttd.style.backgroundRepeat = 'no-repeat';\n\ttd.style.backgroundPosition = '2px 50%';\n};\n\n/**\n * Function: createSubmenu\n *\n * Creates the nodes required to add submenu items inside the given parent\n * item. This is called in <addItem> if a parent item is used for the first\n * time. This adds various DOM nodes and a <submenuImage> to the parent.\n *\n * Parameters:\n *\n * parent - An item returned by <addItem>.\n */\nmxPopupMenu.prototype.createSubmenu = function(parent)\n{\n\tparent.table = document.createElement('table');\n\tparent.table.className = 'mxPopupMenu';\n\n\tparent.tbody = document.createElement('tbody');\n\tparent.table.appendChild(parent.tbody);\n\n\tparent.div = document.createElement('div');\n\tparent.div.className = 'mxPopupMenu';\n\n\tparent.div.style.position = 'absolute';\n\tparent.div.style.display = 'inline';\n\tparent.div.style.zIndex = this.zIndex;\n\n\tparent.div.appendChild(parent.table);\n\n\tvar img = document.createElement('img');\n\timg.setAttribute('src', this.submenuImage);\n\n\t// Last column of the submenu item in the parent menu\n\ttd = parent.firstChild.nextSibling.nextSibling;\n\ttd.appendChild(img);\n};\n\n/**\n * Function: showSubmenu\n *\n * Shows the submenu inside the given parent row.\n */\nmxPopupMenu.prototype.showSubmenu = function(parent, row)\n{\n\tif (row.div != null)\n\t{\n\t\trow.div.style.left = (parent.div.offsetLeft +\n\t\t\trow.offsetLeft+row.offsetWidth - 1) + 'px';\n\t\trow.div.style.top = (parent.div.offsetTop+row.offsetTop) + 'px';\n\t\tdocument.body.appendChild(row.div);\n\n\t\t// Moves the submenu to the left side if there is no space\n\t\tvar left = parseInt(row.div.offsetLeft);\n\t\tvar width = parseInt(row.div.offsetWidth);\n\t\tvar offset = mxUtils.getDocumentScrollOrigin(document);\n\n\t\tvar b = document.body;\n\t\tvar d = document.documentElement;\n\n\t\tvar right = offset.x + (b.clientWidth || d.clientWidth);\n\n\t\tif (left + width > right)\n\t\t{\n\t\t\trow.div.style.left = Math.max(0, (parent.div.offsetLeft - width + ((mxClient.IS_IE) ? 6 : -6))) + 'px';\n\t\t}\n\n\t\tmxUtils.fit(row.div);\n\t}\n};\n\n/**\n * Function: addSeparator\n *\n * Adds a horizontal separator in the given parent item or the top-level menu\n * if no parent is specified.\n *\n * Parameters:\n *\n * parent - Optional item returned by <addItem>.\n * force - Optional boolean to ignore <smartSeparators>. Default is false.\n */\nmxPopupMenu.prototype.addSeparator = function(parent, force)\n{\n\tparent = parent || this;\n\n\tif (this.smartSeparators && !force)\n\t{\n\t\tparent.willAddSeparator = true;\n\t}\n\telse if (parent.tbody != null)\n\t{\n\t\tparent.willAddSeparator = false;\n\t\tvar tr = document.createElement('tr');\n\n\t\tvar col1 = document.createElement('td');\n\t\tcol1.className = 'mxPopupMenuIcon';\n\t\tcol1.style.padding = '0 0 0 0px';\n\n\t\ttr.appendChild(col1);\n\n\t\tvar col2 = document.createElement('td');\n\t\tcol2.style.padding = '0 0 0 0px';\n\t\tcol2.setAttribute('colSpan', '2');\n\n\t\tvar hr = document.createElement('hr');\n\t\thr.setAttribute('size', '1');\n\t\tcol2.appendChild(hr);\n\n\t\ttr.appendChild(col2);\n\n\t\tparent.tbody.appendChild(tr);\n\t}\n};\n\n/**\n * Function: popup\n *\n * Shows the popup menu for the given event and cell.\n *\n * Example:\n *\n * (code)\n * graph.panningHandler.popup = function(x, y, cell, evt)\n * {\n *   mxUtils.alert('Hello, World!');\n * }\n * (end)\n */\nmxPopupMenu.prototype.popup = function(x, y, cell, evt)\n{\n\tif (this.div != null && this.tbody != null && this.factoryMethod != null)\n\t{\n\t\tthis.div.style.left = x + 'px';\n\t\tthis.div.style.top = y + 'px';\n\n\t\t// Removes all child nodes from the existing menu\n\t\twhile (this.tbody.firstChild != null)\n\t\t{\n\t\t\tmxEvent.release(this.tbody.firstChild);\n\t\t\tthis.tbody.removeChild(this.tbody.firstChild);\n\t\t}\n\n\t\tthis.itemCount = 0;\n\t\tthis.factoryMethod(this, cell, evt);\n\n\t\tif (this.itemCount > 0)\n\t\t{\n\t\t\tthis.showMenu();\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.SHOW));\n\t\t}\n\t}\n};\n\n/**\n * Function: isMenuShowing\n *\n * Returns true if the menu is showing.\n */\nmxPopupMenu.prototype.isMenuShowing = function()\n{\n\treturn this.div != null && this.div.parentNode == document.body;\n};\n\n/**\n * Function: showMenu\n *\n * Shows the menu.\n */\nmxPopupMenu.prototype.showMenu = function()\n{\n\t// Disables filter-based shadow in IE9 standards mode\n\tif (document.documentMode >= 9)\n\t{\n\t\tthis.div.style.filter = 'none';\n\t}\n\n\t// Fits the div inside the viewport\n\tdocument.body.appendChild(this.div);\n\tmxUtils.fit(this.div);\n};\n\n/**\n * Function: hideMenu\n *\n * Removes the menu and all submenus.\n */\nmxPopupMenu.prototype.hideMenu = function()\n{\n\tif (this.div != null)\n\t{\n\t\tif (this.div.parentNode != null)\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\n\t\tthis.hideSubmenu(this);\n\t\tthis.containsItems = false;\n\t\tthis.fireEvent(new mxEventObject(mxEvent.HIDE));\n\t}\n};\n\n/**\n * Function: hideSubmenu\n *\n * Removes all submenus inside the given parent.\n *\n * Parameters:\n *\n * parent - An item returned by <addItem>.\n */\nmxPopupMenu.prototype.hideSubmenu = function(parent)\n{\n\tif (parent.activeRow != null)\n\t{\n\t\tthis.hideSubmenu(parent.activeRow);\n\n\t\tif (parent.activeRow.div.parentNode != null)\n\t\t{\n\t\t\tparent.activeRow.div.parentNode.removeChild(parent.activeRow.div);\n\t\t}\n\n\t\tparent.activeRow = null;\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxPopupMenu.prototype.destroy = function()\n{\n\tif (this.div != null)\n\t{\n\t\tmxEvent.release(this.div);\n\n\t\tif (this.div.parentNode != null)\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\n\t\tthis.div = null;\n\t}\n};\n\n__mxOutput.mxPopupMenu = typeof mxPopupMenu !== 'undefined' ? mxPopupMenu : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxAutoSaveManager\n *\n * Manager for automatically saving diagrams. The <save> hook must be\n * implemented.\n *\n * Example:\n *\n * (code)\n * var mgr = new mxAutoSaveManager(editor.graph);\n * mgr.save = function()\n * {\n *   mxLog.show();\n *   mxLog.debug('save');\n * };\n * (end)\n *\n * Constructor: mxAutoSaveManager\n *\n * Constructs a new automatic layout for the given graph.\n *\n * Arguments:\n *\n * graph - Reference to the enclosing graph.\n */\nfunction mxAutoSaveManager(graph)\n{\n\t// Notifies the manager of a change\n\tthis.changeHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.graphModelChanged(evt.getProperty('edit').changes);\n\t\t}\n\t});\n\n\tthis.setGraph(graph);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxAutoSaveManager.prototype = new mxEventSource();\nmxAutoSaveManager.prototype.constructor = mxAutoSaveManager;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxAutoSaveManager.prototype.graph = null;\n\n/**\n * Variable: autoSaveDelay\n *\n * Minimum amount of seconds between two consecutive autosaves. Eg. a\n * value of 1 (s) means the graph is not stored more than once per second.\n * Default is 10.\n */\nmxAutoSaveManager.prototype.autoSaveDelay = 10;\n\n/**\n * Variable: autoSaveThrottle\n *\n * Minimum amount of seconds between two consecutive autosaves triggered by\n * more than <autoSaveThreshhold> changes within a timespan of less than\n * <autoSaveDelay> seconds. Eg. a value of 1 (s) means the graph is not\n * stored more than once per second even if there are more than\n * <autoSaveThreshold> changes within that timespan. Default is 2.\n */\nmxAutoSaveManager.prototype.autoSaveThrottle = 2;\n\n/**\n * Variable: autoSaveThreshold\n *\n * Minimum amount of ignored changes before an autosave. Eg. a value of 2\n * means after 2 change of the graph model the autosave will trigger if the\n * condition below is true. Default is 5.\n */\nmxAutoSaveManager.prototype.autoSaveThreshold = 5;\n\n/**\n * Variable: ignoredChanges\n *\n * Counter for ignored changes in autosave.\n */\nmxAutoSaveManager.prototype.ignoredChanges = 0;\n\n/**\n * Variable: lastSnapshot\n *\n * Used for autosaving. See <autosave>.\n */\nmxAutoSaveManager.prototype.lastSnapshot = 0;\n\n/**\n * Variable: enabled\n *\n * Specifies if event handling is enabled. Default is true.\n */\nmxAutoSaveManager.prototype.enabled = true;\n\n/**\n * Variable: changeHandler\n *\n * Holds the function that handles graph model changes.\n */\nmxAutoSaveManager.prototype.changeHandler = null;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxAutoSaveManager.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n *\n * Parameters:\n *\n * enabled - Boolean that specifies the new enabled state.\n */\nmxAutoSaveManager.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: setGraph\n *\n * Sets the graph that the layouts operate on.\n */\nmxAutoSaveManager.prototype.setGraph = function(graph)\n{\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.changeHandler);\n\t}\n\n\tthis.graph = graph;\n\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);\n\t}\n};\n\n/**\n * Function: save\n *\n * Empty hook that is called if the graph should be saved.\n */\nmxAutoSaveManager.prototype.save = function()\n{\n\t// empty\n};\n\n/**\n * Function: graphModelChanged\n *\n * Invoked when the graph model has changed.\n */\nmxAutoSaveManager.prototype.graphModelChanged = function(changes)\n{\n\tvar now = new Date().getTime();\n\tvar dt = (now - this.lastSnapshot) / 1000;\n\n\tif (dt > this.autoSaveDelay ||\n\t\t(this.ignoredChanges >= this.autoSaveThreshold &&\n\t\t dt > this.autoSaveThrottle))\n\t{\n\t\tthis.save();\n\t\tthis.reset();\n\t}\n\telse\n\t{\n\t\t// Increments the number of ignored changes\n\t\tthis.ignoredChanges++;\n\t}\n};\n\n/**\n * Function: reset\n *\n * Resets all counters.\n */\nmxAutoSaveManager.prototype.reset = function()\n{\n\tthis.lastSnapshot = new Date().getTime();\n\tthis.ignoredChanges = 0;\n};\n\n/**\n * Function: destroy\n *\n * Removes all handlers from the <graph> and deletes the reference to it.\n */\nmxAutoSaveManager.prototype.destroy = function()\n{\n\tthis.setGraph(null);\n};\n\n__mxOutput.mxAutoSaveManager = typeof mxAutoSaveManager !== 'undefined' ? mxAutoSaveManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxAnimation\n *\n * Implements a basic animation in JavaScript.\n *\n * Constructor: mxAnimation\n *\n * Constructs an animation.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxAnimation(delay)\n{\n\tthis.delay = (delay != null) ? delay : 20;\n};\n\n/**\n * Extends mxEventSource.\n */\nmxAnimation.prototype = new mxEventSource();\nmxAnimation.prototype.constructor = mxAnimation;\n\n/**\n * Variable: delay\n *\n * Specifies the delay between the animation steps. Defaul is 30ms.\n */\nmxAnimation.prototype.delay = null;\n\n/**\n * Variable: thread\n *\n * Reference to the thread while the animation is running.\n */\nmxAnimation.prototype.thread = null;\n\n/**\n * Function: isRunning\n *\n * Returns true if the animation is running.\n */\nmxAnimation.prototype.isRunning = function()\n{\n\treturn this.thread != null;\n};\n\n/**\n * Function: startAnimation\n *\n * Starts the animation by repeatedly invoking updateAnimation.\n */\nmxAnimation.prototype.startAnimation = function()\n{\n\tif (this.thread == null)\n\t{\n\t\tthis.thread = window.setInterval(mxUtils.bind(this, this.updateAnimation), this.delay);\n\t}\n};\n\n/**\n * Function: updateAnimation\n *\n * Hook for subclassers to implement the animation. Invoke stopAnimation\n * when finished, startAnimation to resume. This is called whenever the\n * timer fires and fires an mxEvent.EXECUTE event with no properties.\n */\nmxAnimation.prototype.updateAnimation = function()\n{\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTE));\n};\n\n/**\n * Function: stopAnimation\n *\n * Stops the animation by deleting the timer and fires an <mxEvent.DONE>.\n */\nmxAnimation.prototype.stopAnimation = function()\n{\n\tif (this.thread != null)\n\t{\n\t\twindow.clearInterval(this.thread);\n\t\tthis.thread = null;\n\t\tthis.fireEvent(new mxEventObject(mxEvent.DONE));\n\t}\n};\n\n__mxOutput.mxAnimation = typeof mxAnimation !== 'undefined' ? mxAnimation : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxMorphing\n *\n * Implements animation for morphing cells. Here is an example of\n * using this class for animating the result of a layout algorithm:\n *\n * (code)\n * graph.getModel().beginUpdate();\n * try\n * {\n *   var circleLayout = new mxCircleLayout(graph);\n *   circleLayout.execute(graph.getDefaultParent());\n * }\n * finally\n * {\n *   var morph = new mxMorphing(graph);\n *   morph.addListener(mxEvent.DONE, function()\n *   {\n *     graph.getModel().endUpdate();\n *   });\n *\n *   morph.startAnimation();\n * }\n * (end)\n *\n * Constructor: mxMorphing\n *\n * Constructs an animation.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * steps - Optional number of steps in the morphing animation. Default is 6.\n * ease - Optional easing constant for the animation. Default is 1.5.\n * delay - Optional delay between the animation steps. Passed to <mxAnimation>.\n */\nfunction mxMorphing(graph, steps, ease, delay)\n{\n\tmxAnimation.call(this, delay);\n\tthis.graph = graph;\n\tthis.steps = (steps != null) ? steps : 6;\n\tthis.ease = (ease != null) ? ease : 1.5;\n};\n\n/**\n * Extends mxEventSource.\n */\nmxMorphing.prototype = new mxAnimation();\nmxMorphing.prototype.constructor = mxMorphing;\n\n/**\n * Variable: graph\n *\n * Specifies the delay between the animation steps. Defaul is 30ms.\n */\nmxMorphing.prototype.graph = null;\n\n/**\n * Variable: steps\n *\n * Specifies the maximum number of steps for the morphing.\n */\nmxMorphing.prototype.steps = null;\n\n/**\n * Variable: step\n *\n * Contains the current step.\n */\nmxMorphing.prototype.step = 0;\n\n/**\n * Variable: ease\n *\n * Ease-off for movement towards the given vector. Larger values are\n * slower and smoother. Default is 4.\n */\nmxMorphing.prototype.ease = null;\n\n/**\n * Variable: cells\n *\n * Optional array of cells to be animated. If this is not specified\n * then all cells are checked and animated if they have been moved\n * in the current transaction.\n */\nmxMorphing.prototype.cells = null;\n\n/**\n * Function: updateAnimation\n *\n * Animation step.\n */\nmxMorphing.prototype.updateAnimation = function()\n{\n\tmxAnimation.prototype.updateAnimation.apply(this, arguments);\n\tvar move = new mxCellStatePreview(this.graph);\n\n\tif (this.cells != null)\n\t{\n\t\t// Animates the given cells individually without recursion\n\t\tfor (var i = 0; i < this.cells.length; i++)\n\t\t{\n\t\t\tthis.animateCell(this.cells[i], move, false);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Animates all changed cells by using recursion to find\n\t\t// the changed cells but not for the animation itself\n\t\tthis.animateCell(this.graph.getModel().getRoot(), move, true);\n\t}\n\n\tthis.show(move);\n\n\tif (move.isEmpty() || this.step++ >= this.steps)\n\t{\n\t\tthis.stopAnimation();\n\t}\n};\n\n/**\n * Function: show\n *\n * Shows the changes in the given <mxCellStatePreview>.\n */\nmxMorphing.prototype.show = function(move)\n{\n\tmove.show();\n};\n\n/**\n * Function: animateCell\n *\n * Animates the given cell state using <mxCellStatePreview.moveState>.\n */\nmxMorphing.prototype.animateCell = function(cell, move, recurse)\n{\n\tvar state = this.graph.getView().getState(cell);\n\tvar delta = null;\n\n\tif (state != null)\n\t{\n\t\t// Moves the animated state from where it will be after the model\n\t\t// change by subtracting the given delta vector from that location\n\t\tdelta = this.getDelta(state);\n\n\t\tif (this.graph.getModel().isVertex(cell) && (delta.x != 0 || delta.y != 0))\n\t\t{\n\t\t\tvar translate = this.graph.view.getTranslate();\n\t\t\tvar scale = this.graph.view.getScale();\n\n\t\t\tdelta.x += translate.x * scale;\n\t\t\tdelta.y += translate.y * scale;\n\n\t\t\tmove.moveState(state, -delta.x / this.ease, -delta.y / this.ease);\n\t\t}\n\t}\n\n\tif (recurse && !this.stopRecursion(state, delta))\n\t{\n\t\tvar childCount = this.graph.getModel().getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.animateCell(this.graph.getModel().getChildAt(cell, i), move, recurse);\n\t\t}\n\t}\n};\n\n/**\n * Function: stopRecursion\n *\n * Returns true if the animation should not recursively find more\n * deltas for children if the given parent state has been animated.\n */\nmxMorphing.prototype.stopRecursion = function(state, delta)\n{\n\treturn delta != null && (delta.x != 0 || delta.y != 0);\n};\n\n/**\n * Function: getDelta\n *\n * Returns the vector between the current rendered state and the future\n * location of the state after the display will be updated.\n */\nmxMorphing.prototype.getDelta = function(state)\n{\n\tvar origin = this.getOriginForCell(state.cell);\n\tvar translate = this.graph.getView().getTranslate();\n\tvar scale = this.graph.getView().getScale();\n\tvar x = state.x / scale - translate.x;\n\tvar y = state.y / scale - translate.y;\n\n\treturn new mxPoint((origin.x - x) * scale, (origin.y - y) * scale);\n};\n\n/**\n * Function: getOriginForCell\n *\n * Returns the top, left corner of the given cell. TODO: Improve performance\n * by using caching inside this method as the result per cell never changes\n * during the lifecycle of this object.\n */\nmxMorphing.prototype.getOriginForCell = function(cell)\n{\n\tvar result = null;\n\n\tif (cell != null)\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\tvar geo = this.graph.getCellGeometry(cell);\n\t\tresult = this.getOriginForCell(parent);\n\n\t\t// TODO: Handle offsets\n\t\tif (geo != null)\n\t\t{\n\t\t\tif (geo.relative)\n\t\t\t{\n\t\t\t\tvar pgeo = this.graph.getCellGeometry(parent);\n\n\t\t\t\tif (pgeo != null)\n\t\t\t\t{\n\t\t\t\t\tresult.x += geo.x * pgeo.width;\n\t\t\t\t\tresult.y += geo.y * pgeo.height;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.x += geo.x;\n\t\t\t\tresult.y += geo.y;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (result == null)\n\t{\n\t\tvar t = this.graph.view.getTranslate();\n\t\tresult = new mxPoint(-t.x, -t.y);\n\t}\n\n\treturn result;\n};\n\n__mxOutput.mxMorphing = typeof mxMorphing !== 'undefined' ? mxMorphing : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImageBundle\n *\n * Maps from keys to base64 encoded images or file locations. All values must\n * be URLs or use the format data:image/format followed by a comma and the base64\n * encoded image data, eg. \"data:image/gif,XYZ\", where XYZ is the base64 encoded\n * image data.\n *\n * To add a new image bundle to an existing graph, the following code is used:\n *\n * (code)\n * var bundle = new mxImageBundle(alt);\n * bundle.putImage('myImage', 'data:image/gif,R0lGODlhEAAQAMIGAAAAAICAAICAgP' +\n *   '//AOzp2O3r2////////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAh+QQBCgAHACwAAAAA' +\n *   'EAAQAAADTXi63AowynnAMDfjPUDlnAAJhmeBFxAEloliKltWmiYCQvfVr6lBPB1ggxN1hi' +\n *   'laSSASFQpIV5HJBDyHpqK2ejVRm2AAgZCdmCGO9CIBADs=', fallback);\n * bundle.putImage('mySvgImage', 'data:image/svg+xml,' + encodeURIComponent(\n *   '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\">' +\n *   '<linearGradient id=\"gradient\"><stop offset=\"10%\" stop-color=\"#F00\"/>' +\n *   '<stop offset=\"90%\" stop-color=\"#fcc\"/></linearGradient>' +\n *   '<rect fill=\"url(#gradient)\" width=\"100%\" height=\"100%\"/></svg>'), fallback);\n * graph.addImageBundle(bundle);\n * (end);\n *\n * Alt is an optional boolean (default is false) that specifies if the value\n * or the fallback should be returned in <getImage>.\n *\n * The image can then be referenced in any cell style using image=myImage.\n * If you are using mxOutline, you should use the same image bundles in the\n * graph that renders the outline.\n *\n * The keys for images are resolved in <mxGraph.postProcessCellStyle> and\n * turned into a data URI if the returned value has a short data URI format\n * as specified above.\n *\n * A typical value for the fallback is a MTHML link as defined in RFC 2557.\n * Note that this format requires a file to be dynamically created on the\n * server-side, or the page that contains the graph to be modified to contain\n * the resources, this can be done by adding a comment that contains the\n * resource in the HEAD section of the page after the title tag.\n *\n * This type of fallback mechanism should be used in IE6 and IE7. IE8 does\n * support data URIs, but the maximum size is limited to 32 KB, which means\n * all data URIs should be limited to 32 KB.\n */\nfunction mxImageBundle(alt)\n{\n\tthis.images = [];\n\tthis.alt = (alt != null) ? alt : false;\n};\n\n/**\n * Variable: images\n *\n * Maps from keys to images.\n */\nmxImageBundle.prototype.images = null;\n\n/**\n * Variable: alt\n *\n * Specifies if the fallback representation should be returned.\n */\nmxImageBundle.prototype.images = null;\n\n/**\n * Function: putImage\n *\n * Adds the specified entry to the map. The entry is an object with a value and\n * fallback property as specified in the arguments.\n */\nmxImageBundle.prototype.putImage = function(key, value, fallback)\n{\n\tthis.images[key] = {value: value, fallback: fallback};\n};\n\n/**\n * Function: getImage\n *\n * Returns the value for the given key. This returns the value\n * or fallback, depending on <alt>. The fallback is returned if\n * <alt> is true, the value is returned otherwise.\n */\nmxImageBundle.prototype.getImage = function(key)\n{\n\tvar result = null;\n\n\tif (key != null)\n\t{\n\t\tvar img = this.images[key];\n\n\t\tif (img != null)\n\t\t{\n\t\t\tresult = (this.alt) ? img.fallback : img.value;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n__mxOutput.mxImageBundle = typeof mxImageBundle !== 'undefined' ? mxImageBundle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImageExport\n *\n * Creates a new image export instance to be used with an export canvas. Here\n * is an example that uses this class to create an image via a backend using\n * <mxXmlExportCanvas>.\n *\n * (code)\n * var xmlDoc = mxUtils.createXmlDocument();\n * var root = xmlDoc.createElement('output');\n * xmlDoc.appendChild(root);\n *\n * var xmlCanvas = new mxXmlCanvas2D(root);\n * var imgExport = new mxImageExport();\n * imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);\n *\n * var bounds = graph.getGraphBounds();\n * var w = Math.ceil(bounds.x + bounds.width);\n * var h = Math.ceil(bounds.y + bounds.height);\n *\n * var xml = mxUtils.getXml(root);\n * new mxXmlRequest('export', 'format=png&w=' + w +\n * \t\t'&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))\n * \t\t.simulate(document, '_blank');\n * (end)\n *\n * Constructor: mxImageExport\n *\n * Constructs a new image export.\n */\nfunction mxImageExport() { };\n\n/**\n * Variable: includeOverlays\n *\n * Specifies if overlays should be included in the export. Default is false.\n */\nmxImageExport.prototype.includeOverlays = false;\n\n/**\n * Function: drawState\n *\n * Draws the given state and all its descendants to the given canvas.\n */\nmxImageExport.prototype.drawState = function(state, canvas)\n{\n\tif (state != null)\n\t{\n\t\tthis.visitStatesRecursive(state, canvas, mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.drawCellState.apply(this, arguments);\n\t\t}));\n\n\t\t// Paints the overlays\n\t\tif (this.includeOverlays)\n\t\t{\n\t\t\tthis.visitStatesRecursive(state, canvas, mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.drawOverlays.apply(this, arguments);\n\t\t\t}));\n\t\t}\n\t}\n};\n\n/**\n * Function: drawState\n *\n * Draws the given state and all its descendants to the given canvas.\n */\nmxImageExport.prototype.visitStatesRecursive = function(state, canvas, visitor)\n{\n\tif (state != null)\n\t{\n\t\tvisitor(state, canvas);\n\n\t\tvar graph = state.view.graph;\n\t\tvar childCount = graph.model.getChildCount(state.cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar childState = graph.view.getState(graph.model.getChildAt(state.cell, i));\n\t\t\tthis.visitStatesRecursive(childState, canvas, visitor);\n\t\t}\n\t}\n};\n\n/**\n * Function: getLinkForCellState\n *\n * Returns the link for the given cell state and canvas. This returns null.\n */\nmxImageExport.prototype.getLinkForCellState = function(state, canvas)\n{\n\treturn null;\n};\n\n/**\n * Function: drawCellState\n *\n * Draws the given state to the given canvas.\n */\nmxImageExport.prototype.drawCellState = function(state, canvas)\n{\n\t// Experimental feature\n\tvar link = this.getLinkForCellState(state, canvas);\n\n\tif (link != null)\n\t{\n\t\tcanvas.setLink(link);\n\t}\n\n\t// Paints the shape and text\n\tthis.drawShape(state, canvas);\n\tthis.drawText(state, canvas);\n\n\tif (link != null)\n\t{\n\t\tcanvas.setLink(null);\n\t}\n};\n\n/**\n * Function: drawShape\n *\n * Draws the shape of the given state.\n */\nmxImageExport.prototype.drawShape = function(state, canvas)\n{\n\tif (state.shape instanceof mxShape && state.shape.checkBounds())\n\t{\n\t\tcanvas.save();\n\t\tstate.shape.paint(canvas);\n\t\tcanvas.restore();\n\t}\n};\n\n/**\n * Function: drawText\n *\n * Draws the text of the given state.\n */\nmxImageExport.prototype.drawText = function(state, canvas)\n{\n\tif (state.text != null && state.text.checkBounds())\n\t{\n\t\tcanvas.save();\n\t\tstate.text.paint(canvas);\n\t\tcanvas.restore();\n\t}\n};\n\n/**\n * Function: drawOverlays\n *\n * Draws the overlays for the given state. This is called if <includeOverlays>\n * is true.\n */\nmxImageExport.prototype.drawOverlays = function(state, canvas)\n{\n\tif (state.overlays != null)\n\t{\n\t\tstate.overlays.visit(function(id, shape)\n\t\t{\n\t\t\tif (shape instanceof mxShape)\n\t\t\t{\n\t\t\t\tshape.paint(canvas);\n\t\t\t}\n\t\t});\n\t}\n};\n\n\n__mxOutput.mxImageExport = typeof mxImageExport !== 'undefined' ? mxImageExport : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxAbstractCanvas2D\n *\n * Base class for all canvases. A description of the public API is available in <mxXmlCanvas2D>.\n * All color values of <mxConstants.NONE> will be converted to null in the state.\n *\n * Constructor: mxAbstractCanvas2D\n *\n * Constructs a new abstract canvas.\n */\nfunction mxAbstractCanvas2D()\n{\n\t/**\n\t * Variable: converter\n\t *\n\t * Holds the <mxUrlConverter> to convert image URLs.\n\t */\n\tthis.converter = this.createUrlConverter();\n\n\tthis.reset();\n};\n\n/**\n * Variable: state\n *\n * Holds the current state.\n */\nmxAbstractCanvas2D.prototype.state = null;\n\n/**\n * Variable: states\n *\n * Stack of states.\n */\nmxAbstractCanvas2D.prototype.states = null;\n\n/**\n * Variable: path\n *\n * Holds the current path as an array.\n */\nmxAbstractCanvas2D.prototype.path = null;\n\n/**\n * Variable: rotateHtml\n *\n * Switch for rotation of HTML. Default is false.\n */\nmxAbstractCanvas2D.prototype.rotateHtml = true;\n\n/**\n * Variable: lastX\n *\n * Holds the last x coordinate.\n */\nmxAbstractCanvas2D.prototype.lastX = 0;\n\n/**\n * Variable: lastY\n *\n * Holds the last y coordinate.\n */\nmxAbstractCanvas2D.prototype.lastY = 0;\n\n/**\n * Variable: moveOp\n *\n * Contains the string used for moving in paths. Default is 'M'.\n */\nmxAbstractCanvas2D.prototype.moveOp = 'M';\n\n/**\n * Variable: lineOp\n *\n * Contains the string used for moving in paths. Default is 'L'.\n */\nmxAbstractCanvas2D.prototype.lineOp = 'L';\n\n/**\n * Variable: quadOp\n *\n * Contains the string used for quadratic paths. Default is 'Q'.\n */\nmxAbstractCanvas2D.prototype.quadOp = 'Q';\n\n/**\n * Variable: curveOp\n *\n * Contains the string used for bezier curves. Default is 'C'.\n */\nmxAbstractCanvas2D.prototype.curveOp = 'C';\n\n/**\n * Variable: closeOp\n *\n * Holds the operator for closing curves. Default is 'Z'.\n */\nmxAbstractCanvas2D.prototype.closeOp = 'Z';\n\n/**\n * Variable: pointerEvents\n *\n * Boolean value that specifies if events should be handled. Default is false.\n */\nmxAbstractCanvas2D.prototype.pointerEvents = false;\n\n/**\n * Function: createUrlConverter\n *\n * Create a new <mxUrlConverter> and returns it.\n */\nmxAbstractCanvas2D.prototype.createUrlConverter = function()\n{\n\treturn new mxUrlConverter();\n};\n\n/**\n * Function: reset\n *\n * Resets the state of this canvas.\n */\nmxAbstractCanvas2D.prototype.reset = function()\n{\n\tthis.state = this.createState();\n\tthis.states = [];\n};\n\n/**\n * Function: createState\n *\n * Creates the state of the this canvas.\n */\nmxAbstractCanvas2D.prototype.createState = function()\n{\n\treturn {\n\t\tdx: 0,\n\t\tdy: 0,\n\t\tscale: 1,\n\t\talpha: 1,\n\t\tfillAlpha: 1,\n\t\tstrokeAlpha: 1,\n\t\tfillColor: null,\n\t\tgradientFillAlpha: 1,\n\t\tgradientColor: null,\n\t\tgradientAlpha: 1,\n\t\tgradientDirection: null,\n\t\tstrokeColor: null,\n\t\tstrokeWidth: 1,\n\t\tdashed: false,\n\t\tdashPattern: '3 3',\n\t\tfixDash: false,\n\t\tlineCap: 'flat',\n\t\tlineJoin: 'miter',\n\t\tmiterLimit: 10,\n\t\tfontColor: '#000000',\n\t\tfontBackgroundColor: null,\n\t\tfontBorderColor: null,\n\t\tfontSize: mxConstants.DEFAULT_FONTSIZE,\n\t\tfontFamily: mxConstants.DEFAULT_FONTFAMILY,\n\t\tfontStyle: 0,\n\t\tshadow: false,\n\t\tshadowColor: mxConstants.SHADOWCOLOR,\n\t\tshadowAlpha: mxConstants.SHADOW_OPACITY,\n\t\tshadowDx: mxConstants.SHADOW_OFFSET_X,\n\t\tshadowDy: mxConstants.SHADOW_OFFSET_Y,\n\t\trotation: 0,\n\t\trotationCx: 0,\n\t\trotationCy: 0\n\t};\n};\n\n/**\n * Function: format\n *\n * Rounds all numbers to integers.\n */\nmxAbstractCanvas2D.prototype.format = function(value)\n{\n\treturn Math.round(parseFloat(value));\n};\n\n/**\n * Function: addOp\n *\n * Adds the given operation to the path.\n */\nmxAbstractCanvas2D.prototype.addOp = function()\n{\n\tif (this.path != null)\n\t{\n\t\tthis.path.push(arguments[0]);\n\n\t\tif (arguments.length > 2)\n\t\t{\n\t\t\tvar s = this.state;\n\n\t\t\tfor (var i = 2; i < arguments.length; i += 2)\n\t\t\t{\n\t\t\t\tthis.lastX = arguments[i - 1];\n\t\t\t\tthis.lastY = arguments[i];\n\n\t\t\t\tthis.path.push(this.format((this.lastX + s.dx) * s.scale));\n\t\t\t\tthis.path.push(this.format((this.lastY + s.dy) * s.scale));\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: rotatePoint\n *\n * Rotates the given point and returns the result as an <mxPoint>.\n */\nmxAbstractCanvas2D.prototype.rotatePoint = function(x, y, theta, cx, cy)\n{\n\tvar rad = theta * (Math.PI / 180);\n\n\treturn mxUtils.getRotatedPoint(new mxPoint(x, y), Math.cos(rad),\n\t\tMath.sin(rad), new mxPoint(cx, cy));\n};\n\n/**\n * Function: save\n *\n * Saves the current state.\n */\nmxAbstractCanvas2D.prototype.save = function()\n{\n\tthis.states.push(this.state);\n\tthis.state = mxUtils.clone(this.state);\n};\n\n/**\n * Function: restore\n *\n * Restores the current state.\n */\nmxAbstractCanvas2D.prototype.restore = function()\n{\n\tif (this.states.length > 0)\n\t{\n\t\tthis.state = this.states.pop();\n\t}\n};\n\n/**\n * Function: setLink\n *\n * Sets the current link. Hook for subclassers.\n */\nmxAbstractCanvas2D.prototype.setLink = function(link)\n{\n\t// nop\n};\n\n/**\n * Function: scale\n *\n * Scales the current state.\n */\nmxAbstractCanvas2D.prototype.scale = function(value)\n{\n\tthis.state.scale *= value;\n\tthis.state.strokeWidth *= value;\n};\n\n/**\n * Function: translate\n *\n * Translates the current state.\n */\nmxAbstractCanvas2D.prototype.translate = function(dx, dy)\n{\n\tthis.state.dx += dx;\n\tthis.state.dy += dy;\n};\n\n/**\n * Function: rotate\n *\n * Rotates the current state.\n */\nmxAbstractCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\t// nop\n};\n\n/**\n * Function: setAlpha\n *\n * Sets the current alpha.\n */\nmxAbstractCanvas2D.prototype.setAlpha = function(value)\n{\n\tthis.state.alpha = value;\n};\n\n/**\n * Function: setFillAlpha\n *\n * Sets the current solid fill alpha.\n */\nmxAbstractCanvas2D.prototype.setFillAlpha = function(value)\n{\n\tthis.state.fillAlpha = value;\n};\n\n/**\n * Function: setStrokeAlpha\n *\n * Sets the current stroke alpha.\n */\nmxAbstractCanvas2D.prototype.setStrokeAlpha = function(value)\n{\n\tthis.state.strokeAlpha = value;\n};\n\n/**\n * Function: setFillColor\n *\n * Sets the current fill color.\n */\nmxAbstractCanvas2D.prototype.setFillColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tthis.state.fillColor = value;\n\tthis.state.gradientColor = null;\n};\n\n/**\n * Function: setGradient\n *\n * Sets the current gradient.\n */\nmxAbstractCanvas2D.prototype.setGradient = function(color1, color2, x, y, w, h, direction, alpha1, alpha2)\n{\n\tvar s = this.state;\n\ts.fillColor = color1;\n\ts.gradientFillAlpha = (alpha1 != null) ? alpha1 : 1;\n\ts.gradientColor = color2;\n\ts.gradientAlpha = (alpha2 != null) ? alpha2 : 1;\n\ts.gradientDirection = direction;\n};\n\n/**\n * Function: setStrokeColor\n *\n * Sets the current stroke color.\n */\nmxAbstractCanvas2D.prototype.setStrokeColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tthis.state.strokeColor = value;\n};\n\n/**\n * Function: setStrokeWidth\n *\n * Sets the current stroke width.\n */\nmxAbstractCanvas2D.prototype.setStrokeWidth = function(value)\n{\n\tthis.state.strokeWidth = value;\n};\n\n/**\n * Function: setDashed\n *\n * Enables or disables dashed lines.\n */\nmxAbstractCanvas2D.prototype.setDashed = function(value, fixDash)\n{\n\tthis.state.dashed = value;\n\tthis.state.fixDash = fixDash;\n};\n\n/**\n * Function: setDashPattern\n *\n * Sets the current dash pattern.\n */\nmxAbstractCanvas2D.prototype.setDashPattern = function(value)\n{\n\tthis.state.dashPattern = value;\n};\n\n/**\n * Function: setLineCap\n *\n * Sets the current line cap.\n */\nmxAbstractCanvas2D.prototype.setLineCap = function(value)\n{\n\tthis.state.lineCap = value;\n};\n\n/**\n * Function: setLineJoin\n *\n * Sets the current line join.\n */\nmxAbstractCanvas2D.prototype.setLineJoin = function(value)\n{\n\tthis.state.lineJoin = value;\n};\n\n/**\n * Function: setMiterLimit\n *\n * Sets the current miter limit.\n */\nmxAbstractCanvas2D.prototype.setMiterLimit = function(value)\n{\n\tthis.state.miterLimit = value;\n};\n\n/**\n * Function: setFontColor\n *\n * Sets the current font color.\n */\nmxAbstractCanvas2D.prototype.setFontColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tthis.state.fontColor = value;\n};\n\n/**\n * Function: setFontColor\n *\n * Sets the current font color.\n */\nmxAbstractCanvas2D.prototype.setFontBackgroundColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tthis.state.fontBackgroundColor = value;\n};\n\n/**\n * Function: setFontColor\n *\n * Sets the current font color.\n */\nmxAbstractCanvas2D.prototype.setFontBorderColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tthis.state.fontBorderColor = value;\n};\n\n/**\n * Function: setFontSize\n *\n * Sets the current font size.\n */\nmxAbstractCanvas2D.prototype.setFontSize = function(value)\n{\n\tthis.state.fontSize = parseFloat(value);\n};\n\n/**\n * Function: setFontFamily\n *\n * Sets the current font family.\n */\nmxAbstractCanvas2D.prototype.setFontFamily = function(value)\n{\n\tthis.state.fontFamily = value;\n};\n\n/**\n * Function: setFontStyle\n *\n * Sets the current font style.\n */\nmxAbstractCanvas2D.prototype.setFontStyle = function(value)\n{\n\tif (value == null)\n\t{\n\t\tvalue = 0;\n\t}\n\n\tthis.state.fontStyle = value;\n};\n\n/**\n * Function: setShadow\n *\n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadow = function(enabled)\n{\n\tthis.state.shadow = enabled;\n};\n\n/**\n * Function: setShadowColor\n *\n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadowColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tthis.state.shadowColor = value;\n};\n\n/**\n * Function: setShadowAlpha\n *\n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadowAlpha = function(value)\n{\n\tthis.state.shadowAlpha = value;\n};\n\n/**\n * Function: setShadowOffset\n *\n * Enables or disables and configures the current shadow.\n */\nmxAbstractCanvas2D.prototype.setShadowOffset = function(dx, dy)\n{\n\tthis.state.shadowDx = dx;\n\tthis.state.shadowDy = dy;\n};\n\n/**\n * Function: begin\n *\n * Starts a new path.\n */\nmxAbstractCanvas2D.prototype.begin = function()\n{\n\tthis.lastX = 0;\n\tthis.lastY = 0;\n\tthis.path = [];\n};\n\n/**\n * Function: moveTo\n *\n *  Moves the current path the given coordinates.\n */\nmxAbstractCanvas2D.prototype.moveTo = function(x, y)\n{\n\tthis.addOp(this.moveOp, x, y);\n};\n\n/**\n * Function: lineTo\n *\n * Draws a line to the given coordinates. Uses moveTo with the op argument.\n */\nmxAbstractCanvas2D.prototype.lineTo = function(x, y)\n{\n\tthis.addOp(this.lineOp, x, y);\n};\n\n/**\n * Function: quadTo\n *\n * Adds a quadratic curve to the current path.\n */\nmxAbstractCanvas2D.prototype.quadTo = function(x1, y1, x2, y2)\n{\n\tthis.addOp(this.quadOp, x1, y1, x2, y2);\n};\n\n/**\n * Function: curveTo\n *\n * Adds a bezier curve to the current path.\n */\nmxAbstractCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3)\n{\n\tthis.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);\n};\n\n/**\n * Function: arcTo\n *\n * Adds the given arc to the current path. This is a synthetic operation that\n * is broken down into curves.\n */\nmxAbstractCanvas2D.prototype.arcTo = function(rx, ry, angle, largeArcFlag, sweepFlag, x, y)\n{\n\tvar curves = mxUtils.arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);\n\n\tif (curves != null)\n\t{\n\t\tfor (var i = 0; i < curves.length; i += 6)\n\t\t{\n\t\t\tthis.curveTo(curves[i], curves[i + 1], curves[i + 2],\n\t\t\t\tcurves[i + 3], curves[i + 4], curves[i + 5]);\n\t\t}\n\t}\n};\n\n/**\n * Function: close\n *\n * Closes the current path.\n */\nmxAbstractCanvas2D.prototype.close = function(x1, y1, x2, y2, x3, y3)\n{\n\tthis.addOp(this.closeOp);\n};\n\n/**\n * Function: end\n *\n * Empty implementation for backwards compatibility. This will be removed.\n */\nmxAbstractCanvas2D.prototype.end = function() { };\n\n__mxOutput.mxAbstractCanvas2D = typeof mxAbstractCanvas2D !== 'undefined' ? mxAbstractCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxXmlCanvas2D\n *\n * Base class for all canvases. The following methods make up the public\n * interface of the canvas 2D for all painting in mxGraph:\n *\n * - <save>, <restore>\n * - <scale>, <translate>, <rotate>\n * - <setAlpha>, <setFillAlpha>, <setStrokeAlpha>, <setFillColor>, <setGradient>,\n *   <setStrokeColor>, <setStrokeWidth>, <setDashed>, <setDashPattern>, <setLineCap>,\n *   <setLineJoin>, <setMiterLimit>\n * - <setFontColor>, <setFontBackgroundColor>, <setFontBorderColor>, <setFontSize>,\n *   <setFontFamily>, <setFontStyle>\n * - <setShadow>, <setShadowColor>, <setShadowAlpha>, <setShadowOffset>\n * - <rect>, <roundrect>, <ellipse>, <image>, <text>\n * - <begin>, <moveTo>, <lineTo>, <quadTo>, <curveTo>\n * - <stroke>, <fill>, <fillAndStroke>\n *\n * <mxAbstractCanvas2D.arcTo> is an additional method for drawing paths. This is\n * a synthetic method, meaning that it is turned into a sequence of curves by\n * default. Subclassers may add native support for arcs.\n *\n * Constructor: mxXmlCanvas2D\n *\n * Constructs a new abstract canvas.\n */\nfunction mxXmlCanvas2D(root)\n{\n\tmxAbstractCanvas2D.call(this);\n\n\t/**\n\t * Variable: root\n\t *\n\t * Reference to the container for the SVG content.\n\t */\n\tthis.root = root;\n\n\t// Writes default settings;\n\tthis.writeDefaults();\n};\n\n/**\n * Extends mxAbstractCanvas2D\n */\nmxUtils.extend(mxXmlCanvas2D, mxAbstractCanvas2D);\n\n/**\n * Variable: textEnabled\n *\n * Specifies if text output should be enabled. Default is true.\n */\nmxXmlCanvas2D.prototype.textEnabled = true;\n\n/**\n * Variable: compressed\n *\n * Specifies if the output should be compressed by removing redundant calls.\n * Default is true.\n */\nmxXmlCanvas2D.prototype.compressed = true;\n\n/**\n * Function: writeDefaults\n *\n * Writes the rendering defaults to <root>:\n */\nmxXmlCanvas2D.prototype.writeDefaults = function()\n{\n\tvar elem;\n\n\t// Writes font defaults\n\telem = this.createElement('fontfamily');\n\telem.setAttribute('family', mxConstants.DEFAULT_FONTFAMILY);\n\tthis.root.appendChild(elem);\n\n\telem = this.createElement('fontsize');\n\telem.setAttribute('size', mxConstants.DEFAULT_FONTSIZE);\n\tthis.root.appendChild(elem);\n\n\t// Writes shadow defaults\n\telem = this.createElement('shadowcolor');\n\telem.setAttribute('color', mxConstants.SHADOWCOLOR);\n\tthis.root.appendChild(elem);\n\n\telem = this.createElement('shadowalpha');\n\telem.setAttribute('alpha', mxConstants.SHADOW_OPACITY);\n\tthis.root.appendChild(elem);\n\n\telem = this.createElement('shadowoffset');\n\telem.setAttribute('dx', mxConstants.SHADOW_OFFSET_X);\n\telem.setAttribute('dy', mxConstants.SHADOW_OFFSET_Y);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: format\n *\n * Returns a formatted number with 2 decimal places.\n */\nmxXmlCanvas2D.prototype.format = function(value)\n{\n\treturn parseFloat(parseFloat(value).toFixed(2));\n};\n\n/**\n * Function: createElement\n *\n * Creates the given element using the owner document of <root>.\n */\nmxXmlCanvas2D.prototype.createElement = function(name)\n{\n\treturn this.root.ownerDocument.createElement(name);\n};\n\n/**\n * Function: save\n *\n * Saves the drawing state.\n */\nmxXmlCanvas2D.prototype.save = function()\n{\n\tif (this.compressed)\n\t{\n\t\tmxAbstractCanvas2D.prototype.save.apply(this, arguments);\n\t}\n\n\tthis.root.appendChild(this.createElement('save'));\n};\n\n/**\n * Function: restore\n *\n * Restores the drawing state.\n */\nmxXmlCanvas2D.prototype.restore = function()\n{\n\tif (this.compressed)\n\t{\n\t\tmxAbstractCanvas2D.prototype.restore.apply(this, arguments);\n\t}\n\n\tthis.root.appendChild(this.createElement('restore'));\n};\n\n/**\n * Function: scale\n *\n * Scales the output.\n *\n * Parameters:\n *\n * scale - Number that represents the scale where 1 is equal to 100%.\n */\nmxXmlCanvas2D.prototype.scale = function(value)\n{\n        var elem = this.createElement('scale');\n        elem.setAttribute('scale', value);\n        this.root.appendChild(elem);\n};\n\n/**\n * Function: translate\n *\n * Translates the output.\n *\n * Parameters:\n *\n * dx - Number that specifies the horizontal translation.\n * dy - Number that specifies the vertical translation.\n */\nmxXmlCanvas2D.prototype.translate = function(dx, dy)\n{\n\tvar elem = this.createElement('translate');\n\telem.setAttribute('dx', this.format(dx));\n\telem.setAttribute('dy', this.format(dy));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: rotate\n *\n * Rotates and/or flips the output around a given center. (Note: Due to\n * limitations in VML, the rotation cannot be concatenated.)\n *\n * Parameters:\n *\n * theta - Number that represents the angle of the rotation (in degrees).\n * flipH - Boolean indicating if the output should be flipped horizontally.\n * flipV - Boolean indicating if the output should be flipped vertically.\n * cx - Number that represents the x-coordinate of the rotation center.\n * cy - Number that represents the y-coordinate of the rotation center.\n */\nmxXmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\tvar elem = this.createElement('rotate');\n\n\tif (theta != 0 || flipH || flipV)\n\t{\n\t\telem.setAttribute('theta', this.format(theta));\n\t\telem.setAttribute('flipH', (flipH) ? '1' : '0');\n\t\telem.setAttribute('flipV', (flipV) ? '1' : '0');\n\t\telem.setAttribute('cx', this.format(cx));\n\t\telem.setAttribute('cy', this.format(cy));\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setAlpha\n *\n * Sets the current alpha.\n *\n * Parameters:\n *\n * value - Number that represents the new alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.alpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setAlpha.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('alpha');\n\telem.setAttribute('alpha', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setFillAlpha\n *\n * Sets the current fill alpha.\n *\n * Parameters:\n *\n * value - Number that represents the new fill alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setFillAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.fillAlpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setFillAlpha.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('fillalpha');\n\telem.setAttribute('alpha', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setStrokeAlpha\n *\n * Sets the current stroke alpha.\n *\n * Parameters:\n *\n * value - Number that represents the new stroke alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setStrokeAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.strokeAlpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setStrokeAlpha.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('strokealpha');\n\telem.setAttribute('alpha', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setFillColor\n *\n * Sets the current fill color.\n *\n * Parameters:\n *\n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFillColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tif (this.compressed)\n\t{\n\t\tif (this.state.fillColor == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setFillColor.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('fillcolor');\n\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setGradient\n *\n * Sets the gradient. Note that the coordinates may be ignored by some implementations.\n *\n * Parameters:\n *\n * color1 - Hexadecimal representation of the start color.\n * color2 - Hexadecimal representation of the end color.\n * x - X-coordinate of the gradient region.\n * y - y-coordinate of the gradient region.\n * w - Width of the gradient region.\n * h - Height of the gradient region.\n * direction - One of <mxConstants.DIRECTION_NORTH>, <mxConstants.DIRECTION_EAST>,\n * <mxConstants.DIRECTION_SOUTH> or <mxConstants.DIRECTION_WEST>.\n * alpha1 - Optional alpha of the start color. Default is 1. Possible values\n * are between 1 (opaque) and 0 (transparent).\n * alpha2 - Optional alpha of the end color. Default is 1. Possible values\n * are between 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setGradient = function(color1, color2, x, y, w, h, direction, alpha1, alpha2)\n{\n\tif (color1 != null && color2 != null)\n\t{\n\t\tmxAbstractCanvas2D.prototype.setGradient.apply(this, arguments);\n\n\t\tvar elem = this.createElement('gradient');\n\t\telem.setAttribute('c1', color1);\n\t\telem.setAttribute('c2', color2);\n\t\telem.setAttribute('x', this.format(x));\n\t\telem.setAttribute('y', this.format(y));\n\t\telem.setAttribute('w', this.format(w));\n\t\telem.setAttribute('h', this.format(h));\n\n\t\t// Default direction is south\n\t\tif (direction != null)\n\t\t{\n\t\t\telem.setAttribute('direction', direction);\n\t\t}\n\n\t\tif (alpha1 != null)\n\t\t{\n\t\t\telem.setAttribute('alpha1', alpha1);\n\t\t}\n\n\t\tif (alpha2 != null)\n\t\t{\n\t\t\telem.setAttribute('alpha2', alpha2);\n\t\t}\n\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setStrokeColor\n *\n * Sets the current stroke color.\n *\n * Parameters:\n *\n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setStrokeColor = function(value)\n{\n\tif (value == mxConstants.NONE)\n\t{\n\t\tvalue = null;\n\t}\n\n\tif (this.compressed)\n\t{\n\t\tif (this.state.strokeColor == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setStrokeColor.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('strokecolor');\n\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setStrokeWidth\n *\n * Sets the current stroke width.\n *\n * Parameters:\n *\n * value - Numeric representation of the stroke width.\n */\nmxXmlCanvas2D.prototype.setStrokeWidth = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.strokeWidth == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setStrokeWidth.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('strokewidth');\n\telem.setAttribute('width', this.format(value));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setDashed\n *\n * Enables or disables dashed lines.\n *\n * Parameters:\n *\n * value - Boolean that specifies if dashed lines should be enabled.\n * value - Boolean that specifies if the stroke width should be ignored\n * for the dash pattern. Default is false.\n */\nmxXmlCanvas2D.prototype.setDashed = function(value, fixDash)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.dashed == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setDashed.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('dashed');\n\telem.setAttribute('dashed', (value) ? '1' : '0');\n\n\tif (fixDash != null)\n\t{\n\t\telem.setAttribute('fixDash', (fixDash) ? '1' : '0');\n\t}\n\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setDashPattern\n *\n * Sets the current dash pattern. Default is '3 3'.\n *\n * Parameters:\n *\n * value - String that represents the dash pattern, which is a sequence of\n * numbers defining the length of the dashes and the length of the spaces\n * between the dashes. The lengths are relative to the line width - a length\n * of 1 is equals to the line width.\n */\nmxXmlCanvas2D.prototype.setDashPattern = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.dashPattern == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setDashPattern.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('dashpattern');\n\telem.setAttribute('pattern', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setLineCap\n *\n * Sets the line cap. Default is 'flat' which corresponds to 'butt' in SVG.\n *\n * Parameters:\n *\n * value - String that represents the line cap. Possible values are flat, round\n * and square.\n */\nmxXmlCanvas2D.prototype.setLineCap = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.lineCap == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setLineCap.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('linecap');\n\telem.setAttribute('cap', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setLineJoin\n *\n * Sets the line join. Default is 'miter'.\n *\n * Parameters:\n *\n * value - String that represents the line join. Possible values are miter,\n * round and bevel.\n */\nmxXmlCanvas2D.prototype.setLineJoin = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.lineJoin == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setLineJoin.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('linejoin');\n\telem.setAttribute('join', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setMiterLimit\n *\n * Sets the miter limit. Default is 10.\n *\n * Parameters:\n *\n * value - Number that represents the miter limit.\n */\nmxXmlCanvas2D.prototype.setMiterLimit = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.miterLimit == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setMiterLimit.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('miterlimit');\n\telem.setAttribute('limit', value);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setFontColor\n *\n * Sets the current font color. Default is '#000000'.\n *\n * Parameters:\n *\n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFontColor = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontColor == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmxAbstractCanvas2D.prototype.setFontColor.apply(this, arguments);\n\t\t}\n\n\t\tvar elem = this.createElement('fontcolor');\n\t\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontBackgroundColor\n *\n * Sets the current font background color.\n *\n * Parameters:\n *\n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFontBackgroundColor = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontBackgroundColor == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmxAbstractCanvas2D.prototype.setFontBackgroundColor.apply(this, arguments);\n\t\t}\n\n\t\tvar elem = this.createElement('fontbackgroundcolor');\n\t\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontBorderColor\n *\n * Sets the current font border color.\n *\n * Parameters:\n *\n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setFontBorderColor = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontBorderColor == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmxAbstractCanvas2D.prototype.setFontBorderColor.apply(this, arguments);\n\t\t}\n\n\t\tvar elem = this.createElement('fontbordercolor');\n\t\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontSize\n *\n * Sets the current font size. Default is <mxConstants.DEFAULT_FONTSIZE>.\n *\n * Parameters:\n *\n * value - Numeric representation of the font size.\n */\nmxXmlCanvas2D.prototype.setFontSize = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontSize == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmxAbstractCanvas2D.prototype.setFontSize.apply(this, arguments);\n\t\t}\n\n\t\tvar elem = this.createElement('fontsize');\n\t\telem.setAttribute('size', value);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontFamily\n *\n * Sets the current font family. Default is <mxConstants.DEFAULT_FONTFAMILY>.\n *\n * Parameters:\n *\n * value - String representation of the font family. This handles the same\n * values as the CSS font-family property.\n */\nmxXmlCanvas2D.prototype.setFontFamily = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontFamily == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmxAbstractCanvas2D.prototype.setFontFamily.apply(this, arguments);\n\t\t}\n\n\t\tvar elem = this.createElement('fontfamily');\n\t\telem.setAttribute('family', value);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setFontStyle\n *\n * Sets the current font style.\n *\n * Parameters:\n *\n * value - Numeric representation of the font family. This is the sum of the\n * font styles from <mxConstants>.\n */\nmxXmlCanvas2D.prototype.setFontStyle = function(value)\n{\n\tif (this.textEnabled)\n\t{\n\t\tif (value == null)\n\t\t{\n\t\t\tvalue = 0;\n\t\t}\n\n\t\tif (this.compressed)\n\t\t{\n\t\t\tif (this.state.fontStyle == value)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmxAbstractCanvas2D.prototype.setFontStyle.apply(this, arguments);\n\t\t}\n\n\t\tvar elem = this.createElement('fontstyle');\n\t\telem.setAttribute('style', value);\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: setShadow\n *\n * Enables or disables shadows.\n *\n * Parameters:\n *\n * value - Boolean that specifies if shadows should be enabled.\n */\nmxXmlCanvas2D.prototype.setShadow = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.shadow == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setShadow.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('shadow');\n\telem.setAttribute('enabled', (value) ? '1' : '0');\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setShadowColor\n *\n * Sets the current shadow color. Default is <mxConstants.SHADOWCOLOR>.\n *\n * Parameters:\n *\n * value - Hexadecimal representation of the color or 'none'.\n */\nmxXmlCanvas2D.prototype.setShadowColor = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (value == mxConstants.NONE)\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\n\t\tif (this.state.shadowColor == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setShadowColor.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('shadowcolor');\n\telem.setAttribute('color', (value != null) ? value : mxConstants.NONE);\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: setShadowAlpha\n *\n * Sets the current shadows alpha. Default is <mxConstants.SHADOW_OPACITY>.\n *\n * Parameters:\n *\n * value - Number that represents the new alpha. Possible values are between\n * 1 (opaque) and 0 (transparent).\n */\nmxXmlCanvas2D.prototype.setShadowAlpha = function(value)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.shadowAlpha == value)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setShadowAlpha.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('shadowalpha');\n\telem.setAttribute('alpha', value);\n\tthis.root.appendChild(elem);\n\n};\n\n/**\n * Function: setShadowOffset\n *\n * Sets the current shadow offset.\n *\n * Parameters:\n *\n * dx - Number that represents the horizontal offset of the shadow.\n * dy - Number that represents the vertical offset of the shadow.\n */\nmxXmlCanvas2D.prototype.setShadowOffset = function(dx, dy)\n{\n\tif (this.compressed)\n\t{\n\t\tif (this.state.shadowDx == dx && this.state.shadowDy == dy)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmxAbstractCanvas2D.prototype.setShadowOffset.apply(this, arguments);\n\t}\n\n\tvar elem = this.createElement('shadowoffset');\n\telem.setAttribute('dx', dx);\n\telem.setAttribute('dy', dy);\n\tthis.root.appendChild(elem);\n\n};\n\n/**\n * Function: rect\n *\n * Puts a rectangle into the drawing buffer.\n *\n * Parameters:\n *\n * x - Number that represents the x-coordinate of the rectangle.\n * y - Number that represents the y-coordinate of the rectangle.\n * w - Number that represents the width of the rectangle.\n * h - Number that represents the height of the rectangle.\n */\nmxXmlCanvas2D.prototype.rect = function(x, y, w, h)\n{\n\tvar elem = this.createElement('rect');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: roundrect\n *\n * Puts a rounded rectangle into the drawing buffer.\n *\n * Parameters:\n *\n * x - Number that represents the x-coordinate of the rectangle.\n * y - Number that represents the y-coordinate of the rectangle.\n * w - Number that represents the width of the rectangle.\n * h - Number that represents the height of the rectangle.\n * dx - Number that represents the horizontal rounding.\n * dy - Number that represents the vertical rounding.\n */\nmxXmlCanvas2D.prototype.roundrect = function(x, y, w, h, dx, dy)\n{\n\tvar elem = this.createElement('roundrect');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\telem.setAttribute('dx', this.format(dx));\n\telem.setAttribute('dy', this.format(dy));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: ellipse\n *\n * Puts an ellipse into the drawing buffer.\n *\n * Parameters:\n *\n * x - Number that represents the x-coordinate of the ellipse.\n * y - Number that represents the y-coordinate of the ellipse.\n * w - Number that represents the width of the ellipse.\n * h - Number that represents the height of the ellipse.\n */\nmxXmlCanvas2D.prototype.ellipse = function(x, y, w, h)\n{\n\tvar elem = this.createElement('ellipse');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: image\n *\n * Paints an image.\n *\n * Parameters:\n *\n * x - Number that represents the x-coordinate of the image.\n * y - Number that represents the y-coordinate of the image.\n * w - Number that represents the width of the image.\n * h - Number that represents the height of the image.\n * src - String that specifies the URL of the image.\n * aspect - Boolean indicating if the aspect of the image should be preserved.\n * flipH - Boolean indicating if the image should be flipped horizontally.\n * flipV - Boolean indicating if the image should be flipped vertically.\n */\nmxXmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n{\n\tsrc = this.converter.convert(src);\n\n\t// LATER: Add option for embedding images as base64.\n\tvar elem = this.createElement('image');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\telem.setAttribute('w', this.format(w));\n\telem.setAttribute('h', this.format(h));\n\telem.setAttribute('src', src);\n\telem.setAttribute('aspect', (aspect) ? '1' : '0');\n\telem.setAttribute('flipH', (flipH) ? '1' : '0');\n\telem.setAttribute('flipV', (flipV) ? '1' : '0');\n\tthis.root.appendChild(elem);\n};\n\n/**\n * Function: begin\n *\n * Starts a new path and puts it into the drawing buffer.\n */\nmxXmlCanvas2D.prototype.begin = function()\n{\n\tthis.root.appendChild(this.createElement('begin'));\n\tthis.lastX = 0;\n\tthis.lastY = 0;\n};\n\n/**\n * Function: moveTo\n *\n * Moves the current path the given point.\n *\n * Parameters:\n *\n * x - Number that represents the x-coordinate of the point.\n * y - Number that represents the y-coordinate of the point.\n */\nmxXmlCanvas2D.prototype.moveTo = function(x, y)\n{\n\tvar elem = this.createElement('move');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x;\n\tthis.lastY = y;\n};\n\n/**\n * Function: lineTo\n *\n * Draws a line to the given coordinates.\n *\n * Parameters:\n *\n * x - Number that represents the x-coordinate of the endpoint.\n * y - Number that represents the y-coordinate of the endpoint.\n */\nmxXmlCanvas2D.prototype.lineTo = function(x, y)\n{\n\tvar elem = this.createElement('line');\n\telem.setAttribute('x', this.format(x));\n\telem.setAttribute('y', this.format(y));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x;\n\tthis.lastY = y;\n};\n\n/**\n * Function: quadTo\n *\n * Adds a quadratic curve to the current path.\n *\n * Parameters:\n *\n * x1 - Number that represents the x-coordinate of the control point.\n * y1 - Number that represents the y-coordinate of the control point.\n * x2 - Number that represents the x-coordinate of the endpoint.\n * y2 - Number that represents the y-coordinate of the endpoint.\n */\nmxXmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2)\n{\n\tvar elem = this.createElement('quad');\n\telem.setAttribute('x1', this.format(x1));\n\telem.setAttribute('y1', this.format(y1));\n\telem.setAttribute('x2', this.format(x2));\n\telem.setAttribute('y2', this.format(y2));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x2;\n\tthis.lastY = y2;\n};\n\n/**\n * Function: curveTo\n *\n * Adds a bezier curve to the current path.\n *\n * Parameters:\n *\n * x1 - Number that represents the x-coordinate of the first control point.\n * y1 - Number that represents the y-coordinate of the first control point.\n * x2 - Number that represents the x-coordinate of the second control point.\n * y2 - Number that represents the y-coordinate of the second control point.\n * x3 - Number that represents the x-coordinate of the endpoint.\n * y3 - Number that represents the y-coordinate of the endpoint.\n */\nmxXmlCanvas2D.prototype.curveTo = function(x1, y1, x2, y2, x3, y3)\n{\n\tvar elem = this.createElement('curve');\n\telem.setAttribute('x1', this.format(x1));\n\telem.setAttribute('y1', this.format(y1));\n\telem.setAttribute('x2', this.format(x2));\n\telem.setAttribute('y2', this.format(y2));\n\telem.setAttribute('x3', this.format(x3));\n\telem.setAttribute('y3', this.format(y3));\n\tthis.root.appendChild(elem);\n\tthis.lastX = x3;\n\tthis.lastY = y3;\n};\n\n/**\n * Function: close\n *\n * Closes the current path.\n */\nmxXmlCanvas2D.prototype.close = function()\n{\n\tthis.root.appendChild(this.createElement('close'));\n};\n\n/**\n * Function: text\n *\n * Paints the given text. Possible values for format are empty string for\n * plain text and html for HTML markup. Background and border color as well\n * as clipping is not available in plain text labels for VML. HTML labels\n * are not available as part of shapes with no foreignObject support in SVG\n * (eg. IE9, IE10).\n *\n * Parameters:\n *\n * x - Number that represents the x-coordinate of the text.\n * y - Number that represents the y-coordinate of the text.\n * w - Number that represents the available width for the text or 0 for automatic width.\n * h - Number that represents the available height for the text or 0 for automatic height.\n * str - String that specifies the text to be painted.\n * align - String that represents the horizontal alignment.\n * valign - String that represents the vertical alignment.\n * wrap - Boolean that specifies if word-wrapping is enabled. Requires w > 0.\n * format - Empty string for plain text or 'html' for HTML markup.\n * overflow - Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.\n * clip - Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.\n * rotation - Number that specifies the angle of the rotation around the anchor point of the text.\n * dir - Optional string that specifies the text direction. Possible values are rtl and lrt.\n */\nmxXmlCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\tif (this.textEnabled && str != null)\n\t{\n\t\tif (mxUtils.isNode(str))\n\t\t{\n\t\t\tstr = mxUtils.getOuterHtml(str);\n\t\t}\n\n\t\tvar elem = this.createElement('text');\n\t\telem.setAttribute('x', this.format(x));\n\t\telem.setAttribute('y', this.format(y));\n\t\telem.setAttribute('w', this.format(w));\n\t\telem.setAttribute('h', this.format(h));\n\t\telem.setAttribute('str', str);\n\n\t\tif (align != null)\n\t\t{\n\t\t\telem.setAttribute('align', align);\n\t\t}\n\n\t\tif (valign != null)\n\t\t{\n\t\t\telem.setAttribute('valign', valign);\n\t\t}\n\n\t\telem.setAttribute('wrap', (wrap) ? '1' : '0');\n\n\t\tif (format == null)\n\t\t{\n\t\t\tformat = '';\n\t\t}\n\n\t\telem.setAttribute('format', format);\n\n\t\tif (overflow != null)\n\t\t{\n\t\t\telem.setAttribute('overflow', overflow);\n\t\t}\n\n\t\tif (clip != null)\n\t\t{\n\t\t\telem.setAttribute('clip', (clip) ? '1' : '0');\n\t\t}\n\n\t\tif (rotation != null)\n\t\t{\n\t\t\telem.setAttribute('rotation', rotation);\n\t\t}\n\n\t\tif (dir != null)\n\t\t{\n\t\t\telem.setAttribute('dir', dir);\n\t\t}\n\n\t\tthis.root.appendChild(elem);\n\t}\n};\n\n/**\n * Function: stroke\n *\n * Paints the outline of the current drawing buffer.\n */\nmxXmlCanvas2D.prototype.stroke = function()\n{\n\tthis.root.appendChild(this.createElement('stroke'));\n};\n\n/**\n * Function: fill\n *\n * Fills the current drawing buffer.\n */\nmxXmlCanvas2D.prototype.fill = function()\n{\n\tthis.root.appendChild(this.createElement('fill'));\n};\n\n/**\n * Function: fillAndStroke\n *\n * Fills the current drawing buffer and its outline.\n */\nmxXmlCanvas2D.prototype.fillAndStroke = function()\n{\n\tthis.root.appendChild(this.createElement('fillstroke'));\n};\n\n__mxOutput.mxXmlCanvas2D = typeof mxXmlCanvas2D !== 'undefined' ? mxXmlCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSvgCanvas2D\n *\n * Extends <mxAbstractCanvas2D> to implement a canvas for SVG. This canvas writes all\n * calls as SVG output to the given SVG root node.\n *\n * (code)\n * var svgDoc = mxUtils.createXmlDocument();\n * var root = (svgDoc.createElementNS != null) ?\n * \t\tsvgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');\n *\n * if (svgDoc.createElementNS == null)\n * {\n *   root.setAttribute('xmlns', mxConstants.NS_SVG);\n *   root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);\n * }\n * else\n * {\n *   root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);\n * }\n *\n * var bounds = graph.getGraphBounds();\n * root.setAttribute('width', (bounds.x + bounds.width + 4) + 'px');\n * root.setAttribute('height', (bounds.y + bounds.height + 4) + 'px');\n * root.setAttribute('version', '1.1');\n *\n * svgDoc.appendChild(root);\n *\n * var svgCanvas = new mxSvgCanvas2D(root);\n * (end)\n *\n * A description of the public API is available in <mxXmlCanvas2D>.\n *\n * To disable anti-aliasing in the output, use the following code.\n *\n * (code)\n * graph.view.canvas.ownerSVGElement.setAttribute('shape-rendering', 'crispEdges');\n * (end)\n *\n * Or set the respective attribute in the SVG element directly.\n *\n * Constructor: mxSvgCanvas2D\n *\n * Constructs a new SVG canvas.\n *\n * Parameters:\n *\n * root - SVG container for the output.\n * styleEnabled - Optional boolean that specifies if a style section should be\n * added. The style section sets the default font-size, font-family and\n * stroke-miterlimit globally. Default is false.\n */\nfunction mxSvgCanvas2D(root, styleEnabled)\n{\n\tmxAbstractCanvas2D.call(this);\n\n\t/**\n\t * Variable: root\n\t *\n\t * Reference to the container for the SVG content.\n\t */\n\tthis.root = root;\n\n\t/**\n\t * Variable: gradients\n\t *\n\t * Local cache of gradients for quick lookups.\n\t */\n\tthis.gradients = [];\n\n\t/**\n\t * Variable: defs\n\t *\n\t * Reference to the defs section of the SVG document. Only for export.\n\t */\n\tthis.defs = null;\n\n\t/**\n\t * Variable: styleEnabled\n\t *\n\t * Stores the value of styleEnabled passed to the constructor.\n\t */\n\tthis.styleEnabled = (styleEnabled != null) ? styleEnabled : false;\n\n\tvar svg = null;\n\n\t// Adds optional defs section for export\n\tif (root.ownerDocument != document)\n\t{\n\t\tvar node = root;\n\n\t\t// Finds owner SVG element in XML DOM\n\t\twhile (node != null && node.nodeName != 'svg')\n\t\t{\n\t\t\tnode = node.parentNode;\n\t\t}\n\n\t\tsvg = node;\n\t}\n\n\tif (svg != null)\n\t{\n\t\t// Tries to get existing defs section\n\t\tvar tmp = svg.getElementsByTagName('defs');\n\n\t\tif (tmp.length > 0)\n\t\t{\n\t\t\tthis.defs = svg.getElementsByTagName('defs')[0];\n\t\t}\n\n\t\t// Adds defs section if none exists\n\t\tif (this.defs == null)\n\t\t{\n\t\t\tthis.defs = this.createElement('defs');\n\n\t\t\tif (svg.firstChild != null)\n\t\t\t{\n\t\t\t\tsvg.insertBefore(this.defs, svg.firstChild);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsvg.appendChild(this.defs);\n\t\t\t}\n\t\t}\n\n\t\t// Adds stylesheet\n\t\tif (this.styleEnabled)\n\t\t{\n\t\t\tthis.defs.appendChild(this.createStyle());\n\t\t}\n\t}\n};\n\n/**\n * Extends mxAbstractCanvas2D\n */\nmxUtils.extend(mxSvgCanvas2D, mxAbstractCanvas2D);\n\n/**\n * Capability check for DOM parser.\n */\n(function()\n{\n\tmxSvgCanvas2D.prototype.useDomParser = !mxClient.IS_IE && typeof DOMParser === 'function' && typeof XMLSerializer === 'function';\n\n\tif (mxSvgCanvas2D.prototype.useDomParser)\n\t{\n\t\t// Checks using a generic test text if the parsing actually works. This is a workaround\n\t\t// for older browsers where the capability check returns true but the parsing fails.\n\t\ttry\n\t\t{\n\t\t\tvar doc = new DOMParser().parseFromString('test text', 'text/html');\n\t\t\tmxSvgCanvas2D.prototype.useDomParser = doc != null;\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tmxSvgCanvas2D.prototype.useDomParser = false;\n\t\t}\n\t}\n})();\n\n/**\n * Variable: path\n *\n * Holds the current DOM node.\n */\nmxSvgCanvas2D.prototype.node = null;\n\n/**\n * Variable: matchHtmlAlignment\n *\n * Specifies if plain text output should match the vertical HTML alignment.\n * Defaul is true.\n */\nmxSvgCanvas2D.prototype.matchHtmlAlignment = true;\n\n/**\n * Variable: textEnabled\n *\n * Specifies if text output should be enabled. Default is true.\n */\nmxSvgCanvas2D.prototype.textEnabled = true;\n\n/**\n * Variable: foEnabled\n *\n * Specifies if use of foreignObject for HTML markup is allowed. Default is true.\n */\nmxSvgCanvas2D.prototype.foEnabled = true;\n\n/**\n * Variable: foAltText\n *\n * Specifies the fallback text for unsupported foreignObjects in exported\n * documents. Default is '[Object]'. If this is set to null then no fallback\n * text is added to the exported document.\n */\nmxSvgCanvas2D.prototype.foAltText = '[Object]';\n\n/**\n * Variable: foOffset\n *\n * Offset to be used for foreignObjects.\n */\nmxSvgCanvas2D.prototype.foOffset = 0;\n\n/**\n * Variable: textOffset\n *\n * Offset to be used for text elements.\n */\nmxSvgCanvas2D.prototype.textOffset = 0;\n\n/**\n * Variable: imageOffset\n *\n * Offset to be used for image elements.\n */\nmxSvgCanvas2D.prototype.imageOffset = 0;\n\n/**\n * Variable: strokeTolerance\n *\n * Adds transparent paths for strokes.\n */\nmxSvgCanvas2D.prototype.strokeTolerance = 0;\n\n/**\n * Variable: minStrokeWidth\n *\n * Minimum stroke width for output.\n */\nmxSvgCanvas2D.prototype.minStrokeWidth = 1;\n\n/**\n * Variable: refCount\n *\n * Local counter for references in SVG export.\n */\nmxSvgCanvas2D.prototype.refCount = 0;\n\n/**\n * Variable: blockImagePointerEvents\n *\n * Specifies if a transparent rectangle should be added on top of images to absorb\n * all pointer events. Default is false. This is only needed in Firefox to disable\n * control-clicks on images.\n */\nmxSvgCanvas2D.prototype.blockImagePointerEvents = false;\n\n/**\n * Variable: lineHeightCorrection\n *\n * Correction factor for <mxConstants.LINE_HEIGHT> in HTML output. Default is 1.\n */\nmxSvgCanvas2D.prototype.lineHeightCorrection = 1;\n\n/**\n * Variable: pointerEventsValue\n *\n * Default value for active pointer events. Default is all.\n */\nmxSvgCanvas2D.prototype.pointerEventsValue = 'all';\n\n/**\n * Variable: fontMetricsPadding\n *\n * Padding to be added for text that is not wrapped to account for differences\n * in font metrics on different platforms in pixels. Default is 10.\n */\nmxSvgCanvas2D.prototype.fontMetricsPadding = 10;\n\n/**\n * Variable: cacheOffsetSize\n *\n * Specifies if offsetWidth and offsetHeight should be cached. Default is true.\n * This is used to speed up repaint of text in <updateText>.\n */\nmxSvgCanvas2D.prototype.cacheOffsetSize = true;\n\n/**\n * Function: format\n *\n * Rounds all numbers to 2 decimal points.\n */\nmxSvgCanvas2D.prototype.format = function(value)\n{\n\treturn parseFloat(parseFloat(value).toFixed(2));\n};\n\n/**\n * Function: getBaseUrl\n *\n * Returns the URL of the page without the hash part. This needs to use href to\n * include any search part with no params (ie question mark alone). This is a\n * workaround for the fact that window.location.search is empty if there is\n * no search string behind the question mark.\n */\nmxSvgCanvas2D.prototype.getBaseUrl = function()\n{\n\tvar href = window.location.href;\n\tvar hash = href.lastIndexOf('#');\n\n\tif (hash > 0)\n\t{\n\t\thref = href.substring(0, hash);\n\t}\n\n\treturn href;\n};\n\n/**\n * Function: reset\n *\n * Returns any offsets for rendering pixels.\n */\nmxSvgCanvas2D.prototype.reset = function()\n{\n\tmxAbstractCanvas2D.prototype.reset.apply(this, arguments);\n\tthis.gradients = [];\n};\n\n/**\n * Function: createStyle\n *\n * Creates the optional style section.\n */\nmxSvgCanvas2D.prototype.createStyle = function(x)\n{\n\tvar style = this.createElement('style');\n\tstyle.setAttribute('type', 'text/css');\n\tmxUtils.write(style, 'svg{font-family:' + mxConstants.DEFAULT_FONTFAMILY +\n\t\t\t';font-size:' + mxConstants.DEFAULT_FONTSIZE +\n\t\t\t';fill:none;stroke-miterlimit:10}');\n\n\treturn style;\n};\n\n/**\n * Function: createElement\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.createElement = function(tagName, namespace)\n{\n\tif (this.root.ownerDocument.createElementNS != null)\n\t{\n\t\treturn this.root.ownerDocument.createElementNS(namespace || mxConstants.NS_SVG, tagName);\n\t}\n\telse\n\t{\n\t\tvar elt = this.root.ownerDocument.createElement(tagName);\n\n\t\tif (namespace != null)\n\t\t{\n\t\t\telt.setAttribute('xmlns', namespace);\n\t\t}\n\n\t\treturn elt;\n\t}\n};\n\n/**\n * Function: getAlternateContent\n *\n * Returns the alternate content for the given foreignObject.\n */\nmxSvgCanvas2D.prototype.createAlternateContent = function(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation)\n{\n\tif (this.foAltText != null)\n\t{\n\t\tvar s = this.state;\n\t\tvar alt = this.createElement('text');\n\t\talt.setAttribute('x', Math.round(w / 2));\n\t\talt.setAttribute('y', Math.round((h + s.fontSize) / 2));\n\t\talt.setAttribute('fill', s.fontColor || 'black');\n\t\talt.setAttribute('text-anchor', 'middle');\n\t\talt.setAttribute('font-size', s.fontSize + 'px');\n\t\t// Quotes are workaround for font name \"m+\"\n\t\talt.setAttribute('font-family', '\\'' + s.fontFamily + '\\'');\n\n\t\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t\t{\n\t\t\talt.setAttribute('font-weight', 'bold');\n\t\t}\n\n\t\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t\t{\n\t\t\talt.setAttribute('font-style', 'italic');\n\t\t}\n\n\t\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t\t{\n\t\t\talt.setAttribute('text-decoration', 'underline');\n\t\t}\n\n\t\tmxUtils.write(alt, this.foAltText);\n\n\t\treturn alt;\n\t}\n\telse\n\t{\n\t\treturn null;\n\t}\n};\n\n/**\n * Function: createGradientId\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.createGradientId = function(start, end, alpha1, alpha2, direction)\n{\n\t// Removes illegal characters from gradient ID\n\tif (start.charAt(0) == '#')\n\t{\n\t\tstart = start.substring(1);\n\t}\n\n\tif (end.charAt(0) == '#')\n\t{\n\t\tend = end.substring(1);\n\t}\n\n\t// Workaround for gradient IDs not working in Safari 5 / Chrome 6\n\t// if they contain uppercase characters\n\tstart = start.toLowerCase() + '-' + alpha1;\n\tend = end.toLowerCase() + '-' + alpha2;\n\n\t// Wrong gradient directions possible?\n\tvar dir = null;\n\n\tif (direction == null || direction == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tdir = 's';\n\t}\n\telse if (direction == mxConstants.DIRECTION_EAST)\n\t{\n\t\tdir = 'e';\n\t}\n\telse\n\t{\n\t\tvar tmp = start;\n\t\tstart = end;\n\t\tend = tmp;\n\n\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tdir = 's';\n\t\t}\n\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tdir = 'e';\n\t\t}\n\t}\n\n\treturn 'mx-gradient-' + start + '-' + end + '-' + dir;\n};\n\n/**\n * Function: getSvgGradient\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.getSvgGradient = function(start, end, alpha1, alpha2, direction)\n{\n\tvar id = this.createGradientId(start, end, alpha1, alpha2, direction);\n\tvar gradient = this.gradients[id];\n\n\tif (gradient == null)\n\t{\n\t\tvar svg = this.root.ownerSVGElement;\n\n\t\tvar counter = 0;\n\t\tvar tmpId = id + '-' + counter;\n\n\t\tif (svg != null)\n\t\t{\n\t\t\tgradient = svg.ownerDocument.getElementById(tmpId);\n\n\t\t\twhile (gradient != null && gradient.ownerSVGElement != svg)\n\t\t\t{\n\t\t\t\ttmpId = id + '-' + counter++;\n\t\t\t\tgradient = svg.ownerDocument.getElementById(tmpId);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Uses shorter IDs for export\n\t\t\ttmpId = 'id' + (++this.refCount);\n\t\t}\n\n\t\tif (gradient == null)\n\t\t{\n\t\t\tgradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);\n\t\t\tgradient.setAttribute('id', tmpId);\n\n\t\t\tif (this.defs != null)\n\t\t\t{\n\t\t\t\tthis.defs.appendChild(gradient);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsvg.appendChild(gradient);\n\t\t\t}\n\t\t}\n\n\t\tthis.gradients[id] = gradient;\n\t}\n\n\treturn gradient.getAttribute('id');\n};\n\n/**\n * Function: createSvgGradient\n *\n * Creates the given SVG gradient.\n */\nmxSvgCanvas2D.prototype.createSvgGradient = function(start, end, alpha1, alpha2, direction)\n{\n\tvar gradient = this.createElement('linearGradient');\n\tgradient.setAttribute('x1', '0%');\n\tgradient.setAttribute('y1', '0%');\n\tgradient.setAttribute('x2', '0%');\n\tgradient.setAttribute('y2', '0%');\n\n\tif (direction == null || direction == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tgradient.setAttribute('y2', '100%');\n\t}\n\telse if (direction == mxConstants.DIRECTION_EAST)\n\t{\n\t\tgradient.setAttribute('x2', '100%');\n\t}\n\telse if (direction == mxConstants.DIRECTION_NORTH)\n\t{\n\t\tgradient.setAttribute('y1', '100%');\n\t}\n\telse if (direction == mxConstants.DIRECTION_WEST)\n\t{\n\t\tgradient.setAttribute('x1', '100%');\n\t}\n\n\tvar op = (alpha1 < 1) ? ';stop-opacity:' + alpha1 : '';\n\n\tvar stop = this.createElement('stop');\n\tstop.setAttribute('offset', '0%');\n\tstop.setAttribute('style', 'stop-color:' + start + op);\n\tgradient.appendChild(stop);\n\n\top = (alpha2 < 1) ? ';stop-opacity:' + alpha2 : '';\n\n\tstop = this.createElement('stop');\n\tstop.setAttribute('offset', '100%');\n\tstop.setAttribute('style', 'stop-color:' + end + op);\n\tgradient.appendChild(stop);\n\n\treturn gradient;\n};\n\n/**\n * Function: addNode\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.addNode = function(filled, stroked)\n{\n\tvar node = this.node;\n\tvar s = this.state;\n\n\tif (node != null)\n\t{\n\t\tif (node.nodeName == 'path')\n\t\t{\n\t\t\t// Checks if the path is not empty\n\t\t\tif (this.path != null && this.path.length > 0)\n\t\t\t{\n\t\t\t\tnode.setAttribute('d', this.path.join(' '));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (filled && s.fillColor != null)\n\t\t{\n\t\t\tthis.updateFill();\n\t\t}\n\t\telse if (!this.styleEnabled)\n\t\t{\n\t\t\t// Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=814952\n\t\t\tif (node.nodeName == 'ellipse' && mxClient.IS_FF)\n\t\t\t{\n\t\t\t\tnode.setAttribute('fill', 'transparent');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode.setAttribute('fill', 'none');\n\t\t\t}\n\n\t\t\t// Sets the actual filled state for stroke tolerance\n\t\t\tfilled = false;\n\t\t}\n\n\t\tif (stroked && s.strokeColor != null)\n\t\t{\n\t\t\tthis.updateStroke();\n\t\t}\n\t\telse if (!this.styleEnabled)\n\t\t{\n\t\t\tnode.setAttribute('stroke', 'none');\n\t\t}\n\n\t\tif (s.transform != null && s.transform.length > 0)\n\t\t{\n\t\t\tnode.setAttribute('transform', s.transform);\n\t\t}\n\n\t\tif (s.shadow)\n\t\t{\n\t\t\tthis.root.appendChild(this.createShadow(node));\n\t\t}\n\n\t\t// Adds stroke tolerance\n\t\tif (this.strokeTolerance > 0 && !filled)\n\t\t{\n\t\t\tthis.root.appendChild(this.createTolerance(node));\n\t\t}\n\n\t\t// Adds pointer events\n\t\tif (this.pointerEvents)\n\t\t{\n\t\t\tnode.setAttribute('pointer-events', this.pointerEventsValue);\n\t\t}\n\t\t// Enables clicks for nodes inside a link element\n\t\telse if (!this.pointerEvents && this.originalRoot == null)\n\t\t{\n\t\t\tnode.setAttribute('pointer-events', 'none');\n\t\t}\n\n\t\t// Removes invisible nodes from output if they don't handle events\n\t\tif ((node.nodeName != 'rect' && node.nodeName != 'path' && node.nodeName != 'ellipse') ||\n\t\t\t(node.getAttribute('fill') != 'none' && node.getAttribute('fill') != 'transparent') ||\n\t\t\tnode.getAttribute('stroke') != 'none' || node.getAttribute('pointer-events') != 'none')\n\t\t{\n\t\t\t// LATER: Update existing DOM for performance\n\t\t\tthis.root.appendChild(node);\n\t\t}\n\n\t\tthis.node = null;\n\t}\n};\n\n/**\n * Function: updateFill\n *\n * Transfers the stroke attributes from <state> to <node>.\n */\nmxSvgCanvas2D.prototype.updateFill = function()\n{\n\tvar s = this.state;\n\n\tif (s.alpha < 1 || s.fillAlpha < 1)\n\t{\n\t\tthis.node.setAttribute('fill-opacity', s.alpha * s.fillAlpha);\n\t}\n\n\tif (s.fillColor != null)\n\t{\n\t\tif (s.gradientColor != null)\n\t\t{\n\t\t\tvar id = this.getSvgGradient(String(s.fillColor), String(s.gradientColor),\n\t\t\t\ts.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);\n\n\t\t\tif (!mxClient.IS_CHROME_APP && !mxClient.IS_IE && !mxClient.IS_IE11 &&\n\t\t\t\t!mxClient.IS_EDGE && this.root.ownerDocument == document)\n\t\t\t{\n\t\t\t\t// Workaround for potential base tag and brackets must be escaped\n\t\t\t\tvar base = this.getBaseUrl().replace(/([\\(\\)])/g, '\\\\$1');\n\t\t\t\tthis.node.setAttribute('fill', 'url(' + base + '#' + id + ')');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.node.setAttribute('fill', 'url(#' + id + ')');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.node.setAttribute('fill', String(s.fillColor).toLowerCase());\n\t\t}\n\t}\n};\n\n/**\n * Function: getCurrentStrokeWidth\n *\n * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).\n */\nmxSvgCanvas2D.prototype.getCurrentStrokeWidth = function()\n{\n\treturn Math.max(this.minStrokeWidth, Math.max(0.01, this.format(this.state.strokeWidth * this.state.scale)));\n};\n\n/**\n * Function: updateStroke\n *\n * Transfers the stroke attributes from <state> to <node>.\n */\nmxSvgCanvas2D.prototype.updateStroke = function()\n{\n\tvar s = this.state;\n\n\tthis.node.setAttribute('stroke', String(s.strokeColor).toLowerCase());\n\n\tif (s.alpha < 1 || s.strokeAlpha < 1)\n\t{\n\t\tthis.node.setAttribute('stroke-opacity', s.alpha * s.strokeAlpha);\n\t}\n\n\tvar sw = this.getCurrentStrokeWidth();\n\n\tif (sw != 1)\n\t{\n\t\tthis.node.setAttribute('stroke-width', sw);\n\t}\n\n\tif (this.node.nodeName == 'path')\n\t{\n\t\tthis.updateStrokeAttributes();\n\t}\n\n\tif (s.dashed)\n\t{\n\t\tthis.node.setAttribute('stroke-dasharray', this.createDashPattern(\n\t\t\t((s.fixDash) ? 1 : s.strokeWidth) * s.scale));\n\t}\n};\n\n/**\n * Function: updateStrokeAttributes\n *\n * Transfers the stroke attributes from <state> to <node>.\n */\nmxSvgCanvas2D.prototype.updateStrokeAttributes = function()\n{\n\tvar s = this.state;\n\n\t// Linejoin miter is default in SVG\n\tif (s.lineJoin != null && s.lineJoin != 'miter')\n\t{\n\t\tthis.node.setAttribute('stroke-linejoin', s.lineJoin);\n\t}\n\n\tif (s.lineCap != null)\n\t{\n\t\t// flat is called butt in SVG\n\t\tvar value = s.lineCap;\n\n\t\tif (value == 'flat')\n\t\t{\n\t\t\tvalue = 'butt';\n\t\t}\n\n\t\t// Linecap butt is default in SVG\n\t\tif (value != 'butt')\n\t\t{\n\t\t\tthis.node.setAttribute('stroke-linecap', value);\n\t\t}\n\t}\n\n\t// Miterlimit 10 is default in our document\n\tif (s.miterLimit != null && (!this.styleEnabled || s.miterLimit != 10))\n\t{\n\t\tthis.node.setAttribute('stroke-miterlimit', s.miterLimit);\n\t}\n};\n\n/**\n * Function: createDashPattern\n *\n * Creates the SVG dash pattern for the given state.\n */\nmxSvgCanvas2D.prototype.createDashPattern = function(scale)\n{\n\tvar pat = [];\n\n\tif (typeof(this.state.dashPattern) === 'string')\n\t{\n\t\tvar dash = this.state.dashPattern.split(' ');\n\n\t\tif (dash.length > 0)\n\t\t{\n\t\t\tfor (var i = 0; i < dash.length; i++)\n\t\t\t{\n\t\t\t\tpat[i] = Number(dash[i]) * scale;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pat.join(' ');\n};\n\n/**\n * Function: createTolerance\n *\n * Creates a hit detection tolerance shape for the given node.\n */\nmxSvgCanvas2D.prototype.createTolerance = function(node)\n{\n\tvar tol = node.cloneNode(true);\n\tvar sw = parseFloat(tol.getAttribute('stroke-width') || 1) + this.strokeTolerance;\n\ttol.setAttribute('pointer-events', 'stroke');\n\ttol.setAttribute('visibility', 'hidden');\n\ttol.removeAttribute('stroke-dasharray');\n\ttol.setAttribute('stroke-width', sw);\n\ttol.setAttribute('fill', 'none');\n\n\t// Workaround for Opera ignoring the visiblity attribute above while\n\t// other browsers need a stroke color to perform the hit-detection but\n\t// do not ignore the visibility attribute. Side-effect is that Opera's\n\t// hit detection for horizontal/vertical edges seems to ignore the tol.\n\ttol.setAttribute('stroke', (mxClient.IS_OT) ? 'none' : 'white');\n\n\treturn tol;\n};\n\n/**\n * Function: createShadow\n *\n * Creates a shadow for the given node.\n */\nmxSvgCanvas2D.prototype.createShadow = function(node)\n{\n\tvar shadow = node.cloneNode(true);\n\tvar s = this.state;\n\n\t// Firefox uses transparent for no fill in ellipses\n\tif (shadow.getAttribute('fill') != 'none' && (!mxClient.IS_FF || shadow.getAttribute('fill') != 'transparent'))\n\t{\n\t\tshadow.setAttribute('fill', s.shadowColor);\n\t}\n\n\tif (shadow.getAttribute('stroke') != 'none')\n\t{\n\t\tshadow.setAttribute('stroke', s.shadowColor);\n\t}\n\n\tshadow.setAttribute('transform', 'translate(' + this.format(s.shadowDx * s.scale) +\n\t\t',' + this.format(s.shadowDy * s.scale) + ')' + (s.transform || ''));\n\tshadow.setAttribute('opacity', s.shadowAlpha);\n\n\treturn shadow;\n};\n\n/**\n * Function: setLink\n *\n * Experimental implementation for hyperlinks.\n */\nmxSvgCanvas2D.prototype.setLink = function(link)\n{\n\tif (link == null)\n\t{\n\t\tthis.root = this.originalRoot;\n\t}\n\telse\n\t{\n\t\tthis.originalRoot = this.root;\n\n\t\tvar node = this.createElement('a');\n\n\t\t// Workaround for implicit namespace handling in HTML5 export, IE adds NS1 namespace so use code below\n\t\t// in all IE versions except quirks mode. KNOWN: Adds xlink namespace to each image tag in output.\n\t\tif (node.setAttributeNS == null || (this.root.ownerDocument != document && document.documentMode == null))\n\t\t{\n\t\t\tnode.setAttribute('xlink:href', link);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.setAttributeNS(mxConstants.NS_XLINK, 'xlink:href', link);\n\t\t}\n\n\t\tthis.root.appendChild(node);\n\t\tthis.root = node;\n\t}\n};\n\n/**\n * Function: rotate\n *\n * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\n */\nmxSvgCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\tif (theta != 0 || flipH || flipV)\n\t{\n\t\tvar s = this.state;\n\t\tcx += s.dx;\n\t\tcy += s.dy;\n\n\t\tcx *= s.scale;\n\t\tcy *= s.scale;\n\n\t\ts.transform = s.transform || '';\n\n\t\t// This implementation uses custom scale/translate and built-in rotation\n\t\t// Rotation state is part of the AffineTransform in state.transform\n\t\tif (flipH && flipV)\n\t\t{\n\t\t\ttheta += 180;\n\t\t}\n\t\telse if (flipH != flipV)\n\t\t{\n\t\t\tvar tx = (flipH) ? cx : 0;\n\t\t\tvar sx = (flipH) ? -1 : 1;\n\n\t\t\tvar ty = (flipV) ? cy : 0;\n\t\t\tvar sy = (flipV) ? -1 : 1;\n\n\t\t\ts.transform += 'translate(' + this.format(tx) + ',' + this.format(ty) + ')' +\n\t\t\t\t'scale(' + this.format(sx) + ',' + this.format(sy) + ')' +\n\t\t\t\t'translate(' + this.format(-tx) + ',' + this.format(-ty) + ')';\n\t\t}\n\n\t\tif (flipH ? !flipV : flipV)\n\t\t{\n\t\t\ttheta *= -1;\n\t\t}\n\n\t\tif (theta != 0)\n\t\t{\n\t\t\ts.transform += 'rotate(' + this.format(theta) + ',' + this.format(cx) + ',' + this.format(cy) + ')';\n\t\t}\n\n\t\ts.rotation = s.rotation + theta;\n\t\ts.rotationCx = cx;\n\t\ts.rotationCy = cy;\n\t}\n};\n\n/**\n * Function: begin\n *\n * Extends superclass to create path.\n */\nmxSvgCanvas2D.prototype.begin = function()\n{\n\tmxAbstractCanvas2D.prototype.begin.apply(this, arguments);\n\tthis.node = this.createElement('path');\n};\n\n/**\n * Function: rect\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.rect = function(x, y, w, h)\n{\n\tvar s = this.state;\n\tvar n = this.createElement('rect');\n\tn.setAttribute('x', this.format((x + s.dx) * s.scale));\n\tn.setAttribute('y', this.format((y + s.dy) * s.scale));\n\tn.setAttribute('width', this.format(w * s.scale));\n\tn.setAttribute('height', this.format(h * s.scale));\n\n\tthis.node = n;\n};\n\n/**\n * Function: roundrect\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.roundrect = function(x, y, w, h, dx, dy)\n{\n\tthis.rect(x, y, w, h);\n\n\tif (dx > 0)\n\t{\n\t\tthis.node.setAttribute('rx', this.format(dx * this.state.scale));\n\t}\n\n\tif (dy > 0)\n\t{\n\t\tthis.node.setAttribute('ry', this.format(dy * this.state.scale));\n\t}\n};\n\n/**\n * Function: ellipse\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.ellipse = function(x, y, w, h)\n{\n\tvar s = this.state;\n\tvar n = this.createElement('ellipse');\n\t// No rounding for consistent output with 1.x\n\tn.setAttribute('cx', Math.round((x + w / 2 + s.dx) * s.scale));\n\tn.setAttribute('cy', Math.round((y + h / 2 + s.dy) * s.scale));\n\tn.setAttribute('rx', w / 2 * s.scale);\n\tn.setAttribute('ry', h / 2 * s.scale);\n\tthis.node = n;\n};\n\n/**\n * Function: image\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n{\n\tsrc = this.converter.convert(src);\n\n\t// LATER: Add option for embedding images as base64.\n\taspect = (aspect != null) ? aspect : true;\n\tflipH = (flipH != null) ? flipH : false;\n\tflipV = (flipV != null) ? flipV : false;\n\n\tvar s = this.state;\n\tx += s.dx;\n\ty += s.dy;\n\n\tvar node = this.createElement('image');\n\tnode.setAttribute('x', this.format(x * s.scale) + this.imageOffset);\n\tnode.setAttribute('y', this.format(y * s.scale) + this.imageOffset);\n\tnode.setAttribute('width', this.format(w * s.scale));\n\tnode.setAttribute('height', this.format(h * s.scale));\n\n\t// Workaround for missing namespace support\n\tif (node.setAttributeNS == null)\n\t{\n\t\tnode.setAttribute('xlink:href', src);\n\t}\n\telse\n\t{\n\t\tnode.setAttributeNS(mxConstants.NS_XLINK, 'xlink:href', src);\n\t}\n\n\tif (!aspect)\n\t{\n\t\tnode.setAttribute('preserveAspectRatio', 'none');\n\t}\n\n\tif (s.alpha < 1 || s.fillAlpha < 1)\n\t{\n\t\tnode.setAttribute('opacity', s.alpha * s.fillAlpha);\n\t}\n\n\tvar tr = this.state.transform || '';\n\n\tif (flipH || flipV)\n\t{\n\t\tvar sx = 1;\n\t\tvar sy = 1;\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\n\t\tif (flipH)\n\t\t{\n\t\t\tsx = -1;\n\t\t\tdx = -w - 2 * x;\n\t\t}\n\n\t\tif (flipV)\n\t\t{\n\t\t\tsy = -1;\n\t\t\tdy = -h - 2 * y;\n\t\t}\n\n\t\t// Adds image tansformation to existing transform\n\t\ttr += 'scale(' + sx + ',' + sy + ')translate(' + (dx * s.scale) + ',' + (dy * s.scale) + ')';\n\t}\n\n\tif (tr.length > 0)\n\t{\n\t\tnode.setAttribute('transform', tr);\n\t}\n\n\tif (!this.pointerEvents)\n\t{\n\t\tnode.setAttribute('pointer-events', 'none');\n\t}\n\n\tthis.root.appendChild(node);\n\n\t// Disables control-clicks on images in Firefox to open in new tab\n\t// by putting a rect in the foreground that absorbs all events and\n\t// disabling all pointer-events on the original image tag.\n\tif (this.blockImagePointerEvents)\n\t{\n\t\tnode.setAttribute('style', 'pointer-events:none');\n\n\t\tnode = this.createElement('rect');\n\t\tnode.setAttribute('visibility', 'hidden');\n\t\tnode.setAttribute('pointer-events', 'fill');\n\t\tnode.setAttribute('x', this.format(x * s.scale));\n\t\tnode.setAttribute('y', this.format(y * s.scale));\n\t\tnode.setAttribute('width', this.format(w * s.scale));\n\t\tnode.setAttribute('height', this.format(h * s.scale));\n\t\tthis.root.appendChild(node);\n\t}\n};\n\n/**\n * Function: convertHtml\n *\n * Converts the given HTML string to XHTML.\n */\nmxSvgCanvas2D.prototype.convertHtml = function(val)\n{\n\tif (this.useDomParser)\n\t{\n\t\tvar doc = new DOMParser().parseFromString(val, 'text/html');\n\n\t\tif (doc != null)\n\t\t{\n\t\t\tval = new XMLSerializer().serializeToString(doc.body);\n\n\t\t\t// Extracts body content from DOM\n\t\t\tif (val.substring(0, 5) == '<body')\n\t\t\t{\n\t\t\t\tval = val.substring(val.indexOf('>', 5) + 1);\n\t\t\t}\n\n\t\t\tif (val.substring(val.length - 7, val.length) == '</body>')\n\t\t\t{\n\t\t\t\tval = val.substring(0, val.length - 7);\n\t\t\t}\n\t\t}\n\t}\n\telse if (document.implementation != null && document.implementation.createDocument != null)\n\t{\n\t\tvar xd = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n\t\tvar xb = xd.createElement('body');\n\t\txd.documentElement.appendChild(xb);\n\n\t\tvar div = document.createElement('div');\n\t\tdiv.innerHTML = val;\n\t\tvar child = div.firstChild;\n\n\t\twhile (child != null)\n\t\t{\n\t\t\tvar next = child.nextSibling;\n\t\t\txb.appendChild(xd.adoptNode(child));\n\t\t\tchild = next;\n\t\t}\n\n\t\treturn xb.innerHTML;\n\t}\n\telse\n\t{\n\t\tvar ta = document.createElement('textarea');\n\n\t\t// Handles special HTML entities < and > and double escaping\n\t\t// and converts unclosed br, hr and img tags to XHTML\n\t\t// LATER: Convert all unclosed tags\n\t\tta.innerHTML = val.replace(/&amp;/g, '&amp;amp;').\n\t\t\treplace(/&#60;/g, '&amp;lt;').replace(/&#62;/g, '&amp;gt;').\n\t\t\treplace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;').\n\t\t\treplace(/</g, '&lt;').replace(/>/g, '&gt;');\n\t\tval = ta.value.replace(/&/g, '&amp;').replace(/&amp;lt;/g, '&lt;').\n\t\t\treplace(/&amp;gt;/g, '&gt;').replace(/&amp;amp;/g, '&amp;').\n\t\t\treplace(/<br>/g, '<br />').replace(/<hr>/g, '<hr />').\n\t\t\treplace(/(<img[^>]+)>/gm, \"$1 />\");\n\t}\n\n\treturn val;\n};\n\n/**\n * Function: createDiv\n *\n * Private helper function to create SVG elements\n */\nmxSvgCanvas2D.prototype.createDiv = function(str, align, valign, style, overflow, whiteSpace)\n{\n\tvar s = this.state;\n\n\t// Inline block for rendering HTML background over SVG in Safari\n\tvar lh = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (s.fontSize * mxConstants.LINE_HEIGHT) + 'px' :\n\t\t(mxConstants.LINE_HEIGHT * this.lineHeightCorrection);\n\n\t// Quotes are workaround for font name \"m+\"\n\tstyle = 'display:inline-block;font-size:' + s.fontSize + 'px;font-family:\"' + s.fontFamily +\n\t\t'\";color:' + s.fontColor + ';line-height:' + lh + ';' + style;\n\n\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tstyle += 'font-weight:bold;';\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tstyle += 'font-style:italic;';\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\tstyle += 'text-decoration:underline;';\n\t}\n\n\tif (align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tstyle += 'text-align:center;';\n\t}\n\telse if (align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tstyle += 'text-align:right;';\n\t}\n\telse\n\t{\n\t\tstyle += 'text-align:left;';\n\t}\n\n\tvar css = '';\n\n\tif (s.fontBackgroundColor != null)\n\t{\n\t\tcss += 'background-color:' + mxUtils.htmlEntities(s.fontBackgroundColor) + ';';\n\t}\n\n\tif (s.fontBorderColor != null)\n\t{\n\t\tcss += 'border:1px solid ' + mxUtils.htmlEntities(s.fontBorderColor) + ';';\n\t}\n\n\tvar val = str;\n\n\tif (!mxUtils.isNode(val))\n\t{\n\t\tval = this.convertHtml(val);\n\n\t\tif (overflow != 'fill' && overflow != 'width')\n\t\t{\n\t\t\t// Workaround for no wrapping in HTML canvas for image\n\t\t\t// export if the inner HTML contains a DIV with width\n\t\t\tif (whiteSpace != null)\n\t\t\t{\n\t\t\t\tcss += 'white-space:' + whiteSpace + ';';\n\t\t\t}\n\n\t\t\t// Inner div always needed to measure wrapped text\n\t\t\tval = '<div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"display:inline-block;text-align:inherit;text-decoration:inherit;' + css + '\">' + val + '</div>';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstyle += css;\n\t\t}\n\t}\n\n\t// Uses DOM API where available. This cannot be used in IE to avoid\n\t// an opening and two (!) closing TBODY tags being added to tables.\n\tif (!mxClient.IS_IE && document.createElementNS)\n\t{\n\t\tvar div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n\t\tdiv.setAttribute('style', style);\n\n\t\tif (mxUtils.isNode(val))\n\t\t{\n\t\t\t// Creates a copy for export\n\t\t\tif (this.root.ownerDocument != document)\n\t\t\t{\n\t\t\t\tdiv.appendChild(val.cloneNode(true));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv.appendChild(val);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiv.innerHTML = val;\n\t\t}\n\n\t\treturn div;\n\t}\n\telse\n\t{\n\t\t// Serializes for export\n\t\tif (mxUtils.isNode(val) && this.root.ownerDocument != document)\n\t\t{\n\t\t\tval = val.outerHTML;\n\t\t}\n\n\t\t// NOTE: FF 3.6 crashes if content CSS contains \"height:100%\"\n\t\treturn mxUtils.parseXml('<div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"' + style +\n\t\t\t'\">' + val + '</div>').documentElement;\n\t}\n};\n\n/**\n * Invalidates the cached offset size for the given node.\n */\nmxSvgCanvas2D.prototype.invalidateCachedOffsetSize = function(node)\n{\n\tdelete node.firstChild.mxCachedOffsetWidth;\n\tdelete node.firstChild.mxCachedFinalOffsetWidth;\n\tdelete node.firstChild.mxCachedFinalOffsetHeight;\n};\n\n/**\n * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.\n */\nmxSvgCanvas2D.prototype.updateText = function(x, y, w, h, align, valign, wrap, overflow, clip, rotation, node)\n{\n\tif (node != null && node.firstChild != null && node.firstChild.firstChild != null &&\n\t\tnode.firstChild.firstChild.firstChild != null)\n\t{\n\t\t// Uses outer group for opacity and transforms to\n\t\t// fix rendering order in Chrome\n\t\tvar group = node.firstChild;\n\t\tvar fo = group.firstChild;\n\t\tvar div = fo.firstChild;\n\n\t\trotation = (rotation != null) ? rotation : 0;\n\n\t\tvar s = this.state;\n\t\tx += s.dx;\n\t\ty += s.dy;\n\n\t\tif (clip)\n\t\t{\n\t\t\tdiv.style.maxHeight = Math.round(h) + 'px';\n\t\t\tdiv.style.maxWidth = Math.round(w) + 'px';\n\t\t}\n\t\telse if (overflow == 'fill')\n\t\t{\n\t\t\tdiv.style.width = Math.round(w + 1) + 'px';\n\t\t\tdiv.style.height = Math.round(h + 1) + 'px';\n\t\t}\n\t\telse if (overflow == 'width')\n\t\t{\n\t\t\tdiv.style.width = Math.round(w + 1) + 'px';\n\n\t\t\tif (h > 0)\n\t\t\t{\n\t\t\t\tdiv.style.maxHeight = Math.round(h) + 'px';\n\t\t\t}\n\t\t}\n\n\t\tif (wrap && w > 0)\n\t\t{\n\t\t\tdiv.style.width = Math.round(w + 1) + 'px';\n\t\t}\n\n\t\t// Code that depends on the size which is computed after\n\t\t// the element was added to the DOM.\n\t\tvar ow = 0;\n\t\tvar oh = 0;\n\n\t\t// Padding avoids clipping on border and wrapping for differing font metrics on platforms\n\t\tvar padX = 0;\n\t\tvar padY = 2;\n\n\t\tvar sizeDiv = div;\n\n\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t{\n\t\t\tsizeDiv = sizeDiv.firstChild;\n\t\t}\n\n\t\tvar tmp = (group.mxCachedOffsetWidth != null) ? group.mxCachedOffsetWidth : sizeDiv.offsetWidth;\n\t\tow = tmp + padX;\n\n\t\t// Recomputes the height of the element for wrapped width\n\t\tif (wrap && overflow != 'fill')\n\t\t{\n\t\t\tif (clip)\n\t\t\t{\n\t\t\t\tow = Math.min(ow, w);\n\t\t\t}\n\n\t\t\tdiv.style.width = Math.round(ow + 1) + 'px';\n\t\t}\n\n\t\tow = (group.mxCachedFinalOffsetWidth != null) ? group.mxCachedFinalOffsetWidth : sizeDiv.offsetWidth;\n\t\toh = (group.mxCachedFinalOffsetHeight != null) ? group.mxCachedFinalOffsetHeight : sizeDiv.offsetHeight;\n\n\t\tif (this.cacheOffsetSize)\n\t\t{\n\t\t\tgroup.mxCachedOffsetWidth = tmp;\n\t\t\tgroup.mxCachedFinalOffsetWidth = ow;\n\t\t\tgroup.mxCachedFinalOffsetHeight = oh;\n\t\t}\n\n\t\tow += padX;\n\t\toh -= 2;\n\n\t\tif (clip)\n\t\t{\n\t\t\toh = Math.min(oh, h);\n\t\t\tow = Math.min(ow, w);\n\t\t}\n\n\t\tif (overflow == 'width')\n\t\t{\n\t\t\th = oh;\n\t\t}\n\t\telse if (overflow != 'fill')\n\t\t{\n\t\t\tw = ow;\n\t\t\th = oh;\n\t\t}\n\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\n\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t{\n\t\t\tdx -= w / 2;\n\t\t}\n\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t{\n\t\t\tdx -= w;\n\t\t}\n\n\t\tx += dx;\n\n\t\t// FIXME: LINE_HEIGHT not ideal for all text sizes, fix for export\n\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t{\n\t\t\tdy -= h / 2;\n\t\t}\n\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t{\n\t\t\tdy -= h;\n\t\t}\n\n\t\t// Workaround for rendering offsets\n\t\t// TODO: Check if export needs these fixes, too\n\t\tif (overflow != 'fill' && mxClient.IS_FF && mxClient.IS_WIN)\n\t\t{\n\t\t\tdy -= 2;\n\t\t}\n\n\t\ty += dy;\n\n\t\tvar tr = (s.scale != 1) ? 'scale(' + s.scale + ')' : '';\n\n\t\tif (s.rotation != 0 && this.rotateHtml)\n\t\t{\n\t\t\ttr += 'rotate(' + (s.rotation) + ',' + (w / 2) + ',' + (h / 2) + ')';\n\t\t\tvar pt = this.rotatePoint((x + w / 2) * s.scale, (y + h / 2) * s.scale,\n\t\t\t\ts.rotation, s.rotationCx, s.rotationCy);\n\t\t\tx = pt.x - w * s.scale / 2;\n\t\t\ty = pt.y - h * s.scale / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx *= s.scale;\n\t\t\ty *= s.scale;\n\t\t}\n\n\t\tif (rotation != 0)\n\t\t{\n\t\t\ttr += 'rotate(' + (rotation) + ',' + (-dx) + ',' + (-dy) + ')';\n\t\t}\n\n\t\tgroup.setAttribute('transform', 'translate(' + Math.round(x) + ',' + Math.round(y) + ')' + tr);\n\t\tfo.setAttribute('width', Math.round(Math.max(1, w)));\n\t\tfo.setAttribute('height', Math.round(Math.max(1, h)));\n\t}\n};\n\n/**\n * Function: text\n *\n * Paints the given text. Possible values for format are empty string for plain\n * text and html for HTML markup. Note that HTML markup is only supported if\n * foreignObject is supported and <foEnabled> is true. (This means IE9 and later\n * does currently not support HTML text as part of shapes.)\n */\nmxSvgCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\tif (this.textEnabled && str != null)\n\t{\n\t\trotation = (rotation != null) ? rotation : 0;\n\n\t\tvar s = this.state;\n\t\tx += s.dx;\n\t\ty += s.dy;\n\n\t\tif (this.foEnabled && format == 'html')\n\t\t{\n\t\t\tvar style = 'vertical-align:top;';\n\n\t\t\tif (clip)\n\t\t\t{\n\t\t\t\tstyle += 'overflow:hidden;max-height:' + Math.round(h) + 'px;max-width:' + Math.round(w) + 'px;';\n\t\t\t}\n\t\t\telse if (overflow == 'fill')\n\t\t\t{\n\t\t\t\tstyle += 'width:' + Math.round(w + 1) + 'px;height:' + Math.round(h + 1) + 'px;overflow:hidden;';\n\t\t\t}\n\t\t\telse if (overflow == 'width')\n\t\t\t{\n\t\t\t\tstyle += 'width:' + Math.round(w + 1) + 'px;';\n\n\t\t\t\tif (h > 0)\n\t\t\t\t{\n\t\t\t\t\tstyle += 'max-height:' + Math.round(h) + 'px;overflow:hidden;';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (wrap && w > 0)\n\t\t\t{\n\t\t\t\tstyle += 'width:' + Math.round(w + 1) + 'px;white-space:normal;word-wrap:' +\n\t\t\t\t\tmxConstants.WORD_WRAP + ';';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstyle += 'white-space:nowrap;';\n\t\t\t}\n\n\t\t\t// Uses outer group for opacity and transforms to\n\t\t\t// fix rendering order in Chrome\n\t\t\tvar group = this.createElement('g');\n\n\t\t\tif (s.alpha < 1)\n\t\t\t{\n\t\t\t\tgroup.setAttribute('opacity', s.alpha);\n\t\t\t}\n\n\t\t\tvar fo = this.createElement('foreignObject');\n\t\t\tfo.setAttribute('style', 'overflow:visible;');\n\t\t\tfo.setAttribute('pointer-events', 'all');\n\n\t\t\tvar div = this.createDiv(str, align, valign, style, overflow, (wrap && w > 0) ? 'normal' : null);\n\n\t\t\t// Ignores invalid XHTML labels\n\t\t\tif (div == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (dir != null)\n\t\t\t{\n\t\t\t\tdiv.setAttribute('dir', dir);\n\t\t\t}\n\n\t\t\tgroup.appendChild(fo);\n\t\t\tthis.root.appendChild(group);\n\n\t\t\t// Code that depends on the size which is computed after\n\t\t\t// the element was added to the DOM.\n\t\t\tvar ow = 0;\n\t\t\tvar oh = 0;\n\n\t\t\t// Padding avoids clipping on border and wrapping for differing font metrics on platforms\n\t\t\tvar padX = 2;\n\t\t\tvar padY = 2;\n\n\t\t\t// NOTE: IE is always export as it does not support foreign objects\n\t\t\tif (mxClient.IS_IE && (document.documentMode == 9 || !mxClient.IS_SVG))\n\t\t\t{\n\t\t\t\t// Handles non-standard namespace for getting size in IE\n\t\t\t\tvar clone = document.createElement('div');\n\n\t\t\t\tclone.style.cssText = div.getAttribute('style');\n\t\t\t\tclone.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\t\t\tclone.style.position = 'absolute';\n\t\t\t\tclone.style.visibility = 'hidden';\n\n\t\t\t\t// Inner DIV is needed for text measuring\n\t\t\t\tvar div2 = document.createElement('div');\n\t\t\t\tdiv2.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\t\t\tdiv2.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\tdiv2.innerHTML = (mxUtils.isNode(str)) ? str.outerHTML : str;\n\t\t\t\tclone.appendChild(div2);\n\n\t\t\t\tdocument.body.appendChild(clone);\n\n\t\t\t\t// Workaround for different box models\n\t\t\t\tif (document.documentMode != 8 && document.documentMode != 9 && s.fontBorderColor != null)\n\t\t\t\t{\n\t\t\t\t\tpadX += 2;\n\t\t\t\t\tpadY += 2;\n\t\t\t\t}\n\n\t\t\t\tif (wrap && w > 0)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = div2.offsetWidth;\n\n\t\t\t\t\t// Workaround for adding padding twice in IE8/IE9 standards mode if label is wrapped\n\t\t\t\t\tpadDx = 0;\n\n\t\t\t\t\t// For export, if no wrapping occurs, we add a large padding to make\n\t\t\t\t\t// sure there is no wrapping even if the text metrics are different.\n\t\t\t\t\t// This adds support for text metrics on different operating systems.\n\t\t\t\t\t// Disables wrapping if text is not wrapped for given width\n\t\t\t\t\tif (!clip && wrap && w > 0 && this.root.ownerDocument != document && overflow != 'fill')\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ws = clone.style.whiteSpace;\n\t\t\t\t\t\tdiv2.style.whiteSpace = 'nowrap';\n\n\t\t\t\t\t\tif (tmp < div2.offsetWidth)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclone.style.whiteSpace = ws;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (clip)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = Math.min(tmp, w);\n\t\t\t\t\t}\n\n\t\t\t\t\tclone.style.width = tmp + 'px';\n\n\t\t\t\t\t// Padding avoids clipping on border\n\t\t\t\t\tow = div2.offsetWidth + padX + padDx;\n\t\t\t\t\toh = div2.offsetHeight + padY;\n\n\t\t\t\t\t// Overrides the width of the DIV via XML DOM by using the\n\t\t\t\t\t// clone DOM style, getting the CSS text for that and\n\t\t\t\t\t// then setting that on the DIV via setAttribute\n\t\t\t\t\tclone.style.display = 'inline-block';\n\t\t\t\t\tclone.style.position = '';\n\t\t\t\t\tclone.style.visibility = '';\n\t\t\t\t\tclone.style.width = ow + 'px';\n\n\t\t\t\t\tdiv.setAttribute('style', clone.style.cssText);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Padding avoids clipping on border\n\t\t\t\t\tow = div2.offsetWidth + padX;\n\t\t\t\t\toh = div2.offsetHeight + padY;\n\t\t\t\t}\n\n\t\t\t\tclone.parentNode.removeChild(clone);\n\t\t\t\tfo.appendChild(div);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Uses document for text measuring during export\n\t\t\t\tif (this.root.ownerDocument != document)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.visibility = 'hidden';\n\t\t\t\t\tdocument.body.appendChild(div);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfo.appendChild(div);\n\t\t\t\t}\n\n\t\t\t\tvar sizeDiv = div;\n\n\t\t\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t\t\t{\n\t\t\t\t\tsizeDiv = sizeDiv.firstChild;\n\n\t\t\t\t\tif (wrap && div.style.wordWrap == 'break-word')\n\t\t\t\t\t{\n\t\t\t\t\t\tsizeDiv.style.width = '100%';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar tmp = sizeDiv.offsetWidth;\n\n\t\t\t\t// Workaround for text measuring in hidden containers\n\t\t\t\tif (tmp == 0 && div.parentNode == fo)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.visibility = 'hidden';\n\t\t\t\t\tdocument.body.appendChild(div);\n\n\t\t\t\t\ttmp = sizeDiv.offsetWidth;\n\t\t\t\t}\n\n\t\t\t\tif (this.cacheOffsetSize)\n\t\t\t\t{\n\t\t\t\t\tgroup.mxCachedOffsetWidth = tmp;\n\t\t\t\t}\n\n\t\t\t\t// Disables wrapping if text is not wrapped for given width\n\t\t\t\tif (!clip && wrap && w > 0 && this.root.ownerDocument != document &&\n\t\t\t\t\toverflow != 'fill' && overflow != 'width')\n\t\t\t\t{\n\t\t\t\t\tvar ws = div.style.whiteSpace;\n\t\t\t\t\tdiv.style.whiteSpace = 'nowrap';\n\n\t\t\t\t\tif (tmp < sizeDiv.offsetWidth)\n\t\t\t\t\t{\n\t\t\t\t\t\tdiv.style.whiteSpace = ws;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tow = tmp + padX - 1;\n\n\t\t\t\t// Recomputes the height of the element for wrapped width\n\t\t\t\tif (wrap && overflow != 'fill' && overflow != 'width')\n\t\t\t\t{\n\t\t\t\t\tif (clip)\n\t\t\t\t\t{\n\t\t\t\t\t\tow = Math.min(ow, w);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiv.style.width = ow + 'px';\n\t\t\t\t}\n\n\t\t\t\tow = sizeDiv.offsetWidth;\n\t\t\t\toh = sizeDiv.offsetHeight;\n\n\t\t\t\tif (this.cacheOffsetSize)\n\t\t\t\t{\n\t\t\t\t\tgroup.mxCachedFinalOffsetWidth = ow;\n\t\t\t\t\tgroup.mxCachedFinalOffsetHeight = oh;\n\t\t\t\t}\n\n\t\t\t\toh -= padY;\n\n\t\t\t\tif (div.parentNode != fo)\n\t\t\t\t{\n\t\t\t\t\tfo.appendChild(div);\n\t\t\t\t\tdiv.style.visibility = '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (clip)\n\t\t\t{\n\t\t\t\toh = Math.min(oh, h);\n\t\t\t\tow = Math.min(ow, w);\n\t\t\t}\n\n\t\t\tif (overflow == 'width')\n\t\t\t{\n\t\t\t\th = oh;\n\t\t\t}\n\t\t\telse if (overflow != 'fill')\n\t\t\t{\n\t\t\t\tw = ow;\n\t\t\t\th = oh;\n\t\t\t}\n\n\t\t\tif (s.alpha < 1)\n\t\t\t{\n\t\t\t\tgroup.setAttribute('opacity', s.alpha);\n\t\t\t}\n\n\t\t\tvar dx = 0;\n\t\t\tvar dy = 0;\n\n\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t{\n\t\t\t\tdx -= w / 2;\n\t\t\t}\n\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tdx -= w;\n\t\t\t}\n\n\t\t\tx += dx;\n\n\t\t\t// FIXME: LINE_HEIGHT not ideal for all text sizes, fix for export\n\t\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t{\n\t\t\t\tdy -= h / 2;\n\t\t\t}\n\t\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\tdy -= h;\n\t\t\t}\n\n\t\t\t// Workaround for rendering offsets\n\t\t\t// TODO: Check if export needs these fixes, too\n\t\t\t//if (this.root.ownerDocument == document)\n\t\t\tif (overflow != 'fill' && mxClient.IS_FF && mxClient.IS_WIN)\n\t\t\t{\n\t\t\t\tdy -= 2;\n\t\t\t}\n\n\t\t\ty += dy;\n\n\t\t\tvar tr = (s.scale != 1) ? 'scale(' + s.scale + ')' : '';\n\n\t\t\tif (s.rotation != 0 && this.rotateHtml)\n\t\t\t{\n\t\t\t\ttr += 'rotate(' + (s.rotation) + ',' + (w / 2) + ',' + (h / 2) + ')';\n\t\t\t\tvar pt = this.rotatePoint((x + w / 2) * s.scale, (y + h / 2) * s.scale,\n\t\t\t\t\ts.rotation, s.rotationCx, s.rotationCy);\n\t\t\t\tx = pt.x - w * s.scale / 2;\n\t\t\t\ty = pt.y - h * s.scale / 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx *= s.scale;\n\t\t\t\ty *= s.scale;\n\t\t\t}\n\n\t\t\tif (rotation != 0)\n\t\t\t{\n\t\t\t\ttr += 'rotate(' + (rotation) + ',' + (-dx) + ',' + (-dy) + ')';\n\t\t\t}\n\n\t\t\tgroup.setAttribute('transform', 'translate(' + (Math.round(x) + this.foOffset) + ',' +\n\t\t\t\t(Math.round(y) + this.foOffset) + ')' + tr);\n\t\t\tfo.setAttribute('width', Math.round(Math.max(1, w)));\n\t\t\tfo.setAttribute('height', Math.round(Math.max(1, h)));\n\n\t\t\t// Adds alternate content if foreignObject not supported in viewer\n\t\t\tif (this.root.ownerDocument != document)\n\t\t\t{\n\t\t\t\tvar alt = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);\n\n\t\t\t\tif (alt != null)\n\t\t\t\t{\n\t\t\t\t\tfo.setAttribute('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility');\n\t\t\t\t\tvar sw = this.createElement('switch');\n\t\t\t\t\tsw.appendChild(fo);\n\t\t\t\t\tsw.appendChild(alt);\n\t\t\t\t\tgroup.appendChild(sw);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.plainText(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation, dir);\n\t\t}\n\t}\n};\n\n/**\n * Function: createClip\n *\n * Creates a clip for the given coordinates.\n */\nmxSvgCanvas2D.prototype.createClip = function(x, y, w, h)\n{\n\tx = Math.round(x);\n\ty = Math.round(y);\n\tw = Math.round(w);\n\th = Math.round(h);\n\n\tvar id = 'mx-clip-' + x + '-' + y + '-' + w + '-' + h;\n\n\tvar counter = 0;\n\tvar tmp = id + '-' + counter;\n\n\t// Resolves ID conflicts\n\twhile (document.getElementById(tmp) != null)\n\t{\n\t\ttmp = id + '-' + (++counter);\n\t}\n\n\tclip = this.createElement('clipPath');\n\tclip.setAttribute('id', tmp);\n\n\tvar rect = this.createElement('rect');\n\trect.setAttribute('x', x);\n\trect.setAttribute('y', y);\n\trect.setAttribute('width', w);\n\trect.setAttribute('height', h);\n\n\tclip.appendChild(rect);\n\n\treturn clip;\n};\n\n/**\n * Function: text\n *\n * Paints the given text. Possible values for format are empty string for\n * plain text and html for HTML markup.\n */\nmxSvgCanvas2D.prototype.plainText = function(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation, dir)\n{\n\trotation = (rotation != null) ? rotation : 0;\n\tvar s = this.state;\n\tvar size = s.fontSize;\n\tvar node = this.createElement('g');\n\tvar tr = s.transform || '';\n\tthis.updateFont(node);\n\n\t// Non-rotated text\n\tif (rotation != 0)\n\t{\n\t\ttr += 'rotate(' + rotation  + ',' + this.format(x * s.scale) + ',' + this.format(y * s.scale) + ')';\n\t}\n\n\tif (dir != null)\n\t{\n\t\tnode.setAttribute('direction', dir);\n\t}\n\n\tif (clip && w > 0 && h > 0)\n\t{\n\t\tvar cx = x;\n\t\tvar cy = y;\n\n\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t{\n\t\t\tcx -= w / 2;\n\t\t}\n\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t{\n\t\t\tcx -= w;\n\t\t}\n\n\t\tif (overflow != 'fill')\n\t\t{\n\t\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t{\n\t\t\t\tcy -= h / 2;\n\t\t\t}\n\t\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\tcy -= h;\n\t\t\t}\n\t\t}\n\n\t\t// LATER: Remove spacing from clip rectangle\n\t\tvar c = this.createClip(cx * s.scale - 2, cy * s.scale - 2, w * s.scale + 4, h * s.scale + 4);\n\n\t\tif (this.defs != null)\n\t\t{\n\t\t\tthis.defs.appendChild(c);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Makes sure clip is removed with referencing node\n\t\t\tthis.root.appendChild(c);\n\t\t}\n\n\t\tif (!mxClient.IS_CHROME_APP && !mxClient.IS_IE && !mxClient.IS_IE11 &&\n\t\t\t!mxClient.IS_EDGE && this.root.ownerDocument == document)\n\t\t{\n\t\t\t// Workaround for potential base tag\n\t\t\tvar base = this.getBaseUrl().replace(/([\\(\\)])/g, '\\\\$1');\n\t\t\tnode.setAttribute('clip-path', 'url(' + base + '#' + c.getAttribute('id') + ')');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.setAttribute('clip-path', 'url(#' + c.getAttribute('id') + ')');\n\t\t}\n\t}\n\n\t// Default is left\n\tvar anchor = (align == mxConstants.ALIGN_RIGHT) ? 'end' :\n\t\t\t\t\t(align == mxConstants.ALIGN_CENTER) ? 'middle' :\n\t\t\t\t\t'start';\n\n\t// Text-anchor start is default in SVG\n\tif (anchor != 'start')\n\t{\n\t\tnode.setAttribute('text-anchor', anchor);\n\t}\n\n\tif (!this.styleEnabled || size != mxConstants.DEFAULT_FONTSIZE)\n\t{\n\t\tnode.setAttribute('font-size', (size * s.scale) + 'px');\n\t}\n\n\tif (tr.length > 0)\n\t{\n\t\tnode.setAttribute('transform', tr);\n\t}\n\n\tif (s.alpha < 1)\n\t{\n\t\tnode.setAttribute('opacity', s.alpha);\n\t}\n\n\tvar lines = str.split('\\n');\n\tvar lh = Math.round(size * mxConstants.LINE_HEIGHT);\n\tvar textHeight = size + (lines.length - 1) * lh;\n\n\tvar cy = y + size - 1;\n\n\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t{\n\t\tif (overflow == 'fill')\n\t\t{\n\t\t\tcy -= h / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar dy = ((this.matchHtmlAlignment && clip && h > 0) ? Math.min(textHeight, h) : textHeight) / 2;\n\t\t\tcy -= dy + 1;\n\t\t}\n\t}\n\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tif (overflow == 'fill')\n\t\t{\n\t\t\tcy -= h;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar dy = (this.matchHtmlAlignment && clip && h > 0) ? Math.min(textHeight, h) : textHeight;\n\t\t\tcy -= dy + 2;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < lines.length; i++)\n\t{\n\t\t// Workaround for bounding box of empty lines and spaces\n\t\tif (lines[i].length > 0 && mxUtils.trim(lines[i]).length > 0)\n\t\t{\n\t\t\tvar text = this.createElement('text');\n\t\t\t// LATER: Match horizontal HTML alignment\n\t\t\ttext.setAttribute('x', this.format(x * s.scale) + this.textOffset);\n\t\t\ttext.setAttribute('y', this.format(cy * s.scale) + this.textOffset);\n\n\t\t\tmxUtils.write(text, lines[i]);\n\t\t\tnode.appendChild(text);\n\t\t}\n\n\t\tcy += lh;\n\t}\n\n\tthis.root.appendChild(node);\n\tthis.addTextBackground(node, str, x, y, w, (overflow == 'fill') ? h : textHeight, align, valign, overflow);\n};\n\n/**\n * Function: updateFont\n *\n * Updates the text properties for the given node. (NOTE: For this to work in\n * IE, the given node must be a text or tspan element.)\n */\nmxSvgCanvas2D.prototype.updateFont = function(node)\n{\n\tvar s = this.state;\n\n\tnode.setAttribute('fill', s.fontColor);\n\n\tif (!this.styleEnabled || s.fontFamily != mxConstants.DEFAULT_FONTFAMILY)\n\t{\n\t\tnode.setAttribute('font-family', '\\'' + s.fontFamily + '\\'');\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tnode.setAttribute('font-weight', 'bold');\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tnode.setAttribute('font-style', 'italic');\n\t}\n\n\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\tnode.setAttribute('text-decoration', 'underline');\n\t}\n};\n\n/**\n * Function: addTextBackground\n *\n * Background color and border\n */\nmxSvgCanvas2D.prototype.addTextBackground = function(node, str, x, y, w, h, align, valign, overflow)\n{\n\tvar s = this.state;\n\n\tif (s.fontBackgroundColor != null || s.fontBorderColor != null)\n\t{\n\t\tvar bbox = null;\n\n\t\tif (overflow == 'fill' || overflow == 'width')\n\t\t{\n\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t{\n\t\t\t\tx -= w / 2;\n\t\t\t}\n\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tx -= w;\n\t\t\t}\n\n\t\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t{\n\t\t\t\ty -= h / 2;\n\t\t\t}\n\t\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\ty -= h;\n\t\t\t}\n\n\t\t\tbbox = new mxRectangle((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);\n\t\t}\n\t\telse if (node.getBBox != null && this.root.ownerDocument == document)\n\t\t{\n\t\t\t// Uses getBBox only if inside document for correct size\n\t\t\ttry\n\t\t\t{\n\t\t\t\tbbox = node.getBBox();\n\t\t\t\tvar ie = mxClient.IS_IE && mxClient.IS_SVG;\n\t\t\t\tbbox = new mxRectangle(bbox.x, bbox.y + ((ie) ? 0 : 1), bbox.width, bbox.height + ((ie) ? 1 : 0));\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\t// Ignores NS_ERROR_FAILURE in FF if container display is none.\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Computes size if not in document or no getBBox available\n\t\t\tvar div = document.createElement('div');\n\n\t\t\t// Wrapping and clipping can be ignored here\n\t\t\tdiv.style.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (s.fontSize * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;\n\t\t\tdiv.style.fontSize = s.fontSize + 'px';\n\t\t\t// Quotes are workaround for font name \"m+\"\n\t\t\tdiv.style.fontFamily = '\"' + s.fontFamily + '\"';\n\t\t\tdiv.style.whiteSpace = 'nowrap';\n\t\t\tdiv.style.position = 'absolute';\n\t\t\tdiv.style.visibility = 'hidden';\n\t\t\tdiv.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\t\tdiv.style.zoom = '1';\n\n\t\t\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t\t\t{\n\t\t\t\tdiv.style.fontWeight = 'bold';\n\t\t\t}\n\n\t\t\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t\t\t{\n\t\t\t\tdiv.style.fontStyle = 'italic';\n\t\t\t}\n\n\t\t\tstr = mxUtils.htmlEntities(str, false);\n\t\t\tdiv.innerHTML = str.replace(/\\n/g, '<br/>');\n\n\t\t\tdocument.body.appendChild(div);\n\t\t\tvar w = div.offsetWidth;\n\t\t\tvar h = div.offsetHeight;\n\t\t\tdiv.parentNode.removeChild(div);\n\n\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t{\n\t\t\t\tx -= w / 2;\n\t\t\t}\n\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tx -= w;\n\t\t\t}\n\n\t\t\tif (valign == mxConstants.ALIGN_MIDDLE)\n\t\t\t{\n\t\t\t\ty -= h / 2;\n\t\t\t}\n\t\t\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\ty -= h;\n\t\t\t}\n\n\t\t\tbbox = new mxRectangle((x + 1) * s.scale, (y + 2) * s.scale, w * s.scale, (h + 1) * s.scale);\n\t\t}\n\n\t\tif (bbox != null)\n\t\t{\n\t\t\tvar n = this.createElement('rect');\n\t\t\tn.setAttribute('fill', s.fontBackgroundColor || 'none');\n\t\t\tn.setAttribute('stroke', s.fontBorderColor || 'none');\n\t\t\tn.setAttribute('x', Math.floor(bbox.x - 1));\n\t\t\tn.setAttribute('y', Math.floor(bbox.y - 1));\n\t\t\tn.setAttribute('width', Math.ceil(bbox.width + 2));\n\t\t\tn.setAttribute('height', Math.ceil(bbox.height));\n\n\t\t\tvar sw = (s.fontBorderColor != null) ? Math.max(1, this.format(s.scale)) : 0;\n\t\t\tn.setAttribute('stroke-width', sw);\n\n\t\t\t// Workaround for crisp rendering - only required if not exporting\n\t\t\tif (this.root.ownerDocument == document && mxUtils.mod(sw, 2) == 1)\n\t\t\t{\n\t\t\t\tn.setAttribute('transform', 'translate(0.5, 0.5)');\n\t\t\t}\n\n\t\t\tnode.insertBefore(n, node.firstChild);\n\t\t}\n\t}\n};\n\n/**\n * Function: stroke\n *\n * Paints the outline of the current path.\n */\nmxSvgCanvas2D.prototype.stroke = function()\n{\n\tthis.addNode(false, true);\n};\n\n/**\n * Function: fill\n *\n * Fills the current path.\n */\nmxSvgCanvas2D.prototype.fill = function()\n{\n\tthis.addNode(true, false);\n};\n\n/**\n * Function: fillAndStroke\n *\n * Fills and paints the outline of the current path.\n */\nmxSvgCanvas2D.prototype.fillAndStroke = function()\n{\n\tthis.addNode(true, true);\n};\n\n__mxOutput.mxSvgCanvas2D = typeof mxSvgCanvas2D !== 'undefined' ? mxSvgCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxVmlCanvas2D\n *\n * Implements a canvas to be used for rendering VML. Here is an example of implementing a\n * fallback for SVG images which are not supported in VML-based browsers.\n *\n * (code)\n * var mxVmlCanvas2DImage = mxVmlCanvas2D.prototype.image;\n * mxVmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n * {\n *   if (src.substring(src.length - 4, src.length) == '.svg')\n *   {\n *     src = 'http://www.jgraph.com/images/mxgraph.gif';\n *   }\n *\n *   mxVmlCanvas2DImage.apply(this, arguments);\n * };\n * (end)\n *\n * To disable anti-aliasing in the output, use the following code.\n *\n * (code)\n * document.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{antialias:false;)}';\n * (end)\n *\n * A description of the public API is available in <mxXmlCanvas2D>. Note that\n * there is a known issue in VML where gradients are painted using the outer\n * bounding box of rotated shapes, not the actual bounds of the shape. See\n * also <text> for plain text label restrictions in shapes for VML.\n */\nvar mxVmlCanvas2D = function(root)\n{\n\tmxAbstractCanvas2D.call(this);\n\n\t/**\n\t * Variable: root\n\t *\n\t * Reference to the container for the SVG content.\n\t */\n\tthis.root = root;\n};\n\n/**\n * Extends mxAbstractCanvas2D\n */\nmxUtils.extend(mxVmlCanvas2D, mxAbstractCanvas2D);\n\n/**\n * Variable: path\n *\n * Holds the current DOM node.\n */\nmxVmlCanvas2D.prototype.node = null;\n\n/**\n * Variable: textEnabled\n *\n * Specifies if text output should be enabledetB. Default is true.\n */\nmxVmlCanvas2D.prototype.textEnabled = true;\n\n/**\n * Variable: moveOp\n *\n * Contains the string used for moving in paths. Default is 'm'.\n */\nmxVmlCanvas2D.prototype.moveOp = 'm';\n\n/**\n * Variable: lineOp\n *\n * Contains the string used for moving in paths. Default is 'l'.\n */\nmxVmlCanvas2D.prototype.lineOp = 'l';\n\n/**\n * Variable: curveOp\n *\n * Contains the string used for bezier curves. Default is 'c'.\n */\nmxVmlCanvas2D.prototype.curveOp = 'c';\n\n/**\n * Variable: closeOp\n *\n * Holds the operator for closing curves. Default is 'x e'.\n */\nmxVmlCanvas2D.prototype.closeOp = 'x';\n\n/**\n * Variable: rotatedHtmlBackground\n *\n * Background color for rotated HTML. Default is ''. This can be set to eg.\n * white to improve rendering of rotated text in VML for IE9.\n */\nmxVmlCanvas2D.prototype.rotatedHtmlBackground = '';\n\n/**\n * Variable: vmlScale\n *\n * Specifies the scale used to draw VML shapes.\n */\nmxVmlCanvas2D.prototype.vmlScale = 1;\n\n/**\n * Function: createElement\n *\n * Creates the given element using the document.\n */\nmxVmlCanvas2D.prototype.createElement = function(name)\n{\n\treturn document.createElement(name);\n};\n\n/**\n * Function: createVmlElement\n *\n * Creates a new element using <createElement> and prefixes the given name with\n * <mxClient.VML_PREFIX>.\n */\nmxVmlCanvas2D.prototype.createVmlElement = function(name)\n{\n\treturn this.createElement(mxClient.VML_PREFIX + ':' + name);\n};\n\n/**\n * Function: addNode\n *\n * Adds the current node to the <root>.\n */\nmxVmlCanvas2D.prototype.addNode = function(filled, stroked)\n{\n\tvar node = this.node;\n\tvar s = this.state;\n\n\tif (node != null)\n\t{\n\t\tif (node.nodeName == 'shape')\n\t\t{\n\t\t\t// Checks if the path is not empty\n\t\t\tif (this.path != null && this.path.length > 0)\n\t\t\t{\n\t\t\t\tnode.path = this.path.join(' ') + ' e';\n\t\t\t\tnode.style.width = this.root.style.width;\n\t\t\t\tnode.style.height = this.root.style.height;\n\t\t\t\tnode.coordsize = parseInt(node.style.width) + ' ' + parseInt(node.style.height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tnode.strokeweight = this.format(Math.max(1, s.strokeWidth * s.scale / this.vmlScale)) + 'px';\n\n\t\tif (s.shadow)\n\t\t{\n\t\t\tthis.root.appendChild(this.createShadow(node,\n\t\t\t\tfilled && s.fillColor != null,\n\t\t\t\tstroked && s.strokeColor != null));\n\t\t}\n\n\t\tif (stroked && s.strokeColor != null)\n\t\t{\n\t\t\tnode.stroked = 'true';\n\t\t\tnode.strokecolor = s.strokeColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.stroked = 'false';\n\t\t}\n\n\t\tnode.appendChild(this.createStroke());\n\n\t\tif (filled && s.fillColor != null)\n\t\t{\n\t\t\tnode.appendChild(this.createFill());\n\t\t}\n\t\telse if (this.pointerEvents && (node.nodeName != 'shape' ||\n\t\t\tthis.path[this.path.length - 1] == this.closeOp))\n\t\t{\n\t\t\tnode.appendChild(this.createTransparentFill());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.filled = 'false';\n\t\t}\n\n\t\t// LATER: Update existing DOM for performance\n\t\tthis.root.appendChild(node);\n\t}\n};\n\n/**\n * Function: createTransparentFill\n *\n * Creates a transparent fill.\n */\nmxVmlCanvas2D.prototype.createTransparentFill = function()\n{\n\tvar fill = this.createVmlElement('fill');\n\tfill.src = mxClient.imageBasePath + '/transparent.gif';\n\tfill.type = 'tile';\n\n\treturn fill;\n};\n\n/**\n * Function: createFill\n *\n * Creates a fill for the current state.\n */\nmxVmlCanvas2D.prototype.createFill = function()\n{\n\tvar s = this.state;\n\n\t// Gradients in foregrounds not supported because special gradients\n\t// with bounds must be created for each element in graphics-canvases\n\tvar fill = this.createVmlElement('fill');\n\tfill.color = s.fillColor;\n\n\tif (s.gradientColor != null)\n\t{\n\t\tfill.type = 'gradient';\n\t\tfill.method = 'none';\n\t\tfill.color2 = s.gradientColor;\n\t\tvar angle = 180 - s.rotation;\n\n\t\tif (s.gradientDirection == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tangle -= 90 + ((this.root.style.flip == 'x') ? 180 : 0);\n\t\t}\n\t\telse if (s.gradientDirection == mxConstants.DIRECTION_EAST)\n\t\t{\n\t\t\tangle += 90 + ((this.root.style.flip == 'x') ? 180 : 0);\n\t\t}\n\t\telse if (s.gradientDirection == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tangle -= 180 + ((this.root.style.flip == 'y') ? -180 : 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t angle += ((this.root.style.flip == 'y') ? -180 : 0);\n\t\t}\n\n\t\tif (this.root.style.flip == 'x' || this.root.style.flip == 'y')\n\t\t{\n\t\t\tangle *= -1;\n\t\t}\n\n\t\t// LATER: Fix outer bounding box for rotated shapes used in VML.\n\t\tfill.angle = mxUtils.mod(angle, 360);\n\t\tfill.opacity = (s.alpha * s.gradientFillAlpha * 100) + '%';\n\t\tfill.setAttribute(mxClient.OFFICE_PREFIX + ':opacity2', (s.alpha * s.gradientAlpha * 100) + '%');\n\t}\n\telse if (s.alpha < 1 || s.fillAlpha < 1)\n\t{\n\t\tfill.opacity = (s.alpha * s.fillAlpha * 100) + '%';\n\t}\n\n\treturn fill;\n};\n/**\n * Function: createStroke\n *\n * Creates a fill for the current state.\n */\nmxVmlCanvas2D.prototype.createStroke = function()\n{\n\tvar s = this.state;\n\tvar stroke = this.createVmlElement('stroke');\n\tstroke.endcap = s.lineCap || 'flat';\n\tstroke.joinstyle = s.lineJoin || 'miter';\n\tstroke.miterlimit = s.miterLimit || '10';\n\n\tif (s.alpha < 1 || s.strokeAlpha < 1)\n\t{\n\t\tstroke.opacity = (s.alpha * s.strokeAlpha * 100) + '%';\n\t}\n\n\tif (s.dashed)\n\t{\n\t\tstroke.dashstyle = this.getVmlDashStyle();\n\t}\n\n\treturn stroke;\n};\n\n/**\n * Function: getVmlDashPattern\n *\n * Returns a VML dash pattern for the current dashPattern.\n * See http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx\n */\nmxVmlCanvas2D.prototype.getVmlDashStyle = function()\n{\n\tvar result = 'dash';\n\n\tif (typeof(this.state.dashPattern) === 'string')\n\t{\n\t\tvar tok = this.state.dashPattern.split(' ');\n\n\t\tif (tok.length > 0 && tok[0] == 1)\n\t\t{\n\t\t\tresult = '0 2';\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: createShadow\n *\n * Creates a shadow for the given node.\n */\nmxVmlCanvas2D.prototype.createShadow = function(node, filled, stroked)\n{\n\tvar s = this.state;\n\tvar rad = -s.rotation * (Math.PI / 180);\n\tvar cos = Math.cos(rad);\n\tvar sin = Math.sin(rad);\n\n\tvar dx = s.shadowDx * s.scale;\n\tvar dy = s.shadowDy * s.scale;\n\n\tif (this.root.style.flip == 'x')\n\t{\n\t\tdx *= -1;\n\t}\n\telse if (this.root.style.flip == 'y')\n\t{\n\t\tdy *= -1;\n\t}\n\n\tvar shadow = node.cloneNode(true);\n\tshadow.style.marginLeft = Math.round(dx * cos - dy * sin) + 'px';\n\tshadow.style.marginTop = Math.round(dx * sin + dy * cos) + 'px';\n\n\t// Workaround for wrong cloning in IE8 standards mode\n\tif (document.documentMode == 8)\n\t{\n\t\tshadow.strokeweight = node.strokeweight;\n\n\t\tif (node.nodeName == 'shape')\n\t\t{\n\t\t\tshadow.path = this.path.join(' ') + ' e';\n\t\t\tshadow.style.width = this.root.style.width;\n\t\t\tshadow.style.height = this.root.style.height;\n\t\t\tshadow.coordsize = parseInt(node.style.width) + ' ' + parseInt(node.style.height);\n\t\t}\n\t}\n\n\tif (stroked)\n\t{\n\t\tshadow.strokecolor = s.shadowColor;\n\t\tshadow.appendChild(this.createShadowStroke());\n\t}\n\telse\n\t{\n\t\tshadow.stroked = 'false';\n\t}\n\n\tif (filled)\n\t{\n\t\tshadow.appendChild(this.createShadowFill());\n\t}\n\telse\n\t{\n\t\tshadow.filled = 'false';\n\t}\n\n\treturn shadow;\n};\n\n/**\n * Function: createShadowFill\n *\n * Creates the fill for the shadow.\n */\nmxVmlCanvas2D.prototype.createShadowFill = function()\n{\n\tvar fill = this.createVmlElement('fill');\n\tfill.color = this.state.shadowColor;\n\tfill.opacity = (this.state.alpha * this.state.shadowAlpha * 100) + '%';\n\n\treturn fill;\n};\n\n/**\n * Function: createShadowStroke\n *\n * Creates the stroke for the shadow.\n */\nmxVmlCanvas2D.prototype.createShadowStroke = function()\n{\n\tvar stroke = this.createStroke();\n\tstroke.opacity = (this.state.alpha * this.state.shadowAlpha * 100) + '%';\n\n\treturn stroke;\n};\n\n/**\n * Function: rotate\n *\n * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\n */\nmxVmlCanvas2D.prototype.rotate = function(theta, flipH, flipV, cx, cy)\n{\n\tif (flipH && flipV)\n\t{\n\t\ttheta += 180;\n\t}\n\telse if (flipH)\n\t{\n\t\tthis.root.style.flip = 'x';\n\t}\n\telse if (flipV)\n\t{\n\t\tthis.root.style.flip = 'y';\n\t}\n\n\tif (flipH ? !flipV : flipV)\n\t{\n\t\ttheta *= -1;\n\t}\n\n\tthis.root.style.rotation = theta;\n\tthis.state.rotation = this.state.rotation + theta;\n\tthis.state.rotationCx = cx;\n\tthis.state.rotationCy = cy;\n};\n\n/**\n * Function: begin\n *\n * Extends superclass to create path.\n */\nmxVmlCanvas2D.prototype.begin = function()\n{\n\tmxAbstractCanvas2D.prototype.begin.apply(this, arguments);\n\tthis.node = this.createVmlElement('shape');\n\tthis.node.style.position = 'absolute';\n};\n\n/**\n * Function: quadTo\n *\n * Replaces quadratic curve with bezier curve in VML.\n */\nmxVmlCanvas2D.prototype.quadTo = function(x1, y1, x2, y2)\n{\n\tvar s = this.state;\n\n\tvar cpx0 = (this.lastX + s.dx) * s.scale;\n\tvar cpy0 = (this.lastY + s.dy) * s.scale;\n\tvar qpx1 = (x1 + s.dx) * s.scale;\n\tvar qpy1 = (y1 + s.dy) * s.scale;\n\tvar cpx3 = (x2 + s.dx) * s.scale;\n\tvar cpy3 = (y2 + s.dy) * s.scale;\n\n\tvar cpx1 = cpx0 + 2/3 * (qpx1 - cpx0);\n\tvar cpy1 = cpy0 + 2/3 * (qpy1 - cpy0);\n\n\tvar cpx2 = cpx3 + 2/3 * (qpx1 - cpx3);\n\tvar cpy2 = cpy3 + 2/3 * (qpy1 - cpy3);\n\n\tthis.path.push('c ' + this.format(cpx1) + ' ' + this.format(cpy1) +\n\t\t\t' ' + this.format(cpx2) + ' ' + this.format(cpy2) +\n\t\t\t' ' + this.format(cpx3) + ' ' + this.format(cpy3));\n\tthis.lastX = (cpx3 / s.scale) - s.dx;\n\tthis.lastY = (cpy3 / s.scale) - s.dy;\n\n};\n\n/**\n * Function: createRect\n *\n * Sets the glass gradient.\n */\nmxVmlCanvas2D.prototype.createRect = function(nodeName, x, y, w, h)\n{\n\tvar s = this.state;\n\tvar n = this.createVmlElement(nodeName);\n\tn.style.position = 'absolute';\n\tn.style.left = this.format((x + s.dx) * s.scale) + 'px';\n\tn.style.top = this.format((y + s.dy) * s.scale) + 'px';\n\tn.style.width = this.format(w * s.scale) + 'px';\n\tn.style.height = this.format(h * s.scale) + 'px';\n\n\treturn n;\n};\n\n/**\n * Function: rect\n *\n * Sets the current path to a rectangle.\n */\nmxVmlCanvas2D.prototype.rect = function(x, y, w, h)\n{\n\tthis.node = this.createRect('rect', x, y, w, h);\n};\n\n/**\n * Function: roundrect\n *\n * Sets the current path to a rounded rectangle.\n */\nmxVmlCanvas2D.prototype.roundrect = function(x, y, w, h, dx, dy)\n{\n\tthis.node = this.createRect('roundrect', x, y, w, h);\n\t// SetAttribute needed here for IE8\n\tthis.node.setAttribute('arcsize', Math.max(dx * 100 / w, dy * 100 / h) + '%');\n};\n\n/**\n * Function: ellipse\n *\n * Sets the current path to an ellipse.\n */\nmxVmlCanvas2D.prototype.ellipse = function(x, y, w, h)\n{\n\tthis.node = this.createRect('oval', x, y, w, h);\n};\n\n/**\n * Function: image\n *\n * Paints an image.\n */\nmxVmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\n{\n\tvar node = null;\n\n\tif (!aspect)\n\t{\n\t\tnode = this.createRect('image', x, y, w, h);\n\t\tnode.src = src;\n\t}\n\telse\n\t{\n\t\t// Uses fill with aspect to avoid asynchronous update of size\n\t\tnode = this.createRect('rect', x, y, w, h);\n\t\tnode.stroked = 'false';\n\n\t\t// Handles image aspect via fill\n\t\tvar fill = this.createVmlElement('fill');\n\t\tfill.aspect = (aspect) ? 'atmost' : 'ignore';\n\t\tfill.rotate = 'true';\n\t\tfill.type = 'frame';\n\t\tfill.src = src;\n\n\t\tnode.appendChild(fill);\n\t}\n\n\tif (flipH && flipV)\n\t{\n\t\tnode.style.rotation = '180';\n\t}\n\telse if (flipH)\n\t{\n\t\tnode.style.flip = 'x';\n\t}\n\telse if (flipV)\n\t{\n\t\tnode.style.flip = 'y';\n\t}\n\n\tif (this.state.alpha < 1 || this.state.fillAlpha < 1)\n\t{\n\t\t// KNOWN: Borders around transparent images in IE<9. Using fill.opacity\n\t\t// fixes this problem by adding a white background in all IE versions.\n\t\tnode.style.filter += 'alpha(opacity=' + (this.state.alpha * this.state.fillAlpha * 100) + ')';\n\t}\n\n\tthis.root.appendChild(node);\n};\n\n/**\n * Function: createText\n *\n * Creates the innermost element that contains the HTML text.\n */\nmxVmlCanvas2D.prototype.createDiv = function(str, align, valign, overflow)\n{\n\tvar div = this.createElement('div');\n\tvar state = this.state;\n\n\tvar css = '';\n\n\tif (state.fontBackgroundColor != null)\n\t{\n\t\tcss += 'background-color:' + mxUtils.htmlEntities(state.fontBackgroundColor) + ';';\n\t}\n\n\tif (state.fontBorderColor != null)\n\t{\n\t\tcss += 'border:1px solid ' + mxUtils.htmlEntities(state.fontBorderColor) + ';';\n\t}\n\n\tif (mxUtils.isNode(str))\n\t{\n\t\tdiv.appendChild(str);\n\t}\n\telse\n\t{\n\t\tif (overflow != 'fill' && overflow != 'width')\n\t\t{\n\t\t\tvar div2 = this.createElement('div');\n\t\t\tdiv2.style.cssText = css;\n\t\t\tdiv2.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\t\tdiv2.style.zoom = '1';\n\t\t\tdiv2.style.textDecoration = 'inherit';\n\t\t\tdiv2.innerHTML = str;\n\t\t\tdiv.appendChild(div2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdiv.style.cssText = css;\n\t\t\tdiv.innerHTML = str;\n\t\t}\n\t}\n\n\tvar style = div.style;\n\n\tstyle.fontSize = (state.fontSize / this.vmlScale) + 'px';\n\tstyle.fontFamily = state.fontFamily;\n\tstyle.color = state.fontColor;\n\tstyle.verticalAlign = 'top';\n\tstyle.textAlign = align || 'left';\n\tstyle.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (state.fontSize * mxConstants.LINE_HEIGHT / this.vmlScale) + 'px' : mxConstants.LINE_HEIGHT;\n\n\tif ((state.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tstyle.fontWeight = 'bold';\n\t}\n\n\tif ((state.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tstyle.fontStyle = 'italic';\n\t}\n\n\tif ((state.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\tstyle.textDecoration = 'underline';\n\t}\n\n\treturn div;\n};\n\n/**\n * Function: text\n *\n * Paints the given text. Possible values for format are empty string for plain\n * text and html for HTML markup. Clipping, text background and border are not\n * supported for plain text in VML.\n */\nmxVmlCanvas2D.prototype.text = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\tif (this.textEnabled && str != null)\n\t{\n\t\tvar s = this.state;\n\n\t\tif (format == 'html')\n\t\t{\n\t\t\tif (s.rotation != null)\n\t\t\t{\n\t\t\t\tvar pt = this.rotatePoint(x, y, s.rotation, s.rotationCx, s.rotationCy);\n\n\t\t\t\tx = pt.x;\n\t\t\t\ty = pt.y;\n\t\t\t}\n\n\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tx += s.dx;\n\t\t\t\ty += s.dy;\n\n\t\t\t\t// Workaround for rendering offsets\n\t\t\t\tif (overflow != 'fill' && valign == mxConstants.ALIGN_TOP)\n\t\t\t\t{\n\t\t\t\t\ty -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx *= s.scale;\n\t\t\t\ty *= s.scale;\n\t\t\t}\n\n\t\t\t// Adds event transparency in IE8 standards without the transparent background\n\t\t\t// filter which cannot be used due to bugs in the zoomed bounding box (too slow)\n\t\t\t// FIXME: No event transparency if inside v:rect (ie part of shape)\n\t\t\t// KNOWN: Offset wrong for rotated text with word that are longer than the wrapping\n\t\t\t// width in IE8 because real width of text cannot be determined here.\n\t\t\t// This should be fixed in mxText.updateBoundingBox by calling before this and\n\t\t\t// passing the real width to this method if not clipped and wrapped.\n\t\t\tvar abs = (document.documentMode == 8 && !mxClient.IS_EM) ? this.createVmlElement('group') : this.createElement('div');\n\t\t\tabs.style.position = 'absolute';\n\t\t\tabs.style.display = 'inline';\n\t\t\tabs.style.left = this.format(x) + 'px';\n\t\t\tabs.style.top = this.format(y) + 'px';\n\t\t\tabs.style.zoom = s.scale;\n\n\t\t\tvar box = this.createElement('div');\n\t\t\tbox.style.position = 'relative';\n\t\t\tbox.style.display = 'inline';\n\n\t\t\tvar margin = mxUtils.getAlignmentAsPoint(align, valign);\n\t\t\tvar dx = margin.x;\n\t\t\tvar dy = margin.y;\n\n\t\t\tvar div = this.createDiv(str, align, valign, overflow);\n\t\t\tvar inner = this.createElement('div');\n\n\t\t\tif (dir != null)\n\t\t\t{\n\t\t\t\tdiv.setAttribute('dir', dir);\n\t\t\t}\n\n\t\t\tif (wrap && w > 0)\n\t\t\t{\n\t\t\t\tif (!clip)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.width = Math.round(w) + 'px';\n\t\t\t\t}\n\n\t\t\t\tdiv.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\tdiv.style.whiteSpace = 'normal';\n\n\t\t\t\t// LATER: Check if other cases need to be handled\n\t\t\t\tif (div.style.wordWrap == 'break-word')\n\t\t\t\t{\n\t\t\t\t\tvar tmp = div;\n\n\t\t\t\t\tif (tmp.firstChild != null && tmp.firstChild.nodeName == 'DIV')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp.firstChild.style.width = '100%';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv.style.whiteSpace = 'nowrap';\n\t\t\t}\n\n\t\t\tvar rot = s.rotation + (rotation || 0);\n\n\t\t\tif (this.rotateHtml && rot != 0)\n\t\t\t{\n\t\t\t\tinner.style.display = 'inline';\n\t\t\t\tinner.style.zoom = '1';\n\t\t\t\tinner.appendChild(div);\n\n\t\t\t\t// Box not needed for rendering in IE8 standards\n\t\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM && this.root.nodeName != 'DIV')\n\t\t\t\t{\n\t\t\t\t\tbox.appendChild(inner);\n\t\t\t\t\tabs.appendChild(box);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tabs.appendChild(inner);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tbox.appendChild(div);\n\t\t\t\tabs.appendChild(box);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv.style.display = 'inline';\n\t\t\t\tabs.appendChild(div);\n\t\t\t}\n\n\t\t\t// Inserts the node into the DOM\n\t\t\tif (this.root.nodeName != 'DIV')\n\t\t\t{\n\t\t\t\t// Rectangle to fix position in group\n\t\t\t\tvar rect = this.createVmlElement('rect');\n\t\t\t\trect.stroked = 'false';\n\t\t\t\trect.filled = 'false';\n\n\t\t\t\trect.appendChild(abs);\n\t\t\t\tthis.root.appendChild(rect);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.root.appendChild(abs);\n\t\t\t}\n\n\t\t\tif (clip)\n\t\t\t{\n\t\t\t\tdiv.style.overflow = 'hidden';\n\t\t\t\tdiv.style.width = Math.round(w) + 'px';\n\n\t\t\t\tif (!mxClient.IS_QUIRKS)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.maxHeight = Math.round(h) + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (overflow == 'fill')\n\t\t\t{\n\t\t\t\t// KNOWN: Affects horizontal alignment in quirks\n\t\t\t\t// but fill should only be used with align=left\n\t\t\t\tdiv.style.overflow = 'hidden';\n\t\t\t\tdiv.style.width = (Math.max(0, w) + 1) + 'px';\n\t\t\t\tdiv.style.height = (Math.max(0, h) + 1) + 'px';\n\t\t\t}\n\t\t\telse if (overflow == 'width')\n\t\t\t{\n\t\t\t\t// KNOWN: Affects horizontal alignment in quirks\n\t\t\t\t// but fill should only be used with align=left\n\t\t\t\tdiv.style.overflow = 'hidden';\n\t\t\t\tdiv.style.width = (Math.max(0, w) + 1) + 'px';\n\t\t\t\tdiv.style.maxHeight = (Math.max(0, h) + 1) + 'px';\n\t\t\t}\n\n\t\t\tif (this.rotateHtml && rot != 0)\n\t\t\t{\n\t\t\t\tvar rad = rot * (Math.PI / 180);\n\n\t\t\t\t// Precalculate cos and sin for the rotation\n\t\t\t\tvar real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));\n\t\t\t\tvar real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));\n\n\t\t\t\trad %= 2 * Math.PI;\n\t\t\t\tif (rad < 0) rad += 2 * Math.PI;\n\t\t\t\trad %= Math.PI;\n\t\t\t\tif (rad > Math.PI / 2) rad = Math.PI - rad;\n\n\t\t\t\tvar cos = Math.cos(rad);\n\t\t\t\tvar sin = Math.sin(rad);\n\n\t\t\t\t// Adds div to document to measure size\n\t\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.display = 'inline-block';\n\t\t\t\t\tinner.style.display = 'inline-block';\n\t\t\t\t\tbox.style.display = 'inline-block';\n\t\t\t\t}\n\n\t\t\t\tdiv.style.visibility = 'hidden';\n\t\t\t\tdiv.style.position = 'absolute';\n\t\t\t\tdocument.body.appendChild(div);\n\n\t\t\t\tvar sizeDiv = div;\n\n\t\t\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t\t\t{\n\t\t\t\t\tsizeDiv = sizeDiv.firstChild;\n\t\t\t\t}\n\n\t\t\t\tvar tmp = sizeDiv.offsetWidth + 3;\n\t\t\t\tvar oh = sizeDiv.offsetHeight;\n\n\t\t\t\tif (clip)\n\t\t\t\t{\n\t\t\t\t\tw = Math.min(w, tmp);\n\t\t\t\t\toh = Math.min(oh, h);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tw = tmp;\n\t\t\t\t}\n\n\t\t\t\t// Handles words that are longer than the given wrapping width\n\t\t\t\tif (wrap)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.width = w + 'px';\n\t\t\t\t}\n\n\t\t\t\t// Simulates max-height in quirks\n\t\t\t\tif (mxClient.IS_QUIRKS && (clip || overflow == 'width') && oh > h)\n\t\t\t\t{\n\t\t\t\t\toh = h;\n\n\t\t\t\t\t// Quirks does not support maxHeight\n\t\t\t\t\tdiv.style.height = oh + 'px';\n\t\t\t\t}\n\n\t\t\t\th = oh;\n\n\t\t\t\tvar top_fix = (h - h * cos + w * -sin) / 2 - real_sin * w * (dx + 0.5) + real_cos * h * (dy + 0.5);\n\t\t\t\tvar left_fix = (w - w * cos + h * -sin) / 2 + real_cos * w * (dx + 0.5) + real_sin * h * (dy + 0.5);\n\n\t\t\t\tif (abs.nodeName == 'group' && this.root.nodeName == 'DIV')\n\t\t\t\t{\n\t\t\t\t\t// Workaround for bug where group gets moved away if left and top are non-zero in IE8 standards\n\t\t\t\t\tvar pos = this.createElement('div');\n\t\t\t\t\tpos.style.display = 'inline-block';\n\t\t\t\t\tpos.style.position = 'absolute';\n\t\t\t\t\tpos.style.left = this.format(x + (left_fix - w / 2) * s.scale) + 'px';\n\t\t\t\t\tpos.style.top = this.format(y + (top_fix - h / 2) * s.scale) + 'px';\n\n\t\t\t\t\tabs.parentNode.appendChild(pos);\n\t\t\t\t\tpos.appendChild(abs);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar sc = (document.documentMode == 8 && !mxClient.IS_EM) ? 1 : s.scale;\n\n\t\t\t\t\tabs.style.left = this.format(x + (left_fix - w / 2) * sc) + 'px';\n\t\t\t\t\tabs.style.top = this.format(y + (top_fix - h / 2) * sc) + 'px';\n\t\t\t\t}\n\n\t\t\t\t// KNOWN: Rotated text rendering quality is bad for IE9 quirks\n\t\t\t\tinner.style.filter = \"progid:DXImageTransform.Microsoft.Matrix(M11=\"+real_cos+\", M12=\"+\n\t\t\t\t\treal_sin+\", M21=\"+(-real_sin)+\", M22=\"+real_cos+\", sizingMethod='auto expand')\";\n\t\t\t\tinner.style.backgroundColor = this.rotatedHtmlBackground;\n\n\t\t\t\tif (this.state.alpha < 1)\n\t\t\t\t{\n\t\t\t\t\tinner.style.filter += 'alpha(opacity=' + (this.state.alpha * 100) + ')';\n\t\t\t\t}\n\n\t\t\t\t// Restore parent node for DIV\n\t\t\t\tinner.appendChild(div);\n\t\t\t\tdiv.style.position = '';\n\t\t\t\tdiv.style.visibility = '';\n\t\t\t}\n\t\t\telse if (document.documentMode != 8 || mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tdiv.style.verticalAlign = 'top';\n\n\t\t\t\tif (this.state.alpha < 1)\n\t\t\t\t{\n\t\t\t\t\tabs.style.filter = 'alpha(opacity=' + (this.state.alpha * 100) + ')';\n\t\t\t\t}\n\n\t\t\t\t// Adds div to document to measure size\n\t\t\t\tvar divParent = div.parentNode;\n\t\t\t\tdiv.style.visibility = 'hidden';\n\t\t\t\tdocument.body.appendChild(div);\n\n\t\t\t\tw = div.offsetWidth;\n\t\t\t\tvar oh = div.offsetHeight;\n\n\t\t\t\t// Simulates max-height in quirks\n\t\t\t\tif (mxClient.IS_QUIRKS && clip && oh > h)\n\t\t\t\t{\n\t\t\t\t\toh = h;\n\n\t\t\t\t\t// Quirks does not support maxHeight\n\t\t\t\t\tdiv.style.height = oh + 'px';\n\t\t\t\t}\n\n\t\t\t\th = oh;\n\n\t\t\t\tdiv.style.visibility = '';\n\t\t\t\tdivParent.appendChild(div);\n\n\t\t\t\tabs.style.left = this.format(x + w * dx * this.state.scale) + 'px';\n\t\t\t\tabs.style.top = this.format(y + h * dy * this.state.scale) + 'px';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this.state.alpha < 1)\n\t\t\t\t{\n\t\t\t\t\tdiv.style.filter = 'alpha(opacity=' + (this.state.alpha * 100) + ')';\n\t\t\t\t}\n\n\t\t\t\t// Faster rendering in IE8 without offsetWidth/Height\n\t\t\t\tbox.style.left = (dx * 100) + '%';\n\t\t\t\tbox.style.top = (dy * 100) + '%';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.plainText(x, y, w, h, mxUtils.htmlEntities(str, false), align, valign, wrap, format, overflow, clip, rotation, dir);\n\t\t}\n\t}\n};\n\n/**\n * Function: plainText\n *\n * Paints the outline of the current path.\n */\nmxVmlCanvas2D.prototype.plainText = function(x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir)\n{\n\t// TextDirection is ignored since this code is not used (format is always HTML in the text function)\n\tvar s = this.state;\n\tx = (x + s.dx) * s.scale;\n\ty = (y + s.dy) * s.scale;\n\n\tvar node = this.createVmlElement('shape');\n\tnode.style.width = '1px';\n\tnode.style.height = '1px';\n\tnode.stroked = 'false';\n\n\tvar fill = this.createVmlElement('fill');\n\tfill.color = s.fontColor;\n\tfill.opacity = (s.alpha * 100) + '%';\n\tnode.appendChild(fill);\n\n\tvar path = this.createVmlElement('path');\n\tpath.textpathok = 'true';\n\tpath.v = 'm ' + this.format(0) + ' ' + this.format(0) + ' l ' + this.format(1) + ' ' + this.format(0);\n\n\tnode.appendChild(path);\n\n\t// KNOWN: Font family and text decoration ignored\n\tvar tp = this.createVmlElement('textpath');\n\ttp.style.cssText = 'v-text-align:' + align;\n\ttp.style.align = align;\n\ttp.style.fontFamily = s.fontFamily;\n\ttp.string = str;\n\ttp.on = 'true';\n\n\t// Scale via fontsize instead of node.style.zoom for correct offsets in IE8\n\tvar size = s.fontSize * s.scale / this.vmlScale;\n\ttp.style.fontSize = size + 'px';\n\n\t// Bold\n\tif ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\ttp.style.fontWeight = 'bold';\n\t}\n\n\t// Italic\n\tif ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\ttp.style.fontStyle = 'italic';\n\t}\n\n\t// Underline\n\tif ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\ttp.style.textDecoration = 'underline';\n\t}\n\n\tvar lines = str.split('\\n');\n\tvar textHeight = size + (lines.length - 1) * size * mxConstants.LINE_HEIGHT;\n\tvar dx = 0;\n\tvar dy = 0;\n\n\tif (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tdy = - textHeight / 2;\n\t}\n\telse if (valign != mxConstants.ALIGN_MIDDLE) // top\n\t{\n\t\tdy = textHeight / 2;\n\t}\n\n\tif (rotation != null)\n\t{\n\t\tnode.style.rotation = rotation;\n\t\tvar rad = rotation * (Math.PI / 180);\n\t\tdx = Math.sin(rad) * dy;\n\t\tdy = Math.cos(rad) * dy;\n\t}\n\n\t// FIXME: Clipping is relative to bounding box\n\t/*if (clip)\n\t{\n\t\tnode.style.clip = 'rect(0px ' + this.format(w) + 'px ' + this.format(h) + 'px 0px)';\n\t}*/\n\n\tnode.appendChild(tp);\n\tnode.style.left = this.format(x - dx) + 'px';\n\tnode.style.top = this.format(y + dy) + 'px';\n\n\tthis.root.appendChild(node);\n};\n\n/**\n * Function: stroke\n *\n * Paints the outline of the current path.\n */\nmxVmlCanvas2D.prototype.stroke = function()\n{\n\tthis.addNode(false, true);\n};\n\n/**\n * Function: fill\n *\n * Fills the current path.\n */\nmxVmlCanvas2D.prototype.fill = function()\n{\n\tthis.addNode(true, false);\n};\n\n/**\n * Function: fillAndStroke\n *\n * Fills and paints the outline of the current path.\n */\nmxVmlCanvas2D.prototype.fillAndStroke = function()\n{\n\tthis.addNode(true, true);\n};\n\n__mxOutput.mxVmlCanvas2D = typeof mxVmlCanvas2D !== 'undefined' ? mxVmlCanvas2D : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGuide\n *\n * Implements the alignment of selection cells to other cells in the graph.\n *\n * Constructor: mxGuide\n *\n * Constructs a new guide object.\n */\nfunction mxGuide(graph, states)\n{\n\tthis.graph = graph;\n\tthis.setStates(states);\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph> instance.\n */\nmxGuide.prototype.graph = null;\n\n/**\n * Variable: states\n *\n * Contains the <mxCellStates> that are used for alignment.\n */\nmxGuide.prototype.states = null;\n\n/**\n * Variable: horizontal\n *\n * Specifies if horizontal guides are enabled. Default is true.\n */\nmxGuide.prototype.horizontal = true;\n\n/**\n * Variable: vertical\n *\n * Specifies if vertical guides are enabled. Default is true.\n */\nmxGuide.prototype.vertical = true;\n\n/**\n * Variable: vertical\n *\n * Holds the <mxShape> for the horizontal guide.\n */\nmxGuide.prototype.guideX = null;\n\n/**\n * Variable: vertical\n *\n * Holds the <mxShape> for the vertical guide.\n */\nmxGuide.prototype.guideY = null;\n\n/**\n * Variable: rounded\n *\n * Specifies if rounded coordinates should be used. Default is false.\n */\nmxGuide.prototype.rounded = false;\n\n/**\n * Function: setStates\n *\n * Sets the <mxCellStates> that should be used for alignment.\n */\nmxGuide.prototype.setStates = function(states)\n{\n\tthis.states = states;\n};\n\n/**\n * Function: isEnabledForEvent\n *\n * Returns true if the guide should be enabled for the given native event. This\n * implementation always returns true.\n */\nmxGuide.prototype.isEnabledForEvent = function(evt)\n{\n\treturn true;\n};\n\n/**\n * Function: getGuideTolerance\n *\n * Returns the tolerance for the guides. Default value is gridSize / 2.\n */\nmxGuide.prototype.getGuideTolerance = function()\n{\n\treturn this.graph.gridSize / 2;\n};\n\n/**\n * Function: createGuideShape\n *\n * Returns the mxShape to be used for painting the respective guide. This\n * implementation returns a new, dashed and crisp <mxPolyline> using\n * <mxConstants.GUIDE_COLOR> and <mxConstants.GUIDE_STROKEWIDTH> as the format.\n *\n * Parameters:\n *\n * horizontal - Boolean that specifies which guide should be created.\n */\nmxGuide.prototype.createGuideShape = function(horizontal)\n{\n\tvar guide = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);\n\tguide.isDashed = true;\n\n\treturn guide;\n};\n\n/**\n * Function: move\n *\n * Moves the <bounds> by the given <mxPoint> and returnt the snapped point.\n */\nmxGuide.prototype.move = function(bounds, delta, gridEnabled, clone)\n{\n\tif (this.states != null && (this.horizontal || this.vertical) && bounds != null && delta != null)\n\t{\n\t\tvar trx = this.graph.getView().translate;\n\t\tvar scale = this.graph.getView().scale;\n\t\tvar dx = delta.x;\n\t\tvar dy = delta.y;\n\n\t\tvar overrideX = false;\n\t\tvar stateX = null;\n\t\tvar valueX = null;\n\t\tvar overrideY = false;\n\t\tvar stateY = null;\n\t\tvar valueY = null;\n\n\t\tvar tt = this.getGuideTolerance();\n\t\tvar ttX = tt;\n\t\tvar ttY = tt;\n\n\t\tvar b = bounds.clone();\n\t\tb.x += delta.x;\n\t\tb.y += delta.y;\n\n\t\tvar left = b.x;\n\t\tvar right = b.x + b.width;\n\t\tvar center = b.getCenterX();\n\t\tvar top = b.y;\n\t\tvar bottom = b.y + b.height;\n\t\tvar middle = b.getCenterY();\n\n\t\t// Snaps the left, center and right to the given x-coordinate\n\t\tfunction snapX(x, state)\n\t\t{\n\t\t\tx += this.graph.panDx;\n\t\t\tvar override = false;\n\n\t\t\tif (Math.abs(x - center) < ttX)\n\t\t\t{\n\t\t\t\tdx = x - bounds.getCenterX();\n\t\t\t\tttX = Math.abs(x - center);\n\t\t\t\toverride = true;\n\t\t\t}\n\t\t\telse if (Math.abs(x - left) < ttX)\n\t\t\t{\n\t\t\t\tdx = x - bounds.x;\n\t\t\t\tttX = Math.abs(x - left);\n\t\t\t\toverride = true;\n\t\t\t}\n\t\t\telse if (Math.abs(x - right) < ttX)\n\t\t\t{\n\t\t\t\tdx = x - bounds.x - bounds.width;\n\t\t\t\tttX = Math.abs(x - right);\n\t\t\t\toverride = true;\n\t\t\t}\n\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\tstateX = state;\n\t\t\t\tvalueX = Math.round(x - this.graph.panDx);\n\n\t\t\t\tif (this.guideX == null)\n\t\t\t\t{\n\t\t\t\t\tthis.guideX = this.createGuideShape(true);\n\n\t\t\t\t\t// Makes sure to use either VML or SVG shapes in order to implement\n\t\t\t\t\t// event-transparency on the background area of the rectangle since\n\t\t\t\t\t// HTML shapes do not let mouseevents through even when transparent\n\t\t\t\t\tthis.guideX.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\t\tthis.guideX.pointerEvents = false;\n\t\t\t\t\tthis.guideX.init(this.graph.getView().getOverlayPane());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toverrideX = overrideX || override;\n\t\t};\n\n\t\t// Snaps the top, middle or bottom to the given y-coordinate\n\t\tfunction snapY(y, state)\n\t\t{\n\t\t\ty += this.graph.panDy;\n\t\t\tvar override = false;\n\n\t\t\tif (Math.abs(y - middle) < ttY)\n\t\t\t{\n\t\t\t\tdy = y - bounds.getCenterY();\n\t\t\t\tttY = Math.abs(y -  middle);\n\t\t\t\toverride = true;\n\t\t\t}\n\t\t\telse if (Math.abs(y - top) < ttY)\n\t\t\t{\n\t\t\t\tdy = y - bounds.y;\n\t\t\t\tttY = Math.abs(y - top);\n\t\t\t\toverride = true;\n\t\t\t}\n\t\t\telse if (Math.abs(y - bottom) < ttY)\n\t\t\t{\n\t\t\t\tdy = y - bounds.y - bounds.height;\n\t\t\t\tttY = Math.abs(y - bottom);\n\t\t\t\toverride = true;\n\t\t\t}\n\n\t\t\tif (override)\n\t\t\t{\n\t\t\t\tstateY = state;\n\t\t\t\tvalueY = Math.round(y - this.graph.panDy);\n\n\t\t\t\tif (this.guideY == null)\n\t\t\t\t{\n\t\t\t\t\tthis.guideY = this.createGuideShape(false);\n\n\t\t\t\t\t// Makes sure to use either VML or SVG shapes in order to implement\n\t\t\t\t\t// event-transparency on the background area of the rectangle since\n\t\t\t\t\t// HTML shapes do not let mouseevents through even when transparent\n\t\t\t\t\tthis.guideY.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\t\tthis.guideY.pointerEvents = false;\n\t\t\t\t\tthis.guideY.init(this.graph.getView().getOverlayPane());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toverrideY = overrideY || override;\n\t\t};\n\n\t\tfor (var i = 0; i < this.states.length; i++)\n\t\t{\n\t\t\tvar state =  this.states[i];\n\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\t// Align x\n\t\t\t\tif (this.horizontal)\n\t\t\t\t{\n\t\t\t\t\tsnapX.call(this, state.getCenterX(), state);\n\t\t\t\t\tsnapX.call(this, state.x, state);\n\t\t\t\t\tsnapX.call(this, state.x + state.width, state);\n\t\t\t\t}\n\n\t\t\t\t// Align y\n\t\t\t\tif (this.vertical)\n\t\t\t\t{\n\t\t\t\t\tsnapY.call(this, state.getCenterY(), state);\n\t\t\t\t\tsnapY.call(this, state.y, state);\n\t\t\t\t\tsnapY.call(this, state.y + state.height, state);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Moves cells that are off-grid back to the grid on move\n\t\tif (gridEnabled)\n\t\t{\n\t\t\tif (!overrideX)\n\t\t\t{\n\t\t\t\tvar tx = bounds.x - (this.graph.snap(bounds.x /\n\t\t\t\t\tscale - trx.x) + trx.x) * scale;\n\t\t\t\tdx = this.graph.snap(dx / scale) * scale - tx;\n\t\t\t}\n\n\t\t\tif (!overrideY)\n\t\t\t{\n\t\t\t\tvar ty = bounds.y - (this.graph.snap(bounds.y /\n\t\t\t\t\tscale - trx.y) + trx.y) * scale;\n\t\t\t\tdy = this.graph.snap(dy / scale) * scale - ty;\n\t\t\t}\n\t\t}\n\n\t\t// Redraws the guides\n\t\tvar c = this.graph.container;\n\n\t\tif (!overrideX && this.guideX != null)\n\t\t{\n\t\t\tthis.guideX.node.style.visibility = 'hidden';\n\t\t}\n\t\telse if (this.guideX != null)\n\t\t{\n\t\t\tif (stateX != null && bounds != null)\n\t\t\t{\n\t\t\t\tminY = Math.min(bounds.y + dy - this.graph.panDy, stateX.y);\n\t\t\t\tmaxY = Math.max(bounds.y + bounds.height + dy - this.graph.panDy, stateX.y + stateX.height);\n\t\t\t}\n\n\t\t\tif (minY != null && maxY != null)\n\t\t\t{\n\t\t\t\tthis.guideX.points = [new mxPoint(valueX, minY), new mxPoint(valueX, maxY)];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.guideX.points = [new mxPoint(valueX, -this.graph.panDy), new mxPoint(valueX, c.scrollHeight - 3 - this.graph.panDy)];\n\t\t\t}\n\n\t\t\tthis.guideX.stroke = this.getGuideColor(stateX, true);\n\t\t\tthis.guideX.node.style.visibility = 'visible';\n\t\t\tthis.guideX.redraw();\n\t\t}\n\n\t\tif (!overrideY && this.guideY != null)\n\t\t{\n\t\t\tthis.guideY.node.style.visibility = 'hidden';\n\t\t}\n\t\telse if (this.guideY != null)\n\t\t{\n\t\t\tif (stateY != null && bounds != null)\n\t\t\t{\n\t\t\t\tminX = Math.min(bounds.x + dx - this.graph.panDx, stateY.x);\n\t\t\t\tmaxX = Math.max(bounds.x + bounds.width + dx - this.graph.panDx, stateY.x + stateY.width);\n\t\t\t}\n\n\t\t\tif (minX != null && maxX != null)\n\t\t\t{\n\t\t\t\tthis.guideY.points = [new mxPoint(minX, valueY), new mxPoint(maxX, valueY)];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.guideY.points = [new mxPoint(-this.graph.panDx, valueY), new mxPoint(c.scrollWidth - 3 - this.graph.panDx, valueY)];\n\t\t\t}\n\n\t\t\tthis.guideY.stroke = this.getGuideColor(stateY, false);\n\t\t\tthis.guideY.node.style.visibility = 'visible';\n\t\t\tthis.guideY.redraw();\n\t\t}\n\n\t\tdelta = this.getDelta(bounds, stateX, dx, stateY, dy)\n\t}\n\n\treturn delta;\n};\n\n/**\n * Function: hide\n *\n * Hides all current guides.\n */\nmxGuide.prototype.getDelta = function(bounds, stateX, dx, stateY, dy)\n{\n\t// Round to pixels for virtual states (eg. page guides)\n\tif (this.rounded || (stateX != null && stateX.cell == null))\n\t{\n\t\tdx = Math.floor(bounds.x + dx) - bounds.x;\n\t}\n\n\tif (this.rounded || (stateY != null && stateY.cell == null))\n\t{\n\t\tdy = Math.floor(bounds.y + dy) - bounds.y;\n\t}\n\n\treturn new mxPoint(dx, dy);\n};\n\n/**\n * Function: hide\n *\n * Hides all current guides.\n */\nmxGuide.prototype.getGuideColor = function(state, horizontal)\n{\n\treturn mxConstants.GUIDE_COLOR;\n};\n\n/**\n * Function: hide\n *\n * Hides all current guides.\n */\nmxGuide.prototype.hide = function()\n{\n\tthis.setVisible(false);\n};\n\n/**\n * Function: setVisible\n *\n * Shows or hides the current guides.\n */\nmxGuide.prototype.setVisible = function(visible)\n{\n\tif (this.guideX != null)\n\t{\n\t\tthis.guideX.node.style.visibility = (visible) ? 'visible' : 'hidden';\n\t}\n\n\tif (this.guideY != null)\n\t{\n\t\tthis.guideY.node.style.visibility = (visible) ? 'visible' : 'hidden';\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys all resources that this object uses.\n */\nmxGuide.prototype.destroy = function()\n{\n\tif (this.guideX != null)\n\t{\n\t\tthis.guideX.destroy();\n\t\tthis.guideX = null;\n\t}\n\n\tif (this.guideY != null)\n\t{\n\t\tthis.guideY.destroy();\n\t\tthis.guideY = null;\n\t}\n};\n\n__mxOutput.mxGuide = typeof mxGuide !== 'undefined' ? mxGuide : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxShape\n *\n * Base class for all shapes. A shape in mxGraph is a\n * separate implementation for SVG, VML and HTML. Which\n * implementation to use is controlled by the <dialect>\n * property which is assigned from within the <mxCellRenderer>\n * when the shape is created. The dialect must be assigned\n * for a shape, and it does normally depend on the browser and\n * the confiuration of the graph (see <mxGraph> rendering hint).\n *\n * For each supported shape in SVG and VML, a corresponding\n * shape exists in mxGraph, namely for text, image, rectangle,\n * rhombus, ellipse and polyline. The other shapes are a\n * combination of these shapes (eg. label and swimlane)\n * or they consist of one or more (filled) path objects\n * (eg. actor and cylinder). The HTML implementation is\n * optional but may be required for a HTML-only view of\n * the graph.\n *\n * Custom Shapes:\n *\n * To extend from this class, the basic code looks as follows.\n * In the special case where the custom shape consists only of\n * one filled region or one filled region and an additional stroke\n * the <mxActor> and <mxCylinder> should be subclassed,\n * respectively.\n *\n * (code)\n * function CustomShape() { }\n *\n * CustomShape.prototype = new mxShape();\n * CustomShape.prototype.constructor = CustomShape;\n * (end)\n *\n * To register a custom shape in an existing graph instance,\n * one must register the shape under a new name in the graph's\n * cell renderer as follows:\n *\n * (code)\n * mxCellRenderer.registerShape('customShape', CustomShape);\n * (end)\n *\n * The second argument is the name of the constructor.\n *\n * In order to use the shape you can refer to the given name above\n * in a stylesheet. For example, to change the shape for the default\n * vertex style, the following code is used:\n *\n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = 'customShape';\n * (end)\n *\n * Constructor: mxShape\n *\n * Constructs a new shape.\n */\nfunction mxShape(stencil)\n{\n\tthis.stencil = stencil;\n\tthis.initStyles();\n};\n\n/**\n * Variable: dialect\n *\n * Holds the dialect in which the shape is to be painted.\n * This can be one of the DIALECT constants in <mxConstants>.\n */\nmxShape.prototype.dialect = null;\n\n/**\n * Variable: scale\n *\n * Holds the scale in which the shape is being painted.\n */\nmxShape.prototype.scale = 1;\n\n/**\n * Variable: antiAlias\n *\n * Rendering hint for configuring the canvas.\n */\nmxShape.prototype.antiAlias = true;\n\n/**\n * Variable: minSvgStrokeWidth\n *\n * Minimum stroke width for SVG output.\n */\nmxShape.prototype.minSvgStrokeWidth = 1;\n\n/**\n * Variable: bounds\n *\n * Holds the <mxRectangle> that specifies the bounds of this shape.\n */\nmxShape.prototype.bounds = null;\n\n/**\n * Variable: points\n *\n * Holds the array of <mxPoints> that specify the points of this shape.\n */\nmxShape.prototype.points = null;\n\n/**\n * Variable: node\n *\n * Holds the outermost DOM node that represents this shape.\n */\nmxShape.prototype.node = null;\n\n/**\n * Variable: state\n *\n * Optional reference to the corresponding <mxCellState>.\n */\nmxShape.prototype.state = null;\n\n/**\n * Variable: style\n *\n * Optional reference to the style of the corresponding <mxCellState>.\n */\nmxShape.prototype.style = null;\n\n/**\n * Variable: boundingBox\n *\n * Contains the bounding box of the shape, that is, the smallest rectangle\n * that includes all pixels of the shape.\n */\nmxShape.prototype.boundingBox = null;\n\n/**\n * Variable: stencil\n *\n * Holds the <mxStencil> that defines the shape.\n */\nmxShape.prototype.stencil = null;\n\n/**\n * Variable: svgStrokeTolerance\n *\n * Event-tolerance for SVG strokes (in px). Default is 8. This is only passed\n * to the canvas in <createSvgCanvas> if <pointerEvents> is true.\n */\nmxShape.prototype.svgStrokeTolerance = 8;\n\n/**\n * Variable: pointerEvents\n *\n * Specifies if pointer events should be handled. Default is true.\n */\nmxShape.prototype.pointerEvents = true;\n\n/**\n * Variable: svgPointerEvents\n *\n * Specifies if pointer events should be handled. Default is true.\n */\nmxShape.prototype.svgPointerEvents = 'all';\n\n/**\n * Variable: shapePointerEvents\n *\n * Specifies if pointer events outside of shape should be handled. Default\n * is false.\n */\nmxShape.prototype.shapePointerEvents = false;\n\n/**\n * Variable: stencilPointerEvents\n *\n * Specifies if pointer events outside of stencils should be handled. Default\n * is false. Set this to true for backwards compatibility with the 1.x branch.\n */\nmxShape.prototype.stencilPointerEvents = false;\n\n/**\n * Variable: vmlScale\n *\n * Scale for improving the precision of VML rendering. Default is 1.\n */\nmxShape.prototype.vmlScale = 1;\n\n/**\n * Variable: outline\n *\n * Specifies if the shape should be drawn as an outline. This disables all\n * fill colors and can be used to disable other drawing states that should\n * not be painted for outlines. Default is false. This should be set before\n * calling <apply>.\n */\nmxShape.prototype.outline = false;\n\n/**\n * Variable: visible\n *\n * Specifies if the shape is visible. Default is true.\n */\nmxShape.prototype.visible = true;\n\n/**\n * Variable: useSvgBoundingBox\n *\n * Allows to use the SVG bounding box in SVG. Default is false for performance\n * reasons.\n */\nmxShape.prototype.useSvgBoundingBox = false;\n\n/**\n * Function: init\n *\n * Initializes the shape by creaing the DOM node using <create>\n * and adding it into the given container.\n *\n * Parameters:\n *\n * container - DOM node that will contain the shape.\n */\nmxShape.prototype.init = function(container)\n{\n\tif (this.node == null)\n\t{\n\t\tthis.node = this.create(container);\n\n\t\tif (container != null)\n\t\t{\n\t\t\tcontainer.appendChild(this.node);\n\t\t}\n\t}\n};\n\n/**\n * Function: initStyles\n *\n * Sets the styles to their default values.\n */\nmxShape.prototype.initStyles = function(container)\n{\n\tthis.strokewidth = 1;\n\tthis.rotation = 0;\n\tthis.opacity = 100;\n\tthis.fillOpacity = 100;\n\tthis.strokeOpacity = 100;\n\tthis.flipH = false;\n\tthis.flipV = false;\n};\n\n/**\n * Function: isParseVml\n *\n * Specifies if any VML should be added via insertAdjacentHtml to the DOM. This\n * is only needed in IE8 and only if the shape contains VML markup. This method\n * returns true.\n */\nmxShape.prototype.isParseVml = function()\n{\n\treturn true;\n};\n\n/**\n * Function: isHtmlAllowed\n *\n * Returns true if HTML is allowed for this shape. This implementation always\n * returns false.\n */\nmxShape.prototype.isHtmlAllowed = function()\n{\n\treturn false;\n};\n\n/**\n * Function: getSvgScreenOffset\n *\n * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\n */\nmxShape.prototype.getSvgScreenOffset = function()\n{\n\tvar sw = this.stencil && this.stencil.strokewidth != 'inherit' ? Number(this.stencil.strokewidth) : this.strokewidth;\n\n\treturn (mxUtils.mod(Math.max(1, Math.round(sw * this.scale)), 2) == 1) ? 0.5 : 0;\n};\n\n/**\n * Function: create\n *\n * Creates and returns the DOM node(s) for the shape in\n * the given container. This implementation invokes\n * <createSvg>, <createHtml> or <createVml> depending\n * on the <dialect> and style settings.\n *\n * Parameters:\n *\n * container - DOM node that will contain the shape.\n */\nmxShape.prototype.create = function(container)\n{\n\tvar node = null;\n\n\tif (container != null && container.ownerSVGElement != null)\n\t{\n\t\tnode = this.createSvg(container);\n\t}\n\telse if (document.documentMode == 8 || !mxClient.IS_VML ||\n\t\t(this.dialect != mxConstants.DIALECT_VML && this.isHtmlAllowed()))\n\t{\n\t\tnode = this.createHtml(container);\n\t}\n\telse\n\t{\n\t\tnode = this.createVml(container);\n\t}\n\n\treturn node;\n};\n\n/**\n * Function: createSvg\n *\n * Creates and returns the SVG node(s) to represent this shape.\n */\nmxShape.prototype.createSvg = function()\n{\n\treturn document.createElementNS(mxConstants.NS_SVG, 'g');\n};\n\n/**\n * Function: createVml\n *\n * Creates and returns the VML node to represent this shape.\n */\nmxShape.prototype.createVml = function()\n{\n\tvar node = document.createElement(mxClient.VML_PREFIX + ':group');\n\tnode.style.position = 'absolute';\n\n\treturn node;\n};\n\n/**\n * Function: createHtml\n *\n * Creates and returns the HTML DOM node(s) to represent\n * this shape. This implementation falls back to <createVml>\n * so that the HTML creation is optional.\n */\nmxShape.prototype.createHtml = function()\n{\n\tvar node = document.createElement('div');\n\tnode.style.position = 'absolute';\n\n\treturn node;\n};\n\n/**\n * Function: reconfigure\n *\n * Reconfigures this shape. This will update the colors etc in\n * addition to the bounds or points.\n */\nmxShape.prototype.reconfigure = function()\n{\n\tthis.redraw();\n};\n\n/**\n * Function: redraw\n *\n * Creates and returns the SVG node(s) to represent this shape.\n */\nmxShape.prototype.redraw = function()\n{\n\tthis.updateBoundsFromPoints();\n\n\tif (this.visible && this.checkBounds())\n\t{\n\t\tthis.node.style.visibility = 'visible';\n\t\tthis.clear();\n\n\t\tif (this.node.nodeName == 'DIV' && (this.isHtmlAllowed() || !mxClient.IS_VML))\n\t\t{\n\t\t\tthis.redrawHtmlShape();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.redrawShape();\n\t\t}\n\n\t\tthis.updateBoundingBox();\n\t}\n\telse\n\t{\n\t\tthis.node.style.visibility = 'hidden';\n\t\tthis.boundingBox = null;\n\t}\n};\n\n/**\n * Function: clear\n *\n * Removes all child nodes and resets all CSS.\n */\nmxShape.prototype.clear = function()\n{\n\tif (this.node.ownerSVGElement != null)\n\t{\n\t\twhile (this.node.lastChild != null)\n\t\t{\n\t\t\tthis.node.removeChild(this.node.lastChild);\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.node.style.cssText = 'position:absolute;' + ((this.cursor != null) ?\n\t\t\t('cursor:' + this.cursor + ';') : '');\n\t\tthis.node.innerHTML = '';\n\t}\n};\n\n/**\n * Function: updateBoundsFromPoints\n *\n * Updates the bounds based on the points.\n */\nmxShape.prototype.updateBoundsFromPoints = function()\n{\n\tvar pts = this.points;\n\n\tif (pts != null && pts.length > 0 && pts[0] != null)\n\t{\n\t\tthis.bounds = new mxRectangle(Number(pts[0].x), Number(pts[0].y), 1, 1);\n\n\t\tfor (var i = 1; i < this.points.length; i++)\n\t\t{\n\t\t\tif (pts[i] != null)\n\t\t\t{\n\t\t\t\tthis.bounds.add(new mxRectangle(Number(pts[i].x), Number(pts[i].y), 1, 1));\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getLabelBounds\n *\n * Returns the <mxRectangle> for the label bounds of this shape, based on the\n * given scaled and translated bounds of the shape. This method should not\n * change the rectangle in-place. This implementation returns the given rect.\n */\nmxShape.prototype.getLabelBounds = function(rect)\n{\n\tvar d = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\tvar bounds = rect;\n\n\t// Normalizes argument for getLabelMargins hook\n\tif (d != mxConstants.DIRECTION_SOUTH && d != mxConstants.DIRECTION_NORTH &&\n\t\tthis.state != null && this.state.text != null &&\n\t\tthis.state.text.isPaintBoundsInverted())\n\t{\n\t\tbounds = bounds.clone();\n\t\tvar tmp = bounds.width;\n\t\tbounds.width = bounds.height;\n\t\tbounds.height = tmp;\n\t}\n\n\tvar m = this.getLabelMargins(bounds);\n\n\tif (m != null)\n\t{\n\t\tvar flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, false) == '1';\n\t\tvar flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, false) == '1';\n\n\t\t// Handles special case for vertical labels\n\t\tif (this.state != null && this.state.text != null &&\n\t\t\tthis.state.text.isPaintBoundsInverted())\n\t\t{\n\t\t\tvar tmp = m.x;\n\t\t\tm.x = m.height;\n\t\t\tm.height = m.width;\n\t\t\tm.width = m.y;\n\t\t\tm.y = tmp;\n\n\t\t\ttmp = flipH;\n\t\t\tflipH = flipV;\n\t\t\tflipV = tmp;\n\t\t}\n\n\t\treturn mxUtils.getDirectedBounds(rect, m, this.style, flipH, flipV);\n\t}\n\n\treturn rect;\n};\n\n/**\n * Function: getLabelMargins\n *\n * Returns the scaled top, left, bottom and right margin to be used for\n * computing the label bounds as an <mxRectangle>, where the bottom and right\n * margin are defined in the width and height of the rectangle, respectively.\n */\nmxShape.prototype.getLabelMargins= function(rect)\n{\n\treturn null;\n};\n\n/**\n * Function: checkBounds\n *\n * Returns true if the bounds are not null and all of its variables are numeric.\n */\nmxShape.prototype.checkBounds = function()\n{\n\treturn (!isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 &&\n\t\t\tthis.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) &&\n\t\t\t!isNaN(this.bounds.width) && !isNaN(this.bounds.height) &&\n\t\t\tthis.bounds.width > 0 && this.bounds.height > 0);\n};\n\n/**\n * Function: createVmlGroup\n *\n * Returns the temporary element used for rendering in IE8 standards mode.\n */\nmxShape.prototype.createVmlGroup = function()\n{\n\tvar node = document.createElement(mxClient.VML_PREFIX + ':group');\n\tnode.style.position = 'absolute';\n\tnode.style.width = this.node.style.width;\n\tnode.style.height = this.node.style.height;\n\n\treturn node;\n};\n\n/**\n * Function: redrawShape\n *\n * Updates the SVG or VML shape.\n */\nmxShape.prototype.redrawShape = function()\n{\n\tvar canvas = this.createCanvas();\n\n\tif (canvas != null)\n\t{\n\t\t// Specifies if events should be handled\n\t\tcanvas.pointerEvents = this.pointerEvents;\n\n\t\tthis.paint(canvas);\n\n\t\tif (this.node != canvas.root)\n\t\t{\n\t\t\t// Forces parsing in IE8 standards mode - slow! avoid\n\t\t\tthis.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);\n\t\t}\n\n\t\tif (this.node.nodeName == 'DIV' && document.documentMode == 8)\n\t\t{\n\t\t\t// Makes DIV transparent to events for IE8 in IE8 standards\n\t\t\t// mode (Note: Does not work for IE9 in IE8 standards mode\n\t\t\t// and not for IE11 in enterprise mode)\n\t\t\tthis.node.style.filter = '';\n\n\t\t\t// Adds event transparency in IE8 standards\n\t\t\tmxUtils.addTransparentBackgroundFilter(this.node);\n\t\t}\n\n\t\tthis.destroyCanvas(canvas);\n\t}\n};\n\n/**\n * Function: createCanvas\n *\n * Creates a new canvas for drawing this shape. May return null.\n */\nmxShape.prototype.createCanvas = function()\n{\n\tvar canvas = null;\n\n\t// LATER: Check if reusing existing DOM nodes improves performance\n\tif (this.node.ownerSVGElement != null)\n\t{\n\t\tcanvas = this.createSvgCanvas();\n\t}\n\telse if (mxClient.IS_VML)\n\t{\n\t\tthis.updateVmlContainer();\n\t\tcanvas = this.createVmlCanvas();\n\t}\n\n\tif (canvas != null && this.outline)\n\t{\n\t\tcanvas.setStrokeWidth(this.strokewidth);\n\t\tcanvas.setStrokeColor(this.stroke);\n\n\t\tif (this.isDashed != null)\n\t\t{\n\t\t\tcanvas.setDashed(this.isDashed);\n\t\t}\n\n\t\tcanvas.setStrokeWidth = function() {};\n\t\tcanvas.setStrokeColor = function() {};\n\t\tcanvas.setFillColor = function() {};\n\t\tcanvas.setGradient = function() {};\n\t\tcanvas.setDashed = function() {};\n\t\tcanvas.text = function() {};\n\t}\n\n\treturn canvas;\n};\n\n/**\n * Function: createSvgCanvas\n *\n * Creates and returns an <mxSvgCanvas2D> for rendering this shape.\n */\nmxShape.prototype.createSvgCanvas = function()\n{\n\tvar canvas = new mxSvgCanvas2D(this.node, false);\n\tcanvas.strokeTolerance = (this.pointerEvents) ? this.svgStrokeTolerance : 0;\n\tcanvas.pointerEventsValue = this.svgPointerEvents;\n\tcanvas.blockImagePointerEvents = mxClient.IS_FF;\n\tvar off = this.getSvgScreenOffset();\n\n\tif (off != 0)\n\t{\n\t\tthis.node.setAttribute('transform', 'translate(' + off + ',' + off + ')');\n\t}\n\telse\n\t{\n\t\tthis.node.removeAttribute('transform');\n\t}\n\n\tcanvas.minStrokeWidth = this.minSvgStrokeWidth;\n\n\tif (!this.antiAlias)\n\t{\n\t\t// Rounds all numbers in the SVG output to integers\n\t\tcanvas.format = function(value)\n\t\t{\n\t\t\treturn Math.round(parseFloat(value));\n\t\t};\n\t}\n\n\treturn canvas;\n};\n\n/**\n * Function: createVmlCanvas\n *\n * Creates and returns an <mxVmlCanvas2D> for rendering this shape.\n */\nmxShape.prototype.createVmlCanvas = function()\n{\n\t// Workaround for VML rendering bug in IE8 standards mode\n\tvar node = (document.documentMode == 8 && this.isParseVml()) ? this.createVmlGroup() : this.node;\n\tvar canvas = new mxVmlCanvas2D(node, false);\n\n\tif (node.tagUrn != '')\n\t{\n\t\tvar w = Math.max(1, Math.round(this.bounds.width));\n\t\tvar h = Math.max(1, Math.round(this.bounds.height));\n\t\tnode.coordsize = (w * this.vmlScale) + ',' + (h * this.vmlScale);\n\t\tcanvas.scale(this.vmlScale);\n\t\tcanvas.vmlScale = this.vmlScale;\n\t}\n\n\t// Painting relative to top, left shape corner\n\tvar s = this.scale;\n\tcanvas.translate(-Math.round(this.bounds.x / s), -Math.round(this.bounds.y / s));\n\n\treturn canvas;\n};\n\n/**\n * Function: updateVmlContainer\n *\n * Updates the bounds of the VML container.\n */\nmxShape.prototype.updateVmlContainer = function()\n{\n\tthis.node.style.left = Math.round(this.bounds.x) + 'px';\n\tthis.node.style.top = Math.round(this.bounds.y) + 'px';\n\tvar w = Math.max(1, Math.round(this.bounds.width));\n\tvar h = Math.max(1, Math.round(this.bounds.height));\n\tthis.node.style.width = w + 'px';\n\tthis.node.style.height = h + 'px';\n\tthis.node.style.overflow = 'visible';\n};\n\n/**\n * Function: redrawHtml\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.redrawHtmlShape = function()\n{\n\t// LATER: Refactor methods\n\tthis.updateHtmlBounds(this.node);\n\tthis.updateHtmlFilters(this.node);\n\tthis.updateHtmlColors(this.node);\n};\n\n/**\n * Function: updateHtmlFilters\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.updateHtmlFilters = function(node)\n{\n\tvar f = '';\n\n\tif (this.opacity < 100)\n\t{\n\t\tf += 'alpha(opacity=' + (this.opacity) + ')';\n\t}\n\n\tif (this.isShadow)\n\t{\n\t\t// FIXME: Cannot implement shadow transparency with filter\n\t\tf += 'progid:DXImageTransform.Microsoft.dropShadow (' +\n\t\t\t'OffX=\\'' + Math.round(mxConstants.SHADOW_OFFSET_X * this.scale) + '\\', ' +\n\t\t\t'OffY=\\'' + Math.round(mxConstants.SHADOW_OFFSET_Y * this.scale) + '\\', ' +\n\t\t\t'Color=\\'' + mxConstants.VML_SHADOWCOLOR + '\\')';\n\t}\n\n\tif (this.fill != null && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE)\n\t{\n\t\tvar start = this.fill;\n\t\tvar end = this.gradient;\n\t\tvar type = '0';\n\n\t\tvar lookup = {east:0,south:1,west:2,north:3};\n\t\tvar dir = (this.direction != null) ? lookup[this.direction] : 0;\n\n\t\tif (this.gradientDirection != null)\n\t\t{\n\t\t\tdir = mxUtils.mod(dir + lookup[this.gradientDirection] - 1, 4);\n\t\t}\n\n\t\tif (dir == 1)\n\t\t{\n\t\t\ttype = '1';\n\t\t\tvar tmp = start;\n\t\t\tstart = end;\n\t\t\tend = tmp;\n\t\t}\n\t\telse if (dir == 2)\n\t\t{\n\t\t\tvar tmp = start;\n\t\t\tstart = end;\n\t\t\tend = tmp;\n\t\t}\n\t\telse if (dir == 3)\n\t\t{\n\t\t\ttype = '1';\n\t\t}\n\n\t\tf += 'progid:DXImageTransform.Microsoft.gradient(' +\n\t\t\t'startColorStr=\\'' + start + '\\', endColorStr=\\'' + end +\n\t\t\t'\\', gradientType=\\'' + type + '\\')';\n\t}\n\n\tnode.style.filter = f;\n};\n\n/**\n * Function: mixedModeHtml\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.updateHtmlColors = function(node)\n{\n\tvar color = this.stroke;\n\n\tif (color != null && color != mxConstants.NONE)\n\t{\n\t\tnode.style.borderColor = color;\n\n\t\tif (this.isDashed)\n\t\t{\n\t\t\tnode.style.borderStyle = 'dashed';\n\t\t}\n\t\telse if (this.strokewidth > 0)\n\t\t{\n\t\t\tnode.style.borderStyle = 'solid';\n\t\t}\n\n\t\tnode.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + 'px';\n\t}\n\telse\n\t{\n\t\tnode.style.borderWidth = '0px';\n\t}\n\n\tcolor = (this.outline) ? null : this.fill;\n\n\tif (color != null && color != mxConstants.NONE)\n\t{\n\t\tnode.style.backgroundColor = color;\n\t\tnode.style.backgroundImage = 'none';\n\t}\n\telse if (this.pointerEvents)\n\t{\n\t\t node.style.backgroundColor = 'transparent';\n\t}\n\telse if (document.documentMode == 8)\n\t{\n\t\tmxUtils.addTransparentBackgroundFilter(node);\n\t}\n\telse\n\t{\n\t\tthis.setTransparentBackgroundImage(node);\n\t}\n};\n\n/**\n * Function: mixedModeHtml\n *\n * Allow optimization by replacing VML with HTML.\n */\nmxShape.prototype.updateHtmlBounds = function(node)\n{\n\tvar sw = (document.documentMode >= 9) ? 0 : Math.ceil(this.strokewidth * this.scale);\n\tnode.style.borderWidth = Math.max(1, sw) + 'px';\n\tnode.style.overflow = 'hidden';\n\n\tnode.style.left = Math.round(this.bounds.x - sw / 2) + 'px';\n\tnode.style.top = Math.round(this.bounds.y - sw / 2) + 'px';\n\n\tif (document.compatMode == 'CSS1Compat')\n\t{\n\t\tsw = -sw;\n\t}\n\n\tnode.style.width = Math.round(Math.max(0, this.bounds.width + sw)) + 'px';\n\tnode.style.height = Math.round(Math.max(0, this.bounds.height + sw)) + 'px';\n};\n\n/**\n * Function: destroyCanvas\n *\n * Destroys the given canvas which was used for drawing. This implementation\n * increments the reference counts on all shared gradients used in the canvas.\n */\nmxShape.prototype.destroyCanvas = function(canvas)\n{\n\t// Manages reference counts\n\tif (canvas instanceof mxSvgCanvas2D)\n\t{\n\t\t// Increments ref counts\n\t\tfor (var key in canvas.gradients)\n\t\t{\n\t\t\tvar gradient = canvas.gradients[key];\n\n\t\t\tif (gradient != null)\n\t\t\t{\n\t\t\t\tgradient.mxRefCount = (gradient.mxRefCount || 0) + 1;\n\t\t\t}\n\t\t}\n\n\t\tthis.releaseSvgGradients(this.oldGradients);\n\t\tthis.oldGradients = canvas.gradients;\n\t}\n};\n\n/**\n * Function: paint\n *\n * Generic rendering code.\n */\nmxShape.prototype.paint = function(c)\n{\n\tvar strokeDrawn = false;\n\n\tif (c != null && this.outline)\n\t{\n\t\tvar stroke = c.stroke;\n\n\t\tc.stroke = function()\n\t\t{\n\t\t\tstrokeDrawn = true;\n\t\t\tstroke.apply(this, arguments);\n\t\t};\n\n\t\tvar fillAndStroke = c.fillAndStroke;\n\n\t\tc.fillAndStroke = function()\n\t\t{\n\t\t\tstrokeDrawn = true;\n\t\t\tfillAndStroke.apply(this, arguments);\n\t\t};\n\t}\n\n\t// Scale is passed-through to canvas\n\tvar s = this.scale;\n\tvar x = this.bounds.x / s;\n\tvar y = this.bounds.y / s;\n\tvar w = this.bounds.width / s;\n\tvar h = this.bounds.height / s;\n\n\tif (this.isPaintBoundsInverted())\n\t{\n\t\tvar t = (w - h) / 2;\n\t\tx += t;\n\t\ty -= t;\n\t\tvar tmp = w;\n\t\tw = h;\n\t\th = tmp;\n\t}\n\n\tthis.updateTransform(c, x, y, w, h);\n\tthis.configureCanvas(c, x, y, w, h);\n\n\t// Adds background rectangle to capture events\n\tvar bg = null;\n\n\tif ((this.stencil == null && this.points == null && this.shapePointerEvents) ||\n\t\t(this.stencil != null && this.stencilPointerEvents))\n\t{\n\t\tvar bb = this.createBoundingBox();\n\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\tbg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);\n\t\t\tthis.node.appendChild(bg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar rect = c.createRect('rect', bb.x / s, bb.y / s, bb.width / s, bb.height / s);\n\t\t\trect.appendChild(c.createTransparentFill());\n\t\t\trect.stroked = 'false';\n\t\t\tc.root.appendChild(rect);\n\t\t}\n\t}\n\n\tif (this.stencil != null)\n\t{\n\t\tthis.stencil.drawShape(c, this, x, y, w, h);\n\t}\n\telse\n\t{\n\t\t// Stencils have separate strokewidth\n\t\tc.setStrokeWidth(this.strokewidth);\n\n\t\tif (this.points != null)\n\t\t{\n\t\t\t// Paints edge shape\n\t\t\tvar pts = [];\n\n\t\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t\t{\n\t\t\t\tif (this.points[i] != null)\n\t\t\t\t{\n\t\t\t\t\tpts.push(new mxPoint(this.points[i].x / s, this.points[i].y / s));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.paintEdgeShape(c, pts);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Paints vertex shape\n\t\t\tthis.paintVertexShape(c, x, y, w, h);\n\t\t}\n\t}\n\n\tif (bg != null && c.state != null && c.state.transform != null)\n\t{\n\t\tbg.setAttribute('transform', c.state.transform);\n\t}\n\n\t// Draws highlight rectangle if no stroke was used\n\tif (c != null && this.outline && !strokeDrawn)\n\t{\n\t\tc.rect(x, y, w, h);\n\t\tc.stroke();\n\t}\n};\n\n/**\n * Function: configureCanvas\n *\n * Sets the state of the canvas for drawing the shape.\n */\nmxShape.prototype.configureCanvas = function(c, x, y, w, h)\n{\n\tvar dash = null;\n\n\tif (this.style != null)\n\t{\n\t\tdash = this.style['dashPattern'];\n\t}\n\n\tc.setAlpha(this.opacity / 100);\n\tc.setFillAlpha(this.fillOpacity / 100);\n\tc.setStrokeAlpha(this.strokeOpacity / 100);\n\n\t// Sets alpha, colors and gradients\n\tif (this.isShadow != null)\n\t{\n\t\tc.setShadow(this.isShadow);\n\t}\n\n\t// Dash pattern\n\tif (this.isDashed != null)\n\t{\n\t\tc.setDashed(this.isDashed, (this.style != null) ?\n\t\t\tmxUtils.getValue(this.style, mxConstants.STYLE_FIX_DASH, false) == 1 : false);\n\t}\n\n\tif (dash != null)\n\t{\n\t\tc.setDashPattern(dash);\n\t}\n\n\tif (this.fill != null && this.fill != mxConstants.NONE && this.gradient && this.gradient != mxConstants.NONE)\n\t{\n\t\tvar b = this.getGradientBounds(c, x, y, w, h);\n\t\tc.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);\n\t}\n\telse\n\t{\n\t\tc.setFillColor(this.fill);\n\t}\n\n\tc.setStrokeColor(this.stroke);\n};\n\n/**\n * Function: getGradientBounds\n *\n * Returns the bounding box for the gradient box for this shape.\n */\nmxShape.prototype.getGradientBounds = function(c, x, y, w, h)\n{\n\treturn new mxRectangle(x, y, w, h);\n};\n\n/**\n * Function: updateTransform\n *\n * Sets the scale and rotation on the given canvas.\n */\nmxShape.prototype.updateTransform = function(c, x, y, w, h)\n{\n\t// NOTE: Currently, scale is implemented in state and canvas. This will\n\t// move to canvas in a later version, so that the states are unscaled\n\t// and untranslated and do not need an update after zooming or panning.\n\tc.scale(this.scale);\n\tc.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2);\n};\n\n/**\n * Function: paintVertexShape\n *\n * Paints the vertex shape.\n */\nmxShape.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tthis.paintBackground(c, x, y, w, h);\n\n\tif (!this.outline || this.style == null || mxUtils.getValue(\n\t\tthis.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0) == 0)\n\t{\n\t\tc.setShadow(false);\n\t\tthis.paintForeground(c, x, y, w, h);\n\t}\n};\n\n/**\n * Function: paintBackground\n *\n * Hook for subclassers. This implementation is empty.\n */\nmxShape.prototype.paintBackground = function(c, x, y, w, h) { };\n\n/**\n * Function: paintForeground\n *\n * Hook for subclassers. This implementation is empty.\n */\nmxShape.prototype.paintForeground = function(c, x, y, w, h) { };\n\n/**\n * Function: paintEdgeShape\n *\n * Hook for subclassers. This implementation is empty.\n */\nmxShape.prototype.paintEdgeShape = function(c, pts) { };\n\n/**\n * Function: getArcSize\n *\n * Returns the arc size for the given dimension.\n */\nmxShape.prototype.getArcSize = function(w, h)\n{\n\tvar r = 0;\n\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')\n\t{\n\t\tr = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style,\n\t\t\tmxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));\n\t}\n\telse\n\t{\n\t\tvar f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE,\n\t\t\tmxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n\t\tr = Math.min(w * f, h * f);\n\t}\n\n\treturn r;\n};\n\n/**\n * Function: paintGlassEffect\n *\n * Paints the glass gradient effect.\n */\nmxShape.prototype.paintGlassEffect = function(c, x, y, w, h, arc)\n{\n\tvar sw = Math.ceil(this.strokewidth / 2);\n\tvar size = 0.4;\n\n\tc.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);\n\tc.begin();\n\tarc += 2 * sw;\n\n\tif (this.isRounded)\n\t{\n\t\tc.moveTo(x - sw + arc, y - sw);\n\t\tc.quadTo(x - sw, y - sw, x - sw, y - sw + arc);\n\t\tc.lineTo(x - sw, y + h * size);\n\t\tc.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n\t\tc.lineTo(x + w + sw, y - sw + arc);\n\t\tc.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);\n\t}\n\telse\n\t{\n\t\tc.moveTo(x - sw, y - sw);\n\t\tc.lineTo(x - sw, y + h * size);\n\t\tc.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n\t\tc.lineTo(x + w + sw, y - sw);\n\t}\n\n\tc.close();\n\tc.fill();\n};\n\n/**\n * Function: addPoints\n *\n * Paints the given points with rounded corners.\n */\nmxShape.prototype.addPoints = function(c, pts, rounded, arcSize, close, exclude, initialMove)\n{\n\tif (pts != null && pts.length > 0)\n\t{\n\t\tinitialMove = (initialMove != null) ? initialMove : true;\n\t\tvar pe = pts[pts.length - 1];\n\n\t\t// Adds virtual waypoint in the center between start and end point\n\t\tif (close && rounded)\n\t\t{\n\t\t\tpts = pts.slice();\n\t\t\tvar p0 = pts[0];\n\t\t\tvar wp = new mxPoint(pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);\n\t\t\tpts.splice(0, 0, wp);\n\t\t}\n\n\t\tvar pt = pts[0];\n\t\tvar i = 1;\n\n\t\t// Draws the line segments\n\t\tif (initialMove)\n\t\t{\n\t\t\tc.moveTo(pt.x, pt.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.lineTo(pt.x, pt.y);\n\t\t}\n\n\t\twhile (i < ((close) ? pts.length : pts.length - 1))\n\t\t{\n\t\t\tvar tmp = pts[mxUtils.mod(i, pts.length)];\n\t\t\tvar dx = pt.x - tmp.x;\n\t\t\tvar dy = pt.y - tmp.y;\n\n\t\t\tif (rounded && (dx != 0 || dy != 0) && (exclude == null || mxUtils.indexOf(exclude, i - 1) < 0))\n\t\t\t{\n\t\t\t\t// Draws a line from the last point to the current\n\t\t\t\t// point with a spacing of size off the current point\n\t\t\t\t// into direction of the last point\n\t\t\t\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tvar nx1 = dx * Math.min(arcSize, dist / 2) / dist;\n\t\t\t\tvar ny1 = dy * Math.min(arcSize, dist / 2) / dist;\n\n\t\t\t\tvar x1 = tmp.x + nx1;\n\t\t\t\tvar y1 = tmp.y + ny1;\n\t\t\t\tc.lineTo(x1, y1);\n\n\t\t\t\t// Draws a curve from the last point to the current\n\t\t\t\t// point with a spacing of size off the current point\n\t\t\t\t// into direction of the next point\n\t\t\t\tvar next = pts[mxUtils.mod(i + 1, pts.length)];\n\n\t\t\t\t// Uses next non-overlapping point\n\t\t\t\twhile (i < pts.length - 2 && Math.round(next.x - tmp.x) == 0 && Math.round(next.y - tmp.y) == 0)\n\t\t\t\t{\n\t\t\t\t\tnext = pts[mxUtils.mod(i + 2, pts.length)];\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\tdx = next.x - tmp.x;\n\t\t\t\tdy = next.y - tmp.y;\n\n\t\t\t\tdist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n\t\t\t\tvar nx2 = dx * Math.min(arcSize, dist / 2) / dist;\n\t\t\t\tvar ny2 = dy * Math.min(arcSize, dist / 2) / dist;\n\n\t\t\t\tvar x2 = tmp.x + nx2;\n\t\t\t\tvar y2 = tmp.y + ny2;\n\n\t\t\t\tc.quadTo(tmp.x, tmp.y, x2, y2);\n\t\t\t\ttmp = new mxPoint(x2, y2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.lineTo(tmp.x, tmp.y);\n\t\t\t}\n\n\t\t\tpt = tmp;\n\t\t\ti++;\n\t\t}\n\n\t\tif (close)\n\t\t{\n\t\t\tc.close();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.lineTo(pe.x, pe.y);\n\t\t}\n\t}\n};\n\n/**\n * Function: resetStyles\n *\n * Resets all styles.\n */\nmxShape.prototype.resetStyles = function()\n{\n\tthis.initStyles();\n\n\tthis.spacing = 0;\n\n\tdelete this.fill;\n\tdelete this.gradient;\n\tdelete this.gradientDirection;\n\tdelete this.stroke;\n\tdelete this.startSize;\n\tdelete this.endSize;\n\tdelete this.startArrow;\n\tdelete this.endArrow;\n\tdelete this.direction;\n\tdelete this.isShadow;\n\tdelete this.isDashed;\n\tdelete this.isRounded;\n\tdelete this.glass;\n};\n\n/**\n * Function: apply\n *\n * Applies the style of the given <mxCellState> to the shape. This\n * implementation assigns the following styles to local fields:\n *\n * - <mxConstants.STYLE_FILLCOLOR> => fill\n * - <mxConstants.STYLE_GRADIENTCOLOR> => gradient\n * - <mxConstants.STYLE_GRADIENT_DIRECTION> => gradientDirection\n * - <mxConstants.STYLE_OPACITY> => opacity\n * - <mxConstants.STYLE_FILL_OPACITY> => fillOpacity\n * - <mxConstants.STYLE_STROKE_OPACITY> => strokeOpacity\n * - <mxConstants.STYLE_STROKECOLOR> => stroke\n * - <mxConstants.STYLE_STROKEWIDTH> => strokewidth\n * - <mxConstants.STYLE_SHADOW> => isShadow\n * - <mxConstants.STYLE_DASHED> => isDashed\n * - <mxConstants.STYLE_SPACING> => spacing\n * - <mxConstants.STYLE_STARTSIZE> => startSize\n * - <mxConstants.STYLE_ENDSIZE> => endSize\n * - <mxConstants.STYLE_ROUNDED> => isRounded\n * - <mxConstants.STYLE_STARTARROW> => startArrow\n * - <mxConstants.STYLE_ENDARROW> => endArrow\n * - <mxConstants.STYLE_ROTATION> => rotation\n * - <mxConstants.STYLE_DIRECTION> => direction\n * - <mxConstants.STYLE_GLASS> => glass\n *\n * This keeps a reference to the <style>. If you need to keep a reference to\n * the cell, you can override this method and store a local reference to\n * state.cell or the <mxCellState> itself. If <outline> should be true, make\n * sure to set it before calling this method.\n *\n * Parameters:\n *\n * state - <mxCellState> of the corresponding cell.\n */\nmxShape.prototype.apply = function(state)\n{\n\tthis.state = state;\n\tthis.style = state.style;\n\n\tif (this.style != null)\n\t{\n\t\tthis.fill = mxUtils.getValue(this.style, mxConstants.STYLE_FILLCOLOR, this.fill);\n\t\tthis.gradient = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENTCOLOR, this.gradient);\n\t\tthis.gradientDirection = mxUtils.getValue(this.style, mxConstants.STYLE_GRADIENT_DIRECTION, this.gradientDirection);\n\t\tthis.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_OPACITY, this.opacity);\n\t\tthis.fillOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_FILL_OPACITY, this.fillOpacity);\n\t\tthis.strokeOpacity = mxUtils.getValue(this.style, mxConstants.STYLE_STROKE_OPACITY, this.strokeOpacity);\n\t\tthis.stroke = mxUtils.getValue(this.style, mxConstants.STYLE_STROKECOLOR, this.stroke);\n\t\tthis.strokewidth = mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth);\n\t\tthis.spacing = mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing);\n\t\tthis.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, this.startSize);\n\t\tthis.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, this.endSize);\n\t\tthis.startArrow = mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, this.startArrow);\n\t\tthis.endArrow = mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, this.endArrow);\n\t\tthis.rotation = mxUtils.getValue(this.style, mxConstants.STYLE_ROTATION, this.rotation);\n\t\tthis.direction = mxUtils.getValue(this.style, mxConstants.STYLE_DIRECTION, this.direction);\n\t\tthis.flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\tthis.flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0) == 1;\n\n\t\t// Legacy support for stencilFlipH/V\n\t\tif (this.stencil != null)\n\t\t{\n\t\t\tthis.flipH = mxUtils.getValue(this.style, 'stencilFlipH', 0) == 1 || this.flipH;\n\t\t\tthis.flipV = mxUtils.getValue(this.style, 'stencilFlipV', 0) == 1 || this.flipV;\n\t\t}\n\n\t\tif (this.direction == mxConstants.DIRECTION_NORTH || this.direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tvar tmp = this.flipH;\n\t\t\tthis.flipH = this.flipV;\n\t\t\tthis.flipV = tmp;\n\t\t}\n\n\t\tthis.isShadow = mxUtils.getValue(this.style, mxConstants.STYLE_SHADOW, this.isShadow) == 1;\n\t\tthis.isDashed = mxUtils.getValue(this.style, mxConstants.STYLE_DASHED, this.isDashed) == 1;\n\t\tthis.isRounded = mxUtils.getValue(this.style, mxConstants.STYLE_ROUNDED, this.isRounded) == 1;\n\t\tthis.glass = mxUtils.getValue(this.style, mxConstants.STYLE_GLASS, this.glass) == 1;\n\n\t\tif (this.fill == mxConstants.NONE)\n\t\t{\n\t\t\tthis.fill = null;\n\t\t}\n\n\t\tif (this.gradient == mxConstants.NONE)\n\t\t{\n\t\t\tthis.gradient = null;\n\t\t}\n\n\t\tif (this.stroke == mxConstants.NONE)\n\t\t{\n\t\t\tthis.stroke = null;\n\t\t}\n\t}\n};\n\n/**\n * Function: setCursor\n *\n * Sets the cursor on the given shape.\n *\n * Parameters:\n *\n * cursor - The cursor to be used.\n */\nmxShape.prototype.setCursor = function(cursor)\n{\n\tif (cursor == null)\n\t{\n\t\tcursor = '';\n\t}\n\n\tthis.cursor = cursor;\n\n\tif (this.node != null)\n\t{\n\t\tthis.node.style.cursor = cursor;\n\t}\n};\n\n/**\n * Function: getCursor\n *\n * Returns the current cursor.\n */\nmxShape.prototype.getCursor = function()\n{\n\treturn this.cursor;\n};\n\n/**\n * Function: isRoundable\n *\n * Hook for subclassers.\n */\nmxShape.prototype.isRoundable = function()\n{\n\treturn false;\n};\n\n/**\n * Function: updateBoundingBox\n *\n * Updates the <boundingBox> for this shape using <createBoundingBox> and\n * <augmentBoundingBox> and stores the result in <boundingBox>.\n */\nmxShape.prototype.updateBoundingBox = function()\n{\n\t// Tries to get bounding box from SVG subsystem\n\t// LATER: Use getBoundingClientRect for fallback in VML\n\tif (this.useSvgBoundingBox && this.node != null && this.node.ownerSVGElement != null)\n\t{\n\t\ttry\n\t\t{\n\t\t\tvar b = this.node.getBBox();\n\n\t\t\tif (b.width > 0 && b.height > 0)\n\t\t\t{\n\t\t\t\tthis.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);\n\n\t\t\t\t// Adds strokeWidth\n\t\t\t\tthis.boundingBox.grow(this.strokewidth * this.scale / 2);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch(e)\n\t\t{\n\t\t\t// fallback to code below\n\t\t}\n\t}\n\n\tif (this.bounds != null)\n\t{\n\t\tvar bbox = this.createBoundingBox();\n\n\t\tif (bbox != null)\n\t\t{\n\t\t\tthis.augmentBoundingBox(bbox);\n\t\t\tvar rot = this.getShapeRotation();\n\n\t\t\tif (rot != 0)\n\t\t\t{\n\t\t\t\tbbox = mxUtils.getBoundingBox(bbox, rot);\n\t\t\t}\n\t\t}\n\n\t\tthis.boundingBox = bbox;\n\t}\n};\n\n/**\n * Function: createBoundingBox\n *\n * Returns a new rectangle that represents the bounding box of the bare shape\n * with no shadows or strokewidths.\n */\nmxShape.prototype.createBoundingBox = function()\n{\n\tvar bb = this.bounds.clone();\n\n\tif ((this.stencil != null && (this.direction == mxConstants.DIRECTION_NORTH ||\n\t\tthis.direction == mxConstants.DIRECTION_SOUTH)) || this.isPaintBoundsInverted())\n\t{\n\t\tbb.rotate90();\n\t}\n\n\treturn bb;\n};\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the strokewidth and shadow offsets.\n */\nmxShape.prototype.augmentBoundingBox = function(bbox)\n{\n\tif (this.isShadow)\n\t{\n\t\tbbox.width += Math.ceil(mxConstants.SHADOW_OFFSET_X * this.scale);\n\t\tbbox.height += Math.ceil(mxConstants.SHADOW_OFFSET_Y * this.scale);\n\t}\n\n\t// Adds strokeWidth\n\tbbox.grow(this.strokewidth * this.scale / 2);\n};\n\n/**\n * Function: isPaintBoundsInverted\n *\n * Returns true if the bounds should be inverted.\n */\nmxShape.prototype.isPaintBoundsInverted = function()\n{\n\t// Stencil implements inversion via aspect\n\treturn this.stencil == null && (this.direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_SOUTH);\n};\n\n/**\n * Function: getRotation\n *\n * Returns the rotation from the style.\n */\nmxShape.prototype.getRotation = function()\n{\n\treturn (this.rotation != null) ? this.rotation : 0;\n};\n\n/**\n * Function: getTextRotation\n *\n * Returns the rotation for the text label.\n */\nmxShape.prototype.getTextRotation = function()\n{\n\tvar rot = this.getRotation();\n\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) != 1)\n\t{\n\t\trot += mxText.prototype.verticalTextRotation;\n\t}\n\n\treturn rot;\n};\n\n/**\n * Function: getShapeRotation\n *\n * Returns the actual rotation of the shape.\n */\nmxShape.prototype.getShapeRotation = function()\n{\n\tvar rot = this.getRotation();\n\n\tif (this.direction != null)\n\t{\n\t\tif (this.direction == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\trot += 270;\n\t\t}\n\t\telse if (this.direction == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\trot += 180;\n\t\t}\n\t\telse if (this.direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\trot += 90;\n\t\t}\n\t}\n\n\treturn rot;\n};\n\n/**\n * Function: createTransparentSvgRectangle\n *\n * Adds a transparent rectangle that catches all events.\n */\nmxShape.prototype.createTransparentSvgRectangle = function(x, y, w, h)\n{\n\tvar rect = document.createElementNS(mxConstants.NS_SVG, 'rect');\n\trect.setAttribute('x', x);\n\trect.setAttribute('y', y);\n\trect.setAttribute('width', w);\n\trect.setAttribute('height', h);\n\trect.setAttribute('fill', 'none');\n\trect.setAttribute('stroke', 'none');\n\trect.setAttribute('pointer-events', 'all');\n\n\treturn rect;\n};\n\n/**\n * Function: setTransparentBackgroundImage\n *\n * Sets a transparent background CSS style to catch all events.\n *\n * Paints the line shape.\n */\nmxShape.prototype.setTransparentBackgroundImage = function(node)\n{\n\tnode.style.backgroundImage = 'url(\\'' + mxClient.imageBasePath + '/transparent.gif\\')';\n};\n\n/**\n * Function: releaseSvgGradients\n *\n * Paints the line shape.\n */\nmxShape.prototype.releaseSvgGradients = function(grads)\n{\n\tif (grads != null)\n\t{\n\t\tfor (var key in grads)\n\t\t{\n\t\t\tvar gradient = grads[key];\n\n\t\t\tif (gradient != null)\n\t\t\t{\n\t\t\t\tgradient.mxRefCount = (gradient.mxRefCount || 0) - 1;\n\n\t\t\t\tif (gradient.mxRefCount == 0 && gradient.parentNode != null)\n\t\t\t\t{\n\t\t\t\t\tgradient.parentNode.removeChild(gradient);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the shape by removing it from the DOM and releasing the DOM\n * node associated with the shape using <mxEvent.release>.\n */\nmxShape.prototype.destroy = function()\n{\n\tif (this.node != null)\n\t{\n\t\tmxEvent.release(this.node);\n\n\t\tif (this.node.parentNode != null)\n\t\t{\n\t\t\tthis.node.parentNode.removeChild(this.node);\n\t\t}\n\n\t\tthis.node = null;\n\t}\n\n\t// Decrements refCount and removes unused\n\tthis.releaseSvgGradients(this.oldGradients);\n\tthis.oldGradients = null;\n};\n\n__mxOutput.mxShape = typeof mxShape !== 'undefined' ? mxShape : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStencil\n *\n * Implements a generic shape which is based on a XML node as a description.\n *\n * shape:\n *\n * The outer element is *shape*, that has attributes:\n *\n * - \"name\", string, required. The stencil name that uniquely identifies the shape.\n * - \"w\" and \"h\" are optional decimal view bounds. This defines your co-ordinate\n * system for the graphics operations in the shape. The default is 100,100.\n * - \"aspect\", optional string. Either \"variable\", the default, or \"fixed\". Fixed\n * means always render the shape with the aspect ratio defined by the ratio w/h.\n * Variable causes the ratio to match that of the geometry of the current vertex.\n * - \"strokewidth\", optional string. Either an integer or the string \"inherit\".\n * \"inherit\" indicates that the strokeWidth of the cell is only changed on scaling,\n * not on resizing. Default is \"1\".\n * If numeric values are used, the strokeWidth of the cell is changed on both\n * scaling and resizing and the value defines the multiple that is applied to\n * the width.\n *\n * connections:\n *\n * If you want to define specific fixed connection points on the shape use the\n * *connections* element. Each *constraint* element within connections defines\n * a fixed connection point on the shape. Constraints have attributes:\n *\n * - \"perimeter\", required. 1 or 0. 0 sets the connection point where specified\n * by x,y. 1 Causes the position of the connection point to be extrapolated from\n * the center of the shape, through x,y to the point of intersection with the\n * perimeter of the shape.\n * - \"x\" and \"y\" are the position of the fixed point relative to the bounds of\n * the shape. They can be automatically adjusted if perimeter=1. So, (0,0) is top\n * left, (0.5,0.5) the center, (1,0.5) the center of the right hand edge of the\n * bounds, etc. Values may be less than 0 or greater than 1 to be positioned\n * outside of the shape.\n * - \"name\", optional string. A unique identifier for the port on the shape.\n *\n * background and foreground:\n *\n * The path of the graphics drawing is split into two elements, *foreground* and\n * *background*. The split is to define which part any shadow applied to the shape\n * is derived from (the background). This, generally, means the background is the\n * line tracing of the outside of the shape, but not always.\n *\n * Any stroke, fill or fillstroke of a background must be the first element of the\n * foreground element, they must not be used within *background*. If the background\n * is empty, this is not required.\n *\n * Because the background cannot have any fill or stroke, it can contain only one\n * *path*, *rect*, *roundrect* or *ellipse* element (or none). It can also not\n * include *image*, *text* or *include-shape*.\n *\n * Note that the state, styling and drawing in mxGraph stencils is very close in\n * design to that of HTML 5 canvas. Tutorials on this subject, if you're not\n * familiar with the topic, will give a good high-level introduction to the\n * concepts used.\n *\n * State:\n *\n * Rendering within the foreground and background elements has the concept of\n * state. There are two types of operations other than state save/load, styling\n * and drawing. The styling operations change the current state, so you can save\n * the current state with <save/> and pull the last saved state from the state\n * stack using <restore/>.\n *\n * Styling:\n *\n * The elements that change colors within the current state all take a hash\n * prefixed hex color code (\"#FFEA80\").\n *\n * - *strokecolor*, this sets the color that drawing paths will be rendered in\n * when a stroke or fillstroke command is issued.\n * - *fillcolor*, this sets the color that the inside of closed paths will be\n * rendered in when a fill or fillstroke command is issued.\n * - *fontcolor*, this sets the color that fonts are rendered in when text is drawn.\n *\n * *alpha* defines the degree of transparency used between 1.0 for fully opaque\n * and 0.0 for fully transparent.\n *\n * *fillalpha* defines the degree of fill transparency used between 1.0 for fully\n * opaque and 0.0 for fully transparent.\n *\n * *strokealpha* defines the degree of stroke transparency used between 1.0 for\n * fully opaque and 0.0 for fully transparent.\n *\n * *strokewidth* defines the integer thickness of drawing elements rendered by\n * stroking. Use fixed=\"1\" to apply the value as-is, without scaling.\n *\n * *dashed* is \"1\" for dashing enabled and \"0\" for disabled.\n *\n * When *dashed* is enabled the current dash pattern, defined by *dashpattern*,\n * is used on strokes. dashpattern is a sequence of space separated \"on, off\"\n * lengths that define what distance to paint the stroke for, then what distance\n * to paint nothing for, repeat... The default is \"3 3\". You could define a more\n * complex pattern with \"5 3 2 6\", for example. Generally, it makes sense to have\n * an even number of elements in the dashpattern, but that's not required.\n *\n * *linejoin*, *linecap* and *miterlimit* are best explained by the Mozilla page\n * on Canvas styling (about halfway down). The values are all the same except we\n * use \"flat\" for linecap, instead of Canvas' \"butt\".\n *\n * For font styling there are.\n *\n * - *fontsize*, an integer,\n * - *fontstyle*, an ORed bit pattern of bold (1), italic (2) and underline (4),\n * i.e bold underline is \"5\".\n * - *fontfamily*, is a string defining the typeface to be used.\n *\n * Drawing:\n *\n * Most drawing is contained within a *path* element. Again, the graphic\n * primitives are very similar to that of HTML 5 canvas.\n *\n * - *move* to attributes required decimals (x,y).\n * - *line* to attributes required decimals (x,y).\n * - *quad* to required decimals (x2,y2) via control point required decimals\n * (x1,y1).\n * - *curve* to required decimals (x3,y3), via control points required decimals\n * (x1,y1) and (x2,y2).\n * - *arc*, this doesn't follow the HTML Canvas signatures, instead it's a copy\n * of the SVG arc command. The SVG specification documentation gives the best\n * description of its behaviors. The attributes are named identically, they are\n * decimals and all required.\n * - *close* ends the current subpath and causes an automatic straight line to\n * be drawn from the current point to the initial point of the current subpath.\n *\n * Complex drawing:\n *\n * In addition to the graphics primitive operations there are non-primitive\n * operations. These provide an easy method to draw some basic shapes.\n *\n * - *rect*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals\n * - *roundrect*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals. Also\n * \"arcsize\" an optional decimal attribute defining how large, the corner curves\n * are.\n * - *ellipse*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals.\n *\n * Note that these 3 shapes and all paths must be followed by either a fill,\n * stroke, or fillstroke.\n *\n * Text:\n *\n * *text* elements have the following attributes.\n *\n * - \"str\", the text string to display, required.\n * - \"x\" and \"y\", the decimal location (x,y) of the text element, required.\n * - \"align\", the horizontal alignment of the text element, either \"left\",\n * \"center\" or \"right\". Optional, default is \"left\".\n * - \"valign\", the vertical alignment of the text element, either \"top\", \"middle\"\n * or \"bottom\". Optional, default is \"top\".\n * - \"localized\", 0 or 1, if 1 then the \"str\" actually contains a key to use to\n * fetch the value out of mxResources. Optional, default is\n * <mxStencil.defaultLocalized>.\n * - \"vertical\", 0 or 1, if 1 the label is rendered vertically (rotated by 90\n * degrees). Optional, default is 0.\n * - \"rotation\", angle in degrees (0 to 360). The angle to rotate the text by.\n * Optional, default is 0.\n * - \"align-shape\", 0 or 1, if 0 ignore the rotation of the shape when setting\n * the text rotation. Optional, default is 1.\n *\n * If <allowEval> is true, then the text content of the this element can define\n * a function which is invoked with the shape as the only argument and returns\n * the value for the text element (ignored if the str attribute is not null).\n *\n * Images:\n *\n * *image* elements can either be external URLs, or data URIs, where supported\n * (not in IE 7-). Attributes are:\n *\n * - \"src\", required string. Either a data URI or URL.\n * - \"x\", \"y\", required decimals. The (x,y) position of the image.\n * - \"w\", \"h\", required decimals. The width and height of the image.\n * - \"flipH\" and \"flipV\", optional 0 or 1. Whether to flip the image along the\n * horizontal/vertical axis. Default is 0 for both.\n *\n * If <allowEval> is true, then the text content of the this element can define\n * a function which is invoked with the shape as the only argument and returns\n * the value for the image source (ignored if the src attribute is not null).\n *\n * Sub-shapes:\n *\n * *include-shape* allow stencils to be rendered within the current stencil by\n * referencing the sub-stencil by name. Attributes are:\n *\n * - \"name\", required string. The unique shape name of the stencil.\n * - \"x\", \"y\", \"w\", \"h\", required decimals. The (x,y) position of the sub-shape\n * and its width and height.\n *\n * Constructor: mxStencil\n *\n * Constructs a new generic shape by setting <desc> to the given XML node and\n * invoking <parseDescription> and <parseConstraints>.\n *\n * Parameters:\n *\n * desc - XML node that contains the stencil description.\n */\nfunction mxStencil(desc)\n{\n\tthis.desc = desc;\n\tthis.parseDescription();\n\tthis.parseConstraints();\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxStencil, mxShape);\n\n/**\n * Variable: defaultLocalized\n *\n * Static global variable that specifies the default value for the localized\n * attribute of the text element. Default is false.\n */\nmxStencil.defaultLocalized = false;\n\n/**\n * Function: allowEval\n *\n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content and images. Default is false. Set this to true\n * if stencils can not contain user input.\n */\nmxStencil.allowEval = false;\n\n/**\n * Variable: desc\n *\n * Holds the XML node with the stencil description.\n */\nmxStencil.prototype.desc = null;\n\n/**\n * Variable: constraints\n *\n * Holds an array of <mxConnectionConstraints> as defined in the shape.\n */\nmxStencil.prototype.constraints = null;\n\n/**\n * Variable: aspect\n *\n * Holds the aspect of the shape. Default is 'auto'.\n */\nmxStencil.prototype.aspect = null;\n\n/**\n * Variable: w0\n *\n * Holds the width of the shape. Default is 100.\n */\nmxStencil.prototype.w0 = null;\n\n/**\n * Variable: h0\n *\n * Holds the height of the shape. Default is 100.\n */\nmxStencil.prototype.h0 = null;\n\n/**\n * Variable: bgNodes\n *\n * Holds the XML node with the stencil description.\n */\nmxStencil.prototype.bgNode = null;\n\n/**\n * Variable: fgNodes\n *\n * Holds the XML node with the stencil description.\n */\nmxStencil.prototype.fgNode = null;\n\n/**\n * Variable: strokewidth\n *\n * Holds the strokewidth direction from the description.\n */\nmxStencil.prototype.strokewidth = null;\n\n/**\n * Function: parseDescription\n *\n * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.\n */\nmxStencil.prototype.parseDescription = function()\n{\n\t// LATER: Preprocess nodes for faster painting\n\tthis.fgNode = this.desc.getElementsByTagName('foreground')[0];\n\tthis.bgNode = this.desc.getElementsByTagName('background')[0];\n\tthis.w0 = Number(this.desc.getAttribute('w') || 100);\n\tthis.h0 = Number(this.desc.getAttribute('h') || 100);\n\n\t// Possible values for aspect are: variable and fixed where\n\t// variable means fill the available space and fixed means\n\t// use w0 and h0 to compute the aspect.\n\tvar aspect = this.desc.getAttribute('aspect');\n\tthis.aspect = (aspect != null) ? aspect : 'variable';\n\n\t// Possible values for strokewidth are all numbers and \"inherit\"\n\t// where the inherit means take the value from the style (ie. the\n\t// user-defined stroke-width). Note that the strokewidth is scaled\n\t// by the minimum scaling that is used to draw the shape (sx, sy).\n\tvar sw = this.desc.getAttribute('strokewidth');\n\tthis.strokewidth = (sw != null) ? sw : '1';\n};\n\n/**\n * Function: parseConstraints\n *\n * Reads the constraints from <desc> into <constraints> using\n * <parseConstraint>.\n */\nmxStencil.prototype.parseConstraints = function()\n{\n\tvar conns = this.desc.getElementsByTagName('connections')[0];\n\n\tif (conns != null)\n\t{\n\t\tvar tmp = mxUtils.getChildNodes(conns);\n\n\t\tif (tmp != null && tmp.length > 0)\n\t\t{\n\t\t\tthis.constraints = [];\n\n\t\t\tfor (var i = 0; i < tmp.length; i++)\n\t\t\t{\n\t\t\t\tthis.constraints.push(this.parseConstraint(tmp[i]));\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: parseConstraint\n *\n * Parses the given XML node and returns its <mxConnectionConstraint>.\n */\nmxStencil.prototype.parseConstraint = function(node)\n{\n\tvar x = Number(node.getAttribute('x'));\n\tvar y = Number(node.getAttribute('y'));\n\tvar perimeter = node.getAttribute('perimeter') == '1';\n\tvar name = node.getAttribute('name');\n\n\treturn new mxConnectionConstraint(new mxPoint(x, y), perimeter, name);\n};\n\n/**\n * Function: evaluateTextAttribute\n *\n * Gets the given attribute as a text. The return value from <evaluateAttribute>\n * is used as a key to <mxResources.get> if the localized attribute in the text\n * node is 1 or if <defaultLocalized> is true.\n */\nmxStencil.prototype.evaluateTextAttribute = function(node, attribute, shape)\n{\n\tvar result = this.evaluateAttribute(node, attribute, shape);\n\tvar loc = node.getAttribute('localized');\n\n\tif ((mxStencil.defaultLocalized && loc == null) || loc == '1')\n\t{\n\t\tresult = mxResources.get(result);\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: evaluateAttribute\n *\n * Gets the attribute for the given name from the given node. If the attribute\n * does not exist then the text content of the node is evaluated and if it is\n * a function it is invoked with <shape> as the only argument and the return\n * value is used as the attribute value to be returned.\n */\nmxStencil.prototype.evaluateAttribute = function(node, attribute, shape)\n{\n\tvar result = node.getAttribute(attribute);\n\n\tif (result == null)\n\t{\n\t\tvar text = mxUtils.getTextContent(node);\n\n\t\tif (text != null && mxStencil.allowEval)\n\t\t{\n\t\t\tvar funct = mxUtils.eval(text);\n\n\t\t\tif (typeof(funct) == 'function')\n\t\t\t{\n\t\t\t\tresult = funct(shape);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: drawShape\n *\n * Draws this stencil inside the given bounds.\n */\nmxStencil.prototype.drawShape = function(canvas, shape, x, y, w, h)\n{\n\t// TODO: Internal structure (array of special structs?), relative and absolute\n\t// coordinates (eg. note shape, process vs star, actor etc.), text rendering\n\t// and non-proportional scaling, how to implement pluggable edge shapes\n\t// (start, segment, end blocks), pluggable markers, how to implement\n\t// swimlanes (title area) with this API, add icon, horizontal/vertical\n\t// label, indicator for all shapes, rotation\n\tvar direction = mxUtils.getValue(shape.style, mxConstants.STYLE_DIRECTION, null);\n\tvar aspect = this.computeAspect(shape.style, x, y, w, h, direction);\n\tvar minScale = Math.min(aspect.width, aspect.height);\n\tvar sw = (this.strokewidth == 'inherit') ?\n\t\t\tNumber(mxUtils.getNumber(shape.style, mxConstants.STYLE_STROKEWIDTH, 1)) :\n\t\t\tNumber(this.strokewidth) * minScale;\n\tcanvas.setStrokeWidth(sw);\n\n\t// Draws a transparent rectangle for catching events\n\tif (shape.style != null && mxUtils.getValue(shape.style, mxConstants.STYLE_POINTER_EVENTS, '0') == '1')\n\t{\n\t\tcanvas.setStrokeColor(mxConstants.NONE);\n\t\tcanvas.rect(x, y, w, h);\n\t\tcanvas.stroke();\n\t\tcanvas.setStrokeColor(shape.stroke);\n\t}\n\n\tthis.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false, true);\n\tthis.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true,\n\t\t!shape.outline || shape.style == null || mxUtils.getValue(\n\t\tshape.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0) == 0);\n};\n\n/**\n * Function: drawChildren\n *\n * Draws this stencil inside the given bounds.\n */\nmxStencil.prototype.drawChildren = function(canvas, shape, x, y, w, h, node, aspect, disableShadow, paint)\n{\n\tif (node != null && w > 0 && h > 0)\n\t{\n\t\tvar tmp = node.firstChild;\n\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t{\n\t\t\t\tthis.drawNode(canvas, shape, tmp, aspect, disableShadow, paint);\n\t\t\t}\n\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\n\t}\n};\n\n/**\n * Function: computeAspect\n *\n * Returns a rectangle that contains the offset in x and y and the horizontal\n * and vertical scale in width and height used to draw this shape inside the\n * given <mxRectangle>.\n *\n * Parameters:\n *\n * shape - <mxShape> to be drawn.\n * bounds - <mxRectangle> that should contain the stencil.\n * direction - Optional direction of the shape to be darwn.\n */\nmxStencil.prototype.computeAspect = function(shape, x, y, w, h, direction)\n{\n\tvar x0 = x;\n\tvar y0 = y;\n\tvar sx = w / this.w0;\n\tvar sy = h / this.h0;\n\n\tvar inverse = (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH);\n\n\tif (inverse)\n\t{\n\t\tsy = w / this.h0;\n\t\tsx = h / this.w0;\n\n\t\tvar delta = (w - h) / 2;\n\n\t\tx0 += delta;\n\t\ty0 -= delta;\n\t}\n\n\tif (this.aspect == 'fixed')\n\t{\n\t\tsy = Math.min(sx, sy);\n\t\tsx = sy;\n\n\t\t// Centers the shape inside the available space\n\t\tif (inverse)\n\t\t{\n\t\t\tx0 += (h - this.w0 * sx) / 2;\n\t\t\ty0 += (w - this.h0 * sy) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx0 += (w - this.w0 * sx) / 2;\n\t\t\ty0 += (h - this.h0 * sy) / 2;\n\t\t}\n\t}\n\n\treturn new mxRectangle(x0, y0, sx, sy);\n};\n\n/**\n * Function: drawNode\n *\n * Draws this stencil inside the given bounds.\n */\nmxStencil.prototype.drawNode = function(canvas, shape, node, aspect, disableShadow, paint)\n{\n\tvar name = node.nodeName;\n\tvar x0 = aspect.x;\n\tvar y0 = aspect.y;\n\tvar sx = aspect.width;\n\tvar sy = aspect.height;\n\tvar minScale = Math.min(sx, sy);\n\n\tif (name == 'save')\n\t{\n\t\tcanvas.save();\n\t}\n\telse if (name == 'restore')\n\t{\n\t\tcanvas.restore();\n\t}\n\telse if (paint)\n\t{\n\t\tif (name == 'path')\n\t\t{\n\t\t\tcanvas.begin();\n\n\t\t\tvar parseRegularly = true;\n\n\t\t\tif (node.getAttribute('rounded') == '1')\n\t\t\t{\n\t\t\t\tparseRegularly = false;\n\n\t\t\t\tvar arcSize = Number(node.getAttribute('arcSize'));\n\t\t\t\tvar pointCount = 0;\n\t\t\t\tvar segs = [];\n\n\t\t\t\t// Renders the elements inside the given path\n\t\t\t\tvar childNode = node.firstChild;\n\n\t\t\t\twhile (childNode != null)\n\t\t\t\t{\n\t\t\t\t\tif (childNode.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar childName = childNode.nodeName;\n\n\t\t\t\t\t\tif (childName == 'move' || childName == 'line')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (childName == 'move' || segs.length == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsegs.push([]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsegs[segs.length - 1].push(new mxPoint(x0 + Number(childNode.getAttribute('x')) * sx,\n\t\t\t\t\t\t\t\ty0 + Number(childNode.getAttribute('y')) * sy));\n\t\t\t\t\t\t\tpointCount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t//We only support move and line for rounded corners\n\t\t\t\t\t\t\tparseRegularly = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tchildNode = childNode.nextSibling;\n\t\t\t\t}\n\n\t\t\t\tif (!parseRegularly && pointCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < segs.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar close = false, ps = segs[i][0], pe = segs[i][segs[i].length - 1];\n\n\t\t\t\t\t\tif (ps.x == pe.x && ps.y == pe.y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsegs[i].pop();\n\t\t\t\t\t\t\tclose = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.addPoints(canvas, segs[i], true, arcSize, close);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparseRegularly = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parseRegularly)\n\t\t\t{\n\t\t\t\t// Renders the elements inside the given path\n\t\t\t\tvar childNode = node.firstChild;\n\n\t\t\t\twhile (childNode != null)\n\t\t\t\t{\n\t\t\t\t\tif (childNode.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.drawNode(canvas, shape, childNode, aspect, disableShadow, paint);\n\t\t\t\t\t}\n\n\t\t\t\t\tchildNode = childNode.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (name == 'close')\n\t\t{\n\t\t\tcanvas.close();\n\t\t}\n\t\telse if (name == 'move')\n\t\t{\n\t\t\tcanvas.moveTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n\t\t}\n\t\telse if (name == 'line')\n\t\t{\n\t\t\tcanvas.lineTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n\t\t}\n\t\telse if (name == 'quad')\n\t\t{\n\t\t\tcanvas.quadTo(x0 + Number(node.getAttribute('x1')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y1')) * sy,\n\t\t\t\t\tx0 + Number(node.getAttribute('x2')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y2')) * sy);\n\t\t}\n\t\telse if (name == 'curve')\n\t\t{\n\t\t\tcanvas.curveTo(x0 + Number(node.getAttribute('x1')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y1')) * sy,\n\t\t\t\t\tx0 + Number(node.getAttribute('x2')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y2')) * sy,\n\t\t\t\t\tx0 + Number(node.getAttribute('x3')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y3')) * sy);\n\t\t}\n\t\telse if (name == 'arc')\n\t\t{\n\t\t\tcanvas.arcTo(Number(node.getAttribute('rx')) * sx,\n\t\t\t\t\tNumber(node.getAttribute('ry')) * sy,\n\t\t\t\t\tNumber(node.getAttribute('x-axis-rotation')),\n\t\t\t\t\tNumber(node.getAttribute('large-arc-flag')),\n\t\t\t\t\tNumber(node.getAttribute('sweep-flag')),\n\t\t\t\t\tx0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy);\n\t\t}\n\t\telse if (name == 'rect')\n\t\t{\n\t\t\tcanvas.rect(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\tNumber(node.getAttribute('w')) * sx,\n\t\t\t\t\tNumber(node.getAttribute('h')) * sy);\n\t\t}\n\t\telse if (name == 'roundrect')\n\t\t{\n\t\t\tvar arcsize = Number(node.getAttribute('arcsize'));\n\n\t\t\tif (arcsize == 0)\n\t\t\t{\n\t\t\t\tarcsize = mxConstants.RECTANGLE_ROUNDING_FACTOR * 100;\n\t\t\t}\n\n\t\t\tvar w = Number(node.getAttribute('w')) * sx;\n\t\t\tvar h = Number(node.getAttribute('h')) * sy;\n\t\t\tvar factor = Number(arcsize) / 100;\n\t\t\tvar r = Math.min(w * factor, h * factor);\n\n\t\t\tcanvas.roundrect(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\tw, h, r, r);\n\t\t}\n\t\telse if (name == 'ellipse')\n\t\t{\n\t\t\tcanvas.ellipse(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\tNumber(node.getAttribute('w')) * sx,\n\t\t\t\tNumber(node.getAttribute('h')) * sy);\n\t\t}\n\t\telse if (name == 'image')\n\t\t{\n\t\t\tif (!shape.outline)\n\t\t\t{\n\t\t\t\tvar src = this.evaluateAttribute(node, 'src', shape);\n\n\t\t\t\tcanvas.image(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\tNumber(node.getAttribute('w')) * sx,\n\t\t\t\t\tNumber(node.getAttribute('h')) * sy,\n\t\t\t\t\tsrc, false, node.getAttribute('flipH') == '1',\n\t\t\t\t\tnode.getAttribute('flipV') == '1');\n\t\t\t}\n\t\t}\n\t\telse if (name == 'text')\n\t\t{\n\t\t\tif (!shape.outline)\n\t\t\t{\n\t\t\t\tvar str = this.evaluateTextAttribute(node, 'str', shape);\n\t\t\t\tvar rotation = node.getAttribute('vertical') == '1' ? -90 : 0;\n\n\t\t\t\tif (node.getAttribute('align-shape') == '0')\n\t\t\t\t{\n\t\t\t\t\tvar dr = shape.rotation;\n\n\t\t\t\t\t// Depends on flipping\n\t\t\t\t\tvar flipH = mxUtils.getValue(shape.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\t\t\t\tvar flipV = mxUtils.getValue(shape.style, mxConstants.STYLE_FLIPV, 0) == 1;\n\n\t\t\t\t\tif (flipH && flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\trotation -= dr;\n\t\t\t\t\t}\n\t\t\t\t\telse if (flipH || flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\trotation += dr;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trotation -= dr;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trotation -= node.getAttribute('rotation');\n\n\t\t\t\tcanvas.text(x0 + Number(node.getAttribute('x')) * sx,\n\t\t\t\t\t\ty0 + Number(node.getAttribute('y')) * sy,\n\t\t\t\t\t\t0, 0, str, node.getAttribute('align') || 'left',\n\t\t\t\t\t\tnode.getAttribute('valign') || 'top', false, '',\n\t\t\t\t\t\tnull, false, rotation);\n\t\t\t}\n\t\t}\n\t\telse if (name == 'include-shape')\n\t\t{\n\t\t\tvar stencil = mxStencilRegistry.getStencil(node.getAttribute('name'));\n\n\t\t\tif (stencil != null)\n\t\t\t{\n\t\t\t\tvar x = x0 + Number(node.getAttribute('x')) * sx;\n\t\t\t\tvar y = y0 + Number(node.getAttribute('y')) * sy;\n\t\t\t\tvar w = Number(node.getAttribute('w')) * sx;\n\t\t\t\tvar h = Number(node.getAttribute('h')) * sy;\n\n\t\t\t\tstencil.drawShape(canvas, shape, x, y, w, h);\n\t\t\t}\n\t\t}\n\t\telse if (name == 'fillstroke')\n\t\t{\n\t\t\tcanvas.fillAndStroke();\n\t\t}\n\t\telse if (name == 'fill')\n\t\t{\n\t\t\tcanvas.fill();\n\t\t}\n\t\telse if (name == 'stroke')\n\t\t{\n\t\t\tcanvas.stroke();\n\t\t}\n\t\telse if (name == 'strokewidth')\n\t\t{\n\t\t\tvar s = (node.getAttribute('fixed') == '1') ? 1 : minScale;\n\t\t\tcanvas.setStrokeWidth(Number(node.getAttribute('width')) * s);\n\t\t}\n\t\telse if (name == 'dashed')\n\t\t{\n\t\t\tcanvas.setDashed(node.getAttribute('dashed') == '1');\n\t\t}\n\t\telse if (name == 'dashpattern')\n\t\t{\n\t\t\tvar value = node.getAttribute('pattern');\n\n\t\t\tif (value != null)\n\t\t\t{\n\t\t\t\tvar tmp = value.split(' ');\n\t\t\t\tvar pat = [];\n\n\t\t\t\tfor (var i = 0; i < tmp.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (tmp[i].length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tpat.push(Number(tmp[i]) * minScale);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalue = pat.join(' ');\n\t\t\t\tcanvas.setDashPattern(value);\n\t\t\t}\n\t\t}\n\t\telse if (name == 'strokecolor')\n\t\t{\n\t\t\tcanvas.setStrokeColor(node.getAttribute('color'));\n\t\t}\n\t\telse if (name == 'linecap')\n\t\t{\n\t\t\tcanvas.setLineCap(node.getAttribute('cap'));\n\t\t}\n\t\telse if (name == 'linejoin')\n\t\t{\n\t\t\tcanvas.setLineJoin(node.getAttribute('join'));\n\t\t}\n\t\telse if (name == 'miterlimit')\n\t\t{\n\t\t\tcanvas.setMiterLimit(Number(node.getAttribute('limit')));\n\t\t}\n\t\telse if (name == 'fillcolor')\n\t\t{\n\t\t\tcanvas.setFillColor(node.getAttribute('color'));\n\t\t}\n\t\telse if (name == 'alpha')\n\t\t{\n\t\t\tcanvas.setAlpha(node.getAttribute('alpha'));\n\t\t}\n\t\telse if (name == 'fillalpha')\n\t\t{\n\t\t\tcanvas.setAlpha(node.getAttribute('alpha'));\n\t\t}\n\t\telse if (name == 'strokealpha')\n\t\t{\n\t\t\tcanvas.setAlpha(node.getAttribute('alpha'));\n\t\t}\n\t\telse if (name == 'fontcolor')\n\t\t{\n\t\t\tcanvas.setFontColor(node.getAttribute('color'));\n\t\t}\n\t\telse if (name == 'fontstyle')\n\t\t{\n\t\t\tcanvas.setFontStyle(node.getAttribute('style'));\n\t\t}\n\t\telse if (name == 'fontfamily')\n\t\t{\n\t\t\tcanvas.setFontFamily(node.getAttribute('family'));\n\t\t}\n\t\telse if (name == 'fontsize')\n\t\t{\n\t\t\tcanvas.setFontSize(Number(node.getAttribute('size')) * minScale);\n\t\t}\n\n\t\tif (disableShadow && (name == 'fillstroke' || name == 'fill' || name == 'stroke'))\n\t\t{\n\t\t\tdisableShadow = false;\n\t\t\tcanvas.setShadow(false);\n\t\t}\n\t}\n};\n\n__mxOutput.mxStencil = typeof mxStencil !== 'undefined' ? mxStencil : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n *\n * Code to add stencils.\n *\n * (code)\n * var req = mxUtils.load('test/stencils.xml');\n * var root = req.getDocumentElement();\n * var shape = root.firstChild;\n *\n * while (shape != null)\n * {\n * \t if (shape.nodeType == mxConstants.NODETYPE_ELEMENT)\n *   {\n *     mxStencilRegistry.addStencil(shape.getAttribute('name'), new mxStencil(shape));\n *   }\n *\n *   shape = shape.nextSibling;\n * }\n * (end)\n */\nvar mxStencilRegistry =\n{\n\t/**\n\t * Class: mxStencilRegistry\n\t *\n\t * A singleton class that provides a registry for stencils and the methods\n\t * for painting those stencils onto a canvas or into a DOM.\n\t */\n\tstencils: {},\n\n\t/**\n\t * Function: addStencil\n\t *\n\t * Adds the given <mxStencil>.\n\t */\n\taddStencil: function(name, stencil)\n\t{\n\t\tmxStencilRegistry.stencils[name] = stencil;\n\t},\n\n\t/**\n\t * Function: getStencil\n\t *\n\t * Returns the <mxStencil> for the given name.\n\t */\n\tgetStencil: function(name)\n\t{\n\t\treturn mxStencilRegistry.stencils[name];\n\t}\n\n};\n\n__mxOutput.mxStencilRegistry = typeof mxStencilRegistry !== 'undefined' ? mxStencilRegistry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxMarker =\n{\n\t/**\n\t * Class: mxMarker\n\t *\n\t * A static class that implements all markers for VML and SVG using a\n\t * registry. NOTE: The signatures in this class will change.\n\t *\n\t * Variable: markers\n\t *\n\t * Maps from markers names to functions to paint the markers.\n\t */\n\tmarkers: [],\n\n\t/**\n\t * Function: addMarker\n\t *\n\t * Adds a factory method that updates a given endpoint and returns a\n\t * function to paint the marker onto the given canvas.\n\t */\n\taddMarker: function(type, funct)\n\t{\n\t\tmxMarker.markers[type] = funct;\n\t},\n\n\t/**\n\t * Function: createMarker\n\t *\n\t * Returns a function to paint the given marker.\n\t */\n\tcreateMarker: function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t{\n\t\tvar funct = mxMarker.markers[type];\n\n\t\treturn (funct != null) ? funct(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) : null;\n\t}\n\n};\n\n/**\n * Adds the classic and block marker factory method.\n */\n(function()\n{\n\tfunction createArrow(widthFactor)\n\t{\n\t\twidthFactor = (widthFactor != null) ? widthFactor : 2;\n\n\t\treturn function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t\t{\n\t\t\t// The angle of the forward facing arrow sides against the x axis is\n\t\t\t// 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n\t\t\t// only half the strokewidth is processed ).\n\t\t\tvar endOffsetX = unitX * sw * 1.118;\n\t\t\tvar endOffsetY = unitY * sw * 1.118;\n\n\t\t\tunitX = unitX * (size + sw);\n\t\t\tunitY = unitY * (size + sw);\n\n\t\t\tvar pt = pe.clone();\n\t\t\tpt.x -= endOffsetX;\n\t\t\tpt.y -= endOffsetY;\n\n\t\t\tvar f = (type != mxConstants.ARROW_CLASSIC && type != mxConstants.ARROW_CLASSIC_THIN) ? 1 : 3 / 4;\n\t\t\tpe.x += -unitX * f - endOffsetX;\n\t\t\tpe.y += -unitY * f - endOffsetY;\n\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tcanvas.begin();\n\t\t\t\tcanvas.moveTo(pt.x, pt.y);\n\t\t\t\tcanvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n\n\t\t\t\tif (type == mxConstants.ARROW_CLASSIC || type == mxConstants.ARROW_CLASSIC_THIN)\n\t\t\t\t{\n\t\t\t\t\tcanvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);\n\t\t\t\t}\n\n\t\t\t\tcanvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n\t\t\t\tcanvas.close();\n\n\t\t\t\tif (filled)\n\t\t\t\t{\n\t\t\t\t\tcanvas.fillAndStroke();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcanvas.stroke();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\tmxMarker.addMarker('classic', createArrow(2));\n\tmxMarker.addMarker('classicThin', createArrow(3));\n\tmxMarker.addMarker('block', createArrow(2));\n\tmxMarker.addMarker('blockThin', createArrow(3));\n\n\tfunction createOpenArrow(widthFactor)\n\t{\n\t\twidthFactor = (widthFactor != null) ? widthFactor : 2;\n\n\t\treturn function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t\t{\n\t\t\t// The angle of the forward facing arrow sides against the x axis is\n\t\t\t// 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n\t\t\t// only half the strokewidth is processed ).\n\t\t\tvar endOffsetX = unitX * sw * 1.118;\n\t\t\tvar endOffsetY = unitY * sw * 1.118;\n\n\t\t\tunitX = unitX * (size + sw);\n\t\t\tunitY = unitY * (size + sw);\n\n\t\t\tvar pt = pe.clone();\n\t\t\tpt.x -= endOffsetX;\n\t\t\tpt.y -= endOffsetY;\n\n\t\t\tpe.x += -endOffsetX * 2;\n\t\t\tpe.y += -endOffsetY * 2;\n\n\t\t\treturn function()\n\t\t\t{\n\t\t\t\tcanvas.begin();\n\t\t\t\tcanvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n\t\t\t\tcanvas.lineTo(pt.x, pt.y);\n\t\t\t\tcanvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n\t\t\t\tcanvas.stroke();\n\t\t\t};\n\t\t}\n\t};\n\n\tmxMarker.addMarker('open', createOpenArrow(2));\n\tmxMarker.addMarker('openThin', createOpenArrow(3));\n\n\tmxMarker.addMarker('oval', function(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t{\n\t\tvar a = size / 2;\n\n\t\tvar pt = pe.clone();\n\t\tpe.x -= unitX * a;\n\t\tpe.y -= unitY * a;\n\n\t\treturn function()\n\t\t{\n\t\t\tcanvas.ellipse(pt.x - a, pt.y - a, size, size);\n\n\t\t\tif (filled)\n\t\t\t{\n\t\t\t\tcanvas.fillAndStroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.stroke();\n\t\t\t}\n\t\t};\n\t});\n\n\tfunction diamond(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)\n\t{\n\t\t// The angle of the forward facing arrow sides against the x axis is\n\t\t// 45 degrees, 1/sin(45) = 1.4142 / 2 = 0.7071 ( / 2 allows for\n\t\t// only half the strokewidth is processed ). Or 0.9862 for thin diamond.\n\t\t// Note these values and the tk variable below are dependent, update\n\t\t// both together (saves trig hard coding it).\n\t\tvar swFactor = (type == mxConstants.ARROW_DIAMOND) ?  0.7071 : 0.9862;\n\t\tvar endOffsetX = unitX * sw * swFactor;\n\t\tvar endOffsetY = unitY * sw * swFactor;\n\n\t\tunitX = unitX * (size + sw);\n\t\tunitY = unitY * (size + sw);\n\n\t\tvar pt = pe.clone();\n\t\tpt.x -= endOffsetX;\n\t\tpt.y -= endOffsetY;\n\n\t\tpe.x += -unitX - endOffsetX;\n\t\tpe.y += -unitY - endOffsetY;\n\n\t\t// thickness factor for diamond\n\t\tvar tk = ((type == mxConstants.ARROW_DIAMOND) ?  2 : 3.4);\n\n\t\treturn function()\n\t\t{\n\t\t\tcanvas.begin();\n\t\t\tcanvas.moveTo(pt.x, pt.y);\n\t\t\tcanvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);\n\t\t\tcanvas.lineTo(pt.x - unitX, pt.y - unitY);\n\t\t\tcanvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);\n\t\t\tcanvas.close();\n\n\t\t\tif (filled)\n\t\t\t{\n\t\t\t\tcanvas.fillAndStroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.stroke();\n\t\t\t}\n\t\t};\n\t};\n\n\tmxMarker.addMarker('diamond', diamond);\n\tmxMarker.addMarker('diamondThin', diamond);\n})();\n\n__mxOutput.mxMarker = typeof mxMarker !== 'undefined' ? mxMarker : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxActor\n *\n * Extends <mxShape> to implement an actor shape. If a custom shape with one\n * filled area is needed, then this shape's <redrawPath> should be overridden.\n *\n * Example:\n *\n * (code)\n * function SampleShape() { }\n *\n * SampleShape.prototype = new mxActor();\n * SampleShape.prototype.constructor = vsAseShape;\n *\n * mxCellRenderer.registerShape('sample', SampleShape);\n * SampleShape.prototype.redrawPath = function(path, x, y, w, h)\n * {\n *   path.moveTo(0, 0);\n *   path.lineTo(w, h);\n *   // ...\n *   path.close();\n * }\n * (end)\n *\n * This shape is registered under <mxConstants.SHAPE_ACTOR> in\n * <mxCellRenderer>.\n *\n * Constructor: mxActor\n *\n * Constructs a new actor shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxActor(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxActor, mxShape);\n\n/**\n * Function: paintVertexShape\n *\n * Redirects to redrawPath for subclasses to work.\n */\nmxActor.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tc.translate(x, y);\n\tc.begin();\n\tthis.redrawPath(c, x, y, w, h);\n\tc.fillAndStroke();\n};\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxActor.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tvar width = w/3;\n\tc.moveTo(0, h);\n\tc.curveTo(0, 3 * h / 5, 0, 2 * h / 5, w / 2, 2 * h / 5);\n\tc.curveTo(w / 2 - width, 2 * h / 5, w / 2 - width, 0, w / 2, 0);\n\tc.curveTo(w / 2 + width, 0, w / 2 + width, 2 * h / 5, w / 2, 2 * h / 5);\n\tc.curveTo(w, 2 * h / 5, w, 3 * h / 5, w, h);\n\tc.close();\n};\n\n__mxOutput.mxActor = typeof mxActor !== 'undefined' ? mxActor : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCloud\n *\n * Extends <mxActor> to implement a cloud shape.\n *\n * This shape is registered under <mxConstants.SHAPE_CLOUD> in\n * <mxCellRenderer>.\n *\n * Constructor: mxCloud\n *\n * Constructs a new cloud shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxCloud(bounds, fill, stroke, strokewidth)\n{\n\tmxActor.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxActor.\n */\nmxUtils.extend(mxCloud, mxActor);\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxCloud.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tc.moveTo(0.25 * w, 0.25 * h);\n\tc.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);\n\tc.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);\n\tc.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);\n\tc.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);\n\tc.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);\n\tc.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);\n\tc.close();\n};\n\n__mxOutput.mxCloud = typeof mxCloud !== 'undefined' ? mxCloud : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRectangleShape\n *\n * Extends <mxShape> to implement a rectangle shape.\n * This shape is registered under <mxConstants.SHAPE_RECTANGLE>\n * in <mxCellRenderer>.\n *\n * Constructor: mxRectangleShape\n *\n * Constructs a new rectangle shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxRectangleShape(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxRectangleShape, mxShape);\n\n/**\n * Function: isHtmlAllowed\n *\n * Returns true for non-rounded, non-rotated shapes with no glass gradient.\n */\nmxRectangleShape.prototype.isHtmlAllowed = function()\n{\n\tvar events = true;\n\n\tif (this.style != null)\n\t{\n\t\tevents = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1';\n\t}\n\n\treturn !this.isRounded && !this.glass && this.rotation == 0 && (events ||\n\t\t(this.fill != null && this.fill != mxConstants.NONE));\n};\n\n/**\n * Function: paintBackground\n *\n * Generic background painting implementation.\n */\nmxRectangleShape.prototype.paintBackground = function(c, x, y, w, h)\n{\n\tvar events = true;\n\n\tif (this.style != null)\n\t{\n\t\tevents = mxUtils.getValue(this.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1';\n\t}\n\n\tif (events || (this.fill != null && this.fill != mxConstants.NONE) ||\n\t\t(this.stroke != null && this.stroke != mxConstants.NONE))\n\t{\n\t\tif (!events && (this.fill == null || this.fill == mxConstants.NONE))\n\t\t{\n\t\t\tc.pointerEvents = false;\n\t\t}\n\n\t\tif (this.isRounded)\n\t\t{\n\t\t\tvar r = 0;\n\n\t\t\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')\n\t\t\t{\n\t\t\t\tr = Math.min(w / 2, Math.min(h / 2, mxUtils.getValue(this.style,\n\t\t\t\t\tmxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE,\n\t\t\t\t\tmxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n\t\t\t\tr = Math.min(w * f, h * f);\n\t\t\t}\n\n\t\t\tc.roundrect(x, y, w, h, r, r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.rect(x, y, w, h);\n\t\t}\n\n\t\tc.fillAndStroke();\n\t}\n};\n\n/**\n * Function: isRoundable\n *\n * Adds roundable support.\n */\nmxRectangleShape.prototype.isRoundable = function(c, x, y, w, h)\n{\n\treturn true;\n};\n\n/**\n * Function: paintForeground\n *\n * Generic background painting implementation.\n */\nmxRectangleShape.prototype.paintForeground = function(c, x, y, w, h)\n{\n\tif (this.glass && !this.outline && this.fill != null && this.fill != mxConstants.NONE)\n\t{\n\t\tthis.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokewidth, h + this.strokewidth));\n\t}\n};\n\n__mxOutput.mxRectangleShape = typeof mxRectangleShape !== 'undefined' ? mxRectangleShape : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEllipse\n *\n * Extends <mxShape> to implement an ellipse shape.\n * This shape is registered under <mxConstants.SHAPE_ELLIPSE>\n * in <mxCellRenderer>.\n *\n * Constructor: mxEllipse\n *\n * Constructs a new ellipse shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxEllipse(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxEllipse, mxShape);\n\n/**\n * Function: paintVertexShape\n *\n * Paints the ellipse shape.\n */\nmxEllipse.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tc.ellipse(x, y, w, h);\n\tc.fillAndStroke();\n};\n\n__mxOutput.mxEllipse = typeof mxEllipse !== 'undefined' ? mxEllipse : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDoubleEllipse\n *\n * Extends <mxShape> to implement a double ellipse shape. This shape is\n * registered under <mxConstants.SHAPE_DOUBLE_ELLIPSE> in <mxCellRenderer>.\n * Use the following override to only fill the inner ellipse in this shape:\n *\n * (code)\n * mxDoubleEllipse.prototype.paintVertexShape = function(c, x, y, w, h)\n * {\n *   c.ellipse(x, y, w, h);\n *   c.stroke();\n *\n *   var inset = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));\n *   x += inset;\n *   y += inset;\n *   w -= 2 * inset;\n *   h -= 2 * inset;\n *\n *   if (w > 0 && h > 0)\n *   {\n *     c.ellipse(x, y, w, h);\n *   }\n *\n *   c.fillAndStroke();\n * };\n * (end)\n *\n * Constructor: mxDoubleEllipse\n *\n * Constructs a new ellipse shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxDoubleEllipse(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxDoubleEllipse, mxShape);\n\n/**\n * Variable: vmlScale\n *\n * Scale for improving the precision of VML rendering. Default is 10.\n */\nmxDoubleEllipse.prototype.vmlScale = 10;\n\n/**\n * Function: paintBackground\n *\n * Paints the background.\n */\nmxDoubleEllipse.prototype.paintBackground = function(c, x, y, w, h)\n{\n\tc.ellipse(x, y, w, h);\n\tc.fillAndStroke();\n};\n\n/**\n * Function: paintForeground\n *\n * Paints the foreground.\n */\nmxDoubleEllipse.prototype.paintForeground = function(c, x, y, w, h)\n{\n\tif (!this.outline)\n\t{\n\t\tvar margin = mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));\n\t\tx += margin;\n\t\ty += margin;\n\t\tw -= 2 * margin;\n\t\th -= 2 * margin;\n\n\t\t// FIXME: Rounding issues in IE8 standards mode (not in 1.x)\n\t\tif (w > 0 && h > 0)\n\t\t{\n\t\t\tc.ellipse(x, y, w, h);\n\t\t}\n\n\t\tc.stroke();\n\t}\n};\n\n/**\n * Function: getLabelBounds\n *\n * Returns the bounds for the label.\n */\nmxDoubleEllipse.prototype.getLabelBounds = function(rect)\n{\n\tvar margin = (mxUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth,\n\t\t\tMath.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale)))) * this.scale;\n\n\treturn new mxRectangle(rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);\n};\n\n__mxOutput.mxDoubleEllipse = typeof mxDoubleEllipse !== 'undefined' ? mxDoubleEllipse : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRhombus\n *\n * Extends <mxShape> to implement a rhombus (aka diamond) shape.\n * This shape is registered under <mxConstants.SHAPE_RHOMBUS>\n * in <mxCellRenderer>.\n *\n * Constructor: mxRhombus\n *\n * Constructs a new rhombus shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxRhombus(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxRhombus, mxShape);\n\n/**\n * Function: isRoundable\n *\n * Adds roundable support.\n */\nmxRhombus.prototype.isRoundable = function()\n{\n\treturn true;\n};\n\n/**\n * Function: paintVertexShape\n *\n * Generic painting implementation.\n */\nmxRhombus.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tvar hw = w / 2;\n\tvar hh = h / 2;\n\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tc.begin();\n\tthis.addPoints(c, [new mxPoint(x + hw, y), new mxPoint(x + w, y + hh), new mxPoint(x + hw, y + h),\n\t     new mxPoint(x, y + hh)], this.isRounded, arcSize, true);\n\tc.fillAndStroke();\n};\n\n__mxOutput.mxRhombus = typeof mxRhombus !== 'undefined' ? mxRhombus : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPolyline\n *\n * Extends <mxShape> to implement a polyline (a line with multiple points).\n * This shape is registered under <mxConstants.SHAPE_POLYLINE> in\n * <mxCellRenderer>.\n *\n * Constructor: mxPolyline\n *\n * Constructs a new polyline shape.\n *\n * Parameters:\n *\n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * stroke - String that defines the stroke color. Default is 'black'. This is\n * stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxPolyline(points, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.points = points;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxPolyline, mxShape);\n\n/**\n * Function: getRotation\n *\n * Returns 0.\n */\nmxPolyline.prototype.getRotation = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: getShapeRotation\n *\n * Returns 0.\n */\nmxPolyline.prototype.getShapeRotation = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: isPaintBoundsInverted\n *\n * Returns false.\n */\nmxPolyline.prototype.isPaintBoundsInverted = function()\n{\n\treturn false;\n};\n\n/**\n * Function: paintEdgeShape\n *\n * Paints the line shape.\n */\nmxPolyline.prototype.paintEdgeShape = function(c, pts)\n{\n\tvar prev = c.pointerEventsValue;\n\tc.pointerEventsValue = 'stroke';\n\n\tif (this.style == null || this.style[mxConstants.STYLE_CURVED] != 1)\n\t{\n\t\tthis.paintLine(c, pts, this.isRounded);\n\t}\n\telse\n\t{\n\t\tthis.paintCurvedLine(c, pts);\n\t}\n\n\tc.pointerEventsValue = prev;\n};\n\n/**\n * Function: paintLine\n *\n * Paints the line shape.\n */\nmxPolyline.prototype.paintLine = function(c, pts, rounded)\n{\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tc.begin();\n\tthis.addPoints(c, pts, rounded, arcSize, false);\n\tc.stroke();\n};\n\n/**\n * Function: paintLine\n *\n * Paints the line shape.\n */\nmxPolyline.prototype.paintCurvedLine = function(c, pts)\n{\n\tc.begin();\n\n\tvar pt = pts[0];\n\tvar n = pts.length;\n\n\tc.moveTo(pt.x, pt.y);\n\n\tfor (var i = 1; i < n - 2; i++)\n\t{\n\t\tvar p0 = pts[i];\n\t\tvar p1 = pts[i + 1];\n\t\tvar ix = (p0.x + p1.x) / 2;\n\t\tvar iy = (p0.y + p1.y) / 2;\n\n\t\tc.quadTo(p0.x, p0.y, ix, iy);\n\t}\n\n\tvar p0 = pts[n - 2];\n\tvar p1 = pts[n - 1];\n\n\tc.quadTo(p0.x, p0.y, p1.x, p1.y);\n\tc.stroke();\n};\n\n__mxOutput.mxPolyline = typeof mxPolyline !== 'undefined' ? mxPolyline : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxArrow\n *\n * Extends <mxShape> to implement an arrow shape. (The shape\n * is used to represent edges, not vertices.)\n * This shape is registered under <mxConstants.SHAPE_ARROW>\n * in <mxCellRenderer>.\n *\n * Constructor: mxArrow\n *\n * Constructs a new arrow shape.\n *\n * Parameters:\n *\n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n * arrowWidth - Optional integer that defines the arrow width. Default is\n * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\n * spacing - Optional integer that defines the spacing between the arrow shape\n * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\n * <spacing>.\n * endSize - Optional integer that defines the size of the arrowhead. Default\n * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\n */\nfunction mxArrow(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize)\n{\n\tmxShape.call(this);\n\tthis.points = points;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n\tthis.arrowWidth = (arrowWidth != null) ? arrowWidth : mxConstants.ARROW_WIDTH;\n\tthis.spacing = (spacing != null) ? spacing : mxConstants.ARROW_SPACING;\n\tthis.endSize = (endSize != null) ? endSize : mxConstants.ARROW_SIZE;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxArrow, mxShape);\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the edge width and markers.\n */\nmxArrow.prototype.augmentBoundingBox = function(bbox)\n{\n\tmxShape.prototype.augmentBoundingBox.apply(this, arguments);\n\n\tvar w = Math.max(this.arrowWidth, this.endSize);\n\tbbox.grow((w / 2 + this.strokewidth) * this.scale);\n};\n\n/**\n * Function: paintEdgeShape\n *\n * Paints the line shape.\n */\nmxArrow.prototype.paintEdgeShape = function(c, pts)\n{\n\t// Geometry of arrow\n\tvar spacing =  mxConstants.ARROW_SPACING;\n\tvar width = mxConstants.ARROW_WIDTH;\n\tvar arrow = mxConstants.ARROW_SIZE;\n\n\t// Base vector (between end points)\n\tvar p0 = pts[0];\n\tvar pe = pts[pts.length - 1];\n\tvar dx = pe.x - p0.x;\n\tvar dy = pe.y - p0.y;\n\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\tvar length = dist - 2 * spacing - arrow;\n\n\t// Computes the norm and the inverse norm\n\tvar nx = dx / dist;\n\tvar ny = dy / dist;\n\tvar basex = length * nx;\n\tvar basey = length * ny;\n\tvar floorx = width * ny/3;\n\tvar floory = -width * nx/3;\n\n\t// Computes points\n\tvar p0x = p0.x - floorx / 2 + spacing * nx;\n\tvar p0y = p0.y - floory / 2 + spacing * ny;\n\tvar p1x = p0x + floorx;\n\tvar p1y = p0y + floory;\n\tvar p2x = p1x + basex;\n\tvar p2y = p1y + basey;\n\tvar p3x = p2x + floorx;\n\tvar p3y = p2y + floory;\n\t// p4 not necessary\n\tvar p5x = p3x - 3 * floorx;\n\tvar p5y = p3y - 3 * floory;\n\n\tc.begin();\n\tc.moveTo(p0x, p0y);\n\tc.lineTo(p1x, p1y);\n\tc.lineTo(p2x, p2y);\n\tc.lineTo(p3x, p3y);\n\tc.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);\n\tc.lineTo(p5x, p5y);\n\tc.lineTo(p5x + floorx, p5y + floory);\n\tc.close();\n\n\tc.fillAndStroke();\n};\n\n__mxOutput.mxArrow = typeof mxArrow !== 'undefined' ? mxArrow : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxArrowConnector\n *\n * Extends <mxShape> to implement an new rounded arrow shape with support for\n * waypoints and double arrows. (The shape is used to represent edges, not\n * vertices.) This shape is registered under <mxConstants.SHAPE_ARROW_CONNECTOR>\n * in <mxCellRenderer>.\n *\n * Constructor: mxArrowConnector\n *\n * Constructs a new arrow shape.\n *\n * Parameters:\n *\n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n * arrowWidth - Optional integer that defines the arrow width. Default is\n * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\n * spacing - Optional integer that defines the spacing between the arrow shape\n * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\n * <spacing>.\n * endSize - Optional integer that defines the size of the arrowhead. Default\n * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\n */\nfunction mxArrowConnector(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize)\n{\n\tmxShape.call(this);\n\tthis.points = points;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n\tthis.arrowWidth = (arrowWidth != null) ? arrowWidth : mxConstants.ARROW_WIDTH;\n\tthis.arrowSpacing = (spacing != null) ? spacing : mxConstants.ARROW_SPACING;\n\tthis.startSize = mxConstants.ARROW_SIZE / 5;\n\tthis.endSize = mxConstants.ARROW_SIZE / 5;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxArrowConnector, mxShape);\n\n/**\n * Variable: useSvgBoundingBox\n *\n * Allows to use the SVG bounding box in SVG. Default is false for performance\n * reasons.\n */\nmxArrowConnector.prototype.useSvgBoundingBox = true;\n\n/**\n * Variable: resetStyles\n *\n * Overrides mxShape to reset spacing.\n */\nmxArrowConnector.prototype.resetStyles = function()\n{\n\tmxShape.prototype.resetStyles.apply(this, arguments);\n\n\tthis.arrowSpacing = mxConstants.ARROW_SPACING;\n};\n\n/**\n * Overrides apply to get smooth transition from default start- and endsize.\n */\nmxArrowConnector.prototype.apply = function(state)\n{\n\tmxShape.prototype.apply.apply(this, arguments);\n\n\tif (this.style != null)\n\t{\n\t\tthis.startSize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5) * 3;\n\t\tthis.endSize = mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5) * 3;\n\t}\n};\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the edge width and markers.\n */\nmxArrowConnector.prototype.augmentBoundingBox = function(bbox)\n{\n\tmxShape.prototype.augmentBoundingBox.apply(this, arguments);\n\n\tvar w = this.getEdgeWidth();\n\n\tif (this.isMarkerStart())\n\t{\n\t\tw = Math.max(w, this.getStartArrowWidth());\n\t}\n\n\tif (this.isMarkerEnd())\n\t{\n\t\tw = Math.max(w, this.getEndArrowWidth());\n\t}\n\n\tbbox.grow((w / 2 + this.strokewidth) * this.scale);\n};\n\n/**\n * Function: paintEdgeShape\n *\n * Paints the line shape.\n */\nmxArrowConnector.prototype.paintEdgeShape = function(c, pts)\n{\n\t// Geometry of arrow\n\tvar strokeWidth = this.strokewidth;\n\n\tif (this.outline)\n\t{\n\t\tstrokeWidth = Math.max(1, mxUtils.getNumber(this.style, mxConstants.STYLE_STROKEWIDTH, this.strokewidth));\n\t}\n\n\tvar startWidth = this.getStartArrowWidth() + strokeWidth;\n\tvar endWidth = this.getEndArrowWidth() + strokeWidth;\n\tvar edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();\n\tvar openEnded = this.isOpenEnded();\n\tvar markerStart = this.isMarkerStart();\n\tvar markerEnd = this.isMarkerEnd();\n\tvar spacing = (openEnded) ? 0 : this.arrowSpacing + strokeWidth / 2;\n\tvar startSize = this.startSize + strokeWidth;\n\tvar endSize = this.endSize + strokeWidth;\n\tvar isRounded = this.isArrowRounded();\n\n\t// Base vector (between first points)\n\tvar pe = pts[pts.length - 1];\n\n\t// Finds first non-overlapping point\n\tvar i0 = 1;\n\n\twhile (i0 < pts.length - 1 && pts[i0].x == pts[0].x && pts[i0].y == pts[0].y)\n\t{\n\t\ti0++;\n\t}\n\n\tvar dx = pts[i0].x - pts[0].x;\n\tvar dy = pts[i0].y - pts[0].y;\n\tvar dist = Math.sqrt(dx * dx + dy * dy);\n\n\tif (dist == 0)\n\t{\n\t\treturn;\n\t}\n\n\t// Computes the norm and the inverse norm\n\tvar nx = dx / dist;\n\tvar nx2, nx1 = nx;\n\tvar ny = dy / dist;\n\tvar ny2, ny1 = ny;\n\tvar orthx = edgeWidth * ny;\n\tvar orthy = -edgeWidth * nx;\n\n\t// Stores the inbound function calls in reverse order in fns\n\tvar fns = [];\n\n\tif (isRounded)\n\t{\n\t\tc.setLineJoin('round');\n\t}\n\telse if (pts.length > 2)\n\t{\n\t\t// Only mitre if there are waypoints\n\t\tc.setMiterLimit(1.42);\n\t}\n\n\tc.begin();\n\n\tvar startNx = nx;\n\tvar startNy = ny;\n\n\tif (markerStart && !openEnded)\n\t{\n\t\tthis.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);\n\t}\n\telse\n\t{\n\t\tvar outStartX = pts[0].x + orthx / 2 + spacing * nx;\n\t\tvar outStartY = pts[0].y + orthy / 2 + spacing * ny;\n\t\tvar inEndX = pts[0].x - orthx / 2 + spacing * nx;\n\t\tvar inEndY = pts[0].y - orthy / 2 + spacing * ny;\n\n\t\tif (openEnded)\n\t\t{\n\t\t\tc.moveTo(outStartX, outStartY);\n\n\t\t\tfns.push(function()\n\t\t\t{\n\t\t\t\tc.lineTo(inEndX, inEndY);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.moveTo(inEndX, inEndY);\n\t\t\tc.lineTo(outStartX, outStartY);\n\t\t}\n\t}\n\n\tvar dx1 = 0;\n\tvar dy1 = 0;\n\tvar dist1 = 0;\n\n\tfor (var i = 0; i < pts.length - 2; i++)\n\t{\n\t\t// Work out in which direction the line is bending\n\t\tvar pos = mxUtils.relativeCcw(pts[i].x, pts[i].y, pts[i+1].x, pts[i+1].y, pts[i+2].x, pts[i+2].y);\n\n\t\tdx1 = pts[i+2].x - pts[i+1].x;\n\t\tdy1 = pts[i+2].y - pts[i+1].y;\n\n\t\tdist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n\n\t\tif (dist1 != 0)\n\t\t{\n\t\t\tnx1 = dx1 / dist1;\n\t\t\tny1 = dy1 / dist1;\n\n\t\t\tvar tmp1 = nx * nx1 + ny * ny1;\n\t\t\ttmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);\n\n\t\t\t// Work out the normal orthogonal to the line through the control point and the edge sides intersection\n\t\t\tnx2 = (nx + nx1);\n\t\t\tny2 = (ny + ny1);\n\n\t\t\tvar dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n\n\t\t\tif (dist2 != 0)\n\t\t\t{\n\t\t\t\tnx2 = nx2 / dist2;\n\t\t\t\tny2 = ny2 / dist2;\n\n\t\t\t\t// Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases\n\t\t\t\tvar strokeWidthFactor = Math.max(tmp, Math.min(this.strokewidth / 200 + 0.04, 0.35));\n\t\t\t\tvar angleFactor = (pos != 0 && isRounded) ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);\n\n\t\t\t\tvar outX = pts[i+1].x + ny2 * edgeWidth / 2 / angleFactor;\n\t\t\t\tvar outY = pts[i+1].y - nx2 * edgeWidth / 2 / angleFactor;\n\t\t\t\tvar inX = pts[i+1].x - ny2 * edgeWidth / 2 / angleFactor;\n\t\t\t\tvar inY = pts[i+1].y + nx2 * edgeWidth / 2 / angleFactor;\n\n\t\t\t\tif (pos == 0 || !isRounded)\n\t\t\t\t{\n\t\t\t\t\t// If the two segments are aligned, or if we're not drawing curved sections between segments\n\t\t\t\t\t// just draw straight to the intersection point\n\t\t\t\t\tc.lineTo(outX, outY);\n\n\t\t\t\t\t(function(x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.lineTo(x, y);\n\t\t\t\t\t\t});\n\t\t\t\t\t})(inX, inY);\n\t\t\t\t}\n\t\t\t\telse if (pos == -1)\n\t\t\t\t{\n\t\t\t\t\tvar c1x = inX + ny * edgeWidth;\n\t\t\t\t\tvar c1y = inY - nx * edgeWidth;\n\t\t\t\t\tvar c2x = inX + ny1 * edgeWidth;\n\t\t\t\t\tvar c2y = inY - nx1 * edgeWidth;\n\t\t\t\t\tc.lineTo(c1x, c1y);\n\t\t\t\t\tc.quadTo(outX, outY, c2x, c2y);\n\n\t\t\t\t\t(function(x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.lineTo(x, y);\n\t\t\t\t\t\t});\n\t\t\t\t\t})(inX, inY);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tc.lineTo(outX, outY);\n\n\t\t\t\t\t(function(x, y)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar c1x = outX - ny * edgeWidth;\n\t\t\t\t\t\tvar c1y = outY + nx * edgeWidth;\n\t\t\t\t\t\tvar c2x = outX - ny1 * edgeWidth;\n\t\t\t\t\t\tvar c2y = outY + nx1 * edgeWidth;\n\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.quadTo(x, y, c1x, c1y);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns.push(function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc.lineTo(c2x, c2y);\n\t\t\t\t\t\t});\n\t\t\t\t\t})(inX, inY);\n\t\t\t\t}\n\n\t\t\t\tnx = nx1;\n\t\t\t\tny = ny1;\n\t\t\t}\n\t\t}\n\t}\n\n\torthx = edgeWidth * ny1;\n\torthy = - edgeWidth * nx1;\n\n\tif (markerEnd && !openEnded)\n\t{\n\t\tthis.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);\n\t}\n\telse\n\t{\n\t\tc.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);\n\n\t\tvar inStartX = pe.x - spacing * nx1 - orthx / 2;\n\t\tvar inStartY = pe.y - spacing * ny1 - orthy / 2;\n\n\t\tif (!openEnded)\n\t\t{\n\t\t\tc.lineTo(inStartX, inStartY);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.moveTo(inStartX, inStartY);\n\n\t\t\tfns.splice(0, 0, function()\n\t\t\t{\n\t\t\t\tc.moveTo(inStartX, inStartY);\n\t\t\t});\n\t\t}\n\t}\n\n\tfor (var i = fns.length - 1; i >= 0; i--)\n\t{\n\t\tfns[i]();\n\t}\n\n\tif (openEnded)\n\t{\n\t\tc.end();\n\t\tc.stroke();\n\t}\n\telse\n\t{\n\t\tc.close();\n\t\tc.fillAndStroke();\n\t}\n\n\t// Workaround for shadow on top of base arrow\n\tc.setShadow(false);\n\n\t// Need to redraw the markers without the low miter limit\n\tc.setMiterLimit(4);\n\n\tif (isRounded)\n\t{\n\t\tc.setLineJoin('flat');\n\t}\n\n\tif (pts.length > 2)\n\t{\n\t\t// Only to repaint markers if no waypoints\n\t\t// Need to redraw the markers without the low miter limit\n\t\tc.setMiterLimit(4);\n\t\tif (markerStart && !openEnded)\n\t\t{\n\t\t\tc.begin();\n\t\t\tthis.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);\n\t\t\tc.stroke();\n\t\t\tc.end();\n\t\t}\n\n\t\tif (markerEnd && !openEnded)\n\t\t{\n\t\t\tc.begin();\n\t\t\tthis.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);\n\t\t\tc.stroke();\n\t\t\tc.end();\n\t\t}\n\t}\n};\n\n/**\n * Function: paintEdgeShape\n *\n * Paints the line shape.\n */\nmxArrowConnector.prototype.paintMarker = function(c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove)\n{\n\tvar widthArrowRatio = edgeWidth / arrowWidth;\n\tvar orthx = edgeWidth * ny / 2;\n\tvar orthy = -edgeWidth * nx / 2;\n\n\tvar spaceX = (spacing + size) * nx;\n\tvar spaceY = (spacing + size) * ny;\n\n\tif (initialMove)\n\t{\n\t\tc.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n\t}\n\telse\n\t{\n\t\tc.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n\t}\n\n\tc.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);\n\tc.lineTo(ptX + spacing * nx, ptY + spacing * ny);\n\tc.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);\n\tc.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);\n}\n\n/**\n * Function: isArrowRounded\n *\n * Returns wether the arrow is rounded\n */\nmxArrowConnector.prototype.isArrowRounded = function()\n{\n\treturn this.isRounded;\n};\n\n/**\n * Function: getStartArrowWidth\n *\n * Returns the width of the start arrow\n */\nmxArrowConnector.prototype.getStartArrowWidth = function()\n{\n\treturn mxConstants.ARROW_WIDTH;\n};\n\n/**\n * Function: getEndArrowWidth\n *\n * Returns the width of the end arrow\n */\nmxArrowConnector.prototype.getEndArrowWidth = function()\n{\n\treturn mxConstants.ARROW_WIDTH;\n};\n\n/**\n * Function: getEdgeWidth\n *\n * Returns the width of the body of the edge\n */\nmxArrowConnector.prototype.getEdgeWidth = function()\n{\n\treturn mxConstants.ARROW_WIDTH / 3;\n};\n\n/**\n * Function: isOpenEnded\n *\n * Returns whether the ends of the shape are drawn\n */\nmxArrowConnector.prototype.isOpenEnded = function()\n{\n\treturn false;\n};\n\n/**\n * Function: isMarkerStart\n *\n * Returns whether the start marker is drawn\n */\nmxArrowConnector.prototype.isMarkerStart = function()\n{\n\treturn (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE);\n};\n\n/**\n * Function: isMarkerEnd\n *\n * Returns whether the end marker is drawn\n */\nmxArrowConnector.prototype.isMarkerEnd = function()\n{\n\treturn (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE);\n};\n__mxOutput.mxArrowConnector = typeof mxArrowConnector !== 'undefined' ? mxArrowConnector : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxText\n *\n * Extends <mxShape> to implement a text shape. To change vertical text from\n * bottom to top to top to bottom, the following code can be used:\n *\n * (code)\n * mxText.prototype.verticalTextRotation = 90;\n * (end)\n *\n * Constructor: mxText\n *\n * Constructs a new text shape.\n *\n * Parameters:\n *\n * value - String that represents the text to be displayed. This is stored in\n * <value>.\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * align - Specifies the horizontal alignment. Default is ''. This is stored in\n * <align>.\n * valign - Specifies the vertical alignment. Default is ''. This is stored in\n * <valign>.\n * color - String that specifies the text color. Default is 'black'. This is\n * stored in <color>.\n * family - String that specifies the font family. Default is\n * <mxConstants.DEFAULT_FONTFAMILY>. This is stored in <family>.\n * size - Integer that specifies the font size. Default is\n * <mxConstants.DEFAULT_FONTSIZE>. This is stored in <size>.\n * fontStyle - Specifies the font style. Default is 0. This is stored in\n * <fontStyle>.\n * spacing - Integer that specifies the global spacing. Default is 2. This is\n * stored in <spacing>.\n * spacingTop - Integer that specifies the top spacing. Default is 0. The\n * sum of the spacing and this is stored in <spacingTop>.\n * spacingRight - Integer that specifies the right spacing. Default is 0. The\n * sum of the spacing and this is stored in <spacingRight>.\n * spacingBottom - Integer that specifies the bottom spacing. Default is 0.The\n * sum of the spacing and this is stored in <spacingBottom>.\n * spacingLeft - Integer that specifies the left spacing. Default is 0. The\n * sum of the spacing and this is stored in <spacingLeft>.\n * horizontal - Boolean that specifies if the label is horizontal. Default is\n * true. This is stored in <horizontal>.\n * background - String that specifies the background color. Default is null.\n * This is stored in <background>.\n * border - String that specifies the label border color. Default is null.\n * This is stored in <border>.\n * wrap - Specifies if word-wrapping should be enabled. Default is false.\n * This is stored in <wrap>.\n * clipped - Specifies if the label should be clipped. Default is false.\n * This is stored in <clipped>.\n * overflow - Value of the overflow style. Default is 'visible'.\n */\nfunction mxText(value, bounds, align, valign, color,\n\tfamily,\tsize, fontStyle, spacing, spacingTop, spacingRight,\n\tspacingBottom, spacingLeft, horizontal, background, border,\n\twrap, clipped, overflow, labelPadding, textDirection)\n{\n\tmxShape.call(this);\n\tthis.value = value;\n\tthis.bounds = bounds;\n\tthis.color = (color != null) ? color : 'black';\n\tthis.align = (align != null) ? align : mxConstants.ALIGN_CENTER;\n\tthis.valign = (valign != null) ? valign : mxConstants.ALIGN_MIDDLE;\n\tthis.family = (family != null) ? family : mxConstants.DEFAULT_FONTFAMILY;\n\tthis.size = (size != null) ? size : mxConstants.DEFAULT_FONTSIZE;\n\tthis.fontStyle = (fontStyle != null) ? fontStyle : mxConstants.DEFAULT_FONTSTYLE;\n\tthis.spacing = parseInt(spacing || 2);\n\tthis.spacingTop = this.spacing + parseInt(spacingTop || 0);\n\tthis.spacingRight = this.spacing + parseInt(spacingRight || 0);\n\tthis.spacingBottom = this.spacing + parseInt(spacingBottom || 0);\n\tthis.spacingLeft = this.spacing + parseInt(spacingLeft || 0);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.background = background;\n\tthis.border = border;\n\tthis.wrap = (wrap != null) ? wrap : false;\n\tthis.clipped = (clipped != null) ? clipped : false;\n\tthis.overflow = (overflow != null) ? overflow : 'visible';\n\tthis.labelPadding = (labelPadding != null) ? labelPadding : 0;\n\tthis.textDirection = textDirection;\n\tthis.rotation = 0;\n\tthis.updateMargin();\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxText, mxShape);\n\n/**\n * Variable: baseSpacingTop\n *\n * Specifies the spacing to be added to the top spacing. Default is 0. Use the\n * value 5 here to get the same label positions as in mxGraph 1.x.\n */\nmxText.prototype.baseSpacingTop = 0;\n\n/**\n * Variable: baseSpacingBottom\n *\n * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\n * value 1 here to get the same label positions as in mxGraph 1.x.\n */\nmxText.prototype.baseSpacingBottom = 0;\n\n/**\n * Variable: baseSpacingLeft\n *\n * Specifies the spacing to be added to the left spacing. Default is 0.\n */\nmxText.prototype.baseSpacingLeft = 0;\n\n/**\n * Variable: baseSpacingRight\n *\n * Specifies the spacing to be added to the right spacing. Default is 0.\n */\nmxText.prototype.baseSpacingRight = 0;\n\n/**\n * Variable: replaceLinefeeds\n *\n * Specifies if linefeeds in HTML labels should be replaced with BR tags.\n * Default is true.\n */\nmxText.prototype.replaceLinefeeds = true;\n\n/**\n * Variable: verticalTextRotation\n *\n * Rotation for vertical text. Default is -90 (bottom to top).\n */\nmxText.prototype.verticalTextRotation = -90;\n\n/**\n * Variable: ignoreClippedStringSize\n *\n * Specifies if the string size should be measured in <updateBoundingBox> if\n * the label is clipped and the label position is center and middle. If this is\n * true, then the bounding box will be set to <bounds>. Default is true.\n * <ignoreStringSize> has precedence over this switch.\n */\nmxText.prototype.ignoreClippedStringSize = true;\n\n/**\n * Variable: ignoreStringSize\n *\n * Specifies if the actual string size should be measured. If disabled the\n * boundingBox will not ignore the actual size of the string, otherwise\n * <bounds> will be used instead. Default is false.\n */\nmxText.prototype.ignoreStringSize = false;\n\n/**\n * Variable: textWidthPadding\n *\n * Specifies the padding to be added to the text width for the bounding box.\n * This is needed to make sure no clipping is applied to borders. Default is 4\n * for IE 8 standards mode and 3 for all others.\n */\nmxText.prototype.textWidthPadding = (document.documentMode == 8 && !mxClient.IS_EM) ? 4 : 3;\n\n/**\n * Variable: lastValue\n *\n * Contains the last rendered text value. Used for caching.\n */\nmxText.prototype.lastValue = null;\n\n/**\n * Variable: cacheEnabled\n *\n * Specifies if caching for HTML labels should be enabled. Default is true.\n */\nmxText.prototype.cacheEnabled = true;\n\n/**\n * Function: isParseVml\n *\n * Text shapes do not contain VML markup and do not need to be parsed. This\n * method returns false to speed up rendering in IE8.\n */\nmxText.prototype.isParseVml = function()\n{\n\treturn false;\n};\n\n/**\n * Function: isHtmlAllowed\n *\n * Returns true if HTML is allowed for this shape. This implementation returns\n * true if the browser is not in IE8 standards mode.\n */\nmxText.prototype.isHtmlAllowed = function()\n{\n\treturn document.documentMode != 8 || mxClient.IS_EM;\n};\n\n/**\n * Function: getSvgScreenOffset\n *\n * Disables offset in IE9 for crisper image output.\n */\nmxText.prototype.getSvgScreenOffset = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: checkBounds\n *\n * Returns true if the bounds are not null and all of its variables are numeric.\n */\nmxText.prototype.checkBounds = function()\n{\n\treturn (!isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 &&\n\t\t\tthis.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) &&\n\t\t\t!isNaN(this.bounds.width) && !isNaN(this.bounds.height));\n};\n\n/**\n * Function: paint\n *\n * Generic rendering code.\n */\nmxText.prototype.paint = function(c, update)\n{\n\t// Scale is passed-through to canvas\n\tvar s = this.scale;\n\tvar x = this.bounds.x / s;\n\tvar y = this.bounds.y / s;\n\tvar w = this.bounds.width / s;\n\tvar h = this.bounds.height / s;\n\n\tthis.updateTransform(c, x, y, w, h);\n\tthis.configureCanvas(c, x, y, w, h);\n\n\tvar unscaledWidth = (this.state != null) ? this.state.unscaledWidth : null;\n\n\tif (update)\n\t{\n\t\tif (this.node.firstChild != null && (unscaledWidth == null ||\n\t\t\tthis.lastUnscaledWidth != unscaledWidth))\n\t\t{\n\t\t\tc.invalidateCachedOffsetSize(this.node);\n\t\t}\n\n\t\tc.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow,\n\t\t\t\tthis.clipped, this.getTextRotation(), this.node);\n\t}\n\telse\n\t{\n\t\t// Checks if text contains HTML markup\n\t\tvar realHtml = mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML;\n\n\t\t// Always renders labels as HTML in VML\n\t\tvar fmt = (realHtml || c instanceof mxVmlCanvas2D) ? 'html' : '';\n\t\tvar val = this.value;\n\n\t\tif (!realHtml && fmt == 'html')\n\t\t{\n\t\t\tval =  mxUtils.htmlEntities(val, false);\n\t\t}\n\n\t\tif (fmt == 'html' && !mxUtils.isNode(this.value))\n\t\t{\n\t\t\tval = mxUtils.replaceTrailingNewlines(val, '<div><br></div>');\n\t\t}\n\n\t\t// Handles trailing newlines to make sure they are visible in rendering output\n\t\tval = (!mxUtils.isNode(this.value) && this.replaceLinefeeds && fmt == 'html') ?\n\t\t\tval.replace(/\\n/g, '<br/>') : val;\n\n\t\tvar dir = this.textDirection;\n\n\t\tif (dir == mxConstants.TEXT_DIRECTION_AUTO && !realHtml)\n\t\t{\n\t\t\tdir = this.getAutoDirection();\n\t\t}\n\n\t\tif (dir != mxConstants.TEXT_DIRECTION_LTR && dir != mxConstants.TEXT_DIRECTION_RTL)\n\t\t{\n\t\t\tdir = null;\n\t\t}\n\n\t\tc.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow,\n\t\t\tthis.clipped, this.getTextRotation(), dir);\n\t}\n\n\t// Needs to invalidate the cached offset widths if the geometry changes\n\tthis.lastUnscaledWidth = unscaledWidth;\n};\n\n/**\n * Function: redraw\n *\n * Renders the text using the given DOM nodes.\n */\nmxText.prototype.redraw = function()\n{\n\tif (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue == this.value &&\n\t\t(mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML))\n\t{\n\t\tif (this.node.nodeName == 'DIV' && (this.isHtmlAllowed() || !mxClient.IS_VML))\n\t\t{\n\t\t\tthis.updateSize(this.node, (this.state == null || this.state.view.textDiv == null));\n\n\t\t\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode <= 8))\n\t\t\t{\n\t\t\t\tthis.updateHtmlFilter();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.updateHtmlTransform();\n\t\t\t}\n\n\t\t\tthis.updateBoundingBox();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar canvas = this.createCanvas();\n\n\t\t\tif (canvas != null && canvas.updateText != null &&\n\t\t\t\tcanvas.invalidateCachedOffsetSize != null)\n\t\t\t{\n\t\t\t\tthis.paint(canvas, true);\n\t\t\t\tthis.destroyCanvas(canvas);\n\t\t\t\tthis.updateBoundingBox();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Fallback if canvas does not support updateText (VML)\n\t\t\t\tmxShape.prototype.redraw.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tmxShape.prototype.redraw.apply(this, arguments);\n\n\t\tif (mxUtils.isNode(this.value) || this.dialect == mxConstants.DIALECT_STRICTHTML)\n\t\t{\n\t\t\tthis.lastValue = this.value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.lastValue = null;\n\t\t}\n\t}\n};\n\n/**\n * Function: resetStyles\n *\n * Resets all styles.\n */\nmxText.prototype.resetStyles = function()\n{\n\tmxShape.prototype.resetStyles.apply(this, arguments);\n\n\tthis.color = 'black';\n\tthis.align = mxConstants.ALIGN_CENTER;\n\tthis.valign = mxConstants.ALIGN_MIDDLE;\n\tthis.family = mxConstants.DEFAULT_FONTFAMILY;\n\tthis.size = mxConstants.DEFAULT_FONTSIZE;\n\tthis.fontStyle = mxConstants.DEFAULT_FONTSTYLE;\n\tthis.spacing = 2;\n\tthis.spacingTop = 2;\n\tthis.spacingRight = 2;\n\tthis.spacingBottom = 2;\n\tthis.spacingLeft = 2;\n\tthis.horizontal = true;\n\tdelete this.background;\n\tdelete this.border;\n\tthis.textDirection = mxConstants.DEFAULT_TEXT_DIRECTION;\n\tdelete this.margin;\n};\n\n/**\n * Function: apply\n *\n * Extends mxShape to update the text styles.\n *\n * Parameters:\n *\n * state - <mxCellState> of the corresponding cell.\n */\nmxText.prototype.apply = function(state)\n{\n\tvar old = this.spacing;\n\tmxShape.prototype.apply.apply(this, arguments);\n\n\tif (this.style != null)\n\t{\n\t\tthis.fontStyle = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSTYLE, this.fontStyle);\n\t\tthis.family = mxUtils.getValue(this.style, mxConstants.STYLE_FONTFAMILY, this.family);\n\t\tthis.size = mxUtils.getValue(this.style, mxConstants.STYLE_FONTSIZE, this.size);\n\t\tthis.color = mxUtils.getValue(this.style, mxConstants.STYLE_FONTCOLOR, this.color);\n\t\tthis.align = mxUtils.getValue(this.style, mxConstants.STYLE_ALIGN, this.align);\n\t\tthis.valign = mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_ALIGN, this.valign);\n\t\tthis.spacing = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING, this.spacing));\n\t\tthis.spacingTop = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_TOP, this.spacingTop - old)) + this.spacing;\n\t\tthis.spacingRight = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_RIGHT, this.spacingRight - old)) + this.spacing;\n\t\tthis.spacingBottom = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_BOTTOM, this.spacingBottom - old)) + this.spacing;\n\t\tthis.spacingLeft = parseInt(mxUtils.getValue(this.style, mxConstants.STYLE_SPACING_LEFT, this.spacingLeft - old)) + this.spacing;\n\t\tthis.horizontal = mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, this.horizontal);\n\t\tthis.background = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, this.background);\n\t\tthis.border = mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_BORDERCOLOR, this.border);\n\t\tthis.textDirection = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);\n\t\tthis.opacity = mxUtils.getValue(this.style, mxConstants.STYLE_TEXT_OPACITY, 100);\n\t\tthis.updateMargin();\n\t}\n\n\tthis.flipV = null;\n\tthis.flipH = null;\n};\n\n/**\n * Function: getAutoDirection\n *\n * Used to determine the automatic text direction. Returns\n * <mxConstants.TEXT_DIRECTION_LTR> or <mxConstants.TEXT_DIRECTION_RTL>\n * depending on the contents of <value>. This is not invoked for HTML, wrapped\n * content or if <value> is a DOM node.\n */\nmxText.prototype.getAutoDirection = function()\n{\n\t// Looks for strong (directional) characters\n\tvar tmp = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(this.value);\n\n\t// Returns the direction defined by the character\n\treturn (tmp != null && tmp.length > 0 && tmp[0] > 'z') ?\n\t\tmxConstants.TEXT_DIRECTION_RTL : mxConstants.TEXT_DIRECTION_LTR;\n};\n\n/**\n * Function: updateBoundingBox\n *\n * Updates the <boundingBox> for this shape using the given node and position.\n */\nmxText.prototype.updateBoundingBox = function()\n{\n\tvar node = this.node;\n\tthis.boundingBox = this.bounds.clone();\n\tvar rot = this.getTextRotation();\n\n\tvar h = (this.style != null) ? mxUtils.getValue(this.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER) : null;\n\tvar v = (this.style != null) ? mxUtils.getValue(this.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE) : null;\n\n\tif (!this.ignoreStringSize && node != null && this.overflow != 'fill' && (!this.clipped ||\n\t\t!this.ignoreClippedStringSize || h != mxConstants.ALIGN_CENTER || v != mxConstants.ALIGN_MIDDLE))\n\t{\n\t\tvar ow = null;\n\t\tvar oh = null;\n\n\t\tif (node.ownerSVGElement != null)\n\t\t{\n\t\t\tif (node.firstChild != null && node.firstChild.firstChild != null &&\n\t\t\t\tnode.firstChild.firstChild.nodeName == 'foreignObject')\n\t\t\t{\n\t\t\t\tnode = node.firstChild.firstChild;\n\t\t\t\tow = parseInt(node.getAttribute('width')) * this.scale;\n\t\t\t\toh = parseInt(node.getAttribute('height')) * this.scale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar b = node.getBBox();\n\n\t\t\t\t\t// Workaround for bounding box of empty string\n\t\t\t\t\tif (typeof(this.value) == 'string' && mxUtils.trim(this.value) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if (b.width == 0 && b.height == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.boundingBox = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.boundingBox = new mxRectangle(b.x, b.y, b.width, b.height);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// Ignores NS_ERROR_FAILURE in FF if container display is none.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar td = (this.state != null) ? this.state.view.textDiv : null;\n\n\t\t\t// Use cached offset size\n\t\t\tif (this.offsetWidth != null && this.offsetHeight != null)\n\t\t\t{\n\t\t\t\tow = this.offsetWidth * this.scale;\n\t\t\t\toh = this.offsetHeight * this.scale;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Cannot get node size while container hidden so a\n\t\t\t\t// shared temporary DIV is used for text measuring\n\t\t\t\tif (td != null)\n\t\t\t\t{\n\t\t\t\t\tthis.updateFont(td);\n\t\t\t\t\tthis.updateSize(td, false);\n\t\t\t\t\tthis.updateInnerHtml(td);\n\n\t\t\t\t\tnode = td;\n\t\t\t\t}\n\n\t\t\t\tvar sizeDiv = node;\n\n\t\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t\t{\n\t\t\t\t\tvar w = Math.round(this.bounds.width / this.scale);\n\n\t\t\t\t\tif (this.wrap && w > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\t\t\tnode.style.whiteSpace = 'normal';\n\n\t\t\t\t\t\tif (node.style.wordWrap != 'break-word')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Innermost DIV is used for measuring text\n\t\t\t\t\t\t\tvar divs = sizeDiv.getElementsByTagName('div');\n\n\t\t\t\t\t\t\tif (divs.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsizeDiv = divs[divs.length - 1];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tow = sizeDiv.offsetWidth + 2;\n\t\t\t\t\t\t\tdivs = this.node.getElementsByTagName('div');\n\n\t\t\t\t\t\t\tif (this.clipped)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tow = Math.min(w, ow);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Second last DIV width must be updated in DOM tree\n\t\t\t\t\t\t\tif (divs.length > 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdivs[divs.length - 2].style.width = ow + 'px';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.style.whiteSpace = 'nowrap';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t\t\t{\n\t\t\t\t\tsizeDiv = sizeDiv.firstChild;\n\t\t\t\t}\n\n\t\t\t\tthis.offsetWidth = sizeDiv.offsetWidth + this.textWidthPadding;\n\t\t\t\tthis.offsetHeight = sizeDiv.offsetHeight;\n\n\t\t\t\tow = this.offsetWidth * this.scale;\n\t\t\t\toh = this.offsetHeight * this.scale;\n\t\t\t}\n\t\t}\n\n\t\tif (ow != null && oh != null)\n\t\t{\n\t\t\tthis.boundingBox = new mxRectangle(this.bounds.x,\n\t\t\t\tthis.bounds.y, ow, oh);\n\t\t}\n\t}\n\n\tif (this.boundingBox != null)\n\t{\n\t\tif (rot != 0)\n\t\t{\n\t\t\t// Accounts for pre-rotated x and y\n\t\t\tvar bbox = mxUtils.getBoundingBox(new mxRectangle(\n\t\t\t\tthis.margin.x * this.boundingBox.width,\n\t\t\t\tthis.margin.y * this.boundingBox.height,\n\t\t\t\tthis.boundingBox.width, this.boundingBox.height),\n\t\t\t\trot, new mxPoint(0, 0));\n\n\t\t\tthis.unrotatedBoundingBox = mxRectangle.fromRectangle(this.boundingBox);\n\t\t\tthis.unrotatedBoundingBox.x += this.margin.x * this.unrotatedBoundingBox.width;\n\t\t\tthis.unrotatedBoundingBox.y += this.margin.y * this.unrotatedBoundingBox.height;\n\n\t\t\tthis.boundingBox.x += bbox.x;\n\t\t\tthis.boundingBox.y += bbox.y;\n\t\t\tthis.boundingBox.width = bbox.width;\n\t\t\tthis.boundingBox.height = bbox.height;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.boundingBox.x += this.margin.x * this.boundingBox.width;\n\t\t\tthis.boundingBox.y += this.margin.y * this.boundingBox.height;\n\t\t\tthis.unrotatedBoundingBox = null;\n\t\t}\n\t}\n};\n\n/**\n * Function: getShapeRotation\n *\n * Returns 0 to avoid using rotation in the canvas via updateTransform.\n */\nmxText.prototype.getShapeRotation = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: getTextRotation\n *\n * Returns the rotation for the text label of the corresponding shape.\n */\nmxText.prototype.getTextRotation = function()\n{\n\treturn (this.state != null && this.state.shape != null) ? this.state.shape.getTextRotation() : 0;\n};\n\n/**\n * Function: isPaintBoundsInverted\n *\n * Inverts the bounds if <mxShape.isBoundsInverted> returns true or if the\n * horizontal style is false.\n */\nmxText.prototype.isPaintBoundsInverted = function()\n{\n\treturn !this.horizontal && this.state != null && this.state.view.graph.model.isVertex(this.state.cell);\n};\n\n/**\n * Function: configureCanvas\n *\n * Sets the state of the canvas for drawing the shape.\n */\nmxText.prototype.configureCanvas = function(c, x, y, w, h)\n{\n\tmxShape.prototype.configureCanvas.apply(this, arguments);\n\n\tc.setFontColor(this.color);\n\tc.setFontBackgroundColor(this.background);\n\tc.setFontBorderColor(this.border);\n\tc.setFontFamily(this.family);\n\tc.setFontSize(this.size);\n\tc.setFontStyle(this.fontStyle);\n};\n\n/**\n * Function: updateVmlContainer\n *\n * Sets the width and height of the container to 1px.\n */\nmxText.prototype.updateVmlContainer = function()\n{\n\tthis.node.style.left = Math.round(this.bounds.x) + 'px';\n\tthis.node.style.top = Math.round(this.bounds.y) + 'px';\n\tthis.node.style.width = '1px';\n\tthis.node.style.height = '1px';\n\tthis.node.style.overflow = 'visible';\n};\n\n/**\n * Function: redrawHtmlShape\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.redrawHtmlShape = function()\n{\n\tvar style = this.node.style;\n\n\t// Resets CSS styles\n\tstyle.whiteSpace = 'normal';\n\tstyle.overflow = '';\n\tstyle.width = '';\n\tstyle.height = '';\n\n\tthis.updateValue();\n\tthis.updateFont(this.node);\n\tthis.updateSize(this.node, (this.state == null || this.state.view.textDiv == null));\n\n\tthis.offsetWidth = null;\n\tthis.offsetHeight = null;\n\n\tif (mxClient.IS_IE && (document.documentMode == null || document.documentMode <= 8))\n\t{\n\t\tthis.updateHtmlFilter();\n\t}\n\telse\n\t{\n\t\tthis.updateHtmlTransform();\n\t}\n};\n\n/**\n * Function: updateHtmlTransform\n *\n * Returns the spacing as an <mxPoint>.\n */\nmxText.prototype.updateHtmlTransform = function()\n{\n\tvar theta = this.getTextRotation();\n\tvar style = this.node.style;\n\tvar dx = this.margin.x;\n\tvar dy = this.margin.y;\n\n\tif (theta != 0)\n\t{\n\t\tmxUtils.setPrefixedStyle(style, 'transformOrigin', (-dx * 100) + '%' + ' ' + (-dy * 100) + '%');\n\t\tmxUtils.setPrefixedStyle(style, 'transform', 'translate(' + (dx * 100) + '%' + ',' + (dy * 100) + '%)' +\n\t\t\t'scale(' + this.scale + ') rotate(' + theta + 'deg)');\n\t}\n\telse\n\t{\n\t\tmxUtils.setPrefixedStyle(style, 'transformOrigin', '0% 0%');\n\t\tmxUtils.setPrefixedStyle(style, 'transform', 'scale(' + this.scale + ')' +\n\t\t\t'translate(' + (dx * 100) + '%' + ',' + (dy * 100) + '%)');\n\t}\n\n\tstyle.left = Math.round(this.bounds.x - Math.ceil(dx * ((this.overflow != 'fill' &&\n\t\tthis.overflow != 'width') ? 3 : 1))) + 'px';\n\tstyle.top = Math.round(this.bounds.y - dy * ((this.overflow != 'fill') ? 3 : 1)) + 'px';\n\n\tif (this.opacity < 100)\n\t{\n\t\tstyle.opacity = this.opacity / 100;\n\t}\n\telse\n\t{\n\t\tstyle.opacity = '';\n\t}\n};\n\n/**\n * Function: setInnerHtml\n *\n * Sets the inner HTML of the given element to the <value>.\n */\nmxText.prototype.updateInnerHtml = function(elt)\n{\n\tif (mxUtils.isNode(this.value))\n\t{\n\t\telt.innerHTML = this.value.outerHTML;\n\t}\n\telse\n\t{\n\t\tvar val = this.value;\n\n\t\tif (this.dialect != mxConstants.DIALECT_STRICTHTML)\n\t\t{\n\t\t\t// LATER: Can be cached in updateValue\n\t\t\tval = mxUtils.htmlEntities(val, false);\n\t\t}\n\n\t\t// Handles trailing newlines to make sure they are visible in rendering output\n\t\tval = mxUtils.replaceTrailingNewlines(val, '<div>&nbsp;</div>');\n\t\tval = (this.replaceLinefeeds) ? val.replace(/\\n/g, '<br/>') : val;\n\t\tval = '<div style=\"display:inline-block;_display:inline;\">' + val + '</div>';\n\n\t\telt.innerHTML = val;\n\t}\n};\n\n/**\n * Function: updateHtmlFilter\n *\n * Rotated text rendering quality is bad for IE9 quirks/IE8 standards\n */\nmxText.prototype.updateHtmlFilter = function()\n{\n\tvar style = this.node.style;\n\tvar dx = this.margin.x;\n\tvar dy = this.margin.y;\n\tvar s = this.scale;\n\n\t// Resets filter before getting offsetWidth\n\tmxUtils.setOpacity(this.node, this.opacity);\n\n\t// Adds 1 to match table height in 1.x\n\tvar ow = 0;\n\tvar oh = 0;\n\tvar td = (this.state != null) ? this.state.view.textDiv : null;\n\tvar sizeDiv = this.node;\n\n\t// Fallback for hidden text rendering in IE quirks mode\n\tif (td != null)\n\t{\n\t\ttd.style.overflow = '';\n\t\ttd.style.height = '';\n\t\ttd.style.width = '';\n\n\t\tthis.updateFont(td);\n\t\tthis.updateSize(td, false);\n\t\tthis.updateInnerHtml(td);\n\n\t\tvar w = Math.round(this.bounds.width / this.scale);\n\n\t\tif (this.wrap && w > 0)\n\t\t{\n\t\t\ttd.style.whiteSpace = 'normal';\n\t\t\ttd.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\tow = w;\n\n\t\t\tif (this.clipped)\n\t\t\t{\n\t\t\t\tow = Math.min(ow, this.bounds.width);\n\t\t\t}\n\n\t\t\ttd.style.width = ow + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttd.style.whiteSpace = 'nowrap';\n\t\t}\n\n\t\tsizeDiv = td;\n\n\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t{\n\t\t\tsizeDiv = sizeDiv.firstChild;\n\n\t\t\tif (this.wrap && td.style.wordWrap == 'break-word')\n\t\t\t{\n\t\t\t\tsizeDiv.style.width = '100%';\n\t\t\t}\n\t\t}\n\n\t\t// Required to update the height of the text box after wrapping width is known\n\t\tif (!this.clipped && this.wrap && w > 0)\n\t\t{\n\t\t\tow = sizeDiv.offsetWidth + this.textWidthPadding;\n\t\t\ttd.style.width = ow + 'px';\n\t\t}\n\n\t\toh = sizeDiv.offsetHeight + 2;\n\n\t\tif (mxClient.IS_QUIRKS && this.border != null && this.border != mxConstants.NONE)\n\t\t{\n\t\t\toh += 3;\n\t\t}\n\t}\n\telse if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t{\n\t\tsizeDiv = sizeDiv.firstChild;\n\t\toh = sizeDiv.offsetHeight;\n\t}\n\n\tow = sizeDiv.offsetWidth + this.textWidthPadding;\n\n\tif (this.clipped)\n\t{\n\t\toh = Math.min(oh, this.bounds.height);\n\t}\n\n\tvar w = this.bounds.width / s;\n\tvar h = this.bounds.height / s;\n\n\t// Handles special case for live preview with no wrapper DIV and no textDiv\n\tif (this.overflow == 'fill')\n\t{\n\t\toh = h;\n\t\tow = w;\n\t}\n\telse if (this.overflow == 'width')\n\t{\n\t\toh = sizeDiv.scrollHeight;\n\t\tow = w;\n\t}\n\n\t// Stores for later use\n\tthis.offsetWidth = ow;\n\tthis.offsetHeight = oh;\n\n\t// Simulates max-height CSS in quirks mode\n\tif (mxClient.IS_QUIRKS && (this.clipped || (this.overflow == 'width' && h > 0)))\n\t{\n\t\th = Math.min(h, oh);\n\t\tstyle.height = Math.round(h) + 'px';\n\t}\n\telse\n\t{\n\t\th = oh;\n\t}\n\n\tif (this.overflow != 'fill' && this.overflow != 'width')\n\t{\n\t\tif (this.clipped)\n\t\t{\n\t\t\tow = Math.min(w, ow);\n\t\t}\n\n\t\tw = ow;\n\n\t\t// Simulates max-width CSS in quirks mode\n\t\tif ((mxClient.IS_QUIRKS && this.clipped) || this.wrap)\n\t\t{\n\t\t\tstyle.width = Math.round(w) + 'px';\n\t\t}\n\t}\n\n\th *= s;\n\tw *= s;\n\n\t// Rotation case is handled via VML canvas\n\tvar rad = this.getTextRotation() * (Math.PI / 180);\n\n\t// Precalculate cos and sin for the rotation\n\tvar real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));\n\tvar real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));\n\n\trad %= 2 * Math.PI;\n\n\tif (rad < 0)\n\t{\n\t\trad += 2 * Math.PI;\n\t}\n\n\trad %= Math.PI;\n\n\tif (rad > Math.PI / 2)\n\t{\n\t\trad = Math.PI - rad;\n\t}\n\n\tvar cos = Math.cos(rad);\n\tvar sin = Math.sin(-rad);\n\n\tvar tx = w * -(dx + 0.5);\n\tvar ty = h * -(dy + 0.5);\n\n\tvar top_fix = (h - h * cos + w * sin) / 2 + real_sin * tx - real_cos * ty;\n\tvar left_fix = (w - w * cos + h * sin) / 2 - real_cos * tx - real_sin * ty;\n\n\tif (rad != 0)\n\t{\n\t\tvar f = 'progid:DXImageTransform.Microsoft.Matrix(M11=' + real_cos + ', M12='+\n\t\t\treal_sin + ', M21=' + (-real_sin) + ', M22=' + real_cos + ', sizingMethod=\\'auto expand\\')';\n\n\t\tif (style.filter != null && style.filter.length > 0)\n\t\t{\n\t\t\tstyle.filter += ' ' + f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstyle.filter = f;\n\t\t}\n\t}\n\n\t// Workaround for rendering offsets\n\tvar dy = 0;\n\n\tif (this.overflow != 'fill' && mxClient.IS_QUIRKS)\n\t{\n\t\tif (this.valign == mxConstants.ALIGN_TOP)\n\t\t{\n\t\t\tdy -= 1;\n\t\t}\n\t\telse if (this.valign == mxConstants.ALIGN_BOTTOM)\n\t\t{\n\t\t\tdy += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdy += 1;\n\t\t}\n\t}\n\n\tstyle.zoom = s;\n\tstyle.left = Math.round(this.bounds.x + left_fix - w / 2) + 'px';\n\tstyle.top = Math.round(this.bounds.y + top_fix - h / 2 + dy) + 'px';\n};\n\n/**\n * Function: updateValue\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.updateValue = function()\n{\n\tif (mxUtils.isNode(this.value))\n\t{\n\t\tthis.node.innerHTML = '';\n\t\tthis.node.appendChild(this.value);\n\t}\n\telse\n\t{\n\t\tvar val = this.value;\n\n\t\tif (this.dialect != mxConstants.DIALECT_STRICTHTML)\n\t\t{\n\t\t\tval = mxUtils.htmlEntities(val, false);\n\t\t}\n\n\t\t// Handles trailing newlines to make sure they are visible in rendering output\n\t\tval = mxUtils.replaceTrailingNewlines(val, '<div><br></div>');\n\t\tval = (this.replaceLinefeeds) ? val.replace(/\\n/g, '<br/>') : val;\n\t\tvar bg = (this.background != null && this.background != mxConstants.NONE) ? this.background : null;\n\t\tvar bd = (this.border != null && this.border != mxConstants.NONE) ? this.border : null;\n\n\t\tif (this.overflow == 'fill' || this.overflow == 'width')\n\t\t{\n\t\t\tif (bg != null)\n\t\t\t{\n\t\t\t\tthis.node.style.backgroundColor = bg;\n\t\t\t}\n\n\t\t\tif (bd != null)\n\t\t\t{\n\t\t\t\tthis.node.style.border = '1px solid ' + bd;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar css = '';\n\n\t\t\tif (bg != null)\n\t\t\t{\n\t\t\t\tcss += 'background-color:' + mxUtils.htmlEntities(bg) + ';';\n\t\t\t}\n\n\t\t\tif (bd != null)\n\t\t\t{\n\t\t\t\tcss += 'border:1px solid ' + mxUtils.htmlEntities(bd) + ';';\n\t\t\t}\n\n\t\t\t// Wrapper DIV for background, zoom needed for inline in quirks\n\t\t\t// and to measure wrapped font sizes in all browsers\n\t\t\t// FIXME: Background size in quirks mode for wrapped text\n\t\t\tvar lh = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (this.size * mxConstants.LINE_HEIGHT) + 'px' :\n\t\t\t\tmxConstants.LINE_HEIGHT;\n\t\t\tval = '<div style=\"zoom:1;' + css + 'display:inline-block;_display:inline;text-decoration:inherit;' +\n\t\t\t\t'padding-bottom:1px;padding-right:1px;line-height:' + lh + '\">' + val + '</div>';\n\t\t}\n\n\t\tthis.node.innerHTML = val;\n\n\t\t// Sets text direction\n\t\tvar divs = this.node.getElementsByTagName('div');\n\n\t\tif (divs.length > 0)\n\t\t{\n\t\t\tvar dir = this.textDirection;\n\n\t\t\tif (dir == mxConstants.TEXT_DIRECTION_AUTO && this.dialect != mxConstants.DIALECT_STRICTHTML)\n\t\t\t{\n\t\t\t\tdir = this.getAutoDirection();\n\t\t\t}\n\n\t\t\tif (dir == mxConstants.TEXT_DIRECTION_LTR || dir == mxConstants.TEXT_DIRECTION_RTL)\n\t\t\t{\n\t\t\t\tdivs[divs.length - 1].setAttribute('dir', dir);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdivs[divs.length - 1].removeAttribute('dir');\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: updateFont\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.updateFont = function(node)\n{\n\tvar style = node.style;\n\n\tstyle.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? (this.size * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;\n\tstyle.fontSize = this.size + 'px';\n\t// Quotes are workaround for font name \"m+\"\n\tstyle.fontFamily = '\"' + this.family + '\"';\n\tstyle.verticalAlign = 'top';\n\tstyle.color = this.color;\n\n\tif ((this.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)\n\t{\n\t\tstyle.fontWeight = 'bold';\n\t}\n\telse\n\t{\n\t\tstyle.fontWeight = '';\n\t}\n\n\tif ((this.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)\n\t{\n\t\tstyle.fontStyle = 'italic';\n\t}\n\telse\n\t{\n\t\tstyle.fontStyle = '';\n\t}\n\n\tif ((this.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)\n\t{\n\t\tstyle.textDecoration = 'underline';\n\t}\n\telse\n\t{\n\t\tstyle.textDecoration = '';\n\t}\n\n\tif (this.align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tstyle.textAlign = 'center';\n\t}\n\telse if (this.align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tstyle.textAlign = 'right';\n\t}\n\telse\n\t{\n\t\tstyle.textAlign = 'left';\n\t}\n};\n\n/**\n * Function: updateSize\n *\n * Updates the HTML node(s) to reflect the latest bounds and scale.\n */\nmxText.prototype.updateSize = function(node, enableWrap)\n{\n\tvar w = Math.max(0, Math.round(this.bounds.width / this.scale));\n\tvar h = Math.max(0, Math.round(this.bounds.height / this.scale));\n\tvar style = node.style;\n\n\t// NOTE: Do not use maxWidth here because wrapping will\n\t// go wrong if the cell is outside of the viewable area\n\tif (this.clipped)\n\t{\n\t\tstyle.overflow = 'hidden';\n\n\t\tif (!mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tstyle.maxHeight = h + 'px';\n\t\t\tstyle.maxWidth = w + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstyle.width = w + 'px';\n\t\t}\n\t}\n\telse if (this.overflow == 'fill')\n\t{\n\t\tstyle.width = (w + 1) + 'px';\n\t\tstyle.height = (h + 1) + 'px';\n\t\tstyle.overflow = 'hidden';\n\t}\n\telse if (this.overflow == 'width')\n\t{\n\t\tstyle.width = (w + 1) + 'px';\n\t\tstyle.maxHeight = (h + 1) + 'px';\n\t\tstyle.overflow = 'hidden';\n\t}\n\n\tif (this.wrap && w > 0)\n\t{\n\t\tstyle.wordWrap = mxConstants.WORD_WRAP;\n\t\tstyle.whiteSpace = 'normal';\n\t\tstyle.width = w + 'px';\n\n\t\tif (enableWrap && this.overflow != 'fill' && this.overflow != 'width')\n\t\t{\n\t\t\tvar sizeDiv = node;\n\n\t\t\tif (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV')\n\t\t\t{\n\t\t\t\tsizeDiv = sizeDiv.firstChild;\n\n\t\t\t\tif (node.style.wordWrap == 'break-word')\n\t\t\t\t{\n\t\t\t\t\tsizeDiv.style.width = '100%';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar tmp = sizeDiv.offsetWidth;\n\n\t\t\t// Workaround for text measuring in hidden containers\n\t\t\tif (tmp == 0)\n\t\t\t{\n\t\t\t\tvar prev = node.parentNode;\n\t\t\t\tnode.style.visibility = 'hidden';\n\t\t\t\tdocument.body.appendChild(node);\n\t\t\t\ttmp = sizeDiv.offsetWidth;\n\t\t\t\tnode.style.visibility = '';\n\t\t\t\tprev.appendChild(node);\n\t\t\t}\n\n\t\t\ttmp += 3;\n\n\t\t\tif (this.clipped)\n\t\t\t{\n\t\t\t\ttmp = Math.min(tmp, w);\n\t\t\t}\n\n\t\t\tstyle.width = tmp + 'px';\n\t\t}\n\t}\n\telse\n\t{\n\t\tstyle.whiteSpace = 'nowrap';\n\t}\n};\n\n/**\n * Function: getMargin\n *\n * Returns the spacing as an <mxPoint>.\n */\nmxText.prototype.updateMargin = function()\n{\n\tthis.margin = mxUtils.getAlignmentAsPoint(this.align, this.valign);\n};\n\n/**\n * Function: getSpacing\n *\n * Returns the spacing as an <mxPoint>.\n */\nmxText.prototype.getSpacing = function()\n{\n\tvar dx = 0;\n\tvar dy = 0;\n\n\tif (this.align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tdx = (this.spacingLeft - this.spacingRight) / 2;\n\t}\n\telse if (this.align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tdx = -this.spacingRight - this.baseSpacingRight;\n\t}\n\telse\n\t{\n\t\tdx = this.spacingLeft + this.baseSpacingLeft;\n\t}\n\n\tif (this.valign == mxConstants.ALIGN_MIDDLE)\n\t{\n\t\tdy = (this.spacingTop - this.spacingBottom) / 2;\n\t}\n\telse if (this.valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tdy = -this.spacingBottom - this.baseSpacingBottom;;\n\t}\n\telse\n\t{\n\t\tdy = this.spacingTop + this.baseSpacingTop;\n\t}\n\n\treturn new mxPoint(dx, dy);\n};\n\n__mxOutput.mxText = typeof mxText !== 'undefined' ? mxText : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxTriangle\n *\n * Implementation of the triangle shape.\n *\n * Constructor: mxTriangle\n *\n * Constructs a new triangle shape.\n */\nfunction mxTriangle()\n{\n\tmxActor.call(this);\n};\n\n/**\n * Extends mxActor.\n */\nmxUtils.extend(mxTriangle, mxActor);\n\n/**\n * Function: isRoundable\n *\n * Adds roundable support.\n */\nmxTriangle.prototype.isRoundable = function()\n{\n\treturn true;\n};\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxTriangle.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tthis.addPoints(c, [new mxPoint(0, 0), new mxPoint(w, 0.5 * h), new mxPoint(0, h)], this.isRounded, arcSize, true);\n};\n\n__mxOutput.mxTriangle = typeof mxTriangle !== 'undefined' ? mxTriangle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxHexagon\n *\n * Implementation of the hexagon shape.\n *\n * Constructor: mxHexagon\n *\n * Constructs a new hexagon shape.\n */\nfunction mxHexagon()\n{\n\tmxActor.call(this);\n};\n\n/**\n * Extends mxActor.\n */\nmxUtils.extend(mxHexagon, mxActor);\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxHexagon.prototype.redrawPath = function(c, x, y, w, h)\n{\n\tvar arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;\n\tthis.addPoints(c, [new mxPoint(0.25 * w, 0), new mxPoint(0.75 * w, 0), new mxPoint(w, 0.5 * h), new mxPoint(0.75 * w, h),\n\t                   new mxPoint(0.25 * w, h), new mxPoint(0, 0.5 * h)], this.isRounded, arcSize, true);\n};\n\n__mxOutput.mxHexagon = typeof mxHexagon !== 'undefined' ? mxHexagon : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxLine\n *\n * Extends <mxShape> to implement a horizontal line shape.\n * This shape is registered under <mxConstants.SHAPE_LINE> in\n * <mxCellRenderer>.\n *\n * Constructor: mxLine\n *\n * Constructs a new line shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * stroke - String that defines the stroke color. Default is 'black'. This is\n * stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxLine(bounds, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxLine, mxShape);\n\n/**\n * Function: paintVertexShape\n *\n * Redirects to redrawPath for subclasses to work.\n */\nmxLine.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tvar mid = y + h / 2;\n\n\tc.begin();\n\tc.moveTo(x, mid);\n\tc.lineTo(x + w, mid);\n\tc.stroke();\n};\n\n__mxOutput.mxLine = typeof mxLine !== 'undefined' ? mxLine : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxImageShape\n *\n * Extends <mxShape> to implement an image shape. This shape is registered\n * under <mxConstants.SHAPE_IMAGE> in <mxCellRenderer>.\n *\n * Constructor: mxImageShape\n *\n * Constructs a new image shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * image - String that specifies the URL of the image. This is stored in\n * <image>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 0. This is stored in <strokewidth>.\n */\nfunction mxImageShape(bounds, image, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.image = image;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n\tthis.shadow = false;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxImageShape, mxRectangleShape);\n\n/**\n * Variable: preserveImageAspect\n *\n * Switch to preserve image aspect. Default is true.\n */\nmxImageShape.prototype.preserveImageAspect = true;\n\n/**\n * Function: getSvgScreenOffset\n *\n * Disables offset in IE9 for crisper image output.\n */\nmxImageShape.prototype.getSvgScreenOffset = function()\n{\n\treturn 0;\n};\n\n/**\n * Function: apply\n *\n * Overrides <mxShape.apply> to replace the fill and stroke colors with the\n * respective values from <mxConstants.STYLE_IMAGE_BACKGROUND> and\n * <mxConstants.STYLE_IMAGE_BORDER>.\n *\n * Applies the style of the given <mxCellState> to the shape. This\n * implementation assigns the following styles to local fields:\n *\n * - <mxConstants.STYLE_IMAGE_BACKGROUND> => fill\n * - <mxConstants.STYLE_IMAGE_BORDER> => stroke\n *\n * Parameters:\n *\n * state - <mxCellState> of the corresponding cell.\n */\nmxImageShape.prototype.apply = function(state)\n{\n\tmxShape.prototype.apply.apply(this, arguments);\n\n\tthis.fill = null;\n\tthis.stroke = null;\n\tthis.gradient = null;\n\n\tif (this.style != null)\n\t{\n\t\tthis.preserveImageAspect = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_ASPECT, 1) == 1;\n\n\t\t// Legacy support for imageFlipH/V\n\t\tthis.flipH = this.flipH || mxUtils.getValue(this.style, 'imageFlipH', 0) == 1;\n\t\tthis.flipV = this.flipV || mxUtils.getValue(this.style, 'imageFlipV', 0) == 1;\n\t}\n};\n\n/**\n * Function: isHtmlAllowed\n *\n * Returns true if HTML is allowed for this shape. This implementation always\n * returns false.\n */\nmxImageShape.prototype.isHtmlAllowed = function()\n{\n\treturn !this.preserveImageAspect;\n};\n\n/**\n * Function: createHtml\n *\n * Creates and returns the HTML DOM node(s) to represent\n * this shape. This implementation falls back to <createVml>\n * so that the HTML creation is optional.\n */\nmxImageShape.prototype.createHtml = function()\n{\n\tvar node = document.createElement('div');\n\tnode.style.position = 'absolute';\n\n\treturn node;\n};\n\n/**\n * Function: isRoundable\n *\n * Disables inherited roundable support.\n */\nmxImageShape.prototype.isRoundable = function(c, x, y, w, h)\n{\n\treturn false;\n};\n\n/**\n * Function: paintVertexShape\n *\n * Generic background painting implementation.\n */\nmxImageShape.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tif (this.image != null)\n\t{\n\t\tvar fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, null);\n\t\tvar stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);\n\n\t\tif (fill != null)\n\t\t{\n\t\t\t// Stroke rendering required for shadow\n\t\t\tc.setFillColor(fill);\n\t\t\tc.setStrokeColor(stroke);\n\t\t\tc.rect(x, y, w, h);\n\t\t\tc.fillAndStroke();\n\t\t}\n\n\t\t// FlipH/V are implicit via mxShape.updateTransform\n\t\tc.image(x, y, w, h, this.image, this.preserveImageAspect, false, false);\n\n\t\tvar stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, null);\n\n\t\tif (stroke != null)\n\t\t{\n\t\t\tc.setShadow(false);\n\t\t\tc.setStrokeColor(stroke);\n\t\t\tc.rect(x, y, w, h);\n\t\t\tc.stroke();\n\t\t}\n\t}\n\telse\n\t{\n\t\tmxRectangleShape.prototype.paintBackground.apply(this, arguments);\n\t}\n};\n\n/**\n * Function: redraw\n *\n * Overrides <mxShape.redraw> to preserve the aspect ratio of images.\n */\nmxImageShape.prototype.redrawHtmlShape = function()\n{\n\tthis.node.style.left = Math.round(this.bounds.x) + 'px';\n\tthis.node.style.top = Math.round(this.bounds.y) + 'px';\n\tthis.node.style.width = Math.max(0, Math.round(this.bounds.width)) + 'px';\n\tthis.node.style.height = Math.max(0, Math.round(this.bounds.height)) + 'px';\n\tthis.node.innerHTML = '';\n\n\tif (this.image != null)\n\t{\n\t\tvar fill = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BACKGROUND, '');\n\t\tvar stroke = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_BORDER, '');\n\t\tthis.node.style.backgroundColor = fill;\n\t\tthis.node.style.borderColor = stroke;\n\n\t\t// VML image supports PNG in IE6\n\t\tvar useVml = mxClient.IS_IE6 || ((document.documentMode == null || document.documentMode <= 8) && this.rotation != 0);\n\t\tvar img = document.createElement((useVml) ? mxClient.VML_PREFIX + ':image' : 'img');\n\t\timg.setAttribute('border', '0');\n\t\timg.style.position = 'absolute';\n\t\timg.src = this.image;\n\n\t\tvar filter = (this.opacity < 100) ? 'alpha(opacity=' + this.opacity + ')' : '';\n\t\tthis.node.style.filter = filter;\n\n\t\tif (this.flipH && this.flipV)\n\t\t{\n\t\t\tfilter += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2)';\n\t\t}\n\t\telse if (this.flipH)\n\t\t{\n\t\t\tfilter += 'progid:DXImageTransform.Microsoft.BasicImage(mirror=1)';\n\t\t}\n\t\telse if (this.flipV)\n\t\t{\n\t\t\tfilter += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)';\n\t\t}\n\n\t\tif (img.style.filter != filter)\n\t\t{\n\t\t\timg.style.filter = filter;\n\t\t}\n\n\t\tif (img.nodeName == 'image')\n\t\t{\n\t\t\timg.style.rotation = this.rotation;\n\t\t}\n\t\telse if (this.rotation != 0)\n\t\t{\n\t\t\t// LATER: Add flipV/H support\n\t\t\tmxUtils.setPrefixedStyle(img.style, 'transform', 'rotate(' + this.rotation + 'deg)');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxUtils.setPrefixedStyle(img.style, 'transform', '');\n\t\t}\n\n\t\t// Known problem: IE clips top line of image for certain angles\n\t\timg.style.width = this.node.style.width;\n\t\timg.style.height = this.node.style.height;\n\n\t\tthis.node.style.backgroundImage = '';\n\t\tthis.node.appendChild(img);\n\t}\n\telse\n\t{\n\t\tthis.setTransparentBackgroundImage(this.node);\n\t}\n};\n\n__mxOutput.mxImageShape = typeof mxImageShape !== 'undefined' ? mxImageShape : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxLabel\n *\n * Extends <mxShape> to implement an image shape with a label.\n * This shape is registered under <mxConstants.SHAPE_LABEL> in\n * <mxCellRenderer>.\n *\n * Constructor: mxLabel\n *\n * Constructs a new label shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxLabel(bounds, fill, stroke, strokewidth)\n{\n\tmxRectangleShape.call(this, bounds, fill, stroke, strokewidth);\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxLabel, mxRectangleShape);\n\n/**\n * Variable: imageSize\n *\n * Default width and height for the image. Default is\n * <mxConstants.DEFAULT_IMAGESIZE>.\n */\nmxLabel.prototype.imageSize = mxConstants.DEFAULT_IMAGESIZE;\n\n/**\n * Variable: spacing\n *\n * Default value for image spacing. Default is 2.\n */\nmxLabel.prototype.spacing = 2;\n\n/**\n * Variable: indicatorSize\n *\n * Default width and height for the indicicator. Default is 10.\n */\nmxLabel.prototype.indicatorSize = 10;\n\n/**\n * Variable: indicatorSpacing\n *\n * Default spacing between image and indicator. Default is 2.\n */\nmxLabel.prototype.indicatorSpacing = 2;\n\n/**\n * Function: init\n *\n * Initializes the shape and the <indicator>.\n */\nmxLabel.prototype.init = function(container)\n{\n\tmxShape.prototype.init.apply(this, arguments);\n\n\tif (this.indicatorShape != null)\n\t{\n\t\tthis.indicator = new this.indicatorShape();\n\t\tthis.indicator.dialect = this.dialect;\n\t\tthis.indicator.init(this.node);\n\t}\n};\n\n/**\n * Function: redraw\n *\n * Reconfigures this shape. This will update the colors of the indicator\n * and reconfigure it if required.\n */\nmxLabel.prototype.redraw = function()\n{\n\tif (this.indicator != null)\n\t{\n\t\tthis.indicator.fill = this.indicatorColor;\n\t\tthis.indicator.stroke = this.indicatorStrokeColor;\n\t\tthis.indicator.gradient = this.indicatorGradientColor;\n\t\tthis.indicator.direction = this.indicatorDirection;\n\t}\n\n\tmxShape.prototype.redraw.apply(this, arguments);\n};\n\n/**\n * Function: isHtmlAllowed\n *\n * Returns true for non-rounded, non-rotated shapes with no glass gradient and\n * no indicator shape.\n */\nmxLabel.prototype.isHtmlAllowed = function()\n{\n\treturn mxRectangleShape.prototype.isHtmlAllowed.apply(this, arguments) &&\n\t\tthis.indicatorColor == null && this.indicatorShape == null;\n};\n\n/**\n * Function: paintForeground\n *\n * Generic background painting implementation.\n */\nmxLabel.prototype.paintForeground = function(c, x, y, w, h)\n{\n\tthis.paintImage(c, x, y, w, h);\n\tthis.paintIndicator(c, x, y, w, h);\n\n\tmxRectangleShape.prototype.paintForeground.apply(this, arguments);\n};\n\n/**\n * Function: paintImage\n *\n * Generic background painting implementation.\n */\nmxLabel.prototype.paintImage = function(c, x, y, w, h)\n{\n\tif (this.image != null)\n\t{\n\t\tvar bounds = this.getImageBounds(x, y, w, h);\n\t\tc.image(bounds.x, bounds.y, bounds.width, bounds.height, this.image, false, false, false);\n\t}\n};\n\n/**\n * Function: getImageBounds\n *\n * Generic background painting implementation.\n */\nmxLabel.prototype.getImageBounds = function(x, y, w, h)\n{\n\tvar align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);\n\tvar valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);\n\tvar width = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_WIDTH, mxConstants.DEFAULT_IMAGESIZE);\n\tvar height = mxUtils.getNumber(this.style, mxConstants.STYLE_IMAGE_HEIGHT, mxConstants.DEFAULT_IMAGESIZE);\n\tvar spacing = mxUtils.getNumber(this.style, mxConstants.STYLE_SPACING, this.spacing) + 5;\n\n\tif (align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tx += (w - width) / 2;\n\t}\n\telse if (align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tx += w - width - spacing;\n\t}\n\telse // default is left\n\t{\n\t\tx += spacing;\n\t}\n\n\tif (valign == mxConstants.ALIGN_TOP)\n\t{\n\t\ty += spacing;\n\t}\n\telse if (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\ty += h - height - spacing;\n\t}\n\telse // default is middle\n\t{\n\t\ty += (h - height) / 2;\n\t}\n\n\treturn new mxRectangle(x, y, width, height);\n};\n\n/**\n * Function: paintIndicator\n *\n * Generic background painting implementation.\n */\nmxLabel.prototype.paintIndicator = function(c, x, y, w, h)\n{\n\tif (this.indicator != null)\n\t{\n\t\tthis.indicator.bounds = this.getIndicatorBounds(x, y, w, h);\n\t\tthis.indicator.paint(c);\n\t}\n\telse if (this.indicatorImage != null)\n\t{\n\t\tvar bounds = this.getIndicatorBounds(x, y, w, h);\n\t\tc.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImage, false, false, false);\n\t}\n};\n\n/**\n * Function: getIndicatorBounds\n *\n * Generic background painting implementation.\n */\nmxLabel.prototype.getIndicatorBounds = function(x, y, w, h)\n{\n\tvar align = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_ALIGN, mxConstants.ALIGN_LEFT);\n\tvar valign = mxUtils.getValue(this.style, mxConstants.STYLE_IMAGE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE);\n\tvar width = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_WIDTH, this.indicatorSize);\n\tvar height = mxUtils.getNumber(this.style, mxConstants.STYLE_INDICATOR_HEIGHT, this.indicatorSize);\n\tvar spacing = this.spacing + 5;\n\n\tif (align == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tx += w - width - spacing;\n\t}\n\telse if (align == mxConstants.ALIGN_CENTER)\n\t{\n\t\tx += (w - width) / 2;\n\t}\n\telse // default is left\n\t{\n\t\tx += spacing;\n\t}\n\n\tif (valign == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\ty += h - height - spacing;\n\t}\n\telse if (valign == mxConstants.ALIGN_TOP)\n\t{\n\t\ty += spacing;\n\t}\n\telse // default is middle\n\t{\n\t\ty += (h - height) / 2;\n\t}\n\n\treturn new mxRectangle(x, y, width, height);\n};\n/**\n * Function: redrawHtmlShape\n *\n * Generic background painting implementation.\n */\nmxLabel.prototype.redrawHtmlShape = function()\n{\n\tmxRectangleShape.prototype.redrawHtmlShape.apply(this, arguments);\n\n\t// Removes all children\n\twhile(this.node.hasChildNodes())\n\t{\n\t\tthis.node.removeChild(this.node.lastChild);\n\t}\n\n\tif (this.image != null)\n\t{\n\t\tvar node = document.createElement('img');\n\t\tnode.style.position = 'relative';\n\t\tnode.setAttribute('border', '0');\n\n\t\tvar bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n\t\tbounds.x -= this.bounds.x;\n\t\tbounds.y -= this.bounds.y;\n\n\t\tnode.style.left = Math.round(bounds.x) + 'px';\n\t\tnode.style.top = Math.round(bounds.y) + 'px';\n\t\tnode.style.width = Math.round(bounds.width) + 'px';\n\t\tnode.style.height = Math.round(bounds.height) + 'px';\n\n\t\tnode.src = this.image;\n\n\t\tthis.node.appendChild(node);\n\t}\n};\n\n__mxOutput.mxLabel = typeof mxLabel !== 'undefined' ? mxLabel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCylinder\n *\n * Extends <mxShape> to implement an cylinder shape. If a\n * custom shape with one filled area and an overlay path is\n * needed, then this shape's <redrawPath> should be overridden.\n * This shape is registered under <mxConstants.SHAPE_CYLINDER>\n * in <mxCellRenderer>.\n *\n * Constructor: mxCylinder\n *\n * Constructs a new cylinder shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxCylinder(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxCylinder, mxShape);\n\n/**\n * Variable: maxHeight\n *\n * Defines the maximum height of the top and bottom part\n * of the cylinder shape.\n */\nmxCylinder.prototype.maxHeight = 40;\n\n/**\n * Variable: svgStrokeTolerance\n *\n * Sets stroke tolerance to 0 for SVG.\n */\nmxCylinder.prototype.svgStrokeTolerance = 0;\n\n/**\n * Function: paintVertexShape\n *\n * Redirects to redrawPath for subclasses to work.\n */\nmxCylinder.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tc.translate(x, y);\n\tc.begin();\n\tthis.redrawPath(c, x, y, w, h, false);\n\tc.fillAndStroke();\n\n\tif (!this.outline || this.style == null || mxUtils.getValue(\n\t\tthis.style, mxConstants.STYLE_BACKGROUND_OUTLINE, 0) == 0)\n\t{\n\t\tc.setShadow(false);\n\t\tc.begin();\n\t\tthis.redrawPath(c, x, y, w, h, true);\n\t\tc.stroke();\n\t}\n};\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxCylinder.prototype.getCylinderSize = function(x, y, w, h)\n{\n\treturn Math.min(this.maxHeight, Math.round(h / 5));\n};\n\n/**\n * Function: redrawPath\n *\n * Draws the path for this shape.\n */\nmxCylinder.prototype.redrawPath = function(c, x, y, w, h, isForeground)\n{\n\tvar dy = this.getCylinderSize(x, y, w, h);\n\n\tif ((isForeground && this.fill != null) || (!isForeground && this.fill == null))\n\t{\n\t\tc.moveTo(0, dy);\n\t\tc.curveTo(0, 2 * dy, w, 2 * dy, w, dy);\n\n\t\t// Needs separate shapes for correct hit-detection\n\t\tif (!isForeground)\n\t\t{\n\t\t\tc.stroke();\n\t\t\tc.begin();\n\t\t}\n\t}\n\n\tif (!isForeground)\n\t{\n\t\tc.moveTo(0, dy);\n\t\tc.curveTo(0, -dy / 3, w, -dy / 3, w, dy);\n\t\tc.lineTo(w, h - dy);\n\t\tc.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);\n\t\tc.close();\n\t}\n};\n\n__mxOutput.mxCylinder = typeof mxCylinder !== 'undefined' ? mxCylinder : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxConnector\n *\n * Extends <mxShape> to implement a connector shape. The connector\n * shape allows for arrow heads on either side.\n *\n * This shape is registered under <mxConstants.SHAPE_CONNECTOR> in\n * <mxCellRenderer>.\n *\n * Constructor: mxConnector\n *\n * Constructs a new connector shape.\n *\n * Parameters:\n *\n * points - Array of <mxPoints> that define the points. This is stored in\n * <mxShape.points>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * Default is 'black'.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxConnector(points, stroke, strokewidth)\n{\n\tmxPolyline.call(this, points, stroke, strokewidth);\n};\n\n/**\n * Extends mxPolyline.\n */\nmxUtils.extend(mxConnector, mxPolyline);\n\n/**\n * Function: updateBoundingBox\n *\n * Updates the <boundingBox> for this shape using <createBoundingBox> and\n * <augmentBoundingBox> and stores the result in <boundingBox>.\n */\nmxConnector.prototype.updateBoundingBox = function()\n{\n\tthis.useSvgBoundingBox = this.style != null && this.style[mxConstants.STYLE_CURVED] == 1;\n\tmxShape.prototype.updateBoundingBox.apply(this, arguments);\n};\n\n/**\n * Function: paintEdgeShape\n *\n * Paints the line shape.\n */\nmxConnector.prototype.paintEdgeShape = function(c, pts)\n{\n\t// The indirection via functions for markers is needed in\n\t// order to apply the offsets before painting the line and\n\t// paint the markers after painting the line.\n\tvar sourceMarker = this.createMarker(c, pts, true);\n\tvar targetMarker = this.createMarker(c, pts, false);\n\n\tmxPolyline.prototype.paintEdgeShape.apply(this, arguments);\n\n\t// Disables shadows, dashed styles and fixes fill color for markers\n\tc.setFillColor(this.stroke);\n\tc.setShadow(false);\n\tc.setDashed(false);\n\n\tif (sourceMarker != null)\n\t{\n\t\tsourceMarker();\n\t}\n\n\tif (targetMarker != null)\n\t{\n\t\ttargetMarker();\n\t}\n};\n\n/**\n * Function: createMarker\n *\n * Prepares the marker by adding offsets in pts and returning a function to\n * paint the marker.\n */\nmxConnector.prototype.createMarker = function(c, pts, source)\n{\n\tvar result = null;\n\tvar n = pts.length;\n\tvar type = mxUtils.getValue(this.style, (source) ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW);\n\tvar p0 = (source) ? pts[1] : pts[n - 2];\n\tvar pe = (source) ? pts[0] : pts[n - 1];\n\n\tif (type != null && p0 != null && pe != null)\n\t{\n\t\tvar count = 1;\n\n\t\t// Uses next non-overlapping point\n\t\twhile (count < n - 1 && Math.round(p0.x - pe.x) == 0 && Math.round(p0.y - pe.y) == 0)\n\t\t{\n\t\t\tp0 = (source) ? pts[1 + count] : pts[n - 2 - count];\n\t\t\tcount++;\n\t\t}\n\n\t\t// Computes the norm and the inverse norm\n\t\tvar dx = pe.x - p0.x;\n\t\tvar dy = pe.y - p0.y;\n\n\t\tvar dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n\n\t\tvar unitX = dx / dist;\n\t\tvar unitY = dy / dist;\n\n\t\tvar size = mxUtils.getNumber(this.style, (source) ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);\n\n\t\t// Allow for stroke width in the end point used and the\n\t\t// orthogonal vectors describing the direction of the marker\n\t\tvar filled = this.style[(source) ? mxConstants.STYLE_STARTFILL : mxConstants.STYLE_ENDFILL] != 0;\n\n\t\tresult = mxMarker.createMarker(c, this, type, pe, unitX, unitY, size, source, this.strokewidth, filled);\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: augmentBoundingBox\n *\n * Augments the bounding box with the strokewidth and shadow offsets.\n */\nmxConnector.prototype.augmentBoundingBox = function(bbox)\n{\n\tmxShape.prototype.augmentBoundingBox.apply(this, arguments);\n\n\t// Adds marker sizes\n\tvar size = 0;\n\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE)\n\t{\n\t\tsize = mxUtils.getNumber(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_MARKERSIZE) + 1;\n\t}\n\n\tif (mxUtils.getValue(this.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE)\n\t{\n\t\tsize = Math.max(size, mxUtils.getNumber(this.style, mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE)) + 1;\n\t}\n\n\tbbox.grow(size * this.scale);\n};\n\n__mxOutput.mxConnector = typeof mxConnector !== 'undefined' ? mxConnector : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlane\n *\n * Extends <mxShape> to implement a swimlane shape. This shape is registered\n * under <mxConstants.SHAPE_SWIMLANE> in <mxCellRenderer>. Use the\n * <mxConstants.STYLE_STYLE_STARTSIZE> to define the size of the title\n * region, <mxConstants.STYLE_SWIMLANE_FILLCOLOR> for the content area fill,\n * <mxConstants.STYLE_SEPARATORCOLOR> to draw an additional vertical separator\n * and <mxConstants.STYLE_SWIMLANE_LINE> to hide the line between the title\n * region and the content area. The <mxConstants.STYLE_HORIZONTAL> affects\n * the orientation of this shape, not only its label.\n *\n * Constructor: mxSwimlane\n *\n * Constructs a new swimlane shape.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that defines the bounds. This is stored in\n * <mxShape.bounds>.\n * fill - String that defines the fill color. This is stored in <fill>.\n * stroke - String that defines the stroke color. This is stored in <stroke>.\n * strokewidth - Optional integer that defines the stroke width. Default is\n * 1. This is stored in <strokewidth>.\n */\nfunction mxSwimlane(bounds, fill, stroke, strokewidth)\n{\n\tmxShape.call(this);\n\tthis.bounds = bounds;\n\tthis.fill = fill;\n\tthis.stroke = stroke;\n\tthis.strokewidth = (strokewidth != null) ? strokewidth : 1;\n};\n\n/**\n * Extends mxShape.\n */\nmxUtils.extend(mxSwimlane, mxShape);\n\n/**\n * Variable: imageSize\n *\n * Default imagewidth and imageheight if an image but no imagewidth\n * and imageheight are defined in the style. Value is 16.\n */\nmxSwimlane.prototype.imageSize = 16;\n\n/**\n * Function: isRoundable\n *\n * Adds roundable support.\n */\nmxSwimlane.prototype.isRoundable = function(c, x, y, w, h)\n{\n\treturn true;\n};\n\n/**\n * Function: getGradientBounds\n *\n * Returns the bounding box for the gradient box for this shape.\n */\nmxSwimlane.prototype.getTitleSize = function()\n{\n\treturn Math.max(0, mxUtils.getValue(this.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));\n};\n\n/**\n * Function: getGradientBounds\n *\n * Returns the bounding box for the gradient box for this shape.\n */\nmxSwimlane.prototype.getLabelBounds = function(rect)\n{\n\tvar start = this.getTitleSize();\n\tvar bounds = new mxRectangle(rect.x, rect.y, rect.width, rect.height);\n\tvar horizontal = this.isHorizontal();\n\n\tvar flipH = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\tvar flipV = mxUtils.getValue(this.style, mxConstants.STYLE_FLIPV, 0) == 1;\n\n\t// East is default\n\tvar shapeVertical = (this.direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_SOUTH);\n\tvar realHorizontal = horizontal == !shapeVertical;\n\n\tvar realFlipH = !realHorizontal && flipH != (this.direction == mxConstants.DIRECTION_SOUTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_WEST);\n\tvar realFlipV = realHorizontal && flipV != (this.direction == mxConstants.DIRECTION_SOUTH ||\n\t\t\tthis.direction == mxConstants.DIRECTION_WEST);\n\n\t// Shape is horizontal\n\tif (!shapeVertical)\n\t{\n\t\tvar tmp = Math.min(bounds.height, start * this.scale);\n\n\t\tif (realFlipH || realFlipV)\n\t\t{\n\t\t\tbounds.y += bounds.height - tmp;\n\t\t}\n\n\t\tbounds.height = tmp;\n\t}\n\telse\n\t{\n\t\tvar tmp = Math.min(bounds.width, start * this.scale);\n\n\t\tif (realFlipH || realFlipV)\n\t\t{\n\t\t\tbounds.x += bounds.width - tmp;\n\t\t}\n\n\t\tbounds.width = tmp;\n\t}\n\n\treturn bounds;\n};\n\n/**\n * Function: getGradientBounds\n *\n * Returns the bounding box for the gradient box for this shape.\n */\nmxSwimlane.prototype.getGradientBounds = function(c, x, y, w, h)\n{\n\tvar start = this.getTitleSize();\n\n\tif (this.isHorizontal())\n\t{\n\t\tstart = Math.min(start, h);\n\t\treturn new mxRectangle(x, y, w, start);\n\t}\n\telse\n\t{\n\t\tstart = Math.min(start, w);\n\t\treturn new mxRectangle(x, y, start, h);\n\t}\n};\n\n/**\n * Function: getArcSize\n *\n * Returns the arcsize for the swimlane.\n */\nmxSwimlane.prototype.getArcSize = function(w, h, start)\n{\n\tvar f = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n\n\treturn start * f * 3;\n};\n\n/**\n * Function: paintVertexShape\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.isHorizontal = function()\n{\n\treturn mxUtils.getValue(this.style, mxConstants.STYLE_HORIZONTAL, 1) == 1;\n};\n\n/**\n * Function: paintVertexShape\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.paintVertexShape = function(c, x, y, w, h)\n{\n\tvar start = this.getTitleSize();\n\tvar fill = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_FILLCOLOR, mxConstants.NONE);\n\tvar swimlaneLine = mxUtils.getValue(this.style, mxConstants.STYLE_SWIMLANE_LINE, 1) == 1;\n\tvar r = 0;\n\n\tif (this.isHorizontal())\n\t{\n\t\tstart = Math.min(start, h);\n\t}\n\telse\n\t{\n\t\tstart = Math.min(start, w);\n\t}\n\n\tc.translate(x, y);\n\n\tif (!this.isRounded)\n\t{\n\t\tthis.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);\n\t}\n\telse\n\t{\n\t\tr = this.getArcSize(w, h, start);\n\t\tr = Math.min(((this.isHorizontal()) ? h : w) - start, Math.min(start, r));\n\t\tthis.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);\n\t}\n\n\tvar sep = mxUtils.getValue(this.style, mxConstants.STYLE_SEPARATORCOLOR, mxConstants.NONE);\n\tthis.paintSeparator(c, x, y, w, h, start, sep);\n\n\tif (this.image != null)\n\t{\n\t\tvar bounds = this.getImageBounds(x, y, w, h);\n\t\tc.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height,\n\t\t\t\tthis.image, false, false, false);\n\t}\n\n\tif (this.glass)\n\t{\n\t\tc.setShadow(false);\n\t\tthis.paintGlassEffect(c, 0, 0, w, start, r);\n\t}\n};\n\n/**\n * Function: paintSwimlane\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.paintSwimlane = function(c, x, y, w, h, start, fill, swimlaneLine)\n{\n\tc.begin();\n\n\tif (this.isHorizontal())\n\t{\n\t\tc.moveTo(0, start);\n\t\tc.lineTo(0, 0);\n\t\tc.lineTo(w, 0);\n\t\tc.lineTo(w, start);\n\t\tc.fillAndStroke();\n\n\t\tif (start < h)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\n\t\t\tc.begin();\n\t\t\tc.moveTo(0, start);\n\t\t\tc.lineTo(0, h);\n\t\t\tc.lineTo(w, h);\n\t\t\tc.lineTo(w, start);\n\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tc.moveTo(start, 0);\n\t\tc.lineTo(0, 0);\n\t\tc.lineTo(0, h);\n\t\tc.lineTo(start, h);\n\t\tc.fillAndStroke();\n\n\t\tif (start < w)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\n\t\t\tc.begin();\n\t\t\tc.moveTo(start, 0);\n\t\t\tc.lineTo(w, 0);\n\t\t\tc.lineTo(w, h);\n\t\t\tc.lineTo(start, h);\n\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (swimlaneLine)\n\t{\n\t\tthis.paintDivider(c, x, y, w, h, start, fill == mxConstants.NONE);\n\t}\n};\n\n/**\n * Function: paintRoundedSwimlane\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.paintRoundedSwimlane = function(c, x, y, w, h, start, r, fill, swimlaneLine)\n{\n\tc.begin();\n\n\tif (this.isHorizontal())\n\t{\n\t\tc.moveTo(w, start);\n\t\tc.lineTo(w, r);\n\t\tc.quadTo(w, 0, w - Math.min(w / 2, r), 0);\n\t\tc.lineTo(Math.min(w / 2, r), 0);\n\t\tc.quadTo(0, 0, 0, r);\n\t\tc.lineTo(0, start);\n\t\tc.fillAndStroke();\n\n\t\tif (start < h)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\n\t\t\tc.begin();\n\t\t\tc.moveTo(0, start);\n\t\t\tc.lineTo(0, h - r);\n\t\t\tc.quadTo(0, h, Math.min(w / 2, r), h);\n\t\t\tc.lineTo(w - Math.min(w / 2, r), h);\n\t\t\tc.quadTo(w, h, w, h - r);\n\t\t\tc.lineTo(w, start);\n\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tc.moveTo(start, 0);\n\t\tc.lineTo(r, 0);\n\t\tc.quadTo(0, 0, 0, Math.min(h / 2, r));\n\t\tc.lineTo(0, h - Math.min(h / 2, r));\n\t\tc.quadTo(0, h, r, h);\n\t\tc.lineTo(start, h);\n\t\tc.fillAndStroke();\n\n\t\tif (start < w)\n\t\t{\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.pointerEvents = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.setFillColor(fill);\n\t\t\t}\n\n\t\t\tc.begin();\n\t\t\tc.moveTo(start, h);\n\t\t\tc.lineTo(w - r, h);\n\t\t\tc.quadTo(w, h, w, h - Math.min(h / 2, r));\n\t\t\tc.lineTo(w, Math.min(h / 2, r));\n\t\t\tc.quadTo(w, 0, w - r, 0);\n\t\t\tc.lineTo(start, 0);\n\n\t\t\tif (fill == mxConstants.NONE)\n\t\t\t{\n\t\t\t\tc.stroke();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.fillAndStroke();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (swimlaneLine)\n\t{\n\t\tthis.paintDivider(c, x, y, w, h, start, fill == mxConstants.NONE);\n\t}\n};\n\n/**\n * Function: paintDivider\n *\n * Paints the divider between swimlane title and content area.\n */\nmxSwimlane.prototype.paintDivider = function(c, x, y, w, h, start, shadow)\n{\n\tif (!shadow)\n\t{\n\t\tc.setShadow(false);\n\t}\n\n\tc.begin();\n\n\tif (this.isHorizontal())\n\t{\n\t\tc.moveTo(0, start);\n\t\tc.lineTo(w, start);\n\t}\n\telse\n\t{\n\t\tc.moveTo(start, 0);\n\t\tc.lineTo(start, h);\n\t}\n\n\tc.stroke();\n};\n\n/**\n * Function: paintSeparator\n *\n * Paints the vertical or horizontal separator line between swimlanes.\n */\nmxSwimlane.prototype.paintSeparator = function(c, x, y, w, h, start, color)\n{\n\tif (color != mxConstants.NONE)\n\t{\n\t\tc.setStrokeColor(color);\n\t\tc.setDashed(true);\n\t\tc.begin();\n\n\t\tif (this.isHorizontal())\n\t\t{\n\t\t\tc.moveTo(w, start);\n\t\t\tc.lineTo(w, h);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc.moveTo(start, 0);\n\t\t\tc.lineTo(w, 0);\n\t\t}\n\n\t\tc.stroke();\n\t\tc.setDashed(false);\n\t}\n};\n\n/**\n * Function: getImageBounds\n *\n * Paints the swimlane vertex shape.\n */\nmxSwimlane.prototype.getImageBounds = function(x, y, w, h)\n{\n\tif (this.isHorizontal())\n\t{\n\t\treturn new mxRectangle(x + w - this.imageSize, y, this.imageSize, this.imageSize);\n\t}\n\telse\n\t{\n\t\treturn new mxRectangle(x, y, this.imageSize, this.imageSize);\n\t}\n};\n\n__mxOutput.mxSwimlane = typeof mxSwimlane !== 'undefined' ? mxSwimlane : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxGraphLayout\n *\n * Base class for all layout algorithms in mxGraph. Main public functions are\n * <move> for handling a moved cell within a layouted parent, and <execute> for\n * running the layout on a given parent cell.\n *\n * Known Subclasses:\n *\n * <mxCircleLayout>, <mxCompactTreeLayout>, <mxCompositeLayout>,\n * <mxFastOrganicLayout>, <mxParallelEdgeLayout>, <mxPartitionLayout>,\n * <mxStackLayout>\n *\n * Constructor: mxGraphLayout\n *\n * Constructs a new layout using the given layouts.\n *\n * Arguments:\n *\n * graph - Enclosing\n */\nfunction mxGraphLayout(graph)\n{\n\tthis.graph = graph;\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxGraphLayout.prototype.graph = null;\n\n/**\n * Variable: useBoundingBox\n *\n * Boolean indicating if the bounding box of the label should be used if\n * its available. Default is true.\n */\nmxGraphLayout.prototype.useBoundingBox = true;\n\n/**\n * Variable: parent\n *\n * The parent cell of the layout, if any\n */\nmxGraphLayout.prototype.parent = null;\n\n/**\n * Function: moveCell\n *\n * Notified when a cell is being moved in a parent that has automatic\n * layout to update the cell state (eg. index) so that the outcome of the\n * layout will position the vertex as close to the point (x, y) as\n * possible.\n *\n * Empty implementation.\n *\n * Parameters:\n *\n * cell - <mxCell> which has been moved.\n * x - X-coordinate of the new cell location.\n * y - Y-coordinate of the new cell location.\n */\nmxGraphLayout.prototype.moveCell = function(cell, x, y) { };\n\n/**\n * Function: execute\n *\n * Executes the layout algorithm for the children of the given parent.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be layed out.\n */\nmxGraphLayout.prototype.execute = function(parent) { };\n\n/**\n * Function: getGraph\n *\n * Returns the graph that this layout operates on.\n */\nmxGraphLayout.prototype.getGraph = function()\n{\n\treturn this.graph;\n};\n\n/**\n * Function: getConstraint\n *\n * Returns the constraint for the given key and cell. The optional edge and\n * source arguments are used to return inbound and outgoing routing-\n * constraints for the given edge and vertex. This implementation always\n * returns the value for the given key in the style of the given cell.\n *\n * Parameters:\n *\n * key - Key of the constraint to be returned.\n * cell - <mxCell> whose constraint should be returned.\n * edge - Optional <mxCell> that represents the connection whose constraint\n * should be returned. Default is null.\n * source - Optional boolean that specifies if the connection is incoming\n * or outgoing. Default is null.\n */\nmxGraphLayout.prototype.getConstraint = function(key, cell, edge, source)\n{\n\tvar state = this.graph.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.graph.getCellStyle(cell);\n\n\treturn (style != null) ? style[key] : null;\n};\n\n/**\n * Function: traverse\n *\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n *\n * Example:\n *\n * (code)\n * mxLog.show();\n * var cell = graph.getSelectionCell();\n * graph.traverse(cell, false, function(vertex, edge)\n * {\n *   mxLog.debug(graph.getLabel(vertex));\n * });\n * (end)\n *\n * Parameters:\n *\n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - Optional boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * func - Visitor function that takes the current vertex and the incoming\n * edge as arguments. The traversal stops if the function returns false.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * visited - Optional <mxDictionary> of cell paths for the visited cells.\n */\nmxGraphLayout.traverse = function(vertex, directed, func, edge, visited)\n{\n\tif (func != null && vertex != null)\n\t{\n\t\tdirected = (directed != null) ? directed : true;\n\t\tvisited = visited || new mxDictionary();\n\n\t\tif (!visited.get(vertex))\n\t\t{\n\t\t\tvisited.put(vertex, true);\n\t\t\tvar result = func(vertex, edge);\n\n\t\t\tif (result == null || result)\n\t\t\t{\n\t\t\t\tvar edgeCount = this.graph.model.getEdgeCount(vertex);\n\n\t\t\t\tif (edgeCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar e = this.graph.model.getEdgeAt(vertex, i);\n\t\t\t\t\t\tvar isSource = this.graph.model.getTerminal(e, true) == vertex;\n\n\t\t\t\t\t\tif (!directed || isSource)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar next = this.graph.view.getVisibleTerminal(e, !isSource);\n\t\t\t\t\t\t\tthis.traverse(next, directed, func, e, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isAncestor\n *\n * Returns true if the given parent is an ancestor of the given child.\n *\n * Parameters:\n *\n * parent - <mxCell> that specifies the parent.\n * child - <mxCell> that specifies the child.\n * traverseAncestors - boolean whether to\n */\nmxGraphLayout.prototype.isAncestor = function(parent, child, traverseAncestors)\n{\n\tif (!traverseAncestors)\n\t{\n\t\treturn (this.graph.model.getParent(child) == parent);\n\t}\n\n\tif (child == parent)\n\t{\n\t\treturn false;\n\t}\n\n\twhile (child != null && child != parent)\n\t{\n\t\tchild = this.graph.model.getParent(child);\n\t}\n\n\treturn child == parent;\n};\n\n/**\n * Function: isVertexMovable\n *\n * Returns a boolean indicating if the given <mxCell> is movable or\n * bendable by the algorithm. This implementation returns true if the given\n * cell is movable in the graph.\n *\n * Parameters:\n *\n * cell - <mxCell> whose movable state should be returned.\n */\nmxGraphLayout.prototype.isVertexMovable = function(cell)\n{\n\treturn this.graph.isCellMovable(cell);\n};\n\n/**\n * Function: isVertexIgnored\n *\n * Returns a boolean indicating if the given <mxCell> should be ignored by\n * the algorithm. This implementation returns false for all vertices.\n *\n * Parameters:\n *\n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxGraphLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn !this.graph.getModel().isVertex(vertex) ||\n\t\t!this.graph.isCellVisible(vertex);\n};\n\n/**\n * Function: isEdgeIgnored\n *\n * Returns a boolean indicating if the given <mxCell> should be ignored by\n * the algorithm. This implementation returns false for all vertices.\n *\n * Parameters:\n *\n * cell - <mxCell> whose ignored state should be returned.\n */\nmxGraphLayout.prototype.isEdgeIgnored = function(edge)\n{\n\tvar model = this.graph.getModel();\n\n\treturn !model.isEdge(edge) ||\n\t\t!this.graph.isCellVisible(edge) ||\n\t\tmodel.getTerminal(edge, true) == null ||\n\t\tmodel.getTerminal(edge, false) == null;\n};\n\n/**\n * Function: setEdgeStyleEnabled\n *\n * Disables or enables the edge style of the given edge.\n */\nmxGraphLayout.prototype.setEdgeStyleEnabled = function(edge, value)\n{\n\tthis.graph.setCellStyles(mxConstants.STYLE_NOEDGESTYLE,\n\t\t\t(value) ? '0' : '1', [edge]);\n};\n\n/**\n * Function: setOrthogonalEdge\n *\n * Disables or enables orthogonal end segments of the given edge.\n */\nmxGraphLayout.prototype.setOrthogonalEdge = function(edge, value)\n{\n\tthis.graph.setCellStyles(mxConstants.STYLE_ORTHOGONAL,\n\t\t\t(value) ? '1' : '0', [edge]);\n};\n\n/**\n * Function: getParentOffset\n *\n * Determines the offset of the given parent to the parent\n * of the layout\n */\nmxGraphLayout.prototype.getParentOffset = function(parent)\n{\n\tvar result = new mxPoint();\n\n\tif (parent != null && parent != this.parent)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tif (model.isAncestor(this.parent, parent))\n\t\t{\n\t\t\tvar parentGeo = model.getGeometry(parent);\n\n\t\t\twhile (parent != this.parent)\n\t\t\t{\n\t\t\t\tresult.x = result.x + parentGeo.x;\n\t\t\t\tresult.y = result.y + parentGeo.y;\n\n\t\t\t\tparent = model.getParent(parent);;\n\t\t\t\tparentGeo = model.getGeometry(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: setEdgePoints\n *\n * Replaces the array of mxPoints in the geometry of the given edge\n * with the given array of mxPoints.\n */\nmxGraphLayout.prototype.setEdgePoints = function(edge, points)\n{\n\tif (edge != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar geometry = model.getGeometry(edge);\n\n\t\tif (geometry == null)\n\t\t{\n\t\t\tgeometry = new mxGeometry();\n\t\t\tgeometry.setRelative(true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeometry = geometry.clone();\n\t\t}\n\n\t\tif (this.parent != null && points != null)\n\t\t{\n\t\t\tvar parent = model.getParent(edge);\n\n\t\t\tvar parentOffset = this.getParentOffset(parent);\n\n\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t{\n\t\t\t\tpoints[i].x = points[i].x - parentOffset.x;\n\t\t\t\tpoints[i].y = points[i].y - parentOffset.y;\n\t\t\t}\n\t\t}\n\n\t\tgeometry.points = points;\n\t\tmodel.setGeometry(edge, geometry);\n\t}\n};\n\n/**\n * Function: setVertexLocation\n *\n * Sets the new position of the given cell taking into account the size of\n * the bounding box if <useBoundingBox> is true. The change is only carried\n * out if the new location is not equal to the existing location, otherwise\n * the geometry is not replaced with an updated instance. The new or old\n * bounds are returned (including overlapping labels).\n *\n * Parameters:\n *\n * cell - <mxCell> whose geometry is to be set.\n * x - Integer that defines the x-coordinate of the new location.\n * y - Integer that defines the y-coordinate of the new location.\n */\nmxGraphLayout.prototype.setVertexLocation = function(cell, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar geometry = model.getGeometry(cell);\n\tvar result = null;\n\n\tif (geometry != null)\n\t{\n\t\tresult = new mxRectangle(x, y, geometry.width, geometry.height);\n\n\t\t// Checks for oversize labels and shifts the result\n\t\t// TODO: Use mxUtils.getStringSize for label bounds\n\t\tif (this.useBoundingBox)\n\t\t{\n\t\t\tvar state = this.graph.getView().getState(cell);\n\n\t\t\tif (state != null && state.text != null && state.text.boundingBox != null)\n\t\t\t{\n\t\t\t\tvar scale = this.graph.getView().scale;\n\t\t\t\tvar box = state.text.boundingBox;\n\n\t\t\t\tif (state.text.boundingBox.x < state.x)\n\t\t\t\t{\n\t\t\t\t\tx += (state.x - box.x) / scale;\n\t\t\t\t\tresult.width = box.width;\n\t\t\t\t}\n\n\t\t\t\tif (state.text.boundingBox.y < state.y)\n\t\t\t\t{\n\t\t\t\t\ty += (state.y - box.y) / scale;\n\t\t\t\t\tresult.height = box.height;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.parent != null)\n\t\t{\n\t\t\tvar parent = model.getParent(cell);\n\n\t\t\tif (parent != null && parent != this.parent)\n\t\t\t{\n\t\t\t\tvar parentOffset = this.getParentOffset(parent);\n\n\t\t\t\tx = x - parentOffset.x;\n\t\t\t\ty = y - parentOffset.y;\n\t\t\t}\n\t\t}\n\n\t\tif (geometry.x != x || geometry.y != y)\n\t\t{\n\t\t\tgeometry = geometry.clone();\n\t\t\tgeometry.x = x;\n\t\t\tgeometry.y = y;\n\n\t\t\tmodel.setGeometry(cell, geometry);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getVertexBounds\n *\n * Returns an <mxRectangle> that defines the bounds of the given cell or\n * the bounding box if <useBoundingBox> is true.\n */\nmxGraphLayout.prototype.getVertexBounds = function(cell)\n{\n\tvar geo = this.graph.getModel().getGeometry(cell);\n\n\t// Checks for oversize label bounding box and corrects\n\t// the return value accordingly\n\t// TODO: Use mxUtils.getStringSize for label bounds\n\tif (this.useBoundingBox)\n\t{\n\t\tvar state = this.graph.getView().getState(cell);\n\n\t\tif (state != null && state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tvar scale = this.graph.getView().scale;\n\t\t\tvar tmp = state.text.boundingBox;\n\n\t\t\tvar dx0 = Math.max(state.x - tmp.x, 0) / scale;\n\t\t\tvar dy0 = Math.max(state.y - tmp.y, 0) / scale;\n\t\t\tvar dx1 = Math.max((tmp.x + tmp.width) - (state.x + state.width), 0) / scale;\n  \t\t\tvar dy1 = Math.max((tmp.y + tmp.height) - (state.y + state.height), 0) / scale;\n\n\t\t\tgeo = new mxRectangle(geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);\n\t\t}\n\t}\n\n\tif (this.parent != null)\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\t\tgeo = geo.clone();\n\n\t\tif (parent != null && parent != this.parent)\n\t\t{\n\t\t\tvar parentOffset = this.getParentOffset(parent);\n\t\t\tgeo.x = geo.x + parentOffset.x;\n\t\t\tgeo.y = geo.y + parentOffset.y;\n\t\t}\n\t}\n\n\treturn new mxRectangle(geo.x, geo.y, geo.width, geo.height);\n};\n\n/**\n * Function: arrangeGroups\n *\n * Shortcut to <mxGraph.updateGroupBounds> with moveGroup set to true.\n */\nmxGraphLayout.prototype.arrangeGroups = function(cells, border, topBorder, rightBorder, bottomBorder, leftBorder)\n{\n\treturn this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);\n};\n\n/**\n * Class: WeightedCellSorter\n *\n * A utility class used to track cells whilst sorting occurs on the weighted\n * sum of their connected edges. Does not violate (x.compareTo(y)==0) ==\n * (x.equals(y))\n *\n * Constructor: WeightedCellSorter\n *\n * Constructs a new weighted cell sorted for the given cell and weight.\n */\nfunction WeightedCellSorter(cell, weightedValue)\n{\n\tthis.cell = cell;\n\tthis.weightedValue = weightedValue;\n};\n\n/**\n * Variable: weightedValue\n *\n * The weighted value of the cell stored.\n */\nWeightedCellSorter.prototype.weightedValue = 0;\n\n/**\n * Variable: nudge\n *\n * Whether or not to flip equal weight values.\n */\nWeightedCellSorter.prototype.nudge = false;\n\n/**\n * Variable: visited\n *\n * Whether or not this cell has been visited in the current assignment.\n */\nWeightedCellSorter.prototype.visited = false;\n\n/**\n * Variable: rankIndex\n *\n * The index this cell is in the model rank.\n */\nWeightedCellSorter.prototype.rankIndex = null;\n\n/**\n * Variable: cell\n *\n * The cell whose median value is being calculated.\n */\nWeightedCellSorter.prototype.cell = null;\n\n/**\n * Function: compare\n *\n * Compares two WeightedCellSorters.\n */\nWeightedCellSorter.prototype.compare = function(a, b)\n{\n\tif (a != null && b != null)\n\t{\n\t\tif (b.weightedValue > a.weightedValue)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse if (b.weightedValue < a.weightedValue)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (b.nudge)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n};\n\n__mxOutput.mxGraphLayout = typeof mxGraphLayout !== 'undefined' ? mxGraphLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStackLayout\n *\n * Extends <mxGraphLayout> to create a horizontal or vertical stack of the\n * child vertices. The children do not need to be connected for this layout\n * to work.\n *\n * Example:\n *\n * (code)\n * var layout = new mxStackLayout(graph, true);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxStackLayout\n *\n * Constructs a new stack layout layout for the specified graph,\n * spacing, orientation and offset.\n */\nfunction mxStackLayout(graph, horizontal, spacing, x0, y0, border)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.spacing = (spacing != null) ? spacing : 0;\n\tthis.x0 = (x0 != null) ? x0 : 0;\n\tthis.y0 = (y0 != null) ? y0 : 0;\n\tthis.border = (border != null) ? border : 0;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxStackLayout.prototype = new mxGraphLayout();\nmxStackLayout.prototype.constructor = mxStackLayout;\n\n/**\n * Variable: horizontal\n *\n * Specifies the orientation of the layout. Default is true.\n */\nmxStackLayout.prototype.horizontal = null;\n\n/**\n * Variable: spacing\n *\n * Specifies the spacing between the cells. Default is 0.\n */\nmxStackLayout.prototype.spacing = null;\n\n/**\n * Variable: x0\n *\n * Specifies the horizontal origin of the layout. Default is 0.\n */\nmxStackLayout.prototype.x0 = null;\n\n/**\n * Variable: y0\n *\n * Specifies the vertical origin of the layout. Default is 0.\n */\nmxStackLayout.prototype.y0 = null;\n\n/**\n * Variable: border\n *\n * Border to be added if fill is true. Default is 0.\n */\nmxStackLayout.prototype.border = 0;\n\n/**\n * Variable: marginTop\n *\n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginTop = 0;\n\n/**\n * Variable: marginLeft\n *\n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginLeft = 0;\n\n/**\n * Variable: marginRight\n *\n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginRight = 0;\n\n/**\n * Variable: marginBottom\n *\n * Top margin for the child area. Default is 0.\n */\nmxStackLayout.prototype.marginBottom = 0;\n\n/**\n * Variable: keepFirstLocation\n *\n * Boolean indicating if the location of the first cell should be\n * kept, that is, it will not be moved to x0 or y0.\n */\nmxStackLayout.prototype.keepFirstLocation = false;\n\n/**\n * Variable: fill\n *\n * Boolean indicating if dimension should be changed to fill out the parent\n * cell. Default is false.\n */\nmxStackLayout.prototype.fill = false;\n\n/**\n * Variable: resizeParent\n *\n * If the parent should be resized to match the width/height of the\n * stack. Default is false.\n */\nmxStackLayout.prototype.resizeParent = false;\n\n/**\n * Variable: resizeParentMax\n *\n * Use maximum of existing value and new value for resize of parent.\n * Default is false.\n */\nmxStackLayout.prototype.resizeParentMax = false;\n\n/**\n * Variable: resizeLast\n *\n * If the last element should be resized to fill out the parent. Default is\n * false. If <resizeParent> is true then this is ignored.\n */\nmxStackLayout.prototype.resizeLast = false;\n\n/**\n * Variable: wrap\n *\n * Value at which a new column or row should be created. Default is null.\n */\nmxStackLayout.prototype.wrap = null;\n\n/**\n * Variable: borderCollapse\n *\n * If the strokeWidth should be ignored. Default is true.\n */\nmxStackLayout.prototype.borderCollapse = true;\n\n/**\n * Variable: allowGaps\n *\n * If gaps should be allowed in the stack. Default is false.\n */\nmxStackLayout.prototype.allowGaps = false;\n\n/**\n * Variable: gridSize\n *\n * Grid size for alignment of position and size. Default is 0.\n */\nmxStackLayout.prototype.gridSize = 0;\n\n/**\n * Function: isHorizontal\n *\n * Returns <horizontal>.\n */\nmxStackLayout.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: moveCell\n *\n * Implements <mxGraphLayout.moveCell>.\n */\nmxStackLayout.prototype.moveCell = function(cell, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar parent = model.getParent(cell);\n\tvar horizontal = this.isHorizontal();\n\n\tif (cell != null && parent != null)\n\t{\n\t\tvar i = 0;\n\t\tvar last = 0;\n\t\tvar childCount = model.getChildCount(parent);\n\t\tvar value = (horizontal) ? x : y;\n\t\tvar pstate = this.graph.getView().getState(parent);\n\n\t\tif (pstate != null)\n\t\t{\n\t\t\tvalue -= (horizontal) ? pstate.x : pstate.y;\n\t\t}\n\n\t\tvalue /= this.graph.view.scale;\n\n\t\tfor (i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(parent, i);\n\n\t\t\tif (child != cell)\n\t\t\t{\n\t\t\t\tvar bounds = model.getGeometry(child);\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = (horizontal) ?\n\t\t\t\t\t\tbounds.x + bounds.width / 2 :\n\t\t\t\t\t\tbounds.y + bounds.height / 2;\n\n\t\t\t\t\tif (last <= value && tmp > value)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlast = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Changes child order in parent\n\t\tvar idx = parent.getIndex(cell);\n\t\tidx = Math.max(0, i - ((i > idx) ? 1 : 0));\n\n\t\tmodel.add(parent, cell, idx);\n\t}\n};\n\n/**\n * Function: getParentSize\n *\n * Returns the size for the parent container or the size of the graph\n * container if the parent is a layer or the root of the model.\n */\nmxStackLayout.prototype.getParentSize = function(parent)\n{\n\tvar model = this.graph.getModel();\n\tvar pgeo = model.getGeometry(parent);\n\n\t// Handles special case where the parent is either a layer with no\n\t// geometry or the current root of the view in which case the size\n\t// of the graph's container will be used.\n\tif (this.graph.container != null && ((pgeo == null &&\n\t\tmodel.isLayer(parent)) || parent == this.graph.getView().currentRoot))\n\t{\n\t\tvar width = this.graph.container.offsetWidth - 1;\n\t\tvar height = this.graph.container.offsetHeight - 1;\n\t\tpgeo = new mxRectangle(0, 0, width, height);\n\t}\n\n\treturn pgeo;\n};\n\n/**\n * Function: getLayoutCells\n *\n * Returns the cells to be layouted.\n */\nmxStackLayout.prototype.getLayoutCells = function(parent)\n{\n\tvar model = this.graph.getModel();\n\tvar childCount = model.getChildCount(parent);\n\tvar cells = [];\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(parent, i);\n\n\t\tif (!this.isVertexIgnored(child) && this.isVertexMovable(child))\n\t\t{\n\t\t\tcells.push(child);\n\t\t}\n\t}\n\n\tif (this.allowGaps)\n\t{\n\t\tcells.sort(mxUtils.bind(this, function(c1, c2)\n\t\t{\n\t\t\tvar geo1 = this.graph.getCellGeometry(c1);\n\t\t\tvar geo2 = this.graph.getCellGeometry(c2);\n\n\t\t\treturn (geo1.y == geo2.y) ? 0 : ((geo1.y > geo2.y > 0) ? 1 : -1);\n\t\t}));\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: snap\n *\n * Snaps the given value to the grid size.\n */\nmxStackLayout.prototype.snap = function(value)\n{\n\tif (this.gridSize != null && this.gridSize > 0)\n\t{\n\t\tvalue = Math.max(value, this.gridSize);\n\n\t\tif (value / this.gridSize > 1)\n\t\t{\n\t\t\tvar mod = value % this.gridSize;\n\t\t\tvalue += mod > this.gridSize / 2 ? (this.gridSize - mod) : -mod;\n\t\t}\n\t}\n\n\treturn value;\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n *\n * Only children where <isVertexIgnored> returns false are taken into\n * account.\n */\nmxStackLayout.prototype.execute = function(parent)\n{\n\tif (parent != null)\n\t{\n\t\tvar pgeo = this.getParentSize(parent);\n\t\tvar horizontal = this.isHorizontal();\n\t\tvar model = this.graph.getModel();\n\t\tvar fillValue = null;\n\n\t\tif (pgeo != null)\n\t\t{\n\t\t\tfillValue = (horizontal) ? pgeo.height - this.marginTop - this.marginBottom :\n\t\t\t\tpgeo.width - this.marginLeft - this.marginRight;\n\t\t}\n\n\t\tfillValue -= 2 * this.border;\n\t\tvar x0 = this.x0 + this.border + this.marginLeft;\n\t\tvar y0 = this.y0 + this.border + this.marginTop;\n\n\t\t// Handles swimlane start size\n\t\tif (this.graph.isSwimlane(parent))\n\t\t{\n\t\t\t// Uses computed style to get latest\n\t\t\tvar style = this.graph.getCellStyle(parent);\n\t\t\tvar start = mxUtils.getNumber(style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE);\n\t\t\tvar horz = mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true) == 1;\n\n\t\t\tif (pgeo != null)\n\t\t\t{\n\t\t\t\tif (horz)\n\t\t\t\t{\n\t\t\t\t\tstart = Math.min(start, pgeo.height);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstart = Math.min(start, pgeo.width);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (horizontal == horz)\n\t\t\t{\n\t\t\t\tfillValue -= start;\n\t\t\t}\n\n\t\t\tif (horz)\n\t\t\t{\n\t\t\t\ty0 += start;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx0 += start;\n\t\t\t}\n\t\t}\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar tmp = 0;\n\t\t\tvar last = null;\n\t\t\tvar lastValue = 0;\n\t\t\tvar lastChild = null;\n\t\t\tvar cells = this.getLayoutCells(parent);\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar child = cells[i];\n\t\t\t\tvar geo = model.getGeometry(child);\n\n\t\t\t\tif (geo != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\tif (this.wrap != null && last != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((horizontal && last.x + last.width +\n\t\t\t\t\t\t\tgeo.width + 2 * this.spacing > this.wrap) ||\n\t\t\t\t\t\t\t(!horizontal && last.y + last.height +\n\t\t\t\t\t\t\tgeo.height + 2 * this.spacing > this.wrap))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlast = null;\n\n\t\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ty0 += tmp + this.spacing;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tx0 += tmp + this.spacing;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttmp = Math.max(tmp, (horizontal) ? geo.height : geo.width);\n\t\t\t\t\tvar sw = 0;\n\n\t\t\t\t\tif (!this.borderCollapse)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar childStyle = this.graph.getCellStyle(child);\n\t\t\t\t\t\tsw = mxUtils.getNumber(childStyle, mxConstants.STYLE_STROKEWIDTH, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (last != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar temp = lastValue + this.spacing + Math.floor(sw / 2);\n\n\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x = this.snap(((this.allowGaps) ? Math.max(temp, geo.x) :\n\t\t\t\t\t\t\t\ttemp) - this.marginLeft) + this.marginLeft;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.y = this.snap(((this.allowGaps) ? Math.max(temp, geo.y) :\n\t\t\t\t\t\t\t\ttemp) - this.marginTop) + this.marginTop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!this.keepFirstLocation)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x = (this.allowGaps && geo.x > x0) ? Math.max(this.snap(geo.x -\n\t\t\t\t\t\t\t\tthis.marginLeft) + this.marginLeft, x0) : x0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.y = (this.allowGaps && geo.y > y0) ? Math.max(this.snap(geo.y -\n\t\t\t\t\t\t\t\tthis.marginTop) + this.marginTop, y0) : y0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (horizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.y = y0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.x = x0;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.fill && fillValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.height = fillValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.width = fillValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (horizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.width = this.snap(geo.width);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.height = this.snap(geo.height);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.setChildGeometry(child, geo);\n\t\t\t\t\tlastChild = child;\n\t\t\t\t\tlast = geo;\n\n\t\t\t\t\tif (horizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tlastValue = last.x + last.width + Math.floor(sw / 2);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlastValue = last.y + last.height + Math.floor(sw / 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.resizeParent && pgeo != null && last != null && !this.graph.isCellCollapsed(parent))\n\t\t\t{\n\t\t\t\tthis.updateParentGeometry(parent, pgeo, last);\n\t\t\t}\n\t\t\telse if (this.resizeLast && pgeo != null && last != null && lastChild != null)\n\t\t\t{\n\t\t\t\tif (horizontal)\n\t\t\t\t{\n\t\t\t\t\tlast.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlast.height = pgeo.height - last.y - this.spacing - this.marginBottom;\n\t\t\t\t}\n\n\t\t\t\tthis.setChildGeometry(lastChild, last);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n *\n * Only children where <isVertexIgnored> returns false are taken into\n * account.\n */\nmxStackLayout.prototype.setChildGeometry = function(child, geo)\n{\n\tvar geo2 = this.graph.getCellGeometry(child);\n\n\tif (geo2 == null || geo.x != geo2.x || geo.y != geo2.y ||\n\t\tgeo.width != geo2.width || geo.height != geo2.height)\n\t{\n\t\tthis.graph.getModel().setGeometry(child, geo);\n\t}\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n *\n * Only children where <isVertexIgnored> returns false are taken into\n * account.\n */\nmxStackLayout.prototype.updateParentGeometry = function(parent, pgeo, last)\n{\n\tvar horizontal = this.isHorizontal();\n\tvar model = this.graph.getModel();\n\n\tvar pgeo2 = pgeo.clone();\n\n\tif (horizontal)\n\t{\n\t\tvar tmp = last.x + last.width + this.marginRight + this.border;\n\n\t\tif (this.resizeParentMax)\n\t\t{\n\t\t\tpgeo2.width = Math.max(pgeo2.width, tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpgeo2.width = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar tmp = last.y + last.height + this.marginBottom + this.border;\n\n\t\tif (this.resizeParentMax)\n\t\t{\n\t\t\tpgeo2.height = Math.max(pgeo2.height, tmp);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpgeo2.height = tmp;\n\t\t}\n\t}\n\n\tif (pgeo.x != pgeo2.x || pgeo.y != pgeo2.y ||\n\t\tpgeo.width != pgeo2.width || pgeo.height != pgeo2.height)\n\t{\n\t\tmodel.setGeometry(parent, pgeo2);\n\t}\n};\n\n__mxOutput.mxStackLayout = typeof mxStackLayout !== 'undefined' ? mxStackLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPartitionLayout\n *\n * Extends <mxGraphLayout> for partitioning the parent cell vertically or\n * horizontally by filling the complete area with the child cells. A horizontal\n * layout partitions the height of the given parent whereas a a non-horizontal\n * layout partitions the width. If the parent is a layer (that is, a child of\n * the root node), then the current graph size is partitioned. The children do\n * not need to be connected for this layout to work.\n *\n * Example:\n *\n * (code)\n * var layout = new mxPartitionLayout(graph, true, 10, 20);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxPartitionLayout\n *\n * Constructs a new stack layout layout for the specified graph,\n * spacing, orientation and offset.\n */\nfunction mxPartitionLayout(graph, horizontal, spacing, border)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.spacing = spacing || 0;\n\tthis.border = border || 0;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxPartitionLayout.prototype = new mxGraphLayout();\nmxPartitionLayout.prototype.constructor = mxPartitionLayout;\n\n/**\n * Variable: horizontal\n *\n * Boolean indicating the direction in which the space is partitioned.\n * Default is true.\n */\nmxPartitionLayout.prototype.horizontal = null;\n\n/**\n * Variable: spacing\n *\n * Integer that specifies the absolute spacing in pixels between the\n * children. Default is 0.\n */\nmxPartitionLayout.prototype.spacing = null;\n\n/**\n * Variable: border\n *\n * Integer that specifies the absolute inset in pixels for the parent that\n * contains the children. Default is 0.\n */\nmxPartitionLayout.prototype.border = null;\n\n/**\n * Variable: resizeVertices\n *\n * Boolean that specifies if vertices should be resized. Default is true.\n */\nmxPartitionLayout.prototype.resizeVertices = true;\n\n/**\n * Function: isHorizontal\n *\n * Returns <horizontal>.\n */\nmxPartitionLayout.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: moveCell\n *\n * Implements <mxGraphLayout.moveCell>.\n */\nmxPartitionLayout.prototype.moveCell = function(cell, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar parent = model.getParent(cell);\n\n\tif (cell != null &&\n\t\tparent != null)\n\t{\n\t\tvar i = 0;\n\t\tvar last = 0;\n\t\tvar childCount = model.getChildCount(parent);\n\n\t\t// Finds index of the closest swimlane\n\t\t// TODO: Take into account the orientation\n\t\tfor (i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(parent, i);\n\t\t\tvar bounds = this.getVertexBounds(child);\n\n\t\t\tif (bounds != null)\n\t\t\t{\n\t\t\t\tvar tmp = bounds.x + bounds.width / 2;\n\n\t\t\t\tif (last < x && tmp > x)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlast = tmp;\n\t\t\t}\n\t\t}\n\n\t\t// Changes child order in parent\n\t\tvar idx = parent.getIndex(cell);\n\t\tidx = Math.max(0, i - ((i > idx) ? 1 : 0));\n\n\t\tmodel.add(parent, cell, idx);\n\t}\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>. All children where <isVertexIgnored>\n * returns false and <isVertexMovable> returns true are modified.\n */\nmxPartitionLayout.prototype.execute = function(parent)\n{\n\tvar horizontal = this.isHorizontal();\n\tvar model = this.graph.getModel();\n\tvar pgeo = model.getGeometry(parent);\n\n\t// Handles special case where the parent is either a layer with no\n\t// geometry or the current root of the view in which case the size\n\t// of the graph's container will be used.\n\tif (this.graph.container != null &&\n\t\t((pgeo == null &&\n\t\tmodel.isLayer(parent)) ||\n\t\tparent == this.graph.getView().currentRoot))\n\t{\n\t\tvar width = this.graph.container.offsetWidth - 1;\n\t\tvar height = this.graph.container.offsetHeight - 1;\n\t\tpgeo = new mxRectangle(0, 0, width, height);\n\t}\n\n\tif (pgeo != null)\n\t{\n\t\tvar children = [];\n\t\tvar childCount = model.getChildCount(parent);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(parent, i);\n\n\t\t\tif (!this.isVertexIgnored(child) &&\n\t\t\t\tthis.isVertexMovable(child))\n\t\t\t{\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\t\t}\n\n\t\tvar n = children.length;\n\n\t\tif (n > 0)\n\t\t{\n\t\t\tvar x0 = this.border;\n\t\t\tvar y0 = this.border;\n\t\t\tvar other = (horizontal) ? pgeo.height : pgeo.width;\n\t\t\tother -= 2 * this.border;\n\n\t\t\tvar size = (this.graph.isSwimlane(parent)) ?\n\t\t\t\tthis.graph.getStartSize(parent) :\n\t\t\t\tnew mxRectangle();\n\n\t\t\tother -= (horizontal) ? size.height : size.width;\n\t\t\tx0 = x0 + size.width;\n\t\t\ty0 = y0 + size.height;\n\n\t\t\tvar tmp = this.border + (n - 1) * this.spacing;\n\t\t\tvar value = (horizontal) ?\n\t\t\t\t((pgeo.width - x0 - tmp) / n) :\n\t\t\t\t((pgeo.height - y0 - tmp) / n);\n\n\t\t\t// Avoids negative values, that is values where the sum of the\n\t\t\t// spacing plus the border is larger then the available space\n\t\t\tif (value > 0)\n\t\t\t{\n\t\t\t\tmodel.beginUpdate();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < n; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar child = children[i];\n\t\t\t\t\t\tvar geo = model.getGeometry(child);\n\n\t\t\t\t\t\tif (geo != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tgeo.x = x0;\n\t\t\t\t\t\t\tgeo.y = y0;\n\n\t\t\t\t\t\t\tif (horizontal)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (this.resizeVertices)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.width = value;\n\t\t\t\t\t\t\t\t\tgeo.height = other;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tx0 += value + this.spacing;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (this.resizeVertices)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.height = value;\n\t\t\t\t\t\t\t\t\tgeo.width = other;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ty0 += value + this.spacing;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmodel.setGeometry(child, geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tmodel.endUpdate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n__mxOutput.mxPartitionLayout = typeof mxPartitionLayout !== 'undefined' ? mxPartitionLayout : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxCompactTreeLayout\n *\n * Extends <mxGraphLayout> to implement a compact tree (Moen) algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n *\n * Example:\n *\n * (code)\n * var layout = new mxCompactTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxCompactTreeLayout\n *\n * Constructs a new compact tree layout for the specified graph\n * and orientation.\n */\nfunction mxCompactTreeLayout(graph, horizontal, invert)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.invert = (invert != null) ? invert : false;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxCompactTreeLayout.prototype = new mxGraphLayout();\nmxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;\n\n/**\n * Variable: horizontal\n *\n * Specifies the orientation of the layout. Default is true.\n */\nmxCompactTreeLayout.prototype.horizontal = null;\n\n/**\n * Variable: invert\n *\n * Specifies if edge directions should be inverted. Default is false.\n */\nmxCompactTreeLayout.prototype.invert = null;\n\n/**\n * Variable: resizeParent\n *\n * If the parents should be resized to match the width/height of the\n * children. Default is true.\n */\nmxCompactTreeLayout.prototype.resizeParent = true;\n\n/**\n * Variable: maintainParentLocation\n *\n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxCompactTreeLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: groupPadding\n *\n * Padding added to resized parents. Default is 10.\n */\nmxCompactTreeLayout.prototype.groupPadding = 10;\n\n/**\n * Variable: groupPaddingTop\n *\n * Top padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingTop = 0;\n\n/**\n * Variable: groupPaddingRight\n *\n * Right padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingRight = 0;\n\n/**\n * Variable: groupPaddingBottom\n *\n * Bottom padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingBottom = 0;\n\n/**\n * Variable: groupPaddingLeft\n *\n * Left padding added to resized parents. Default is 0.\n */\nmxCompactTreeLayout.prototype.groupPaddingLeft = 0;\n\n/**\n * Variable: parentsChanged\n *\n * A set of the parents that need updating based on children\n * process as part of the layout.\n */\nmxCompactTreeLayout.prototype.parentsChanged = null;\n\n/**\n * Variable: moveTree\n *\n * Specifies if the tree should be moved to the top, left corner\n * if it is inside a top-level layer. Default is false.\n */\nmxCompactTreeLayout.prototype.moveTree = false;\n\n/**\n * Variable: visited\n *\n * Specifies if the tree should be moved to the top, left corner\n * if it is inside a top-level layer. Default is false.\n */\nmxCompactTreeLayout.prototype.visited = null;\n\n/**\n * Variable: levelDistance\n *\n * Holds the levelDistance. Default is 10.\n */\nmxCompactTreeLayout.prototype.levelDistance = 10;\n\n/**\n * Variable: nodeDistance\n *\n * Holds the nodeDistance. Default is 20.\n */\nmxCompactTreeLayout.prototype.nodeDistance = 20;\n\n/**\n * Variable: resetEdges\n *\n * Specifies if all edge points of traversed edges should be removed.\n * Default is true.\n */\nmxCompactTreeLayout.prototype.resetEdges = true;\n\n/**\n * Variable: prefHozEdgeSep\n *\n * The preferred horizontal distance between edges exiting a vertex.\n */\nmxCompactTreeLayout.prototype.prefHozEdgeSep = 5;\n\n/**\n * Variable: prefVertEdgeOff\n *\n * The preferred vertical offset between edges exiting a vertex.\n */\nmxCompactTreeLayout.prototype.prefVertEdgeOff = 4;\n\n/**\n * Variable: minEdgeJetty\n *\n * The minimum distance for an edge jetty from a vertex.\n */\nmxCompactTreeLayout.prototype.minEdgeJetty = 8;\n\n/**\n * Variable: channelBuffer\n *\n * The size of the vertical buffer in the center of inter-rank channels\n * where edge control points should not be placed.\n */\nmxCompactTreeLayout.prototype.channelBuffer = 4;\n\n/**\n * Variable: edgeRouting\n *\n * Whether or not to apply the internal tree edge routing.\n */\nmxCompactTreeLayout.prototype.edgeRouting = true;\n\n/**\n * Variable: sortEdges\n *\n * Specifies if edges should be sorted according to the order of their\n * opposite terminal cell in the model.\n */\nmxCompactTreeLayout.prototype.sortEdges = false;\n\n/**\n * Variable: alignRanks\n *\n * Whether or not the tops of cells in each rank should be aligned\n * across the rank\n */\nmxCompactTreeLayout.prototype.alignRanks = false;\n\n/**\n * Variable: maxRankHeight\n *\n * An array of the maximum height of cells (relative to the layout direction)\n * per rank\n */\nmxCompactTreeLayout.prototype.maxRankHeight = null;\n\n/**\n * Variable: root\n *\n * The cell to use as the root of the tree\n */\nmxCompactTreeLayout.prototype.root = null;\n\n/**\n * Variable: node\n *\n * The internal node representation of the root cell. Do not set directly\n * , this value is only exposed to assist with post-processing functionality\n */\nmxCompactTreeLayout.prototype.node = null;\n\n/**\n * Function: isVertexIgnored\n *\n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n *\n * Parameters:\n *\n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxCompactTreeLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: isHorizontal\n *\n * Returns <horizontal>.\n */\nmxCompactTreeLayout.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n *\n * If the parent has any connected edges, then it is used as the root of\n * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\n * root node within the set of children of the given parent.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be laid out.\n * root - Optional <mxCell> that will be used as the root of the tree.\n * Overrides <root> if specified.\n */\nmxCompactTreeLayout.prototype.execute = function(parent, root)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.getModel();\n\n\tif (root == null)\n\t{\n\t\t// Takes the parent as the root if it has outgoing edges\n\t\tif (this.graph.getEdges(parent, model.getParent(parent),\n\t\t\tthis.invert, !this.invert, false).length > 0)\n\t\t{\n\t\t\tthis.root = parent;\n\t\t}\n\n\t\t// Tries to find a suitable root in the parent's\n\t\t// children\n\t\telse\n\t\t{\n\t\t\tvar roots = this.graph.findTreeRoots(parent, true, this.invert);\n\n\t\t\tif (roots.length > 0)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < roots.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (!this.isVertexIgnored(roots[i]) &&\n\t\t\t\t\t\tthis.graph.getEdges(roots[i], null,\n\t\t\t\t\t\t\tthis.invert, !this.invert, false).length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.root = roots[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.root = root;\n\t}\n\n\tif (this.root != null)\n\t{\n\t\tif (this.resizeParent)\n\t\t{\n\t\t\tthis.parentsChanged = new Object();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.parentsChanged = null;\n\t\t}\n\n\t\t//  Maintaining parent location\n\t\tthis.parentX = null;\n\t\tthis.parentY = null;\n\n\t\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tthis.parentX = geo.x;\n\t\t\t\tthis.parentY = geo.y;\n\t\t\t}\n\t\t}\n\n\t\tmodel.beginUpdate();\n\n\t\ttry\n\t\t{\n\t\t\tthis.visited = new Object();\n\t\t\tthis.node = this.dfs(this.root, parent);\n\n\t\t\tif (this.alignRanks)\n\t\t\t{\n\t\t\t\tthis.maxRankHeight = [];\n\t\t\t\tthis.findRankHeights(this.node, 0);\n\t\t\t\tthis.setCellHeights(this.node, 0);\n\t\t\t}\n\n\t\t\tif (this.node != null)\n\t\t\t{\n\t\t\t\tthis.layout(this.node);\n\t\t\t\tvar x0 = this.graph.gridSize;\n\t\t\t\tvar y0 = x0;\n\n\t\t\t\tif (!this.moveTree)\n\t\t\t\t{\n\t\t\t\t\tvar g = this.getVertexBounds(this.root);\n\n\t\t\t\t\tif (g != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx0 = g.x;\n\t\t\t\t\t\ty0 = g.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar bounds = null;\n\n\t\t\t\tif (this.isHorizontal())\n\t\t\t\t{\n\t\t\t\t\tbounds = this.horizontalLayout(this.node, x0, y0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbounds = this.verticalLayout(this.node, null, x0, y0);\n\t\t\t\t}\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tvar dx = 0;\n\t\t\t\t\tvar dy = 0;\n\n\t\t\t\t\tif (bounds.x < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx = Math.abs(x0 - bounds.x);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bounds.y < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy = Math.abs(y0 - bounds.y);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dx != 0 || dy != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.moveNode(this.node, dx, dy);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.resizeParent)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.adjustParents();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.edgeRouting)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Iterate through all edges setting their positions\n\t\t\t\t\t\tthis.localEdgeProcessing(this.node);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Maintaining parent location\n\t\t\t\tif (this.parentX != null && this.parentY != null)\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\tgeo.x = this.parentX;\n\t\t\t\t\t\tgeo.y = this.parentY;\n\t\t\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: moveNode\n *\n * Moves the specified node and all of its children by the given amount.\n */\nmxCompactTreeLayout.prototype.moveNode = function(node, dx, dy)\n{\n\tnode.x += dx;\n\tnode.y += dy;\n\tthis.apply(node);\n\n\tvar child = node.child;\n\n\twhile (child != null)\n\t{\n\t\tthis.moveNode(child, dx, dy);\n\t\tchild = child.next;\n\t}\n};\n\n\n/**\n * Function: sortOutgoingEdges\n *\n * Called if <sortEdges> is true to sort the array of outgoing edges in place.\n */\nmxCompactTreeLayout.prototype.sortOutgoingEdges = function(source, edges)\n{\n\tvar lookup = new mxDictionary();\n\n\tedges.sort(function(e1, e2)\n\t{\n\t\tvar end1 = e1.getTerminal(e1.getTerminal(false) == source);\n\t\tvar p1 = lookup.get(end1);\n\n\t\tif (p1 == null)\n\t\t{\n\t\t\tp1 = mxCellPath.create(end1).split(mxCellPath.PATH_SEPARATOR);\n\t\t\tlookup.put(end1, p1);\n\t\t}\n\n\t\tvar end2 = e2.getTerminal(e2.getTerminal(false) == source);\n\t\tvar p2 = lookup.get(end2);\n\n\t\tif (p2 == null)\n\t\t{\n\t\t\tp2 = mxCellPath.create(end2).split(mxCellPath.PATH_SEPARATOR);\n\t\t\tlookup.put(end2, p2);\n\t\t}\n\n\t\treturn mxCellPath.compare(p1, p2);\n\t});\n};\n\n/**\n * Function: findRankHeights\n *\n * Stores the maximum height (relative to the layout\n * direction) of cells in each rank\n */\nmxCompactTreeLayout.prototype.findRankHeights = function(node, rank)\n{\n\tif (this.maxRankHeight[rank] == null || this.maxRankHeight[rank] < node.height)\n\t{\n\t\tthis.maxRankHeight[rank] = node.height;\n\t}\n\n\tvar child = node.child;\n\n\twhile (child != null)\n\t{\n\t\tthis.findRankHeights(child, rank + 1);\n\t\tchild = child.next;\n\t}\n};\n\n/**\n * Function: setCellHeights\n *\n * Set the cells heights (relative to the layout\n * direction) when the tops of each rank are to be aligned\n */\nmxCompactTreeLayout.prototype.setCellHeights = function(node, rank)\n{\n\tif (this.maxRankHeight[rank] != null && this.maxRankHeight[rank] > node.height)\n\t{\n\t\tnode.height = this.maxRankHeight[rank];\n\t}\n\n\tvar child = node.child;\n\n\twhile (child != null)\n\t{\n\t\tthis.setCellHeights(child, rank + 1);\n\t\tchild = child.next;\n\t}\n};\n\n/**\n * Function: dfs\n *\n * Does a depth first search starting at the specified cell.\n * Makes sure the specified parent is never left by the\n * algorithm.\n */\nmxCompactTreeLayout.prototype.dfs = function(cell, parent)\n{\n\tvar id = mxCellPath.create(cell);\n\tvar node = null;\n\n\tif (cell != null && this.visited[id] == null && !this.isVertexIgnored(cell))\n\t{\n\t\tthis.visited[id] = cell;\n\t\tnode = this.createNode(cell);\n\n\t\tvar model = this.graph.getModel();\n\t\tvar prev = null;\n\t\tvar out = this.graph.getEdges(cell, parent, this.invert, !this.invert, false, true);\n\t\tvar view = this.graph.getView();\n\n\t\tif (this.sortEdges)\n\t\t{\n\t\t\tthis.sortOutgoingEdges(cell, out);\n\t\t}\n\n\t\tfor (var i = 0; i < out.length; i++)\n\t\t{\n\t\t\tvar edge = out[i];\n\n\t\t\tif (!this.isEdgeIgnored(edge))\n\t\t\t{\n\t\t\t\t// Resets the points on the traversed edge\n\t\t\t\tif (this.resetEdges)\n\t\t\t\t{\n\t\t\t\t\tthis.setEdgePoints(edge, null);\n\t\t\t\t}\n\n\t\t\t\tif (this.edgeRouting)\n\t\t\t\t{\n\t\t\t\t\tthis.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\tthis.setEdgePoints(edge, null);\n\t\t\t\t}\n\n\t\t\t\t// Checks if terminal in same swimlane\n\t\t\t\tvar state = view.getState(edge);\n\t\t\t\tvar target = (state != null) ? state.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge, this.invert);\n\t\t\t\tvar tmp = this.dfs(target, parent);\n\n\t\t\t\tif (tmp != null && model.getGeometry(target) != null)\n\t\t\t\t{\n\t\t\t\t\tif (prev == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.child = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tprev.next = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tprev = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n};\n\n/**\n * Function: layout\n *\n * Starts the actual compact tree layout algorithm\n * at the given node.\n */\nmxCompactTreeLayout.prototype.layout = function(node)\n{\n\tif (node != null)\n\t{\n\t\tvar child = node.child;\n\n\t\twhile (child != null)\n\t\t{\n\t\t\tthis.layout(child);\n\t\t\tchild = child.next;\n\t\t}\n\n\t\tif (node.child != null)\n\t\t{\n\t\t\tthis.attachParent(node, this.join(node));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.layoutLeaf(node);\n\t\t}\n\t}\n};\n\n/**\n * Function: horizontalLayout\n */\nmxCompactTreeLayout.prototype.horizontalLayout = function(node, x0, y0, bounds)\n{\n\tnode.x += x0 + node.offsetX;\n\tnode.y += y0 + node.offsetY;\n\tbounds = this.apply(node, bounds);\n\tvar child = node.child;\n\n\tif (child != null)\n\t{\n\t\tbounds = this.horizontalLayout(child, node.x, node.y, bounds);\n\t\tvar siblingOffset = node.y + child.offsetY;\n\t\tvar s = child.next;\n\n\t\twhile (s != null)\n\t\t{\n\t\t\tbounds = this.horizontalLayout(s, node.x + child.offsetX, siblingOffset, bounds);\n\t\t\tsiblingOffset += s.offsetY;\n\t\t\ts = s.next;\n\t\t}\n\t}\n\n\treturn bounds;\n};\n\n/**\n * Function: verticalLayout\n */\nmxCompactTreeLayout.prototype.verticalLayout = function(node, parent, x0, y0, bounds)\n{\n\tnode.x += x0 + node.offsetY;\n\tnode.y += y0 + node.offsetX;\n\tbounds = this.apply(node, bounds);\n\tvar child = node.child;\n\n\tif (child != null)\n\t{\n\t\tbounds = this.verticalLayout(child, node, node.x, node.y, bounds);\n\t\tvar siblingOffset = node.x + child.offsetY;\n\t\tvar s = child.next;\n\n\t\twhile (s != null)\n\t\t{\n\t\t\tbounds = this.verticalLayout(s, node, siblingOffset, node.y + child.offsetX, bounds);\n\t\t\tsiblingOffset += s.offsetY;\n\t\t\ts = s.next;\n\t\t}\n\t}\n\n\treturn bounds;\n};\n\n/**\n * Function: attachParent\n */\nmxCompactTreeLayout.prototype.attachParent = function(node, height)\n{\n\tvar x = this.nodeDistance + this.levelDistance;\n\tvar y2 = (height - node.width) / 2 - this.nodeDistance;\n\tvar y1 = y2 + node.width + 2 * this.nodeDistance - height;\n\n\tnode.child.offsetX = x + node.height;\n\tnode.child.offsetY = y1;\n\n\tnode.contour.upperHead = this.createLine(node.height, 0,\n\t\tthis.createLine(x, y1, node.contour.upperHead));\n\tnode.contour.lowerHead = this.createLine(node.height, 0,\n\t\tthis.createLine(x, y2, node.contour.lowerHead));\n};\n\n/**\n * Function: layoutLeaf\n */\nmxCompactTreeLayout.prototype.layoutLeaf = function(node)\n{\n\tvar dist = 2 * this.nodeDistance;\n\n\tnode.contour.upperTail = this.createLine(\n\t\tnode.height + dist, 0);\n\tnode.contour.upperHead = node.contour.upperTail;\n\tnode.contour.lowerTail = this.createLine(\n\t\t0, -node.width - dist);\n\tnode.contour.lowerHead = this.createLine(\n\t\tnode.height + dist, 0, node.contour.lowerTail);\n};\n\n/**\n * Function: join\n */\nmxCompactTreeLayout.prototype.join = function(node)\n{\n\tvar dist = 2 * this.nodeDistance;\n\n\tvar child = node.child;\n\tnode.contour = child.contour;\n\tvar h = child.width + dist;\n\tvar sum = h;\n\tchild = child.next;\n\n\twhile (child != null)\n\t{\n\t\tvar d = this.merge(node.contour, child.contour);\n\t\tchild.offsetY = d + h;\n\t\tchild.offsetX = 0;\n\t\th = child.width + dist;\n\t\tsum += d + h;\n\t\tchild = child.next;\n\t}\n\n\treturn sum;\n};\n\n/**\n * Function: merge\n */\nmxCompactTreeLayout.prototype.merge = function(p1, p2)\n{\n\tvar x = 0;\n\tvar y = 0;\n\tvar total = 0;\n\n\tvar upper = p1.lowerHead;\n\tvar lower = p2.upperHead;\n\n\twhile (lower != null && upper != null)\n\t{\n\t\tvar d = this.offset(x, y, lower.dx, lower.dy,\n\t\t\tupper.dx, upper.dy);\n\t\ty += d;\n\t\ttotal += d;\n\n\t\tif (x + lower.dx <= upper.dx)\n\t\t{\n\t\t\tx += lower.dx;\n\t\t\ty += lower.dy;\n\t\t\tlower = lower.next;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx -= upper.dx;\n\t\t\ty -= upper.dy;\n\t\t\tupper = upper.next;\n\t\t}\n\t}\n\n\tif (lower != null)\n\t{\n\t\tvar b = this.bridge(p1.upperTail, 0, 0, lower, x, y);\n\t\tp1.upperTail = (b.next != null) ? p2.upperTail : b;\n\t\tp1.lowerTail = p2.lowerTail;\n\t}\n\telse\n\t{\n\t\tvar b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);\n\n\t\tif (b.next == null)\n\t\t{\n\t\t\tp1.lowerTail = b;\n\t\t}\n\t}\n\n\tp1.lowerHead = p2.lowerHead;\n\n\treturn total;\n};\n\n/**\n * Function: offset\n */\nmxCompactTreeLayout.prototype.offset = function(p1, p2, a1, a2, b1, b2)\n{\n\tvar d = 0;\n\n\tif (b1 <= p1 || p1 + a1 <= 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tvar t = b1 * a2 - a1 * b2;\n\n\tif (t > 0)\n\t{\n\t\tif (p1 < 0)\n\t\t{\n\t\t\tvar s = p1 * a2;\n\t\t\td = s / a1 - p2;\n\t\t}\n\t\telse if (p1 > 0)\n\t\t{\n\t\t\tvar s = p1 * b2;\n\t\t\td = s / b1 - p2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\td = -p2;\n\t\t}\n\t}\n\telse if (b1 < p1 + a1)\n\t{\n\t\tvar s = (b1 - p1) * a2;\n\t\td = b2 - (p2 + s / a1);\n\t}\n\telse if (b1 > p1 + a1)\n\t{\n\t\tvar s = (a1 + p1) * b2;\n\t\td = s / b1 - (p2 + a2);\n\t}\n\telse\n\t{\n\t\td = b2 - (p2 + a2);\n\t}\n\n\tif (d > 0)\n\t{\n\t\treturn d;\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n};\n\n/**\n * Function: bridge\n */\nmxCompactTreeLayout.prototype.bridge = function(line1, x1, y1, line2, x2, y2)\n{\n\tvar dx = x2 + line2.dx - x1;\n\tvar dy = 0;\n\tvar s = 0;\n\n\tif (line2.dx == 0)\n\t{\n\t\tdy = line2.dy;\n\t}\n\telse\n\t{\n\t\ts = dx * line2.dy;\n\t\tdy = s / line2.dx;\n\t}\n\n\tvar r = this.createLine(dx, dy, line2.next);\n\tline1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);\n\n\treturn r;\n};\n\n/**\n * Function: createNode\n */\nmxCompactTreeLayout.prototype.createNode = function(cell)\n{\n\tvar node = new Object();\n\tnode.cell = cell;\n\tnode.x = 0;\n\tnode.y = 0;\n\tnode.width = 0;\n\tnode.height = 0;\n\n\tvar geo = this.getVertexBounds(cell);\n\n\tif (geo != null)\n\t{\n\t\tif (this.isHorizontal())\n\t\t{\n\t\t\tnode.width = geo.height;\n\t\t\tnode.height = geo.width;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnode.width = geo.width;\n\t\t\tnode.height = geo.height;\n\t\t}\n\t}\n\n\tnode.offsetX = 0;\n\tnode.offsetY = 0;\n\tnode.contour = new Object();\n\n\treturn node;\n};\n\n/**\n * Function: apply\n */\nmxCompactTreeLayout.prototype.apply = function(node, bounds)\n{\n\tvar model = this.graph.getModel();\n\tvar cell = node.cell;\n\tvar g = model.getGeometry(cell);\n\n\tif (cell != null && g != null)\n\t{\n\t\tif (this.isVertexMovable(cell))\n\t\t{\n\t\t\tg = this.setVertexLocation(cell, node.x, node.y);\n\n\t\t\tif (this.resizeParent)\n\t\t\t{\n\t\t\t\tvar parent = model.getParent(cell);\n\t\t\t\tvar id = mxCellPath.create(parent);\n\n\t\t\t\t// Implements set semantic\n\t\t\t\tif (this.parentsChanged[id] == null)\n\t\t\t\t{\n\t\t\t\t\tthis.parentsChanged[id] = parent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (bounds == null)\n\t\t{\n\t\t\tbounds = new mxRectangle(g.x, g.y, g.width, g.height);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbounds = new mxRectangle(Math.min(bounds.x, g.x),\n\t\t\t\tMath.min(bounds.y, g.y),\n\t\t\t\tMath.max(bounds.x + bounds.width, g.x + g.width),\n\t\t\t\tMath.max(bounds.y + bounds.height, g.y + g.height));\n\t\t}\n\t}\n\n\treturn bounds;\n};\n\n/**\n * Function: createLine\n */\nmxCompactTreeLayout.prototype.createLine = function(dx, dy, next)\n{\n\tvar line = new Object();\n\tline.dx = dx;\n\tline.dy = dy;\n\tline.next = next;\n\n\treturn line;\n};\n\n/**\n * Function: adjustParents\n *\n * Adjust parent cells whose child geometries have changed. The default\n * implementation adjusts the group to just fit around the children with\n * a padding.\n */\nmxCompactTreeLayout.prototype.adjustParents = function()\n{\n\tvar tmp = [];\n\n\tfor (var id in this.parentsChanged)\n\t{\n\t\ttmp.push(this.parentsChanged[id]);\n\t}\n\n\tthis.arrangeGroups(mxUtils.sortCells(tmp, true), this.groupPadding, this.groupPaddingTop,\n\t\tthis.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);\n};\n\n/**\n * Function: localEdgeProcessing\n *\n * Moves the specified node and all of its children by the given amount.\n */\nmxCompactTreeLayout.prototype.localEdgeProcessing = function(node)\n{\n\tthis.processNodeOutgoing(node);\n\tvar child = node.child;\n\n\twhile (child != null)\n\t{\n\t\tthis.localEdgeProcessing(child);\n\t\tchild = child.next;\n\t}\n};\n\n/**\n * Function: localEdgeProcessing\n *\n * Separates the x position of edges as they connect to vertices\n */\nmxCompactTreeLayout.prototype.processNodeOutgoing = function(node)\n{\n\tvar child = node.child;\n\tvar parentCell = node.cell;\n\n\tvar childCount = 0;\n\tvar sortedCells = [];\n\n\twhile (child != null)\n\t{\n\t\tchildCount++;\n\n\t\tvar sortingCriterion = child.x;\n\n\t\tif (this.horizontal)\n\t\t{\n\t\t\tsortingCriterion = child.y;\n\t\t}\n\n\t\tsortedCells.push(new WeightedCellSorter(child, sortingCriterion));\n\t\tchild = child.next;\n\t}\n\n\tsortedCells.sort(WeightedCellSorter.prototype.compare);\n\n\tvar availableWidth = node.width;\n\n\tvar requiredWidth = (childCount + 1) * this.prefHozEdgeSep;\n\n\t// Add a buffer on the edges of the vertex if the edge count allows\n\tif (availableWidth > requiredWidth + (2 * this.prefHozEdgeSep))\n\t{\n\t\tavailableWidth -= 2 * this.prefHozEdgeSep;\n\t}\n\n\tvar edgeSpacing = availableWidth / childCount;\n\n\tvar currentXOffset = edgeSpacing / 2.0;\n\n\tif (availableWidth > requiredWidth + (2 * this.prefHozEdgeSep))\n\t{\n\t\tcurrentXOffset += this.prefHozEdgeSep;\n\t}\n\n\tvar currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n\tvar maxYOffset = 0;\n\n\tvar parentBounds = this.getVertexBounds(parentCell);\n\tchild = node.child;\n\n\tfor (var j = 0; j < sortedCells.length; j++)\n\t{\n\t\tvar childCell = sortedCells[j].cell.cell;\n\t\tvar childBounds = this.getVertexBounds(childCell);\n\n\t\tvar edges = this.graph.getEdgesBetween(parentCell,\n\t\t\t\tchildCell, false);\n\n\t\tvar newPoints = [];\n\t\tvar x = 0;\n\t\tvar y = 0;\n\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tif (this.horizontal)\n\t\t\t{\n\t\t\t\t// Use opposite co-ords, calculation was done for\n\t\t\t\t//\n\t\t\t\tx = parentBounds.x + parentBounds.width;\n\t\t\t\ty = parentBounds.y + currentXOffset;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tx = parentBounds.x + parentBounds.width\n\t\t\t\t\t\t+ currentYOffset;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\ty = childBounds.y + childBounds.height / 2.0;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tthis.setEdgePoints(edges[i], newPoints);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx = parentBounds.x + currentXOffset;\n\t\t\t\ty = parentBounds.y + parentBounds.height;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\ty = parentBounds.y + parentBounds.height\n\t\t\t\t\t\t+ currentYOffset;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tx = childBounds.x + childBounds.width / 2.0;\n\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\tthis.setEdgePoints(edges[i], newPoints);\n\t\t\t}\n\t\t}\n\n\t\tif (j < childCount / 2)\n\t\t{\n\t\t\tcurrentYOffset += this.prefVertEdgeOff;\n\t\t}\n\t\telse if (j > childCount / 2)\n\t\t{\n\t\t\tcurrentYOffset -= this.prefVertEdgeOff;\n\t\t}\n\t\t// Ignore the case if equals, this means the second of 2\n\t\t// jettys with the same y (even number of edges)\n\n\t\t//\t\t\t\t\t\t\t\tpos[k * 2] = currentX;\n\t\tcurrentXOffset += edgeSpacing;\n\t\t//\t\t\t\t\t\t\t\tpos[k * 2 + 1] = currentYOffset;\n\n\t\tmaxYOffset = Math.max(maxYOffset, currentYOffset);\n\t}\n};\n__mxOutput.mxCompactTreeLayout = typeof mxCompactTreeLayout !== 'undefined' ? mxCompactTreeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxRadialTreeLayout\n *\n * Extends <mxGraphLayout> to implement a radial tree algorithm. This\n * layout is suitable for graphs that have no cycles (trees). Vertices that are\n * not connected to the tree will be ignored by this layout.\n *\n * Example:\n *\n * (code)\n * var layout = new mxRadialTreeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxRadialTreeLayout\n *\n * Constructs a new radial tree layout for the specified graph\n */\nfunction mxRadialTreeLayout(graph)\n{\n\tmxCompactTreeLayout.call(this, graph , false);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxUtils.extend(mxRadialTreeLayout, mxCompactTreeLayout);\n\n/**\n * Variable: angleOffset\n *\n * The initial offset to compute the angle position.\n */\nmxRadialTreeLayout.prototype.angleOffset = 0.5;\n\n/**\n * Variable: rootx\n *\n * The X co-ordinate of the root cell\n */\nmxRadialTreeLayout.prototype.rootx = 0;\n\n/**\n * Variable: rooty\n *\n * The Y co-ordinate of the root cell\n */\nmxRadialTreeLayout.prototype.rooty = 0;\n\n/**\n * Variable: levelDistance\n *\n * Holds the levelDistance. Default is 120.\n */\nmxRadialTreeLayout.prototype.levelDistance = 120;\n\n/**\n * Variable: nodeDistance\n *\n * Holds the nodeDistance. Default is 10.\n */\nmxRadialTreeLayout.prototype.nodeDistance = 10;\n\n/**\n * Variable: autoRadius\n *\n * Specifies if the radios should be computed automatically\n */\nmxRadialTreeLayout.prototype.autoRadius = false;\n\n/**\n * Variable: sortEdges\n *\n * Specifies if edges should be sorted according to the order of their\n * opposite terminal cell in the model.\n */\nmxRadialTreeLayout.prototype.sortEdges = false;\n\n/**\n * Variable: rowMinX\n *\n * Array of leftmost x coordinate of each row\n */\nmxRadialTreeLayout.prototype.rowMinX = [];\n\n/**\n * Variable: rowMaxX\n *\n * Array of rightmost x coordinate of each row\n */\nmxRadialTreeLayout.prototype.rowMaxX = [];\n\n/**\n * Variable: rowMinCenX\n *\n * Array of x coordinate of leftmost vertex of each row\n */\nmxRadialTreeLayout.prototype.rowMinCenX = [];\n\n/**\n * Variable: rowMaxCenX\n *\n * Array of x coordinate of rightmost vertex of each row\n */\nmxRadialTreeLayout.prototype.rowMaxCenX = [];\n\n/**\n * Variable: rowRadi\n *\n * Array of y deltas of each row behind root vertex, also the radius in the tree\n */\nmxRadialTreeLayout.prototype.rowRadi = [];\n\n/**\n * Variable: row\n *\n * Array of vertices on each row\n */\nmxRadialTreeLayout.prototype.row = [];\n\n/**\n * Function: isVertexIgnored\n *\n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n *\n * Parameters:\n *\n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxRadialTreeLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n *\n * If the parent has any connected edges, then it is used as the root of\n * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\n * root node within the set of children of the given parent.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be laid out.\n * root - Optional <mxCell> that will be used as the root of the tree.\n */\nmxRadialTreeLayout.prototype.execute = function(parent, root)\n{\n\tthis.parent = parent;\n\n\tthis.useBoundingBox = false;\n\tthis.edgeRouting = false;\n\t//this.horizontal = false;\n\n\tmxCompactTreeLayout.prototype.execute.apply(this, arguments);\n\n\tvar bounds = null;\n\tvar rootBounds = this.getVertexBounds(this.root);\n\tthis.centerX = rootBounds.x + rootBounds.width / 2;\n\tthis.centerY = rootBounds.y + rootBounds.height / 2;\n\n\t// Calculate the bounds of the involved vertices directly from the values set in the compact tree\n\tfor (var vertex in this.visited)\n\t{\n\t\tvar vertexBounds = this.getVertexBounds(this.visited[vertex]);\n\t\tbounds = (bounds != null) ? bounds : vertexBounds.clone();\n\t\tbounds.add(vertexBounds);\n\t}\n\n\tthis.calcRowDims([this.node], 0);\n\n\tvar maxLeftGrad = 0;\n\tvar maxRightGrad = 0;\n\n\t// Find the steepest left and right gradients\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tvar leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];\n\t\tvar rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];\n\n\t\tmaxLeftGrad = Math.max (maxLeftGrad, leftGrad);\n\t\tmaxRightGrad = Math.max (maxRightGrad, rightGrad);\n\t}\n\n\t// Extend out row so they meet the maximum gradient and convert to polar co-ords\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tvar xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];\n\t\tvar xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];\n\t\tvar fullWidth = xRightLimit - xLeftLimit;\n\n\t\tfor (var j = 0; j < this.row[i].length; j ++)\n\t\t{\n\t\t\tvar row = this.row[i];\n\t\t\tvar node = row[j];\n\t\t\tvar vertexBounds = this.getVertexBounds(node.cell);\n\t\t\tvar xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / (fullWidth);\n\t\t\tvar theta =  2 * Math.PI * xProportion;\n\t\t\tnode.theta = theta;\n\t\t}\n\t}\n\n\t// Post-process from outside inwards to try to align parents with children\n\tfor (var i = this.row.length - 2; i >= 0; i--)\n\t{\n\t\tvar row = this.row[i];\n\n\t\tfor (var j = 0; j < row.length; j++)\n\t\t{\n\t\t\tvar node = row[j];\n\t\t\tvar child = node.child;\n\t\t\tvar counter = 0;\n\t\t\tvar totalTheta = 0;\n\n\t\t\twhile (child != null)\n\t\t\t{\n\t\t\t\ttotalTheta += child.theta;\n\t\t\t\tcounter++;\n\t\t\t\tchild = child.next;\n\t\t\t}\n\n\t\t\tif (counter > 0)\n\t\t\t{\n\t\t\t\tvar averTheta = totalTheta / counter;\n\n\t\t\t\tif (averTheta > node.theta && j < row.length - 1)\n\t\t\t\t{\n\t\t\t\t\tvar nextTheta = row[j+1].theta;\n\t\t\t\t\tnode.theta = Math.min (averTheta, nextTheta - Math.PI/10);\n\t\t\t\t}\n\t\t\t\telse if (averTheta < node.theta && j > 0 )\n\t\t\t\t{\n\t\t\t\t\tvar lastTheta = row[j-1].theta;\n\t\t\t\t\tnode.theta = Math.max (averTheta, lastTheta + Math.PI/10);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set locations\n\tfor (var i = 0; i < this.row.length; i++)\n\t{\n\t\tfor (var j = 0; j < this.row[i].length; j ++)\n\t\t{\n\t\t\tvar row = this.row[i];\n\t\t\tvar node = row[j];\n\t\t\tvar vertexBounds = this.getVertexBounds(node.cell);\n\t\t\tthis.setVertexLocation(node.cell,\n\t\t\t\t\t\t\t\t\tthis.centerX - vertexBounds.width / 2 + this.rowRadi[i] * Math.cos(node.theta),\n\t\t\t\t\t\t\t\t\tthis.centerY - vertexBounds.height / 2 + this.rowRadi[i] * Math.sin(node.theta));\n\t\t}\n\t}\n};\n\n/**\n * Function: calcRowDims\n *\n * Recursive function to calculate the dimensions of each row\n *\n * Parameters:\n *\n * row - Array of internal nodes, the children of which are to be processed.\n * rowNum - Integer indicating which row is being processed.\n */\nmxRadialTreeLayout.prototype.calcRowDims = function(row, rowNum)\n{\n\tif (row == null || row.length == 0)\n\t{\n\t\treturn;\n\t}\n\n\t// Place root's children proportionally around the first level\n\tthis.rowMinX[rowNum] = this.centerX;\n\tthis.rowMaxX[rowNum] = this.centerX;\n\tthis.rowMinCenX[rowNum] = this.centerX;\n\tthis.rowMaxCenX[rowNum] = this.centerX;\n\tthis.row[rowNum] = [];\n\n\tvar rowHasChildren = false;\n\n\tfor (var i = 0; i < row.length; i++)\n\t{\n\t\tvar child = row[i] != null ? row[i].child : null;\n\n\t\twhile (child != null)\n\t\t{\n\t\t\tvar cell = child.cell;\n\t\t\tvar vertexBounds = this.getVertexBounds(cell);\n\n\t\t\tthis.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);\n\t\t\tthis.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);\n\t\t\tthis.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);\n\t\t\tthis.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);\n\t\t\tthis.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;\n\n\t\t\tif (child.child != null)\n\t\t\t{\n\t\t\t\trowHasChildren = true;\n\t\t\t}\n\n\t\t\tthis.row[rowNum].push(child);\n\t\t\tchild = child.next;\n\t\t}\n\t}\n\n\tif (rowHasChildren)\n\t{\n\t\tthis.calcRowDims(this.row[rowNum], rowNum + 1);\n\t}\n};\n\n__mxOutput.mxRadialTreeLayout = typeof mxRadialTreeLayout !== 'undefined' ? mxRadialTreeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxFastOrganicLayout\n *\n * Extends <mxGraphLayout> to implement a fast organic layout algorithm.\n * The vertices need to be connected for this layout to work, vertices\n * with no connections are ignored.\n *\n * Example:\n *\n * (code)\n * var layout = new mxFastOrganicLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxCompactTreeLayout\n *\n * Constructs a new fast organic layout for the specified graph.\n */\nfunction mxFastOrganicLayout(graph)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxFastOrganicLayout.prototype = new mxGraphLayout();\nmxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;\n\n/**\n * Variable: useInputOrigin\n *\n * Specifies if the top left corner of the input cells should be the origin\n * of the layout result. Default is true.\n */\nmxFastOrganicLayout.prototype.useInputOrigin = true;\n\n/**\n * Variable: resetEdges\n *\n * Specifies if all edge points of traversed edges should be removed.\n * Default is true.\n */\nmxFastOrganicLayout.prototype.resetEdges = true;\n\n/**\n * Variable: disableEdgeStyle\n *\n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxFastOrganicLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: forceConstant\n *\n * The force constant by which the attractive forces are divided and the\n * replusive forces are multiple by the square of. The value equates to the\n * average radius there is of free space around each node. Default is 50.\n */\nmxFastOrganicLayout.prototype.forceConstant = 50;\n\n/**\n * Variable: forceConstantSquared\n *\n * Cache of <forceConstant>^2 for performance.\n */\nmxFastOrganicLayout.prototype.forceConstantSquared = 0;\n\n/**\n * Variable: minDistanceLimit\n *\n * Minimal distance limit. Default is 2. Prevents of\n * dividing by zero.\n */\nmxFastOrganicLayout.prototype.minDistanceLimit = 2;\n\n/**\n * Variable: minDistanceLimit\n *\n * Minimal distance limit. Default is 2. Prevents of\n * dividing by zero.\n */\nmxFastOrganicLayout.prototype.maxDistanceLimit = 500;\n\n/**\n * Variable: minDistanceLimitSquared\n *\n * Cached version of <minDistanceLimit> squared.\n */\nmxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;\n\n/**\n * Variable: initialTemp\n *\n * Start value of temperature. Default is 200.\n */\nmxFastOrganicLayout.prototype.initialTemp = 200;\n\n/**\n * Variable: temperature\n *\n * Temperature to limit displacement at later stages of layout.\n */\nmxFastOrganicLayout.prototype.temperature = 0;\n\n/**\n * Variable: maxIterations\n *\n * Total number of iterations to run the layout though.\n */\nmxFastOrganicLayout.prototype.maxIterations = 0;\n\n/**\n * Variable: iteration\n *\n * Current iteration count.\n */\nmxFastOrganicLayout.prototype.iteration = 0;\n\n/**\n * Variable: vertexArray\n *\n * An array of all vertices to be laid out.\n */\nmxFastOrganicLayout.prototype.vertexArray;\n\n/**\n * Variable: dispX\n *\n * An array of locally stored X co-ordinate displacements for the vertices.\n */\nmxFastOrganicLayout.prototype.dispX;\n\n/**\n * Variable: dispY\n *\n * An array of locally stored Y co-ordinate displacements for the vertices.\n */\nmxFastOrganicLayout.prototype.dispY;\n\n/**\n * Variable: cellLocation\n *\n * An array of locally stored co-ordinate positions for the vertices.\n */\nmxFastOrganicLayout.prototype.cellLocation;\n\n/**\n * Variable: radius\n *\n * The approximate radius of each cell, nodes only.\n */\nmxFastOrganicLayout.prototype.radius;\n\n/**\n * Variable: radiusSquared\n *\n * The approximate radius squared of each cell, nodes only.\n */\nmxFastOrganicLayout.prototype.radiusSquared;\n\n/**\n * Variable: isMoveable\n *\n * Array of booleans representing the movable states of the vertices.\n */\nmxFastOrganicLayout.prototype.isMoveable;\n\n/**\n * Variable: neighbours\n *\n * Local copy of cell neighbours.\n */\nmxFastOrganicLayout.prototype.neighbours;\n\n/**\n * Variable: indices\n *\n * Hashtable from cells to local indices.\n */\nmxFastOrganicLayout.prototype.indices;\n\n/**\n * Variable: allowedToRun\n *\n * Boolean flag that specifies if the layout is allowed to run. If this is\n * set to false, then the layout exits in the following iteration.\n */\nmxFastOrganicLayout.prototype.allowedToRun = true;\n\n/**\n * Function: isVertexIgnored\n *\n * Returns a boolean indicating if the given <mxCell> should be ignored as a\n * vertex. This returns true if the cell has no connections.\n *\n * Parameters:\n *\n * vertex - <mxCell> whose ignored state should be returned.\n */\nmxFastOrganicLayout.prototype.isVertexIgnored = function(vertex)\n{\n\treturn mxGraphLayout.prototype.isVertexIgnored.apply(this, arguments) ||\n\t\tthis.graph.getConnections(vertex).length == 0;\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>. This operates on all children of the\n * given parent where <isVertexIgnored> returns false.\n */\nmxFastOrganicLayout.prototype.execute = function(parent)\n{\n\tvar model = this.graph.getModel();\n\tthis.vertexArray = [];\n\tvar cells = this.graph.getChildVertices(parent);\n\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (!this.isVertexIgnored(cells[i]))\n\t\t{\n\t\t\tthis.vertexArray.push(cells[i]);\n\t\t}\n\t}\n\n\tvar initialBounds = (this.useInputOrigin) ?\n\t\t\tthis.graph.getBoundingBoxFromGeometry(this.vertexArray) :\n\t\t\t\tnull;\n\tvar n = this.vertexArray.length;\n\n\tthis.indices = [];\n\tthis.dispX = [];\n\tthis.dispY = [];\n\tthis.cellLocation = [];\n\tthis.isMoveable = [];\n\tthis.neighbours = [];\n\tthis.radius = [];\n\tthis.radiusSquared = [];\n\n\tif (this.forceConstant < 0.001)\n\t{\n\t\tthis.forceConstant = 0.001;\n\t}\n\n\tthis.forceConstantSquared = this.forceConstant * this.forceConstant;\n\n\t// Create a map of vertices first. This is required for the array of\n\t// arrays called neighbours which holds, for each vertex, a list of\n\t// ints which represents the neighbours cells to that vertex as\n\t// the indices into vertexArray\n\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t{\n\t\tvar vertex = this.vertexArray[i];\n\t\tthis.cellLocation[i] = [];\n\n\t\t// Set up the mapping from array indices to cells\n\t\tvar id = mxObjectIdentity.get(vertex);\n\t\tthis.indices[id] = i;\n\t\tvar bounds = this.getVertexBounds(vertex);\n\n\t\t// Set the X,Y value of the internal version of the cell to\n\t\t// the center point of the vertex for better positioning\n\t\tvar width = bounds.width;\n\t\tvar height = bounds.height;\n\n\t\t// Randomize (0, 0) locations\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\n\t\tthis.cellLocation[i][0] = x + width / 2.0;\n\t\tthis.cellLocation[i][1] = y + height / 2.0;\n\t\tthis.radius[i] = Math.min(width, height);\n\t\tthis.radiusSquared[i] = this.radius[i] * this.radius[i];\n\t}\n\n\t// Moves cell location back to top-left from center locations used in\n\t// algorithm, resetting the edge points is part of the transaction\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < n; i++)\n\t\t{\n\t\t\tthis.dispX[i] = 0;\n\t\t\tthis.dispY[i] = 0;\n\t\t\tthis.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);\n\n\t\t\t// Get lists of neighbours to all vertices, translate the cells\n\t\t\t// obtained in indices into vertexArray and store as an array\n\t\t\t// against the orginial cell index\n\t\t\tvar edges = this.graph.getConnections(this.vertexArray[i], parent);\n\t\t\tvar cells = this.graph.getOpposites(edges, this.vertexArray[i]);\n\t\t\tthis.neighbours[i] = [];\n\n\t\t\tfor (var j = 0; j < cells.length; j++)\n\t\t\t{\n\t\t\t\t// Resets the points on the traversed edge\n\t\t\t\tif (this.resetEdges)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.resetEdge(edges[j]);\n\t\t\t\t}\n\n\t\t\t    if (this.disableEdgeStyle)\n\t\t\t    {\n\t\t\t    \tthis.setEdgeStyleEnabled(edges[j], false);\n\t\t\t    }\n\n\t\t\t\t// Looks the cell up in the indices dictionary\n\t\t\t\tvar id = mxObjectIdentity.get(cells[j]);\n\t\t\t\tvar index = this.indices[id];\n\n\t\t\t\t// Check the connected cell in part of the vertex list to be\n\t\t\t\t// acted on by this layout\n\t\t\t\tif (index != null)\n\t\t\t\t{\n\t\t\t\t\tthis.neighbours[i][j] = index;\n\t\t\t\t}\n\n\t\t\t\t// Else if index of the other cell doesn't correspond to\n\t\t\t\t// any cell listed to be acted upon in this layout. Set\n\t\t\t\t// the index to the value of this vertex (a dummy self-loop)\n\t\t\t\t// so the attraction force of the edge is not calculated\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.neighbours[i][j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.temperature = this.initialTemp;\n\n\t\t// If max number of iterations has not been set, guess it\n\t\tif (this.maxIterations == 0)\n\t\t{\n\t\t\tthis.maxIterations = 20 * Math.sqrt(n);\n\t\t}\n\n\t\t// Main iteration loop\n\t\tfor (this.iteration = 0; this.iteration < this.maxIterations; this.iteration++)\n\t\t{\n\t\t\tif (!this.allowedToRun)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Calculate repulsive forces on all vertices\n\t\t\tthis.calcRepulsion();\n\n\t\t\t// Calculate attractive forces through edges\n\t\t\tthis.calcAttraction();\n\n\t\t\tthis.calcPositions();\n\t\t\tthis.reduceTemperature();\n\t\t}\n\n\t\tvar minx = null;\n\t\tvar miny = null;\n\n\t\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t\t{\n\t\t\tvar vertex = this.vertexArray[i];\n\n\t\t\tif (this.isVertexMovable(vertex))\n\t\t\t{\n\t\t\t\tvar bounds = this.getVertexBounds(vertex);\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tthis.cellLocation[i][0] -= bounds.width / 2.0;\n\t\t\t\t\tthis.cellLocation[i][1] -= bounds.height / 2.0;\n\n\t\t\t\t\tvar x = this.graph.snap(Math.round(this.cellLocation[i][0]));\n\t\t\t\t\tvar y = this.graph.snap(Math.round(this.cellLocation[i][1]));\n\n\t\t\t\t\tthis.setVertexLocation(vertex, x, y);\n\n\t\t\t\t\tif (minx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tminx = x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminx = Math.min(minx, x);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (miny == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tminy = y;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tminy = Math.min(miny, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Modifies the cloned geometries in-place. Not needed\n\t\t// to clone the geometries again as we're in the same\n\t\t// undoable change.\n\t\tvar dx = -(minx || 0) + 1;\n\t\tvar dy = -(miny || 0) + 1;\n\n\t\tif (initialBounds != null)\n\t\t{\n\t\t\tdx += initialBounds.x;\n\t\t\tdy += initialBounds.y;\n\t\t}\n\n\t\tthis.graph.moveCells(this.vertexArray, dx, dy);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: calcPositions\n *\n * Takes the displacements calculated for each cell and applies them to the\n * local cache of cell positions. Limits the displacement to the current\n * temperature.\n */\nmxFastOrganicLayout.prototype.calcPositions = function()\n{\n\tfor (var index = 0; index < this.vertexArray.length; index++)\n\t{\n\t\tif (this.isMoveable[index])\n\t\t{\n\t\t\t// Get the distance of displacement for this node for this\n\t\t\t// iteration\n\t\t\tvar deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] +\n\t\t\t\tthis.dispY[index] * this.dispY[index]);\n\n\t\t\tif (deltaLength < 0.001)\n\t\t\t{\n\t\t\t\tdeltaLength = 0.001;\n\t\t\t}\n\n\t\t\t// Scale down by the current temperature if less than the\n\t\t\t// displacement distance\n\t\t\tvar newXDisp = this.dispX[index] / deltaLength\n\t\t\t\t* Math.min(deltaLength, this.temperature);\n\n\t\t\tvar newYDisp = this.dispY[index] / deltaLength\n\t\t\t\t* Math.min(deltaLength, this.temperature);\n\n\t\t\t// reset displacements\n\t\t\tthis.dispX[index] = 0;\n\t\t\tthis.dispY[index] = 0;\n\n\t\t\t// Update the cached cell locations\n\t\t\tthis.cellLocation[index][0] += newXDisp;\n\t\t\tthis.cellLocation[index][1] += newYDisp;\n\t\t}\n\t}\n};\n\n/**\n * Function: calcAttraction\n *\n * Calculates the attractive forces between all laid out nodes linked by\n * edges\n */\nmxFastOrganicLayout.prototype.calcAttraction = function()\n{\n\t// Check the neighbours of each vertex and calculate the attractive\n\t// force of the edge connecting them\n\tfor (var i = 0; i < this.vertexArray.length; i++)\n\t{\n\t\tfor (var k = 0; k < this.neighbours[i].length; k++)\n\t\t{\n\t\t\t// Get the index of the othe cell in the vertex array\n\t\t\tvar j = this.neighbours[i][k];\n\n\t\t\t// Do not proceed self-loops\n\t\t\tif (i != j &&\n\t\t\t\tthis.isMoveable[i] &&\n\t\t\t\tthis.isMoveable[j])\n\t\t\t{\n\t\t\t\tvar xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n\t\t\t\tvar yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n\n\t\t\t\t// The distance between the nodes\n\t\t\t\tvar deltaLengthSquared = xDelta * xDelta + yDelta\n\t\t\t\t\t\t* yDelta - this.radiusSquared[i] - this.radiusSquared[j];\n\n\t\t\t\tif (deltaLengthSquared < this.minDistanceLimitSquared)\n\t\t\t\t{\n\t\t\t\t\tdeltaLengthSquared = this.minDistanceLimitSquared;\n\t\t\t\t}\n\n\t\t\t\tvar deltaLength = Math.sqrt(deltaLengthSquared);\n\t\t\t\tvar force = (deltaLengthSquared) / this.forceConstant;\n\n\t\t\t\tvar displacementX = (xDelta / deltaLength) * force;\n\t\t\t\tvar displacementY = (yDelta / deltaLength) * force;\n\n\t\t\t\tthis.dispX[i] -= displacementX;\n\t\t\t\tthis.dispY[i] -= displacementY;\n\n\t\t\t\tthis.dispX[j] += displacementX;\n\t\t\t\tthis.dispY[j] += displacementY;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: calcRepulsion\n *\n * Calculates the repulsive forces between all laid out nodes\n */\nmxFastOrganicLayout.prototype.calcRepulsion = function()\n{\n\tvar vertexCount = this.vertexArray.length;\n\n\tfor (var i = 0; i < vertexCount; i++)\n\t{\n\t\tfor (var j = i; j < vertexCount; j++)\n\t\t{\n\t\t\t// Exits if the layout is no longer allowed to run\n\t\t\tif (!this.allowedToRun)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (j != i &&\n\t\t\t\tthis.isMoveable[i] &&\n\t\t\t\tthis.isMoveable[j])\n\t\t\t{\n\t\t\t\tvar xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n\t\t\t\tvar yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n\n\t\t\t\tif (xDelta == 0)\n\t\t\t\t{\n\t\t\t\t\txDelta = 0.01 + Math.random();\n\t\t\t\t}\n\n\t\t\t\tif (yDelta == 0)\n\t\t\t\t{\n\t\t\t\t\tyDelta = 0.01 + Math.random();\n\t\t\t\t}\n\n\t\t\t\t// Distance between nodes\n\t\t\t\tvar deltaLength = Math.sqrt((xDelta * xDelta)\n\t\t\t\t\t\t+ (yDelta * yDelta));\n\t\t\t\tvar deltaLengthWithRadius = deltaLength - this.radius[i]\n\t\t\t\t\t\t- this.radius[j];\n\n\t\t\t\tif (deltaLengthWithRadius > this.maxDistanceLimit)\n\t\t\t\t{\n\t\t\t\t\t// Ignore vertices too far apart\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (deltaLengthWithRadius < this.minDistanceLimit)\n\t\t\t\t{\n\t\t\t\t\tdeltaLengthWithRadius = this.minDistanceLimit;\n\t\t\t\t}\n\n\t\t\t\tvar force = this.forceConstantSquared / deltaLengthWithRadius;\n\n\t\t\t\tvar displacementX = (xDelta / deltaLength) * force;\n\t\t\t\tvar displacementY = (yDelta / deltaLength) * force;\n\n\t\t\t\tthis.dispX[i] += displacementX;\n\t\t\t\tthis.dispY[i] += displacementY;\n\n\t\t\t\tthis.dispX[j] -= displacementX;\n\t\t\t\tthis.dispY[j] -= displacementY;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: reduceTemperature\n *\n * Reduces the temperature of the layout from an initial setting in a linear\n * fashion to zero.\n */\nmxFastOrganicLayout.prototype.reduceTemperature = function()\n{\n\tthis.temperature = this.initialTemp * (1.0 - this.iteration / this.maxIterations);\n};\n\n__mxOutput.mxFastOrganicLayout = typeof mxFastOrganicLayout !== 'undefined' ? mxFastOrganicLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCircleLayout\n *\n * Extends <mxGraphLayout> to implement a circluar layout for a given radius.\n * The vertices do not need to be connected for this layout to work and all\n * connections between vertices are not taken into account.\n *\n * Example:\n *\n * (code)\n * var layout = new mxCircleLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxCircleLayout\n *\n * Constructs a new circular layout for the specified radius.\n *\n * Arguments:\n *\n * graph - <mxGraph> that contains the cells.\n * radius - Optional radius as an int. Default is 100.\n */\nfunction mxCircleLayout(graph, radius)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.radius = (radius != null) ? radius : 100;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxCircleLayout.prototype = new mxGraphLayout();\nmxCircleLayout.prototype.constructor = mxCircleLayout;\n\n/**\n * Variable: radius\n *\n * Integer specifying the size of the radius. Default is 100.\n */\nmxCircleLayout.prototype.radius = null;\n\n/**\n * Variable: moveCircle\n *\n * Boolean specifying if the circle should be moved to the top,\n * left corner specified by <x0> and <y0>. Default is false.\n */\nmxCircleLayout.prototype.moveCircle = false;\n\n/**\n * Variable: x0\n *\n * Integer specifying the left coordinate of the circle.\n * Default is 0.\n */\nmxCircleLayout.prototype.x0 = 0;\n\n/**\n * Variable: y0\n *\n * Integer specifying the top coordinate of the circle.\n * Default is 0.\n */\nmxCircleLayout.prototype.y0 = 0;\n\n/**\n * Variable: resetEdges\n *\n * Specifies if all edge points of traversed edges should be removed.\n * Default is true.\n */\nmxCircleLayout.prototype.resetEdges = true;\n\n/**\n * Variable: disableEdgeStyle\n *\n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxCircleLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n */\nmxCircleLayout.prototype.execute = function(parent)\n{\n\tvar model = this.graph.getModel();\n\n\t// Moves the vertices to build a circle. Makes sure the\n\t// radius is large enough for the vertices to not\n\t// overlap\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\t// Gets all vertices inside the parent and finds\n\t\t// the maximum dimension of the largest vertex\n\t\tvar max = 0;\n\t\tvar top = null;\n\t\tvar left = null;\n\t\tvar vertices = [];\n\t\tvar childCount = model.getChildCount(parent);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar cell = model.getChildAt(parent, i);\n\n\t\t\tif (!this.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\tvertices.push(cell);\n\t\t\t\tvar bounds = this.getVertexBounds(cell);\n\n\t\t\t\tif (top == null)\n\t\t\t\t{\n\t\t\t\t\ttop = bounds.y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttop = Math.min(top, bounds.y);\n\t\t\t\t}\n\n\t\t\t\tif (left == null)\n\t\t\t\t{\n\t\t\t\t\tleft = bounds.x;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleft = Math.min(left, bounds.x);\n\t\t\t\t}\n\n\t\t\t\tmax = Math.max(max, Math.max(bounds.width, bounds.height));\n\t\t\t}\n\t\t\telse if (!this.isEdgeIgnored(cell))\n\t\t\t{\n\t\t\t\t// Resets the points on the traversed edge\n\t\t\t\tif (this.resetEdges)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.resetEdge(cell);\n\t\t\t\t}\n\n\t\t\t    if (this.disableEdgeStyle)\n\t\t\t    {\n\t\t\t    \t\tthis.setEdgeStyleEnabled(cell, false);\n\t\t\t    }\n\t\t\t}\n\t\t}\n\n\t\tvar r = this.getRadius(vertices.length, max);\n\n\t\t// Moves the circle to the specified origin\n\t\tif (this.moveCircle)\n\t\t{\n\t\t\tleft = this.x0;\n\t\t\ttop = this.y0;\n\t\t}\n\n\t\tthis.circle(vertices, r, left, top);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: getRadius\n *\n * Returns the radius to be used for the given vertex count. Max is the maximum\n * width or height of all vertices in the layout.\n */\nmxCircleLayout.prototype.getRadius = function(count, max)\n{\n\treturn Math.max(count * max / Math.PI, this.radius);\n};\n\n/**\n * Function: circle\n *\n * Executes the circular layout for the specified array\n * of vertices and the given radius. This is called from\n * <execute>.\n */\nmxCircleLayout.prototype.circle = function(vertices, r, left, top)\n{\n\tvar vertexCount = vertices.length;\n\tvar phi = 2 * Math.PI / vertexCount;\n\n\tfor (var i = 0; i < vertexCount; i++)\n\t{\n\t\tif (this.isVertexMovable(vertices[i]))\n\t\t{\n\t\t\tthis.setVertexLocation(vertices[i],\n\t\t\t\tMath.round(left + r + r * Math.sin(i * phi)),\n\t\t\t\tMath.round(top + r + r * Math.cos(i * phi)));\n\t\t}\n\t}\n};\n\n__mxOutput.mxCircleLayout = typeof mxCircleLayout !== 'undefined' ? mxCircleLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxParallelEdgeLayout\n *\n * Extends <mxGraphLayout> for arranging parallel edges. This layout works\n * on edges for all pairs of vertices where there is more than one edge\n * connecting the latter.\n *\n * Example:\n *\n * (code)\n * var layout = new mxParallelEdgeLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * To run the layout for the parallel edges of a changed edge only, the\n * following code can be used.\n *\n * (code)\n * var layout = new mxParallelEdgeLayout(graph);\n *\n * graph.addListener(mxEvent.CELL_CONNECTED, function(sender, evt)\n * {\n *   var model = graph.getModel();\n *   var edge = evt.getProperty('edge');\n *   var src = model.getTerminal(edge, true);\n *   var trg = model.getTerminal(edge, false);\n *\n *   layout.isEdgeIgnored = function(edge2)\n *   {\n *     var src2 = model.getTerminal(edge2, true);\n *     var trg2 = model.getTerminal(edge2, false);\n *\n *     return !(model.isEdge(edge2) && ((src == src2 && trg == trg2) || (src == trg2 && trg == src2)));\n *   };\n *\n *   layout.execute(graph.getDefaultParent());\n * });\n * (end)\n *\n * Constructor: mxCompactTreeLayout\n *\n * Constructs a new fast organic layout for the specified graph.\n */\nfunction mxParallelEdgeLayout(graph)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxParallelEdgeLayout.prototype = new mxGraphLayout();\nmxParallelEdgeLayout.prototype.constructor = mxParallelEdgeLayout;\n\n/**\n * Variable: spacing\n *\n * Defines the spacing between the parallels. Default is 20.\n */\nmxParallelEdgeLayout.prototype.spacing = 20;\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n */\nmxParallelEdgeLayout.prototype.execute = function(parent)\n{\n\tvar lookup = this.findParallels(parent);\n\n\tthis.graph.model.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i in lookup)\n\t\t{\n\t\t\tvar parallels = lookup[i];\n\n\t\t\tif (parallels.length > 1)\n\t\t\t{\n\t\t\t\tthis.layout(parallels);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.graph.model.endUpdate();\n\t}\n};\n\n/**\n * Function: findParallels\n *\n * Finds the parallel edges in the given parent.\n */\nmxParallelEdgeLayout.prototype.findParallels = function(parent)\n{\n\tvar model = this.graph.getModel();\n\tvar lookup = [];\n\tvar childCount = model.getChildCount(parent);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(parent, i);\n\n\t\tif (!this.isEdgeIgnored(child))\n\t\t{\n\t\t\tvar id = this.getEdgeId(child);\n\n\t\t\tif (id != null)\n\t\t\t{\n\t\t\t\tif (lookup[id] == null)\n\t\t\t\t{\n\t\t\t\t\tlookup[id] = [];\n\t\t\t\t}\n\n\t\t\t\tlookup[id].push(child);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn lookup;\n};\n\n/**\n * Function: getEdgeId\n *\n * Returns a unique ID for the given edge. The id is independent of the\n * edge direction and is built using the visible terminal of the given\n * edge.\n */\nmxParallelEdgeLayout.prototype.getEdgeId = function(edge)\n{\n\tvar view = this.graph.getView();\n\n\t// Cannot used cached visible terminal because this could be triggered in BEFORE_UNDO\n\tvar src = view.getVisibleTerminal(edge, true);\n\tvar trg = view.getVisibleTerminal(edge, false);\n\n\tif (src != null && trg != null)\n\t{\n\t\tsrc = mxObjectIdentity.get(src);\n\t\ttrg = mxObjectIdentity.get(trg);\n\n\t\treturn (src > trg) ? trg + '-' + src : src + '-' + trg;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: layout\n *\n * Lays out the parallel edges in the given array.\n */\nmxParallelEdgeLayout.prototype.layout = function(parallels)\n{\n\tvar edge = parallels[0];\n\tvar view = this.graph.getView();\n\tvar model = this.graph.getModel();\n\tvar src = model.getGeometry(view.getVisibleTerminal(edge, true));\n\tvar trg = model.getGeometry(view.getVisibleTerminal(edge, false));\n\n\t// Routes multiple loops\n\tif (src == trg)\n\t{\n\t\tvar x0 = src.x + src.width + this.spacing;\n\t\tvar y0 = src.y + src.height / 2;\n\n\t\tfor (var i = 0; i < parallels.length; i++)\n\t\t{\n\t\t\tthis.route(parallels[i], x0, y0);\n\t\t\tx0 += this.spacing;\n\t\t}\n\t}\n\telse if (src != null && trg != null)\n\t{\n\t\t// Routes parallel edges\n\t\tvar scx = src.x + src.width / 2;\n\t\tvar scy = src.y + src.height / 2;\n\n\t\tvar tcx = trg.x + trg.width / 2;\n\t\tvar tcy = trg.y + trg.height / 2;\n\n\t\tvar dx = tcx - scx;\n\t\tvar dy = tcy - scy;\n\n\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\n\t\tif (len > 0)\n\t\t{\n\t\t\tvar x0 = scx + dx / 2;\n\t\t\tvar y0 = scy + dy / 2;\n\n\t\t\tvar nx = dy * this.spacing / len;\n\t\t\tvar ny = dx * this.spacing / len;\n\n\t\t\tx0 += nx * (parallels.length - 1) / 2;\n\t\t\ty0 -= ny * (parallels.length - 1) / 2;\n\n\t\t\tfor (var i = 0; i < parallels.length; i++)\n\t\t\t{\n\t\t\t\tthis.route(parallels[i], x0, y0);\n\t\t\t\tx0 -= nx;\n\t\t\t\ty0 += ny;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: route\n *\n * Routes the given edge via the given point.\n */\nmxParallelEdgeLayout.prototype.route = function(edge, x, y)\n{\n\tif (this.graph.isCellMovable(edge))\n\t{\n\t\tthis.setEdgePoints(edge, [new mxPoint(x, y)]);\n\t}\n};\n\n__mxOutput.mxParallelEdgeLayout = typeof mxParallelEdgeLayout !== 'undefined' ? mxParallelEdgeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCompositeLayout\n *\n * Allows to compose multiple layouts into a single layout. The master layout\n * is the layout that handles move operations if another layout than the first\n * element in <layouts> should be used. The <master> layout is not executed as\n * the code assumes that it is part of <layouts>.\n *\n * Example:\n * (code)\n * var first = new mxFastOrganicLayout(graph);\n * var second = new mxParallelEdgeLayout(graph);\n * var layout = new mxCompositeLayout(graph, [first, second], first);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxCompositeLayout\n *\n * Constructs a new layout using the given layouts. The graph instance is\n * required for creating the transaction that contains all layouts.\n *\n * Arguments:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * layouts - Array of <mxGraphLayouts>.\n * master - Optional layout that handles moves. If no layout is given then\n * the first layout of the above array is used to handle moves.\n */\nfunction mxCompositeLayout(graph, layouts, master)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.layouts = layouts;\n\tthis.master = master;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxCompositeLayout.prototype = new mxGraphLayout();\nmxCompositeLayout.prototype.constructor = mxCompositeLayout;\n\n/**\n * Variable: layouts\n *\n * Holds the array of <mxGraphLayouts> that this layout contains.\n */\nmxCompositeLayout.prototype.layouts = null;\n\n/**\n * Variable: layouts\n *\n * Reference to the <mxGraphLayouts> that handles moves. If this is null\n * then the first layout in <layouts> is used.\n */\nmxCompositeLayout.prototype.master = null;\n\n/**\n * Function: moveCell\n *\n * Implements <mxGraphLayout.moveCell> by calling move on <master> or the first\n * layout in <layouts>.\n */\nmxCompositeLayout.prototype.moveCell = function(cell, x, y)\n{\n\tif (this.master != null)\n\t{\n\t\tthis.master.moveCell.apply(this.master, arguments);\n\t}\n\telse\n\t{\n\t\tthis.layouts[0].moveCell.apply(this.layouts[0], arguments);\n\t}\n};\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute> by executing all <layouts> in a\n * single transaction.\n */\nmxCompositeLayout.prototype.execute = function(parent)\n{\n\tvar model = this.graph.getModel();\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < this.layouts.length; i++)\n\t\t{\n\t\t\tthis.layouts[i].execute.apply(this.layouts[i], arguments);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n__mxOutput.mxCompositeLayout = typeof mxCompositeLayout !== 'undefined' ? mxCompositeLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEdgeLabelLayout\n *\n * Extends <mxGraphLayout> to implement an edge label layout. This layout\n * makes use of cell states, which means the graph must be validated in\n * a graph view (so that the label bounds are available) before this layout\n * can be executed.\n *\n * Example:\n *\n * (code)\n * var layout = new mxEdgeLabelLayout(graph);\n * layout.execute(graph.getDefaultParent());\n * (end)\n *\n * Constructor: mxEdgeLabelLayout\n *\n * Constructs a new edge label layout.\n *\n * Arguments:\n *\n * graph - <mxGraph> that contains the cells.\n */\nfunction mxEdgeLabelLayout(graph, radius)\n{\n\tmxGraphLayout.call(this, graph);\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxEdgeLabelLayout.prototype = new mxGraphLayout();\nmxEdgeLabelLayout.prototype.constructor = mxEdgeLabelLayout;\n\n/**\n * Function: execute\n *\n * Implements <mxGraphLayout.execute>.\n */\nmxEdgeLabelLayout.prototype.execute = function(parent)\n{\n\tvar view = this.graph.view;\n\tvar model = this.graph.getModel();\n\n\t// Gets all vertices and edges inside the parent\n\tvar edges = [];\n\tvar vertices = [];\n\tvar childCount = model.getChildCount(parent);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar cell = model.getChildAt(parent, i);\n\t\tvar state = view.getState(cell);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tif (!this.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\tvertices.push(state);\n\t\t\t}\n\t\t\telse if (!this.isEdgeIgnored(cell))\n\t\t\t{\n\t\t\t\tedges.push(state);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.placeLabels(vertices, edges);\n};\n\n/**\n * Function: placeLabels\n *\n * Places the labels of the given edges.\n */\nmxEdgeLabelLayout.prototype.placeLabels = function(v, e)\n{\n\tvar model = this.graph.getModel();\n\n\t// Moves the vertices to build a circle. Makes sure the\n\t// radius is large enough for the vertices to not\n\t// overlap\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = 0; i < e.length; i++)\n\t\t{\n\t\t\tvar edge = e[i];\n\n\t\t\tif (edge != null && edge.text != null &&\n\t\t\t\tedge.text.boundingBox != null)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < v.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar vertex = v[j];\n\n\t\t\t\t\tif (vertex != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.avoid(edge, vertex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: avoid\n *\n * Places the labels of the given edges.\n */\nmxEdgeLabelLayout.prototype.avoid = function(edge, vertex)\n{\n\tvar model = this.graph.getModel();\n\tvar labRect = edge.text.boundingBox;\n\n\tif (mxUtils.intersects(labRect, vertex))\n\t{\n\t\tvar dy1 = -labRect.y - labRect.height + vertex.y;\n\t\tvar dy2 = -labRect.y + vertex.y + vertex.height;\n\n\t\tvar dy = (Math.abs(dy1) < Math.abs(dy2)) ? dy1 : dy2;\n\n\t\tvar dx1 = -labRect.x - labRect.width + vertex.x;\n\t\tvar dx2 = -labRect.x + vertex.x + vertex.width;\n\n\t\tvar dx = (Math.abs(dx1) < Math.abs(dx2)) ? dx1 : dx2;\n\n\t\tif (Math.abs(dx) < Math.abs(dy))\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\n\t\tvar g = model.getGeometry(edge.cell);\n\n\t\tif (g != null)\n\t\t{\n\t\t\tg = g.clone();\n\n\t\t\tif (g.offset != null)\n\t\t\t{\n\t\t\t\tg.offset.x += dx;\n\t\t\t\tg.offset.y += dy;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg.offset = new mxPoint(dx, dy);\n\t\t\t}\n\n\t\t\tmodel.setGeometry(edge.cell, g);\n\t\t}\n\t}\n};\n\n__mxOutput.mxEdgeLabelLayout = typeof mxEdgeLabelLayout !== 'undefined' ? mxEdgeLabelLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphAbstractHierarchyCell\n *\n * An abstraction of an internal hierarchy node or edge\n *\n * Constructor: mxGraphAbstractHierarchyCell\n *\n * Constructs a new hierarchical layout algorithm.\n *\n * Arguments:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * deterministic - Optional boolean that specifies if this layout should be\n * deterministic. Default is true.\n */\nfunction mxGraphAbstractHierarchyCell()\n{\n\tthis.x = [];\n\tthis.y = [];\n\tthis.temp = [];\n};\n\n/**\n * Variable: maxRank\n *\n * The maximum rank this cell occupies. Default is -1.\n */\nmxGraphAbstractHierarchyCell.prototype.maxRank = -1;\n\n/**\n * Variable: minRank\n *\n * The minimum rank this cell occupies. Default is -1.\n */\nmxGraphAbstractHierarchyCell.prototype.minRank = -1;\n\n/**\n * Variable: x\n *\n * The x position of this cell for each layer it occupies\n */\nmxGraphAbstractHierarchyCell.prototype.x = null;\n\n/**\n * Variable: y\n *\n * The y position of this cell for each layer it occupies\n */\nmxGraphAbstractHierarchyCell.prototype.y = null;\n\n/**\n * Variable: width\n *\n * The width of this cell\n */\nmxGraphAbstractHierarchyCell.prototype.width = 0;\n\n/**\n * Variable: height\n *\n * The height of this cell\n */\nmxGraphAbstractHierarchyCell.prototype.height = 0;\n\n/**\n * Variable: nextLayerConnectedCells\n *\n * A cached version of the cells this cell connects to on the next layer up\n */\nmxGraphAbstractHierarchyCell.prototype.nextLayerConnectedCells = null;\n\n/**\n * Variable: previousLayerConnectedCells\n *\n * A cached version of the cells this cell connects to on the next layer down\n */\nmxGraphAbstractHierarchyCell.prototype.previousLayerConnectedCells = null;\n\n/**\n * Variable: temp\n *\n * Temporary variable for general use. Generally, try to avoid\n * carrying information between stages. Currently, the longest\n * path layering sets temp to the rank position in fixRanks()\n * and the crossing reduction uses this. This meant temp couldn't\n * be used for hashing the nodes in the model dfs and so hashCode\n * was created\n */\nmxGraphAbstractHierarchyCell.prototype.temp = null;\n\n/**\n * Function: getNextLayerConnectedCells\n *\n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphAbstractHierarchyCell.prototype.getNextLayerConnectedCells = function(layer)\n{\n\treturn null;\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n *\n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphAbstractHierarchyCell.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\treturn null;\n};\n\n/**\n * Function: isEdge\n *\n * Returns whether or not this cell is an edge\n */\nmxGraphAbstractHierarchyCell.prototype.isEdge = function()\n{\n\treturn false;\n};\n\n/**\n * Function: isVertex\n *\n * Returns whether or not this cell is a node\n */\nmxGraphAbstractHierarchyCell.prototype.isVertex = function()\n{\n\treturn false;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n *\n * Gets the value of temp for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn null;\n};\n\n/**\n * Function: setGeneralPurposeVariable\n *\n * Set the value of temp for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\treturn null;\n};\n\n/**\n * Function: setX\n *\n * Set the value of x for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.setX = function(layer, value)\n{\n\tif (this.isVertex())\n\t{\n\t\tthis.x[0] = value;\n\t}\n\telse if (this.isEdge())\n\t{\n\t\tthis.x[layer - this.minRank - 1] = value;\n\t}\n};\n\n/**\n * Function: getX\n *\n * Gets the value of x on the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.getX = function(layer)\n{\n\tif (this.isVertex())\n\t{\n\t\treturn this.x[0];\n\t}\n\telse if (this.isEdge())\n\t{\n\t\treturn this.x[layer - this.minRank - 1];\n\t}\n\n\treturn 0.0;\n};\n\n/**\n * Function: setY\n *\n * Set the value of y for the specified layer\n */\nmxGraphAbstractHierarchyCell.prototype.setY = function(layer, value)\n{\n\tif (this.isVertex())\n\t{\n\t\tthis.y[0] = value;\n\t}\n\telse if (this.isEdge())\n\t{\n\t\tthis.y[layer -this. minRank - 1] = value;\n\t}\n};\n\n__mxOutput.mxGraphAbstractHierarchyCell = typeof mxGraphAbstractHierarchyCell !== 'undefined' ? mxGraphAbstractHierarchyCell : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyNode\n *\n * An abstraction of a hierarchical edge for the hierarchy layout\n *\n * Constructor: mxGraphHierarchyNode\n *\n * Constructs an internal node to represent the specified real graph cell\n *\n * Arguments:\n *\n * cell - the real graph cell this node represents\n */\nfunction mxGraphHierarchyNode(cell)\n{\n\tmxGraphAbstractHierarchyCell.apply(this, arguments);\n\tthis.cell = cell;\n\tthis.id = mxObjectIdentity.get(cell);\n\tthis.connectsAsTarget = [];\n\tthis.connectsAsSource = [];\n};\n\n/**\n * Extends mxGraphAbstractHierarchyCell.\n */\nmxGraphHierarchyNode.prototype = new mxGraphAbstractHierarchyCell();\nmxGraphHierarchyNode.prototype.constructor = mxGraphHierarchyNode;\n\n/**\n * Variable: cell\n *\n * The graph cell this object represents.\n */\nmxGraphHierarchyNode.prototype.cell = null;\n\n/**\n * Variable: id\n *\n * The object identity of the wrapped cell\n */\nmxGraphHierarchyNode.prototype.id = null;\n\n/**\n * Variable: connectsAsTarget\n *\n * Collection of hierarchy edges that have this node as a target\n */\nmxGraphHierarchyNode.prototype.connectsAsTarget = null;\n\n/**\n * Variable: connectsAsSource\n *\n * Collection of hierarchy edges that have this node as a source\n */\nmxGraphHierarchyNode.prototype.connectsAsSource = null;\n\n/**\n * Variable: hashCode\n *\n * Assigns a unique hashcode for each node. Used by the model dfs instead\n * of copying HashSets\n */\nmxGraphHierarchyNode.prototype.hashCode = false;\n\n/**\n * Function: getRankValue\n *\n * Returns the integer value of the layer that this node resides in\n */\nmxGraphHierarchyNode.prototype.getRankValue = function(layer)\n{\n\treturn this.maxRank;\n};\n\n/**\n * Function: getNextLayerConnectedCells\n *\n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphHierarchyNode.prototype.getNextLayerConnectedCells = function(layer)\n{\n\tif (this.nextLayerConnectedCells == null)\n\t{\n\t\tthis.nextLayerConnectedCells = [];\n\t\tthis.nextLayerConnectedCells[0] = [];\n\n\t\tfor (var i = 0; i < this.connectsAsTarget.length; i++)\n\t\t{\n\t\t\tvar edge = this.connectsAsTarget[i];\n\n\t\t\tif (edge.maxRank == -1 || edge.maxRank == layer + 1)\n\t\t\t{\n\t\t\t\t// Either edge is not in any rank or\n\t\t\t\t// no dummy nodes in edge, add node of other side of edge\n\t\t\t\tthis.nextLayerConnectedCells[0].push(edge.source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Edge spans at least two layers, add edge\n\t\t\t\tthis.nextLayerConnectedCells[0].push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.nextLayerConnectedCells[0];\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n *\n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphHierarchyNode.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\tif (this.previousLayerConnectedCells == null)\n\t{\n\t\tthis.previousLayerConnectedCells = [];\n\t\tthis.previousLayerConnectedCells[0] = [];\n\n\t\tfor (var i = 0; i < this.connectsAsSource.length; i++)\n\t\t{\n\t\t\tvar edge = this.connectsAsSource[i];\n\n\t\t\tif (edge.minRank == -1 || edge.minRank == layer - 1)\n\t\t\t{\n\t\t\t\t// No dummy nodes in edge, add node of other side of edge\n\t\t\t\tthis.previousLayerConnectedCells[0].push(edge.target);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Edge spans at least two layers, add edge\n\t\t\t\tthis.previousLayerConnectedCells[0].push(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.previousLayerConnectedCells[0];\n};\n\n/**\n * Function: isVertex\n *\n * Returns true.\n */\nmxGraphHierarchyNode.prototype.isVertex = function()\n{\n\treturn true;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n *\n * Gets the value of temp for the specified layer\n */\nmxGraphHierarchyNode.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn this.temp[0];\n};\n\n/**\n * Function: setGeneralPurposeVariable\n *\n * Set the value of temp for the specified layer\n */\nmxGraphHierarchyNode.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\tthis.temp[0] = value;\n};\n\n/**\n * Function: isAncestor\n */\nmxGraphHierarchyNode.prototype.isAncestor = function(otherNode)\n{\n\t// Firstly, the hash code of this node needs to be shorter than the\n\t// other node\n\tif (otherNode != null && this.hashCode != null && otherNode.hashCode != null\n\t\t\t&& this.hashCode.length < otherNode.hashCode.length)\n\t{\n\t\tif (this.hashCode == otherNode.hashCode)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this.hashCode == null || this.hashCode == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Secondly, this hash code must match the start of the other\n\t\t// node's hash code. Arrays.equals cannot be used here since\n\t\t// the arrays are different length, and we do not want to\n\t\t// perform another array copy.\n\t\tfor (var i = 0; i < this.hashCode.length; i++)\n\t\t{\n\t\t\tif (this.hashCode[i] != otherNode.hashCode[i])\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getCoreCell\n *\n * Gets the core vertex associated with this wrapper\n */\nmxGraphHierarchyNode.prototype.getCoreCell = function()\n{\n\treturn this.cell;\n};\n\n__mxOutput.mxGraphHierarchyNode = typeof mxGraphHierarchyNode !== 'undefined' ? mxGraphHierarchyNode : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyEdge\n *\n * An abstraction of a hierarchical edge for the hierarchy layout\n *\n * Constructor: mxGraphHierarchyEdge\n *\n * Constructs a hierarchy edge\n *\n * Arguments:\n *\n * edges - a list of real graph edges this abstraction represents\n */\nfunction mxGraphHierarchyEdge(edges)\n{\n\tmxGraphAbstractHierarchyCell.apply(this, arguments);\n\tthis.edges = edges;\n\tthis.ids = [];\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tthis.ids.push(mxObjectIdentity.get(edges[i]));\n\t}\n};\n\n/**\n * Extends mxGraphAbstractHierarchyCell.\n */\nmxGraphHierarchyEdge.prototype = new mxGraphAbstractHierarchyCell();\nmxGraphHierarchyEdge.prototype.constructor = mxGraphHierarchyEdge;\n\n/**\n * Variable: edges\n *\n * The graph edge(s) this object represents. Parallel edges are all grouped\n * together within one hierarchy edge.\n */\nmxGraphHierarchyEdge.prototype.edges = null;\n\n/**\n * Variable: ids\n *\n * The object identities of the wrapped cells\n */\nmxGraphHierarchyEdge.prototype.ids = null;\n\n/**\n * Variable: source\n *\n * The node this edge is sourced at\n */\nmxGraphHierarchyEdge.prototype.source = null;\n\n/**\n * Variable: target\n *\n * The node this edge targets\n */\nmxGraphHierarchyEdge.prototype.target = null;\n\n/**\n * Variable: isReversed\n *\n * Whether or not the direction of this edge has been reversed\n * internally to create a DAG for the hierarchical layout\n */\nmxGraphHierarchyEdge.prototype.isReversed = false;\n\n/**\n * Function: invert\n *\n * Inverts the direction of this internal edge(s)\n */\nmxGraphHierarchyEdge.prototype.invert = function(layer)\n{\n\tvar temp = this.source;\n\tthis.source = this.target;\n\tthis.target = temp;\n\tthis.isReversed = !this.isReversed;\n};\n\n/**\n * Function: getNextLayerConnectedCells\n *\n * Returns the cells this cell connects to on the next layer up\n */\nmxGraphHierarchyEdge.prototype.getNextLayerConnectedCells = function(layer)\n{\n\tif (this.nextLayerConnectedCells == null)\n\t{\n\t\tthis.nextLayerConnectedCells = [];\n\n\t\tfor (var i = 0; i < this.temp.length; i++)\n\t\t{\n\t\t\tthis.nextLayerConnectedCells[i] = [];\n\n\t\t\tif (i == this.temp.length - 1)\n\t\t\t{\n\t\t\t\tthis.nextLayerConnectedCells[i].push(this.source);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.nextLayerConnectedCells[i].push(this);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.nextLayerConnectedCells[layer - this.minRank - 1];\n};\n\n/**\n * Function: getPreviousLayerConnectedCells\n *\n * Returns the cells this cell connects to on the next layer down\n */\nmxGraphHierarchyEdge.prototype.getPreviousLayerConnectedCells = function(layer)\n{\n\tif (this.previousLayerConnectedCells == null)\n\t{\n\t\tthis.previousLayerConnectedCells = [];\n\n\t\tfor (var i = 0; i < this.temp.length; i++)\n\t\t{\n\t\t\tthis.previousLayerConnectedCells[i] = [];\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t\tthis.previousLayerConnectedCells[i].push(this.target);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.previousLayerConnectedCells[i].push(this);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.previousLayerConnectedCells[layer - this.minRank - 1];\n};\n\n/**\n * Function: isEdge\n *\n * Returns true.\n */\nmxGraphHierarchyEdge.prototype.isEdge = function()\n{\n\treturn true;\n};\n\n/**\n * Function: getGeneralPurposeVariable\n *\n * Gets the value of temp for the specified layer\n */\nmxGraphHierarchyEdge.prototype.getGeneralPurposeVariable = function(layer)\n{\n\treturn this.temp[layer - this.minRank - 1];\n};\n\n/**\n * Function: setGeneralPurposeVariable\n *\n * Set the value of temp for the specified layer\n */\nmxGraphHierarchyEdge.prototype.setGeneralPurposeVariable = function(layer, value)\n{\n\tthis.temp[layer - this.minRank - 1] = value;\n};\n\n/**\n * Function: getCoreCell\n *\n * Gets the first core edge associated with this wrapper\n */\nmxGraphHierarchyEdge.prototype.getCoreCell = function()\n{\n\tif (this.edges != null && this.edges.length > 0)\n\t{\n\t\treturn this.edges[0];\n\t}\n\n\treturn null;\n};\n\n__mxOutput.mxGraphHierarchyEdge = typeof mxGraphHierarchyEdge !== 'undefined' ? mxGraphHierarchyEdge : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHierarchyModel\n *\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * Constructor: mxGraphHierarchyModel\n *\n * Creates an internal ordered graph model using the vertices passed in. If\n * there are any, leftward edge need to be inverted in the internal model\n *\n * Arguments:\n *\n * graph - the facade describing the graph to be operated on\n * vertices - the vertices for this hierarchy\n * ordered - whether or not the vertices are already ordered\n * deterministic - whether or not this layout should be deterministic on each\n * tightenToSource - whether or not to tighten vertices towards the sources\n * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\n * usage\n */\nfunction mxGraphHierarchyModel(layout, vertices, roots, parent, tightenToSource)\n{\n\tvar graph = layout.getGraph();\n\tthis.tightenToSource = tightenToSource;\n\tthis.roots = roots;\n\tthis.parent = parent;\n\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly\n\tthis.vertexMapper = new mxDictionary();\n\tthis.edgeMapper = new mxDictionary();\n\tthis.maxRank = 0;\n\tvar internalVertices = [];\n\n\tif (vertices == null)\n\t{\n\t\tvertices = this.graph.getChildVertices(parent);\n\t}\n\n\tthis.maxRank = this.SOURCESCANSTARTRANK;\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly. Guess size by number\n\t// of edges is roughly same as number of vertices.\n\tthis.createInternalCells(layout, vertices, internalVertices);\n\n\t// Go through edges set their sink values. Also check the\n\t// ordering if and invert edges if necessary\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tvar edges = internalVertices[i].connectsAsSource;\n\n\t\tfor (var j = 0; j < edges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = edges[j];\n\t\t\tvar realEdges = internalEdge.edges;\n\n\t\t\t// Only need to process the first real edge, since\n\t\t\t// all the edges connect to the same other vertex\n\t\t\tif (realEdges != null && realEdges.length > 0)\n\t\t\t{\n\t\t\t\tvar realEdge = realEdges[0];\n\t\t\t\tvar targetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\trealEdge, false);\n\t\t\t\tvar internalTargetCell = this.vertexMapper.get(targetCell);\n\n\t\t\t\tif (internalVertices[i] == internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\t// If there are parallel edges going between two vertices and not all are in the same direction\n\t\t\t\t\t// you can have navigated across one direction when doing the cycle reversal that isn't the same\n\t\t\t\t\t// direction as the first real edge in the array above. When that happens the if above catches\n\t\t\t\t\t// that and we correct the target cell before continuing.\n\t\t\t\t\t// This branch only detects this single case\n\t\t\t\t\ttargetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\t\trealEdge, true);\n\t\t\t\t\tinternalTargetCell = this.vertexMapper.get(targetCell);\n\t\t\t\t}\n\n\t\t\t\tif (internalTargetCell != null\n\t\t\t\t\t\t&& internalVertices[i] != internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\tinternalEdge.target = internalTargetCell;\n\n\t\t\t\t\tif (internalTargetCell.connectsAsTarget.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Use the temp variable in the internal nodes to mark this\n\t\t// internal vertex as having been visited.\n\t\tinternalVertices[i].temp[0] = 1;\n\t}\n};\n\n/**\n * Variable: maxRank\n *\n * Stores the largest rank number allocated\n */\nmxGraphHierarchyModel.prototype.maxRank = null;\n\n/**\n * Variable: vertexMapper\n *\n * Map from graph vertices to internal model nodes.\n */\nmxGraphHierarchyModel.prototype.vertexMapper = null;\n\n/**\n * Variable: edgeMapper\n *\n * Map from graph edges to internal model edges\n */\nmxGraphHierarchyModel.prototype.edgeMapper = null;\n\n/**\n * Variable: ranks\n *\n * Mapping from rank number to actual rank\n */\nmxGraphHierarchyModel.prototype.ranks = null;\n\n/**\n * Variable: roots\n *\n * Store of roots of this hierarchy model, these are real graph cells, not\n * internal cells\n */\nmxGraphHierarchyModel.prototype.roots = null;\n\n/**\n * Variable: parent\n *\n * The parent cell whose children are being laid out\n */\nmxGraphHierarchyModel.prototype.parent = null;\n\n/**\n * Variable: dfsCount\n *\n * Count of the number of times the ancestor dfs has been used.\n */\nmxGraphHierarchyModel.prototype.dfsCount = 0;\n\n/**\n * Variable: SOURCESCANSTARTRANK\n *\n * High value to start source layering scan rank value from.\n */\nmxGraphHierarchyModel.prototype.SOURCESCANSTARTRANK = 100000000;\n\n/**\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxGraphHierarchyModel.prototype.tightenToSource = false;\n\n/**\n * Function: createInternalCells\n *\n * Creates all edges in the internal model\n *\n * Parameters:\n *\n * layout - Reference to the <mxHierarchicalLayout> algorithm.\n * vertices - Array of <mxCells> that represent the vertices whom are to\n * have an internal representation created.\n * internalVertices - The array of <mxGraphHierarchyNodes> to have their\n * information filled in using the real vertices.\n */\nmxGraphHierarchyModel.prototype.createInternalCells = function(layout, vertices, internalVertices)\n{\n\tvar graph = layout.getGraph();\n\n\t// Create internal edges\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tinternalVertices[i] = new mxGraphHierarchyNode(vertices[i]);\n\t\tthis.vertexMapper.put(vertices[i], internalVertices[i]);\n\n\t\t// If the layout is deterministic, order the cells\n\t\t//List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n\t\tvar conns = layout.getEdges(vertices[i]);\n\t\tinternalVertices[i].connectsAsSource = [];\n\n\t\t// Create internal edges, but don't do any rank assignment yet\n\t\t// First use the information from the greedy cycle remover to\n\t\t// invert the leftward edges internally\n\t\tfor (var j = 0; j < conns.length; j++)\n\t\t{\n\t\t\tvar cell = layout.getVisibleTerminal(conns[j], false);\n\n\t\t\t// Looking for outgoing edges only\n\t\t\tif (cell != vertices[i] && layout.graph.model.isVertex(cell) &&\n\t\t\t\t\t!layout.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\t// We process all edge between this source and its targets\n\t\t\t\t// If there are edges going both ways, we need to collect\n\t\t\t\t// them all into one internal edges to avoid looping problems\n\t\t\t\t// later. We assume this direction (source -> target) is the\n\t\t\t\t// natural direction if at least half the edges are going in\n\t\t\t\t// that direction.\n\n\t\t\t\t// The check below for edges[0] being in the vertex mapper is\n\t\t\t\t// in case we've processed this the other way around\n\t\t\t\t// (target -> source) and the number of edges in each direction\n\t\t\t\t// are the same. All the graph edges will have been assigned to\n\t\t\t\t// an internal edge going the other way, so we don't want to\n\t\t\t\t// process them again\n\t\t\t\tvar undirectedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, false);\n\t\t\t\tvar directedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, true);\n\n\t\t\t\tif (undirectedEdges != null &&\n\t\t\t\t\t\tundirectedEdges.length > 0 &&\n\t\t\t\t\t\tthis.edgeMapper.get(undirectedEdges[0]) == null &&\n\t\t\t\t\t\tdirectedEdges.length * 2 >= undirectedEdges.length)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = new mxGraphHierarchyEdge(undirectedEdges);\n\n\t\t\t\t\tfor (var k = 0; k < undirectedEdges.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar edge = undirectedEdges[k];\n\t\t\t\t\t\tthis.edgeMapper.put(edge, internalEdge);\n\n\t\t\t\t\t\t// Resets all point on the edge and disables the edge style\n\t\t\t\t\t\t// without deleting it from the cell style\n\t\t\t\t\t\tgraph.resetEdge(edge);\n\n\t\t\t\t\t    if (layout.disableEdgeStyle)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tlayout.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\t    \tlayout.setOrthogonalEdge(edge,true);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalEdge.source = internalVertices[i];\n\n\t\t\t\t\tif (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalVertices[i].connectsAsSource.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure temp variable is cleared from any previous use\n\t\tinternalVertices[i].temp[0] = 0;\n\t}\n};\n\n/**\n * Function: initialRank\n *\n * Basic determination of minimum layer ranking by working from from sources\n * or sinks and working through each node in the relevant edge direction.\n * Starting at the sinks is basically a longest path layering algorithm.\n*/\nmxGraphHierarchyModel.prototype.initialRank = function()\n{\n\tvar startNodes = [];\n\n\tif (this.roots != null)\n\t{\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar internalNode = this.vertexMapper.get(this.roots[i]);\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tstartNodes.push(internalNode);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar internalNodes = this.vertexMapper.getValues();\n\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] = -1;\n\t}\n\n\tvar startNodesCopy = startNodes.slice();\n\n\twhile (startNodes.length > 0)\n\t{\n\t\tvar internalNode = startNodes[0];\n\t\tvar layerDeterminingEdges;\n\t\tvar edgesToBeMarked;\n\n\t\tlayerDeterminingEdges = internalNode.connectsAsTarget;\n\t\tedgesToBeMarked = internalNode.connectsAsSource;\n\n\t\t// flag to keep track of whether or not all layer determining\n\t\t// edges have been scanned\n\t\tvar allEdgesScanned = true;\n\n\t\t// Work out the layer of this node from the layer determining\n\t\t// edges. The minimum layer number of any node connected by one of\n\t\t// the layer determining edges variable\n\t\tvar minimumLayer = this.SOURCESCANSTARTRANK;\n\n\t\tfor (var i = 0; i < layerDeterminingEdges.length; i++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[i];\n\n\t\t\tif (internalEdge.temp[0] == 5270620)\n\t\t\t{\n\t\t\t\t// This edge has been scanned, get the layer of the\n\t\t\t\t// node on the other end\n\t\t\t\tvar otherNode = internalEdge.source;\n\t\t\t\tminimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tallEdgesScanned = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If all edge have been scanned, assign the layer, mark all\n\t\t// edges in the other direction and remove from the nodes list\n\t\tif (allEdgesScanned)\n\t\t{\n\t\t\tinternalNode.temp[0] = minimumLayer;\n\t\t\tthis.maxRank = Math.min(this.maxRank, minimumLayer);\n\n\t\t\tif (edgesToBeMarked != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < edgesToBeMarked.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = edgesToBeMarked[i];\n\n\t\t\t\t\t// Assign unique stamp ( y/m/d/h )\n\t\t\t\t\tinternalEdge.temp[0] = 5270620;\n\n\t\t\t\t\t// Add node on other end of edge to LinkedList of\n\t\t\t\t\t// nodes to be analysed\n\t\t\t\t\tvar otherNode = internalEdge.target;\n\n\t\t\t\t\t// Only add node if it hasn't been assigned a layer\n\t\t\t\t\tif (otherNode.temp[0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartNodes.push(otherNode);\n\n\t\t\t\t\t\t// Mark this other node as neither being\n\t\t\t\t\t\t// unassigned nor assigned so it isn't\n\t\t\t\t\t\t// added to this list again, but it's\n\t\t\t\t\t\t// layer isn't used in any calculation.\n\t\t\t\t\t\totherNode.temp[0] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartNodes.shift();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Not all the edges have been scanned, get to the back of\n\t\t\t// the class and put the dunces cap on\n\t\t\tvar removedCell = startNodes.shift();\n\t\t\tstartNodes.push(internalNode);\n\n\t\t\tif (removedCell == internalNode && startNodes.length == 1)\n\t\t\t{\n\t\t\t\t// This is an error condition, we can't get out of\n\t\t\t\t// this loop. It could happen for more than one node\n\t\t\t\t// but that's a lot harder to detect. Log the error\n\t\t\t\t// TODO make log comment\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize the ranks down from their large starting value to place\n\t// at least 1 sink on layer 0\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] -= this.maxRank;\n\t}\n\n\t// Tighten the rank 0 nodes as far as possible\n\tfor ( var i = 0; i < startNodesCopy.length; i++)\n\t{\n\t\tvar internalNode = startNodesCopy[i];\n\t\tvar currentMaxLayer = 0;\n\t\tvar layerDeterminingEdges = internalNode.connectsAsSource;\n\n\t\tfor ( var j = 0; j < layerDeterminingEdges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[j];\n\t\t\tvar otherNode = internalEdge.target;\n\t\t\tinternalNode.temp[0] = Math.max(currentMaxLayer,\n\t\t\t\t\totherNode.temp[0] + 1);\n\t\t\tcurrentMaxLayer = internalNode.temp[0];\n\t\t}\n\t}\n\n\t// Reset the maxRank to that which would be expected for a from-sink\n\t// scan\n\tthis.maxRank = this.SOURCESCANSTARTRANK - this.maxRank;\n};\n\n/**\n * Function: fixRanks\n *\n * Fixes the layer assignments to the values stored in the nodes. Also needs\n * to create dummy nodes for edges that cross layers.\n */\nmxGraphHierarchyModel.prototype.fixRanks = function()\n{\n\tvar rankList = [];\n\tthis.ranks = [];\n\n\tfor (var i = 0; i < this.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tthis.ranks[i] = rankList[i];\n\t}\n\n\t// Perform a DFS to obtain an initial ordering for each rank.\n\t// Without doing this you would end up having to process\n\t// crossings for a standard tree.\n\tvar rootsArray = null;\n\n\tif (this.roots != null)\n\t{\n\t\tvar oldRootsArray = this.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < oldRootsArray.length; i++)\n\t\t{\n\t\t\tvar cell = oldRootsArray[i];\n\t\t\tvar internalNode = this.vertexMapper.get(cell);\n\t\t\trootsArray[i] = internalNode;\n\t\t}\n\t}\n\n\tthis.visit(function(parent, node, edge, layer, seen)\n\t{\n\t\tif (seen == 0 && node.maxRank < 0 && node.minRank < 0)\n\t\t{\n\t\t\trankList[node.temp[0]].push(node);\n\t\t\tnode.maxRank = node.temp[0];\n\t\t\tnode.minRank = node.temp[0];\n\n\t\t\t// Set temp[0] to the nodes position in the rank\n\t\t\tnode.temp[0] = rankList[node.maxRank].length - 1;\n\t\t}\n\n\t\tif (parent != null && edge != null)\n\t\t{\n\t\t\tvar parentToCellRankDifference = parent.maxRank - node.maxRank;\n\n\t\t\tif (parentToCellRankDifference > 1)\n\t\t\t{\n\t\t\t\t// There are ranks in between the parent and current cell\n\t\t\t\tedge.maxRank = parent.maxRank;\n\t\t\t\tedge.minRank = node.maxRank;\n\t\t\t\tedge.temp = [];\n\t\t\t\tedge.x = [];\n\t\t\t\tedge.y = [];\n\n\t\t\t\tfor (var i = edge.minRank + 1; i < edge.maxRank; i++)\n\t\t\t\t{\n\t\t\t\t\t// The connecting edge must be added to the\n\t\t\t\t\t// appropriate ranks\n\t\t\t\t\trankList[i].push(edge);\n\t\t\t\t\tedge.setGeneralPurposeVariable(i, rankList[i]\n\t\t\t\t\t\t\t.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, rootsArray, false, null);\n};\n\n/**\n * Function: visit\n *\n * A depth first search through the internal heirarchy model.\n *\n * Parameters:\n *\n * visitor - The visitor function pattern to be called for each node.\n * trackAncestors - Whether or not the search is to keep track all nodes\n * directly above this one in the search path.\n */\nmxGraphHierarchyModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes)\n{\n\t// Run dfs through on all roots\n\tif (dfsRoots != null)\n\t{\n\t\tfor (var i = 0; i < dfsRoots.length; i++)\n\t\t{\n\t\t\tvar internalNode = dfsRoots[i];\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tif (seenNodes == null)\n\t\t\t\t{\n\t\t\t\t\tseenNodes = new Object();\n\t\t\t\t}\n\n\t\t\t\tif (trackAncestors)\n\t\t\t\t{\n\t\t\t\t\t// Set up hash code for root\n\t\t\t\t\tinternalNode.hashCode = [];\n\t\t\t\t\tinternalNode.hashCode[0] = this.dfsCount;\n\t\t\t\t\tinternalNode.hashCode[1] = i;\n\t\t\t\t\tthis.extendedDfs(null, internalNode, null, visitor, seenNodes,\n\t\t\t\t\t\t\tinternalNode.hashCode, i, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.dfs(null, internalNode, null, visitor, seenNodes, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.dfsCount++;\n\t}\n};\n\n/**\n * Function: dfs\n *\n * Performs a depth first search on the internal hierarchy model\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs a set of all of the\n * ancestor node of the current node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxGraphHierarchyModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i< outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.dfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\tlayer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendedDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of cells ancestors, but it\n * should be only used when necessary because of it can be computationally\n * intensive for deep searches.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs\n * ancestors - the parent hash code\n * childHash - the new hash code for this node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxGraphHierarchyModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer)\n{\n\t// Explanation of custom hash set. Previously, the ancestors variable\n\t// was passed through the dfs as a HashSet. The ancestors were copied\n\t// into a new HashSet and when the new child was processed it was also\n\t// added to the set. If the current node was in its ancestor list it\n\t// meant there is a cycle in the graph and this information is passed\n\t// to the visitor.visit() in the seen parameter. The HashSet clone was\n\t// very expensive on CPU so a custom hash was developed using primitive\n\t// types. temp[] couldn't be used so hashCode[] was added to each node.\n\t// Each new child adds another int to the array, copying the prefix\n\t// from its parent. Child of the same parent add different ints (the\n\t// limit is therefore 2^32 children per parent...). If a node has a\n\t// child with the hashCode already set then the child code is compared\n\t// to the same portion of the current nodes array. If they match there\n\t// is a loop.\n\t// Note that the basic mechanism would only allow for 1 use of this\n\t// functionality, so the root nodes have two ints. The second int is\n\t// incremented through each node root and the first is incremented\n\t// through each run of the dfs algorithm (therefore the dfs is not\n\t// thread safe). The hash code of each node is set if not already set,\n\t// or if the first int does not match that of the current run.\n\tif (root != null)\n\t{\n\t\tif (parent != null)\n\t\t{\n\t\t\t// Form this nodes hash code if necessary, that is, if the\n\t\t\t// hashCode variable has not been initialized or if the\n\t\t\t// start of the parent hash code does not equal the start of\n\t\t\t// this nodes hash code, indicating the code was set on a\n\t\t\t// previous run of this dfs.\n\t\t\tif (root.hashCode == null ||\n\t\t\t\troot.hashCode[0] != parent.hashCode[0])\n\t\t\t{\n\t\t\t\tvar hashCodeLength = parent.hashCode.length + 1;\n\t\t\t\troot.hashCode = parent.hashCode.slice();\n\t\t\t\troot.hashCode[hashCodeLength - 1] = childHash;\n\t\t\t}\n\t\t}\n\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n__mxOutput.mxGraphHierarchyModel = typeof mxGraphHierarchyModel !== 'undefined' ? mxGraphHierarchyModel : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneModel\n *\n * Internal model of a hierarchical graph. This model stores nodes and edges\n * equivalent to the real graph nodes and edges, but also stores the rank of the\n * cells, the order within the ranks and the new candidate locations of cells.\n * The internal model also reverses edge direction were appropriate , ignores\n * self-loop and groups parallels together under one edge object.\n *\n * Constructor: mxSwimlaneModel\n *\n * Creates an internal ordered graph model using the vertices passed in. If\n * there are any, leftward edge need to be inverted in the internal model\n *\n * Arguments:\n *\n * graph - the facade describing the graph to be operated on\n * vertices - the vertices for this hierarchy\n * ordered - whether or not the vertices are already ordered\n * deterministic - whether or not this layout should be deterministic on each\n * tightenToSource - whether or not to tighten vertices towards the sources\n * scanRanksFromSinks - Whether rank assignment is from the sinks or sources.\n * usage\n */\nfunction mxSwimlaneModel(layout, vertices, roots, parent, tightenToSource)\n{\n\tvar graph = layout.getGraph();\n\tthis.tightenToSource = tightenToSource;\n\tthis.roots = roots;\n\tthis.parent = parent;\n\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly\n\tthis.vertexMapper = new mxDictionary();\n\tthis.edgeMapper = new mxDictionary();\n\tthis.maxRank = 0;\n\tvar internalVertices = [];\n\n\tif (vertices == null)\n\t{\n\t\tvertices = this.graph.getChildVertices(parent);\n\t}\n\n\tthis.maxRank = this.SOURCESCANSTARTRANK;\n\t// map of cells to internal cell needed for second run through\n\t// to setup the sink of edges correctly. Guess size by number\n\t// of edges is roughly same as number of vertices.\n\tthis.createInternalCells(layout, vertices, internalVertices);\n\n\t// Go through edges set their sink values. Also check the\n\t// ordering if and invert edges if necessary\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tvar edges = internalVertices[i].connectsAsSource;\n\n\t\tfor (var j = 0; j < edges.length; j++)\n\t\t{\n\t\t\tvar internalEdge = edges[j];\n\t\t\tvar realEdges = internalEdge.edges;\n\n\t\t\t// Only need to process the first real edge, since\n\t\t\t// all the edges connect to the same other vertex\n\t\t\tif (realEdges != null && realEdges.length > 0)\n\t\t\t{\n\t\t\t\tvar realEdge = realEdges[0];\n\t\t\t\tvar targetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\trealEdge, false);\n\t\t\t\tvar internalTargetCell = this.vertexMapper.get(targetCell);\n\n\t\t\t\tif (internalVertices[i] == internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\t// If there are parallel edges going between two vertices and not all are in the same direction\n\t\t\t\t\t// you can have navigated across one direction when doing the cycle reversal that isn't the same\n\t\t\t\t\t// direction as the first real edge in the array above. When that happens the if above catches\n\t\t\t\t\t// that and we correct the target cell before continuing.\n\t\t\t\t\t// This branch only detects this single case\n\t\t\t\t\ttargetCell = layout.getVisibleTerminal(\n\t\t\t\t\t\t\trealEdge, true);\n\t\t\t\t\tinternalTargetCell = this.vertexMapper.get(targetCell);\n\t\t\t\t}\n\n\t\t\t\tif (internalTargetCell != null\n\t\t\t\t\t\t&& internalVertices[i] != internalTargetCell)\n\t\t\t\t{\n\t\t\t\t\tinternalEdge.target = internalTargetCell;\n\n\t\t\t\t\tif (internalTargetCell.connectsAsTarget.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.indexOf(internalTargetCell.connectsAsTarget, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalTargetCell.connectsAsTarget.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Use the temp variable in the internal nodes to mark this\n\t\t// internal vertex as having been visited.\n\t\tinternalVertices[i].temp[0] = 1;\n\t}\n};\n\n/**\n * Variable: maxRank\n *\n * Stores the largest rank number allocated\n */\nmxSwimlaneModel.prototype.maxRank = null;\n\n/**\n * Variable: vertexMapper\n *\n * Map from graph vertices to internal model nodes.\n */\nmxSwimlaneModel.prototype.vertexMapper = null;\n\n/**\n * Variable: edgeMapper\n *\n * Map from graph edges to internal model edges\n */\nmxSwimlaneModel.prototype.edgeMapper = null;\n\n/**\n * Variable: ranks\n *\n * Mapping from rank number to actual rank\n */\nmxSwimlaneModel.prototype.ranks = null;\n\n/**\n * Variable: roots\n *\n * Store of roots of this hierarchy model, these are real graph cells, not\n * internal cells\n */\nmxSwimlaneModel.prototype.roots = null;\n\n/**\n * Variable: parent\n *\n * The parent cell whose children are being laid out\n */\nmxSwimlaneModel.prototype.parent = null;\n\n/**\n * Variable: dfsCount\n *\n * Count of the number of times the ancestor dfs has been used.\n */\nmxSwimlaneModel.prototype.dfsCount = 0;\n\n/**\n * Variable: SOURCESCANSTARTRANK\n *\n * High value to start source layering scan rank value from.\n */\nmxSwimlaneModel.prototype.SOURCESCANSTARTRANK = 100000000;\n\n/**\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxSwimlaneModel.prototype.tightenToSource = false;\n\n/**\n * Variable: ranksPerGroup\n *\n * An array of the number of ranks within each swimlane\n */\nmxSwimlaneModel.prototype.ranksPerGroup = null;\n\n/**\n * Function: createInternalCells\n *\n * Creates all edges in the internal model\n *\n * Parameters:\n *\n * layout - Reference to the <mxHierarchicalLayout> algorithm.\n * vertices - Array of <mxCells> that represent the vertices whom are to\n * have an internal representation created.\n * internalVertices - The array of <mxGraphHierarchyNodes> to have their\n * information filled in using the real vertices.\n */\nmxSwimlaneModel.prototype.createInternalCells = function(layout, vertices, internalVertices)\n{\n\tvar graph = layout.getGraph();\n\tvar swimlanes = layout.swimlanes;\n\n\t// Create internal edges\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tinternalVertices[i] = new mxGraphHierarchyNode(vertices[i]);\n\t\tthis.vertexMapper.put(vertices[i], internalVertices[i]);\n\t\tinternalVertices[i].swimlaneIndex = -1;\n\n\t\tfor (var ii = 0; ii < swimlanes.length; ii++)\n\t\t{\n\t\t\tif (graph.model.getParent(vertices[i]) == swimlanes[ii])\n\t\t\t{\n\t\t\t\tinternalVertices[i].swimlaneIndex = ii;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If the layout is deterministic, order the cells\n\t\t//List outgoingCells = graph.getNeighbours(vertices[i], deterministic);\n\t\tvar conns = layout.getEdges(vertices[i]);\n\t\tinternalVertices[i].connectsAsSource = [];\n\n\t\t// Create internal edges, but don't do any rank assignment yet\n\t\t// First use the information from the greedy cycle remover to\n\t\t// invert the leftward edges internally\n\t\tfor (var j = 0; j < conns.length; j++)\n\t\t{\n\t\t\tvar cell = layout.getVisibleTerminal(conns[j], false);\n\n\t\t\t// Looking for outgoing edges only\n\t\t\tif (cell != vertices[i] && layout.graph.model.isVertex(cell) &&\n\t\t\t\t\t!layout.isVertexIgnored(cell))\n\t\t\t{\n\t\t\t\t// We process all edge between this source and its targets\n\t\t\t\t// If there are edges going both ways, we need to collect\n\t\t\t\t// them all into one internal edges to avoid looping problems\n\t\t\t\t// later. We assume this direction (source -> target) is the\n\t\t\t\t// natural direction if at least half the edges are going in\n\t\t\t\t// that direction.\n\n\t\t\t\t// The check below for edges[0] being in the vertex mapper is\n\t\t\t\t// in case we've processed this the other way around\n\t\t\t\t// (target -> source) and the number of edges in each direction\n\t\t\t\t// are the same. All the graph edges will have been assigned to\n\t\t\t\t// an internal edge going the other way, so we don't want to\n\t\t\t\t// process them again\n\t\t\t\tvar undirectedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, false);\n\t\t\t\tvar directedEdges = layout.getEdgesBetween(vertices[i],\n\t\t\t\t\t\tcell, true);\n\n\t\t\t\tif (undirectedEdges != null &&\n\t\t\t\t\t\tundirectedEdges.length > 0 &&\n\t\t\t\t\t\tthis.edgeMapper.get(undirectedEdges[0]) == null &&\n\t\t\t\t\t\tdirectedEdges.length * 2 >= undirectedEdges.length)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = new mxGraphHierarchyEdge(undirectedEdges);\n\n\t\t\t\t\tfor (var k = 0; k < undirectedEdges.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar edge = undirectedEdges[k];\n\t\t\t\t\t\tthis.edgeMapper.put(edge, internalEdge);\n\n\t\t\t\t\t\t// Resets all point on the edge and disables the edge style\n\t\t\t\t\t\t// without deleting it from the cell style\n\t\t\t\t\t\tgraph.resetEdge(edge);\n\n\t\t\t\t\t    if (layout.disableEdgeStyle)\n\t\t\t\t\t    {\n\t\t\t\t\t    \tlayout.setEdgeStyleEnabled(edge, false);\n\t\t\t\t\t    \tlayout.setOrthogonalEdge(edge,true);\n\t\t\t\t\t    }\n\t\t\t\t\t}\n\n\t\t\t\t\tinternalEdge.source = internalVertices[i];\n\n\t\t\t\t\tif (mxUtils.indexOf(internalVertices[i].connectsAsSource, internalEdge) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tinternalVertices[i].connectsAsSource.push(internalEdge);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure temp variable is cleared from any previous use\n\t\tinternalVertices[i].temp[0] = 0;\n\t}\n};\n\n/**\n * Function: initialRank\n *\n * Basic determination of minimum layer ranking by working from from sources\n * or sinks and working through each node in the relevant edge direction.\n * Starting at the sinks is basically a longest path layering algorithm.\n*/\nmxSwimlaneModel.prototype.initialRank = function()\n{\n\tthis.ranksPerGroup = [];\n\n\tvar startNodes = [];\n\tvar seen = new Object();\n\n\tif (this.roots != null)\n\t{\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar internalNode = this.vertexMapper.get(this.roots[i]);\n\t\t\tthis.maxChainDfs(null, internalNode, null, seen, 0);\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tstartNodes.push(internalNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the lower and upper rank bounds of each swimlane\n\tvar lowerRank = [];\n\tvar upperRank = [];\n\n\tfor (var i = this.ranksPerGroup.length - 1; i >= 0; i--)\n\t{\n\t\tif (i == this.ranksPerGroup.length - 1)\n\t\t{\n\t\t\tlowerRank[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlowerRank[i] = upperRank[i+1] + 1;\n\t\t}\n\n\t\tupperRank[i] = lowerRank[i] + this.ranksPerGroup[i];\n\t}\n\n\tthis.maxRank = upperRank[0];\n\n\tvar internalNodes = this.vertexMapper.getValues();\n\n\tfor (var i=0; i < internalNodes.length; i++)\n\t{\n\t\t// Mark the node as not having had a layer assigned\n\t\tinternalNodes[i].temp[0] = -1;\n\t}\n\n\tvar startNodesCopy = startNodes.slice();\n\n\twhile (startNodes.length > 0)\n\t{\n\t\tvar internalNode = startNodes[0];\n\t\tvar layerDeterminingEdges;\n\t\tvar edgesToBeMarked;\n\n\t\tlayerDeterminingEdges = internalNode.connectsAsTarget;\n\t\tedgesToBeMarked = internalNode.connectsAsSource;\n\n\t\t// flag to keep track of whether or not all layer determining\n\t\t// edges have been scanned\n\t\tvar allEdgesScanned = true;\n\n\t\t// Work out the layer of this node from the layer determining\n\t\t// edges. The minimum layer number of any node connected by one of\n\t\t// the layer determining edges variable\n\t\tvar minimumLayer = upperRank[0];\n\n\t\tfor (var i = 0; i < layerDeterminingEdges.length; i++)\n\t\t{\n\t\t\tvar internalEdge = layerDeterminingEdges[i];\n\n\t\t\tif (internalEdge.temp[0] == 5270620)\n\t\t\t{\n\t\t\t\t// This edge has been scanned, get the layer of the\n\t\t\t\t// node on the other end\n\t\t\t\tvar otherNode = internalEdge.source;\n\t\t\t\tminimumLayer = Math.min(minimumLayer, otherNode.temp[0] - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tallEdgesScanned = false;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If all edge have been scanned, assign the layer, mark all\n\t\t// edges in the other direction and remove from the nodes list\n\t\tif (allEdgesScanned)\n\t\t{\n\t\t\tif (minimumLayer > upperRank[internalNode.swimlaneIndex])\n\t\t\t{\n\t\t\t\tminimumLayer = upperRank[internalNode.swimlaneIndex];\n\t\t\t}\n\n\t\t\tinternalNode.temp[0] = minimumLayer;\n\n\t\t\tif (edgesToBeMarked != null)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < edgesToBeMarked.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar internalEdge = edgesToBeMarked[i];\n\n\t\t\t\t\t// Assign unique stamp ( y/m/d/h )\n\t\t\t\t\tinternalEdge.temp[0] = 5270620;\n\n\t\t\t\t\t// Add node on other end of edge to LinkedList of\n\t\t\t\t\t// nodes to be analysed\n\t\t\t\t\tvar otherNode = internalEdge.target;\n\n\t\t\t\t\t// Only add node if it hasn't been assigned a layer\n\t\t\t\t\tif (otherNode.temp[0] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tstartNodes.push(otherNode);\n\n\t\t\t\t\t\t// Mark this other node as neither being\n\t\t\t\t\t\t// unassigned nor assigned so it isn't\n\t\t\t\t\t\t// added to this list again, but it's\n\t\t\t\t\t\t// layer isn't used in any calculation.\n\t\t\t\t\t\totherNode.temp[0] = -2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstartNodes.shift();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Not all the edges have been scanned, get to the back of\n\t\t\t// the class and put the dunces cap on\n\t\t\tvar removedCell = startNodes.shift();\n\t\t\tstartNodes.push(internalNode);\n\n\t\t\tif (removedCell == internalNode && startNodes.length == 1)\n\t\t\t{\n\t\t\t\t// This is an error condition, we can't get out of\n\t\t\t\t// this loop. It could happen for more than one node\n\t\t\t\t// but that's a lot harder to detect. Log the error\n\t\t\t\t// TODO make log comment\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize the ranks down from their large starting value to place\n\t// at least 1 sink on layer 0\n//\tfor (var key in this.vertexMapper)\n//\t{\n//\t\tvar internalNode = this.vertexMapper[key];\n//\t\t// Mark the node as not having had a layer assigned\n//\t\tinternalNode.temp[0] -= this.maxRank;\n//\t}\n\n\t// Tighten the rank 0 nodes as far as possible\n//\tfor ( var i = 0; i < startNodesCopy.length; i++)\n//\t{\n//\t\tvar internalNode = startNodesCopy[i];\n//\t\tvar currentMaxLayer = 0;\n//\t\tvar layerDeterminingEdges = internalNode.connectsAsSource;\n//\n//\t\tfor ( var j = 0; j < layerDeterminingEdges.length; j++)\n//\t\t{\n//\t\t\tvar internalEdge = layerDeterminingEdges[j];\n//\t\t\tvar otherNode = internalEdge.target;\n//\t\t\tinternalNode.temp[0] = Math.max(currentMaxLayer,\n//\t\t\t\t\totherNode.temp[0] + 1);\n//\t\t\tcurrentMaxLayer = internalNode.temp[0];\n//\t\t}\n//\t}\n};\n\n/**\n * Function: maxChainDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of chains within groups.\n * Any cycles should be removed prior to running, but previously seen cells\n * are ignored.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * seen - a set of all nodes seen by this dfs\n * chainCount - the number of edges in the chain of vertices going through\n * the current swimlane\n */\nmxSwimlaneModel.prototype.maxChainDfs = function(parent, root, connectingEdge, seen, chainCount)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = mxCellPath.create(root.cell);\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvar slIndex = root.swimlaneIndex;\n\n\t\t\tif (this.ranksPerGroup[slIndex] == null || this.ranksPerGroup[slIndex] < chainCount)\n\t\t\t{\n\t\t\t\tthis.ranksPerGroup[slIndex] = chainCount;\n\t\t\t}\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Only navigate in source->target direction within the same\n\t\t\t\t// swimlane, or from a lower index swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex < targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null , true), 0);\n\t\t\t\t}\n\t\t\t\telse if (root.swimlaneIndex == targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.maxChainDfs(root, targetNode, internalEdge, mxUtils.clone(seen, null , true), chainCount + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: fixRanks\n *\n * Fixes the layer assignments to the values stored in the nodes. Also needs\n * to create dummy nodes for edges that cross layers.\n */\nmxSwimlaneModel.prototype.fixRanks = function()\n{\n\tvar rankList = [];\n\tthis.ranks = [];\n\n\tfor (var i = 0; i < this.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tthis.ranks[i] = rankList[i];\n\t}\n\n\t// Perform a DFS to obtain an initial ordering for each rank.\n\t// Without doing this you would end up having to process\n\t// crossings for a standard tree.\n\tvar rootsArray = null;\n\n\tif (this.roots != null)\n\t{\n\t\tvar oldRootsArray = this.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < oldRootsArray.length; i++)\n\t\t{\n\t\t\tvar cell = oldRootsArray[i];\n\t\t\tvar internalNode = this.vertexMapper.get(cell);\n\t\t\trootsArray[i] = internalNode;\n\t\t}\n\t}\n\n\tthis.visit(function(parent, node, edge, layer, seen)\n\t{\n\t\tif (seen == 0 && node.maxRank < 0 && node.minRank < 0)\n\t\t{\n\t\t\trankList[node.temp[0]].push(node);\n\t\t\tnode.maxRank = node.temp[0];\n\t\t\tnode.minRank = node.temp[0];\n\n\t\t\t// Set temp[0] to the nodes position in the rank\n\t\t\tnode.temp[0] = rankList[node.maxRank].length - 1;\n\t\t}\n\n\t\tif (parent != null && edge != null)\n\t\t{\n\t\t\tvar parentToCellRankDifference = parent.maxRank - node.maxRank;\n\n\t\t\tif (parentToCellRankDifference > 1)\n\t\t\t{\n\t\t\t\t// There are ranks in between the parent and current cell\n\t\t\t\tedge.maxRank = parent.maxRank;\n\t\t\t\tedge.minRank = node.maxRank;\n\t\t\t\tedge.temp = [];\n\t\t\t\tedge.x = [];\n\t\t\t\tedge.y = [];\n\n\t\t\t\tfor (var i = edge.minRank + 1; i < edge.maxRank; i++)\n\t\t\t\t{\n\t\t\t\t\t// The connecting edge must be added to the\n\t\t\t\t\t// appropriate ranks\n\t\t\t\t\trankList[i].push(edge);\n\t\t\t\t\tedge.setGeneralPurposeVariable(i, rankList[i]\n\t\t\t\t\t\t\t.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, rootsArray, false, null);\n};\n\n/**\n * Function: visit\n *\n * A depth first search through the internal heirarchy model.\n *\n * Parameters:\n *\n * visitor - The visitor function pattern to be called for each node.\n * trackAncestors - Whether or not the search is to keep track all nodes\n * directly above this one in the search path.\n */\nmxSwimlaneModel.prototype.visit = function(visitor, dfsRoots, trackAncestors, seenNodes)\n{\n\t// Run dfs through on all roots\n\tif (dfsRoots != null)\n\t{\n\t\tfor (var i = 0; i < dfsRoots.length; i++)\n\t\t{\n\t\t\tvar internalNode = dfsRoots[i];\n\n\t\t\tif (internalNode != null)\n\t\t\t{\n\t\t\t\tif (seenNodes == null)\n\t\t\t\t{\n\t\t\t\t\tseenNodes = new Object();\n\t\t\t\t}\n\n\t\t\t\tif (trackAncestors)\n\t\t\t\t{\n\t\t\t\t\t// Set up hash code for root\n\t\t\t\t\tinternalNode.hashCode = [];\n\t\t\t\t\tinternalNode.hashCode[0] = this.dfsCount;\n\t\t\t\t\tinternalNode.hashCode[1] = i;\n\t\t\t\t\tthis.extendedDfs(null, internalNode, null, visitor, seenNodes,\n\t\t\t\t\t\t\tinternalNode.hashCode, i, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.dfs(null, internalNode, null, visitor, seenNodes, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.dfsCount++;\n\t}\n};\n\n/**\n * Function: dfs\n *\n * Performs a depth first search on the internal hierarchy model\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs a set of all of the\n * ancestor node of the current node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxSwimlaneModel.prototype.dfs = function(parent, root, connectingEdge, visitor, seen, layer)\n{\n\tif (root != null)\n\t{\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\n\t\t\tfor (var i = 0; i< outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Root check is O(|roots|)\n\t\t\t\tthis.dfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\tlayer + 1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendedDfs\n *\n * Performs a depth first search on the internal hierarchy model. This dfs\n * extends the default version by keeping track of cells ancestors, but it\n * should be only used when necessary because of it can be computationally\n * intensive for deep searches.\n *\n * Parameters:\n *\n * parent - the parent internal node of the current internal node\n * root - the current internal node\n * connectingEdge - the internal edge connecting the internal node and the parent\n * internal node, if any\n * visitor - the visitor pattern to be called for each node\n * seen - a set of all nodes seen by this dfs\n * ancestors - the parent hash code\n * childHash - the new hash code for this node\n * layer - the layer on the dfs tree ( not the same as the model ranks )\n */\nmxSwimlaneModel.prototype.extendedDfs = function(parent, root, connectingEdge, visitor, seen, ancestors, childHash, layer)\n{\n\t// Explanation of custom hash set. Previously, the ancestors variable\n\t// was passed through the dfs as a HashSet. The ancestors were copied\n\t// into a new HashSet and when the new child was processed it was also\n\t// added to the set. If the current node was in its ancestor list it\n\t// meant there is a cycle in the graph and this information is passed\n\t// to the visitor.visit() in the seen parameter. The HashSet clone was\n\t// very expensive on CPU so a custom hash was developed using primitive\n\t// types. temp[] couldn't be used so hashCode[] was added to each node.\n\t// Each new child adds another int to the array, copying the prefix\n\t// from its parent. Child of the same parent add different ints (the\n\t// limit is therefore 2^32 children per parent...). If a node has a\n\t// child with the hashCode already set then the child code is compared\n\t// to the same portion of the current nodes array. If they match there\n\t// is a loop.\n\t// Note that the basic mechanism would only allow for 1 use of this\n\t// functionality, so the root nodes have two ints. The second int is\n\t// incremented through each node root and the first is incremented\n\t// through each run of the dfs algorithm (therefore the dfs is not\n\t// thread safe). The hash code of each node is set if not already set,\n\t// or if the first int does not match that of the current run.\n\tif (root != null)\n\t{\n\t\tif (parent != null)\n\t\t{\n\t\t\t// Form this nodes hash code if necessary, that is, if the\n\t\t\t// hashCode variable has not been initialized or if the\n\t\t\t// start of the parent hash code does not equal the start of\n\t\t\t// this nodes hash code, indicating the code was set on a\n\t\t\t// previous run of this dfs.\n\t\t\tif (root.hashCode == null ||\n\t\t\t\troot.hashCode[0] != parent.hashCode[0])\n\t\t\t{\n\t\t\t\tvar hashCodeLength = parent.hashCode.length + 1;\n\t\t\t\troot.hashCode = parent.hashCode.slice();\n\t\t\t\troot.hashCode[hashCodeLength - 1] = childHash;\n\t\t\t}\n\t\t}\n\n\t\tvar rootId = root.id;\n\n\t\tif (seen[rootId] == null)\n\t\t{\n\t\t\tseen[rootId] = root;\n\t\t\tvisitor(parent, root, connectingEdge, layer, 0);\n\n\t\t\t// Copy the connects as source list so that visitors\n\t\t\t// can change the original for edge direction inversions\n\t\t\tvar outgoingEdges = root.connectsAsSource.slice();\n\t\t\tvar incomingEdges = root.connectsAsTarget.slice();\n\n\t\t\tfor (var i = 0; i < outgoingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = outgoingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.target;\n\n\t\t\t\t// Only navigate in source->target direction within the same\n\t\t\t\t// swimlane, or from a lower index swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex <= targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < incomingEdges.length; i++)\n\t\t\t{\n\t\t\t\tvar internalEdge = incomingEdges[i];\n\t\t\t\tvar targetNode = internalEdge.source;\n\n\t\t\t\t// Only navigate in target->source direction from a lower index\n\t\t\t\t// swimlane to a higher one\n\t\t\t\tif (root.swimlaneIndex < targetNode.swimlaneIndex)\n\t\t\t\t{\n\t\t\t\t\tthis.extendedDfs(root, targetNode, internalEdge, visitor, seen,\n\t\t\t\t\t\t\troot.hashCode, i, layer + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Use the int field to indicate this node has been seen\n\t\t\tvisitor(parent, root, connectingEdge, layer, 1);\n\t\t}\n\t}\n};\n\n__mxOutput.mxSwimlaneModel = typeof mxSwimlaneModel !== 'undefined' ? mxSwimlaneModel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxHierarchicalLayoutStage\n *\n * The specific layout interface for hierarchical layouts. It adds a\n * <code>run</code> method with a parameter for the hierarchical layout model\n * that is shared between the layout stages.\n *\n * Constructor: mxHierarchicalLayoutStage\n *\n * Constructs a new hierarchical layout stage.\n */\nfunction mxHierarchicalLayoutStage() { };\n\n/**\n * Function: execute\n *\n * Takes the graph detail and configuration information within the facade\n * and creates the resulting laid out graph within that facade for further\n * use.\n */\nmxHierarchicalLayoutStage.prototype.execute = function(parent) { };\n\n__mxOutput.mxHierarchicalLayoutStage = typeof mxHierarchicalLayoutStage !== 'undefined' ? mxHierarchicalLayoutStage : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMedianHybridCrossingReduction\n *\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well heuristic to straighten edges as\n * far as possible.\n *\n * Constructor: mxMedianHybridCrossingReduction\n *\n * Creates a coordinate assignment.\n *\n * Arguments:\n *\n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nfunction mxMedianHybridCrossingReduction(layout)\n{\n\tthis.layout = layout;\n};\n\n/**\n * Extends mxMedianHybridCrossingReduction.\n */\nmxMedianHybridCrossingReduction.prototype = new mxHierarchicalLayoutStage();\nmxMedianHybridCrossingReduction.prototype.constructor = mxMedianHybridCrossingReduction;\n\n/**\n * Variable: layout\n *\n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxMedianHybridCrossingReduction.prototype.layout = null;\n\n/**\n * Variable: maxIterations\n *\n * The maximum number of iterations to perform whilst reducing edge\n * crossings. Default is 24.\n */\nmxMedianHybridCrossingReduction.prototype.maxIterations = 24;\n\n/**\n * Variable: nestedBestRanks\n *\n * Stores each rank as a collection of cells in the best order found for\n * each layer so far\n */\nmxMedianHybridCrossingReduction.prototype.nestedBestRanks = null;\n\n/**\n * Variable: currentBestCrossings\n *\n * The total number of crossings found in the best configuration so far\n */\nmxMedianHybridCrossingReduction.prototype.currentBestCrossings = 0;\n\n/**\n * Variable: iterationsWithoutImprovement\n *\n * The total number of crossings found in the best configuration so far\n */\nmxMedianHybridCrossingReduction.prototype.iterationsWithoutImprovement = 0;\n\n/**\n * Variable: maxNoImprovementIterations\n *\n * The total number of crossings found in the best configuration so far\n */\nmxMedianHybridCrossingReduction.prototype.maxNoImprovementIterations = 2;\n\n/**\n * Function: execute\n *\n * Performs a vertex ordering within ranks as described by Gansner et al\n * 1993\n */\nmxMedianHybridCrossingReduction.prototype.execute = function(parent)\n{\n\tvar model = this.layout.getModel();\n\n\t// Stores initial ordering as being the best one found so far\n\tthis.nestedBestRanks = [];\n\n\tfor (var i = 0; i < model.ranks.length; i++)\n\t{\n\t\tthis.nestedBestRanks[i] = model.ranks[i].slice();\n\t}\n\n\tvar iterationsWithoutImprovement = 0;\n\tvar currentBestCrossings = this.calculateCrossings(model);\n\n\tfor (var i = 0; i < this.maxIterations &&\n\t\titerationsWithoutImprovement < this.maxNoImprovementIterations; i++)\n\t{\n\t\tthis.weightedMedian(i, model);\n\t\tthis.transpose(i, model);\n\t\tvar candidateCrossings = this.calculateCrossings(model);\n\n\t\tif (candidateCrossings < currentBestCrossings)\n\t\t{\n\t\t\tcurrentBestCrossings = candidateCrossings;\n\t\t\titerationsWithoutImprovement = 0;\n\n\t\t\t// Store the current rankings as the best ones\n\t\t\tfor (var j = 0; j < this.nestedBestRanks.length; j++)\n\t\t\t{\n\t\t\t\tvar rank = model.ranks[j];\n\n\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\tthis.nestedBestRanks[j][cell.getGeneralPurposeVariable(j)] = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Increase count of iterations where we haven't improved the\n\t\t\t// layout\n\t\t\titerationsWithoutImprovement++;\n\n\t\t\t// Restore the best values to the cells\n\t\t\tfor (var j = 0; j < this.nestedBestRanks.length; j++)\n\t\t\t{\n\t\t\t\tvar rank = model.ranks[j];\n\n\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\tcell.setGeneralPurposeVariable(j, k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (currentBestCrossings == 0)\n\t\t{\n\t\t\t// Do nothing further\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Store the best rankings but in the model\n\tvar ranks = [];\n\tvar rankList = [];\n\n\tfor (var i = 0; i < model.maxRank + 1; i++)\n\t{\n\t\trankList[i] = [];\n\t\tranks[i] = rankList[i];\n\t}\n\n\tfor (var i = 0; i < this.nestedBestRanks.length; i++)\n\t{\n\t\tfor (var j = 0; j < this.nestedBestRanks[i].length; j++)\n\t\t{\n\t\t\trankList[i].push(this.nestedBestRanks[i][j]);\n\t\t}\n\t}\n\n\tmodel.ranks = ranks;\n};\n\n\n/**\n * Function: calculateCrossings\n *\n * Calculates the total number of edge crossing in the current graph.\n * Returns the current number of edge crossings in the hierarchy graph\n * model in the current candidate layout\n *\n * Parameters:\n *\n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.calculateCrossings = function(model)\n{\n\tvar numRanks = model.ranks.length;\n\tvar totalCrossings = 0;\n\n\tfor (var i = 1; i < numRanks; i++)\n\t{\n\t\ttotalCrossings += this.calculateRankCrossing(i, model);\n\t}\n\n\treturn totalCrossings;\n};\n\n/**\n * Function: calculateRankCrossing\n *\n * Calculates the number of edges crossings between the specified rank and\n * the rank below it. Returns the number of edges crossings with the rank\n * beneath\n *\n * Parameters:\n *\n * i -  the topmost rank of the pair ( higher rank value )\n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.calculateRankCrossing = function(i, model)\n{\n\tvar totalCrossings = 0;\n\tvar rank = model.ranks[i];\n\tvar previousRank = model.ranks[i - 1];\n\n\tvar tmpIndices = [];\n\n\t// Iterate over the top rank and fill in the connection information\n\tfor (var j = 0; j < rank.length; j++)\n\t{\n\t\tvar node = rank[j];\n\t\tvar rankPosition = node.getGeneralPurposeVariable(i);\n\t\tvar connectedCells = node.getPreviousLayerConnectedCells(i);\n\t\tvar nodeIndices = [];\n\n\t\tfor (var k = 0; k < connectedCells.length; k++)\n\t\t{\n\t\t\tvar connectedNode = connectedCells[k];\n\t\t\tvar otherCellRankPosition = connectedNode.getGeneralPurposeVariable(i - 1);\n\t\t\tnodeIndices.push(otherCellRankPosition);\n\t\t}\n\n\t\tnodeIndices.sort(function(x, y) { return x - y; });\n\t\ttmpIndices[rankPosition] = nodeIndices;\n\t}\n\n\tvar indices = [];\n\n\tfor (var j = 0; j < tmpIndices.length; j++)\n\t{\n\t\tindices = indices.concat(tmpIndices[j]);\n\t}\n\n\tvar firstIndex = 1;\n\n\twhile (firstIndex < previousRank.length)\n\t{\n\t\tfirstIndex <<= 1;\n\t}\n\n\tvar treeSize = 2 * firstIndex - 1;\n\tfirstIndex -= 1;\n\n\tvar tree = [];\n\n\tfor (var j = 0; j < treeSize; ++j)\n\t{\n\t\ttree[j] = 0;\n\t}\n\n\tfor (var j = 0; j < indices.length; j++)\n\t{\n\t\tvar index = indices[j];\n\t    var treeIndex = index + firstIndex;\n\t    ++tree[treeIndex];\n\n\t    while (treeIndex > 0)\n\t    {\n\t    \tif (treeIndex % 2)\n\t    \t{\n\t    \t\ttotalCrossings += tree[treeIndex + 1];\n\t    \t}\n\n\t    \ttreeIndex = (treeIndex - 1) >> 1;\n\t    \t++tree[treeIndex];\n\t    }\n\t}\n\n\treturn totalCrossings;\n};\n\n/**\n * Function: transpose\n *\n * Takes each possible adjacent cell pair on each rank and checks if\n * swapping them around reduces the number of crossing\n *\n * Parameters:\n *\n * mainLoopIteration - the iteration number of the main loop\n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.transpose = function(mainLoopIteration, model)\n{\n\tvar improved = true;\n\n\t// Track the number of iterations in case of looping\n\tvar count = 0;\n\tvar maxCount = 10;\n\twhile (improved && count++ < maxCount)\n\t{\n\t\t// On certain iterations allow allow swapping of cell pairs with\n\t\t// equal edge crossings switched or not switched. This help to\n\t\t// nudge a stuck layout into a lower crossing total.\n\t\tvar nudge = mainLoopIteration % 2 == 1 && count % 2 == 1;\n\t\timproved = false;\n\n\t\tfor (var i = 0; i < model.ranks.length; i++)\n\t\t{\n\t\t\tvar rank = model.ranks[i];\n\t\t\tvar orderedCells = [];\n\n\t\t\tfor (var j = 0; j < rank.length; j++)\n\t\t\t{\n\t\t\t\tvar cell = rank[j];\n\t\t\t\tvar tempRank = cell.getGeneralPurposeVariable(i);\n\n\t\t\t\t// FIXME: Workaround to avoid negative tempRanks\n\t\t\t\tif (tempRank < 0)\n\t\t\t\t{\n\t\t\t\t\ttempRank = j;\n\t\t\t\t}\n\t\t\t\torderedCells[tempRank] = cell;\n\t\t\t}\n\n\t\t\tvar leftCellAboveConnections = null;\n\t\t\tvar leftCellBelowConnections = null;\n\t\t\tvar rightCellAboveConnections = null;\n\t\t\tvar rightCellBelowConnections = null;\n\n\t\t\tvar leftAbovePositions = null;\n\t\t\tvar leftBelowPositions = null;\n\t\t\tvar rightAbovePositions = null;\n\t\t\tvar rightBelowPositions = null;\n\n\t\t\tvar leftCell = null;\n\t\t\tvar rightCell = null;\n\n\t\t\tfor (var j = 0; j < (rank.length - 1); j++)\n\t\t\t{\n\t\t\t\t// For each intra-rank adjacent pair of cells\n\t\t\t\t// see if swapping them around would reduce the\n\t\t\t\t// number of edges crossing they cause in total\n\t\t\t\t// On every cell pair except the first on each rank, we\n\t\t\t\t// can save processing using the previous values for the\n\t\t\t\t// right cell on the new left cell\n\t\t\t\tif (j == 0)\n\t\t\t\t{\n\t\t\t\t\tleftCell = orderedCells[j];\n\t\t\t\t\tleftCellAboveConnections = leftCell\n\t\t\t\t\t\t\t.getNextLayerConnectedCells(i);\n\t\t\t\t\tleftCellBelowConnections = leftCell\n\t\t\t\t\t\t\t.getPreviousLayerConnectedCells(i);\n\t\t\t\t\tleftAbovePositions = [];\n\t\t\t\t\tleftBelowPositions = [];\n\n\t\t\t\t\tfor (var k = 0; k < leftCellAboveConnections.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tleftAbovePositions[k] = leftCellAboveConnections[k].getGeneralPurposeVariable(i + 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var k = 0; k < leftCellBelowConnections.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tleftBelowPositions[k] = leftCellBelowConnections[k].getGeneralPurposeVariable(i - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleftCellAboveConnections = rightCellAboveConnections;\n\t\t\t\t\tleftCellBelowConnections = rightCellBelowConnections;\n\t\t\t\t\tleftAbovePositions = rightAbovePositions;\n\t\t\t\t\tleftBelowPositions = rightBelowPositions;\n\t\t\t\t\tleftCell = rightCell;\n\t\t\t\t}\n\n\t\t\t\trightCell = orderedCells[j + 1];\n\t\t\t\trightCellAboveConnections = rightCell\n\t\t\t\t\t\t.getNextLayerConnectedCells(i);\n\t\t\t\trightCellBelowConnections = rightCell\n\t\t\t\t\t\t.getPreviousLayerConnectedCells(i);\n\n\t\t\t\trightAbovePositions = [];\n\t\t\t\trightBelowPositions = [];\n\n\t\t\t\tfor (var k = 0; k < rightCellAboveConnections.length; k++)\n\t\t\t\t{\n\t\t\t\t\trightAbovePositions[k] = rightCellAboveConnections[k].getGeneralPurposeVariable(i + 1);\n\t\t\t\t}\n\n\t\t\t\tfor (var k = 0; k < rightCellBelowConnections.length; k++)\n\t\t\t\t{\n\t\t\t\t\trightBelowPositions[k] = rightCellBelowConnections[k].getGeneralPurposeVariable(i - 1);\n\t\t\t\t}\n\n\t\t\t\tvar totalCurrentCrossings = 0;\n\t\t\t\tvar totalSwitchedCrossings = 0;\n\n\t\t\t\tfor (var k = 0; k < leftAbovePositions.length; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (var ik = 0; ik < rightAbovePositions.length; ik++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (leftAbovePositions[k] > rightAbovePositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalCurrentCrossings++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (leftAbovePositions[k] < rightAbovePositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalSwitchedCrossings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var k = 0; k < leftBelowPositions.length; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (var ik = 0; ik < rightBelowPositions.length; ik++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (leftBelowPositions[k] > rightBelowPositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalCurrentCrossings++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (leftBelowPositions[k] < rightBelowPositions[ik])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalSwitchedCrossings++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ((totalSwitchedCrossings < totalCurrentCrossings) ||\n\t\t\t\t\t(totalSwitchedCrossings == totalCurrentCrossings &&\n\t\t\t\t\tnudge))\n\t\t\t\t{\n\t\t\t\t\tvar temp = leftCell.getGeneralPurposeVariable(i);\n\t\t\t\t\tleftCell.setGeneralPurposeVariable(i, rightCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(i));\n\t\t\t\t\trightCell.setGeneralPurposeVariable(i, temp);\n\n\t\t\t\t\t// With this pair exchanged we have to switch all of\n\t\t\t\t\t// values for the left cell to the right cell so the\n\t\t\t\t\t// next iteration for this rank uses it as the left\n\t\t\t\t\t// cell again\n\t\t\t\t\trightCellAboveConnections = leftCellAboveConnections;\n\t\t\t\t\trightCellBelowConnections = leftCellBelowConnections;\n\t\t\t\t\trightAbovePositions = leftAbovePositions;\n\t\t\t\t\trightBelowPositions = leftBelowPositions;\n\t\t\t\t\trightCell = leftCell;\n\n\t\t\t\t\tif (!nudge)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Don't count nudges as improvement or we'll end\n\t\t\t\t\t\t// up stuck in two combinations and not finishing\n\t\t\t\t\t\t// as early as we should\n\t\t\t\t\t\timproved = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: weightedMedian\n *\n * Sweeps up or down the layout attempting to minimise the median placement\n * of connected cells on adjacent ranks\n *\n * Parameters:\n *\n * iteration - the iteration number of the main loop\n * model - the internal model describing the hierarchy\n */\nmxMedianHybridCrossingReduction.prototype.weightedMedian = function(iteration, model)\n{\n\t// Reverse sweep direction each time through this method\n\tvar downwardSweep = (iteration % 2 == 0);\n\tif (downwardSweep)\n\t{\n\t\tfor (var j = model.maxRank - 1; j >= 0; j--)\n\t\t{\n\t\t\tthis.medianRank(j, downwardSweep);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (var j = 1; j < model.maxRank; j++)\n\t\t{\n\t\t\tthis.medianRank(j, downwardSweep);\n\t\t}\n\t}\n};\n\n/**\n * Function: medianRank\n *\n * Attempts to minimise the median placement of connected cells on this rank\n * and one of the adjacent ranks\n *\n * Parameters:\n *\n * rankValue - the layer number of this rank\n * downwardSweep - whether or not this is a downward sweep through the graph\n */\nmxMedianHybridCrossingReduction.prototype.medianRank = function(rankValue, downwardSweep)\n{\n\tvar numCellsForRank = this.nestedBestRanks[rankValue].length;\n\tvar medianValues = [];\n\tvar reservedPositions = [];\n\n\tfor (var i = 0; i < numCellsForRank; i++)\n\t{\n\t\tvar cell = this.nestedBestRanks[rankValue][i];\n\t\tvar sorterEntry = new MedianCellSorter();\n\t\tsorterEntry.cell = cell;\n\n\t\t// Flip whether or not equal medians are flipped on up and down\n\t\t// sweeps\n\t\t// TODO re-implement some kind of nudge\n\t\t// medianValues[i].nudge = !downwardSweep;\n\t\tvar nextLevelConnectedCells;\n\n\t\tif (downwardSweep)\n\t\t{\n\t\t\tnextLevelConnectedCells = cell\n\t\t\t\t\t.getNextLayerConnectedCells(rankValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLevelConnectedCells = cell\n\t\t\t\t\t.getPreviousLayerConnectedCells(rankValue);\n\t\t}\n\n\t\tvar nextRankValue;\n\n\t\tif (downwardSweep)\n\t\t{\n\t\t\tnextRankValue = rankValue + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextRankValue = rankValue - 1;\n\t\t}\n\n\t\tif (nextLevelConnectedCells != null\n\t\t\t\t&& nextLevelConnectedCells.length != 0)\n\t\t{\n\t\t\tsorterEntry.medianValue = this.medianValue(\n\t\t\t\t\tnextLevelConnectedCells, nextRankValue);\n\t\t\tmedianValues.push(sorterEntry);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Nodes with no adjacent vertices are flagged in the reserved array\n\t\t\t// to indicate they should be left in their current position.\n\t\t\treservedPositions[cell.getGeneralPurposeVariable(rankValue)] = true;\n\t\t}\n\t}\n\n\tmedianValues.sort(MedianCellSorter.prototype.compare);\n\n\t// Set the new position of each node within the rank using\n\t// its temp variable\n\tfor (var i = 0; i < numCellsForRank; i++)\n\t{\n\t\tif (reservedPositions[i] == null)\n\t\t{\n\t\t\tvar cell = medianValues.shift().cell;\n\t\t\tcell.setGeneralPurposeVariable(rankValue, i);\n\t\t}\n\t}\n};\n\n/**\n * Function: medianValue\n *\n * Calculates the median rank order positioning for the specified cell using\n * the connected cells on the specified rank. Returns the median rank\n * ordering value of the connected cells\n *\n * Parameters:\n *\n * connectedCells - the cells on the specified rank connected to the\n * specified cell\n * rankValue - the rank that the connected cell lie upon\n */\nmxMedianHybridCrossingReduction.prototype.medianValue = function(connectedCells, rankValue)\n{\n\tvar medianValues = [];\n\tvar arrayCount = 0;\n\n\tfor (var i = 0; i < connectedCells.length; i++)\n\t{\n\t\tvar cell = connectedCells[i];\n\t\tmedianValues[arrayCount++] = cell.getGeneralPurposeVariable(rankValue);\n\t}\n\n\t// Sort() sorts lexicographically by default (i.e. 11 before 9) so force\n\t// numerical order sort\n\tmedianValues.sort(function(a,b){return a - b;});\n\n\tif (arrayCount % 2 == 1)\n\t{\n\t\t// For odd numbers of adjacent vertices return the median\n\t\treturn medianValues[Math.floor(arrayCount / 2)];\n\t}\n\telse if (arrayCount == 2)\n\t{\n\t\treturn ((medianValues[0] + medianValues[1]) / 2.0);\n\t}\n\telse\n\t{\n\t\tvar medianPoint = arrayCount / 2;\n\t\tvar leftMedian = medianValues[medianPoint - 1] - medianValues[0];\n\t\tvar rightMedian = medianValues[arrayCount - 1]\n\t\t\t\t- medianValues[medianPoint];\n\n\t\treturn (medianValues[medianPoint - 1] * rightMedian + medianValues[medianPoint]\n\t\t\t\t* leftMedian)\n\t\t\t\t/ (leftMedian + rightMedian);\n\t}\n};\n\n/**\n * Class: MedianCellSorter\n *\n * A utility class used to track cells whilst sorting occurs on the median\n * values. Does not violate (x.compareTo(y)==0) == (x.equals(y))\n *\n * Constructor: MedianCellSorter\n *\n * Constructs a new median cell sorter.\n */\nfunction MedianCellSorter()\n{\n\t// empty\n};\n\n/**\n * Variable: medianValue\n *\n * The weighted value of the cell stored.\n */\nMedianCellSorter.prototype.medianValue = 0;\n\n/**\n * Variable: cell\n *\n * The cell whose median value is being calculated\n */\nMedianCellSorter.prototype.cell = false;\n\n/**\n * Function: compare\n *\n * Compares two MedianCellSorters.\n */\nMedianCellSorter.prototype.compare = function(a, b)\n{\n\tif (a != null && b != null)\n\t{\n\t\tif (b.medianValue > a.medianValue)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\telse if (b.medianValue < a.medianValue)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse\n\t{\n\t\treturn 0;\n\t}\n};\n\n__mxOutput.mxMedianHybridCrossingReduction = typeof mxMedianHybridCrossingReduction !== 'undefined' ? mxMedianHybridCrossingReduction : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMinimumCycleRemover\n *\n * An implementation of the first stage of the Sugiyama layout. Straightforward\n * longest path calculation of layer assignment\n *\n * Constructor: mxMinimumCycleRemover\n *\n * Creates a cycle remover for the given internal model.\n */\nfunction mxMinimumCycleRemover(layout)\n{\n\tthis.layout = layout;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxMinimumCycleRemover.prototype = new mxHierarchicalLayoutStage();\nmxMinimumCycleRemover.prototype.constructor = mxMinimumCycleRemover;\n\n/**\n * Variable: layout\n *\n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxMinimumCycleRemover.prototype.layout = null;\n\n/**\n * Function: execute\n *\n * Takes the graph detail and configuration information within the facade\n * and creates the resulting laid out graph within that facade for further\n * use.\n */\nmxMinimumCycleRemover.prototype.execute = function(parent)\n{\n\tvar model = this.layout.getModel();\n\tvar seenNodes = new Object();\n\tvar unseenNodesArray = model.vertexMapper.getValues();\n\tvar unseenNodes = new Object();\n\n\tfor (var i = 0; i < unseenNodesArray.length; i++)\n\t{\n\t\tunseenNodes[unseenNodesArray[i].id] = unseenNodesArray[i];\n\t}\n\n\t// Perform a dfs through the internal model. If a cycle is found,\n\t// reverse it.\n\tvar rootsArray = null;\n\n\tif (model.roots != null)\n\t{\n\t\tvar modelRoots = model.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < modelRoots.length; i++)\n\t\t{\n\t\t\trootsArray[i] = model.vertexMapper.get(modelRoots[i]);\n\t\t}\n\t}\n\n\tmodel.visit(function(parent, node, connectingEdge, layer, seen)\n\t{\n\t\t// Check if the cell is in it's own ancestor list, if so\n\t\t// invert the connecting edge and reverse the target/source\n\t\t// relationship to that edge in the parent and the cell\n\t\tif (node.isAncestor(parent))\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsSource);\n\t\t\tparent.connectsAsTarget.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsTarget);\n\t\t\tnode.connectsAsSource.push(connectingEdge);\n\t\t}\n\n\t\tseenNodes[node.id] = node;\n\t\tdelete unseenNodes[node.id];\n\t}, rootsArray, true, null);\n\n\t// If there are any nodes that should be nodes that the dfs can miss\n\t// these need to be processed with the dfs and the roots assigned\n\t// correctly to form a correct internal model\n\tvar seenNodesCopy = mxUtils.clone(seenNodes, null, true);\n\n\t// Pick a random cell and dfs from it\n\tmodel.visit(function(parent, node, connectingEdge, layer, seen)\n\t{\n\t\t// Check if the cell is in it's own ancestor list, if so\n\t\t// invert the connecting edge and reverse the target/source\n\t\t// relationship to that edge in the parent and the cell\n\t\tif (node.isAncestor(parent))\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsSource);\n\t\t\tnode.connectsAsSource.push(connectingEdge);\n\t\t\tparent.connectsAsTarget.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsTarget);\n\t\t}\n\n\t\tseenNodes[node.id] = node;\n\t\tdelete unseenNodes[node.id];\n\t}, unseenNodes, true, seenNodesCopy);\n};\n\n__mxOutput.mxMinimumCycleRemover = typeof mxMinimumCycleRemover !== 'undefined' ? mxMinimumCycleRemover : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxCoordinateAssignment\n *\n * Sets the horizontal locations of node and edge dummy nodes on each layer.\n * Uses median down and up weighings as well as heuristics to straighten edges as\n * far as possible.\n *\n * Constructor: mxCoordinateAssignment\n *\n * Creates a coordinate assignment.\n *\n * Arguments:\n *\n * intraCellSpacing - the minimum buffer between cells on the same rank\n * interRankCellSpacing - the minimum distance between cells on adjacent ranks\n * orientation - the position of the root node(s) relative to the graph\n * initialX - the leftmost coordinate node placement starts at\n */\nfunction mxCoordinateAssignment(layout, intraCellSpacing, interRankCellSpacing,\n\torientation, initialX, parallelEdgeSpacing)\n{\n\tthis.layout = layout;\n\tthis.intraCellSpacing = intraCellSpacing;\n\tthis.interRankCellSpacing = interRankCellSpacing;\n\tthis.orientation = orientation;\n\tthis.initialX = initialX;\n\tthis.parallelEdgeSpacing = parallelEdgeSpacing;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxCoordinateAssignment.prototype = new mxHierarchicalLayoutStage();\nmxCoordinateAssignment.prototype.constructor = mxCoordinateAssignment;\n\n/**\n * Variable: layout\n *\n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxCoordinateAssignment.prototype.layout = null;\n\n/**\n * Variable: intraCellSpacing\n *\n * The minimum buffer between cells on the same rank. Default is 30.\n */\nmxCoordinateAssignment.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n *\n * The minimum distance between cells on adjacent ranks. Default is 10.\n */\nmxCoordinateAssignment.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: parallelEdgeSpacing\n *\n * The distance between each parallel edge on each ranks for long edges.\n * Default is 10.\n */\nmxCoordinateAssignment.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: maxIterations\n *\n * The number of heuristic iterations to run. Default is 8.\n */\nmxCoordinateAssignment.prototype.maxIterations = 8;\n\n/**\n * Variable: prefHozEdgeSep\n *\n * The preferred horizontal distance between edges exiting a vertex\n */\nmxCoordinateAssignment.prototype.prefHozEdgeSep = 5;\n\n/**\n * Variable: prefVertEdgeOff\n *\n * The preferred vertical offset between edges exiting a vertex\n */\nmxCoordinateAssignment.prototype.prefVertEdgeOff = 2;\n\n/**\n * Variable: minEdgeJetty\n *\n * The minimum distance for an edge jetty from a vertex\n */\nmxCoordinateAssignment.prototype.minEdgeJetty = 12;\n\n/**\n * Variable: channelBuffer\n *\n * The size of the vertical buffer in the center of inter-rank channels\n * where edge control points should not be placed\n */\nmxCoordinateAssignment.prototype.channelBuffer = 4;\n\n/**\n * Variable: jettyPositions\n *\n * Map of internal edges and (x,y) pair of positions of the start and end jetty\n * for that edge where it connects to the source and target vertices.\n * Note this should technically be a WeakHashMap, but since JS does not\n * have an equivalent, housekeeping must be performed before using.\n * i.e. check all edges are still in the model and clear the values.\n * Note that the y co-ord is the offset of the jetty, not the\n * absolute point\n */\nmxCoordinateAssignment.prototype.jettyPositions = null;\n\n/**\n * Variable: orientation\n *\n * The position of the root ( start ) node(s) relative to the rest of the\n * laid out graph. Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxCoordinateAssignment.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: initialX\n *\n * The minimum x position node placement starts at\n */\nmxCoordinateAssignment.prototype.initialX = null;\n\n/**\n * Variable: limitX\n *\n * The maximum x value this positioning lays up to\n */\nmxCoordinateAssignment.prototype.limitX = null;\n\n/**\n * Variable: currentXDelta\n *\n * The sum of x-displacements for the current iteration\n */\nmxCoordinateAssignment.prototype.currentXDelta = null;\n\n/**\n * Variable: widestRank\n *\n * The rank that has the widest x position\n */\nmxCoordinateAssignment.prototype.widestRank = null;\n\n/**\n * Variable: rankTopY\n *\n * Internal cache of top-most values of Y for each rank\n */\nmxCoordinateAssignment.prototype.rankTopY = null;\n\n/**\n * Variable: rankBottomY\n *\n * Internal cache of bottom-most value of Y for each rank\n */\nmxCoordinateAssignment.prototype.rankBottomY = null;\n\n/**\n * Variable: widestRankValue\n *\n * The X-coordinate of the edge of the widest rank\n */\nmxCoordinateAssignment.prototype.widestRankValue = null;\n\n/**\n * Variable: rankWidths\n *\n * The width of all the ranks\n */\nmxCoordinateAssignment.prototype.rankWidths = null;\n\n/**\n * Variable: rankY\n *\n * The Y-coordinate of all the ranks\n */\nmxCoordinateAssignment.prototype.rankY = null;\n\n/**\n * Variable: fineTuning\n *\n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxCoordinateAssignment.prototype.fineTuning = true;\n\n/**\n * Variable: nextLayerConnectedCache\n *\n * A store of connections to the layer above for speed\n */\nmxCoordinateAssignment.prototype.nextLayerConnectedCache = null;\n\n/**\n * Variable: previousLayerConnectedCache\n *\n * A store of connections to the layer below for speed\n */\nmxCoordinateAssignment.prototype.previousLayerConnectedCache = null;\n\n/**\n * Variable: groupPadding\n *\n * Padding added to resized parents\n */\nmxCoordinateAssignment.prototype.groupPadding = 10;\n\n/**\n * Utility method to display current positions\n */\nmxCoordinateAssignment.prototype.printStatus = function()\n{\n\tvar model = this.layout.getModel();\n\tmxLog.show();\n\n\tmxLog.writeln('======Coord assignment debug=======');\n\n\tfor (var j = 0; j < model.ranks.length; j++)\n\t{\n\t\tmxLog.write('Rank ', j, ' : ' );\n\t\tvar rank = model.ranks[j];\n\n\t\tfor (var k = 0; k < rank.length; k++)\n\t\t{\n\t\t\tvar cell = rank[k];\n\n\t\t\tmxLog.write(cell.getGeneralPurposeVariable(j), '  ');\n\t\t}\n\t\tmxLog.writeln();\n\t}\n\n\tmxLog.writeln('====================================');\n};\n\n/**\n * Function: execute\n *\n * A basic horizontal coordinate assignment algorithm\n */\nmxCoordinateAssignment.prototype.execute = function(parent)\n{\n\tthis.jettyPositions = Object();\n\tvar model = this.layout.getModel();\n\tthis.currentXDelta = 0.0;\n\n\tthis.initialCoords(this.layout.getGraph(), model);\n\n//\tthis.printStatus();\n\n\tif (this.fineTuning)\n\t{\n\t\tthis.minNode(model);\n\t}\n\n\tvar bestXDelta = 100000000.0;\n\n\tif (this.fineTuning)\n\t{\n\t\tfor (var i = 0; i < this.maxIterations; i++)\n\t\t{\n//\t\t\tthis.printStatus();\n\n\t\t\t// Median Heuristic\n\t\t\tif (i != 0)\n\t\t\t{\n\t\t\t\tthis.medianPos(i, model);\n\t\t\t\tthis.minNode(model);\n\t\t\t}\n\n\t\t\t// if the total offset is less for the current positioning,\n\t\t\t// there are less heavily angled edges and so the current\n\t\t\t// positioning is used\n\t\t\tif (this.currentXDelta < bestXDelta)\n\t\t\t{\n\t\t\t\tfor (var j = 0; j < model.ranks.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar rank = model.ranks[j];\n\n\t\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\t\tcell.setX(j, cell.getGeneralPurposeVariable(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbestXDelta = this.currentXDelta;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Restore the best positions\n\t\t\t\tfor (var j = 0; j < model.ranks.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar rank = model.ranks[j];\n\n\t\t\t\t\tfor (var k = 0; k < rank.length; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar cell = rank[k];\n\t\t\t\t\t\tcell.setGeneralPurposeVariable(j, cell.getX(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.minPath(this.layout.getGraph(), model);\n\n\t\t\tthis.currentXDelta = 0;\n\t\t}\n\t}\n\n\tthis.setCellLocations(this.layout.getGraph(), model);\n};\n\n/**\n * Function: minNode\n *\n * Performs one median positioning sweep in both directions\n */\nmxCoordinateAssignment.prototype.minNode = function(model)\n{\n\t// Queue all nodes\n\tvar nodeList = [];\n\n\t// Need to be able to map from cell to cellWrapper\n\tvar map = new mxDictionary();\n\tvar rank = [];\n\n\tfor (var i = 0; i <= model.maxRank; i++)\n\t{\n\t\trank[i] = model.ranks[i];\n\n\t\tfor (var j = 0; j < rank[i].length; j++)\n\t\t{\n\t\t\t// Use the weight to store the rank and visited to store whether\n\t\t\t// or not the cell is in the list\n\t\t\tvar node = rank[i][j];\n\t\t\tvar nodeWrapper = new WeightedCellSorter(node, i);\n\t\t\tnodeWrapper.rankIndex = j;\n\t\t\tnodeWrapper.visited = true;\n\t\t\tnodeList.push(nodeWrapper);\n\n\t\t\tmap.put(node, nodeWrapper);\n\t\t}\n\t}\n\n\t// Set a limit of the maximum number of times we will access the queue\n\t// in case a loop appears\n\tvar maxTries = nodeList.length * 10;\n\tvar count = 0;\n\n\t// Don't move cell within this value of their median\n\tvar tolerance = 1;\n\n\twhile (nodeList.length > 0 && count <= maxTries)\n\t{\n\t\tvar cellWrapper = nodeList.shift();\n\t\tvar cell = cellWrapper.cell;\n\n\t\tvar rankValue = cellWrapper.weightedValue;\n\t\tvar rankIndex = parseInt(cellWrapper.rankIndex);\n\n\t\tvar nextLayerConnectedCells = cell.getNextLayerConnectedCells(rankValue);\n\t\tvar previousLayerConnectedCells = cell.getPreviousLayerConnectedCells(rankValue);\n\n\t\tvar numNextLayerConnected = nextLayerConnectedCells.length;\n\t\tvar numPreviousLayerConnected = previousLayerConnectedCells.length;\n\n\t\tvar medianNextLevel = this.medianXValue(nextLayerConnectedCells,\n\t\t\t\trankValue + 1);\n\t\tvar medianPreviousLevel = this.medianXValue(previousLayerConnectedCells,\n\t\t\t\trankValue - 1);\n\n\t\tvar numConnectedNeighbours = numNextLayerConnected\n\t\t\t\t+ numPreviousLayerConnected;\n\t\tvar currentPosition = cell.getGeneralPurposeVariable(rankValue);\n\t\tvar cellMedian = currentPosition;\n\n\t\tif (numConnectedNeighbours > 0)\n\t\t{\n\t\t\tcellMedian = (medianNextLevel * numNextLayerConnected + medianPreviousLevel\n\t\t\t\t\t* numPreviousLayerConnected)\n\t\t\t\t\t/ numConnectedNeighbours;\n\t\t}\n\n\t\t// Flag storing whether or not position has changed\n\t\tvar positionChanged = false;\n\n\t\tif (cellMedian < currentPosition - tolerance)\n\t\t{\n\t\t\tif (rankIndex == 0)\n\t\t\t{\n\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\tpositionChanged = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar leftCell = rank[rankValue][rankIndex - 1];\n\t\t\t\tvar leftLimit = leftCell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue);\n\t\t\t\tleftLimit = leftLimit + leftCell.width / 2\n\t\t\t\t\t\t+ this.intraCellSpacing + cell.width / 2;\n\n\t\t\t\tif (leftLimit < cellMedian)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t\telse if (leftLimit < cell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t- tolerance)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, leftLimit);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (cellMedian > currentPosition + tolerance)\n\t\t{\n\t\t\tvar rankSize = rank[rankValue].length;\n\n\t\t\tif (rankIndex == rankSize - 1)\n\t\t\t{\n\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\tpositionChanged = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar rightCell = rank[rankValue][rankIndex + 1];\n\t\t\t\tvar rightLimit = rightCell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue);\n\t\t\t\trightLimit = rightLimit - rightCell.width / 2\n\t\t\t\t\t\t- this.intraCellSpacing - cell.width / 2;\n\n\t\t\t\tif (rightLimit > cellMedian)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, cellMedian);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t\telse if (rightLimit > cell\n\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t+ tolerance)\n\t\t\t\t{\n\t\t\t\t\tcell.setGeneralPurposeVariable(rankValue, rightLimit);\n\t\t\t\t\tpositionChanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (positionChanged)\n\t\t{\n\t\t\t// Add connected nodes to map and list\n\t\t\tfor (var i = 0; i < nextLayerConnectedCells.length; i++)\n\t\t\t{\n\t\t\t\tvar connectedCell = nextLayerConnectedCells[i];\n\t\t\t\tvar connectedCellWrapper = map.get(connectedCell);\n\n\t\t\t\tif (connectedCellWrapper != null)\n\t\t\t\t{\n\t\t\t\t\tif (connectedCellWrapper.visited == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnectedCellWrapper.visited = true;\n\t\t\t\t\t\tnodeList.push(connectedCellWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add connected nodes to map and list\n\t\t\tfor (var i = 0; i < previousLayerConnectedCells.length; i++)\n\t\t\t{\n\t\t\t\tvar connectedCell = previousLayerConnectedCells[i];\n\t\t\t\tvar connectedCellWrapper = map.get(connectedCell);\n\n\t\t\t\tif (connectedCellWrapper != null)\n\t\t\t\t{\n\t\t\t\t\tif (connectedCellWrapper.visited == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tconnectedCellWrapper.visited = true;\n\t\t\t\t\t\tnodeList.push(connectedCellWrapper);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcellWrapper.visited = false;\n\t\tcount++;\n\t}\n};\n\n/**\n * Function: medianPos\n *\n * Performs one median positioning sweep in one direction\n *\n * Parameters:\n *\n * i - the iteration of the whole process\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.medianPos = function(i, model)\n{\n\t// Reverse sweep direction each time through this method\n\tvar downwardSweep = (i % 2 == 0);\n\n\tif (downwardSweep)\n\t{\n\t\tfor (var j = model.maxRank; j > 0; j--)\n\t\t{\n\t\t\tthis.rankMedianPosition(j - 1, model, j);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (var j = 0; j < model.maxRank - 1; j++)\n\t\t{\n\t\t\tthis.rankMedianPosition(j + 1, model, j);\n\t\t}\n\t}\n};\n\n/**\n * Function: rankMedianPosition\n *\n * Performs median minimisation over one rank.\n *\n * Parameters:\n *\n * rankValue - the layer number of this rank\n * model - an internal model of the hierarchical layout\n * nextRankValue - the layer number whose connected cels are to be laid out\n * relative to\n */\nmxCoordinateAssignment.prototype.rankMedianPosition = function(rankValue, model, nextRankValue)\n{\n\tvar rank = model.ranks[rankValue];\n\n\t// Form an array of the order in which the cell are to be processed\n\t// , the order is given by the weighted sum of the in or out edges,\n\t// depending on whether we're traveling up or down the hierarchy.\n\tvar weightedValues = [];\n\tvar cellMap = new Object();\n\n\tfor (var i = 0; i < rank.length; i++)\n\t{\n\t\tvar currentCell = rank[i];\n\t\tweightedValues[i] = new WeightedCellSorter();\n\t\tweightedValues[i].cell = currentCell;\n\t\tweightedValues[i].rankIndex = i;\n\t\tcellMap[currentCell.id] = weightedValues[i];\n\t\tvar nextLayerConnectedCells = null;\n\n\t\tif (nextRankValue < rankValue)\n\t\t{\n\t\t\tnextLayerConnectedCells = currentCell\n\t\t\t\t\t.getPreviousLayerConnectedCells(rankValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLayerConnectedCells = currentCell\n\t\t\t\t\t.getNextLayerConnectedCells(rankValue);\n\t\t}\n\n\t\t// Calculate the weighing based on this node type and those this\n\t\t// node is connected to on the next layer\n\t\tweightedValues[i].weightedValue = this.calculatedWeightedValue(\n\t\t\t\tcurrentCell, nextLayerConnectedCells);\n\t}\n\n\tweightedValues.sort(WeightedCellSorter.prototype.compare);\n\n\t// Set the new position of each node within the rank using\n\t// its temp variable\n\n\tfor (var i = 0; i < weightedValues.length; i++)\n\t{\n\t\tvar numConnectionsNextLevel = 0;\n\t\tvar cell = weightedValues[i].cell;\n\t\tvar nextLayerConnectedCells = null;\n\t\tvar medianNextLevel = 0;\n\n\t\tif (nextRankValue < rankValue)\n\t\t{\n\t\t\tnextLayerConnectedCells = cell.getPreviousLayerConnectedCells(\n\t\t\t\t\trankValue).slice();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnextLayerConnectedCells = cell.getNextLayerConnectedCells(\n\t\t\t\t\trankValue).slice();\n\t\t}\n\n\t\tif (nextLayerConnectedCells != null)\n\t\t{\n\t\t\tnumConnectionsNextLevel = nextLayerConnectedCells.length;\n\n\t\t\tif (numConnectionsNextLevel > 0)\n\t\t\t{\n\t\t\t\tmedianNextLevel = this.medianXValue(nextLayerConnectedCells,\n\t\t\t\t\t\tnextRankValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// For case of no connections on the next level set the\n\t\t\t\t// median to be the current position and try to be\n\t\t\t\t// positioned there\n\t\t\t\tmedianNextLevel = cell.getGeneralPurposeVariable(rankValue);\n\t\t\t}\n\t\t}\n\n\t\tvar leftBuffer = 0.0;\n\t\tvar leftLimit = -100000000.0;\n\n\t\tfor (var j = weightedValues[i].rankIndex - 1; j >= 0;)\n\t\t{\n\t\t\tvar weightedValue = cellMap[rank[j].id];\n\n\t\t\tif (weightedValue != null)\n\t\t\t{\n\t\t\t\tvar leftCell = weightedValue.cell;\n\n\t\t\t\tif (weightedValue.visited)\n\t\t\t\t{\n\t\t\t\t\t// The left limit is the right hand limit of that\n\t\t\t\t\t// cell plus any allowance for unallocated cells\n\t\t\t\t\t// in-between\n\t\t\t\t\tleftLimit = leftCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t\t+ leftCell.width\n\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t+ this.intraCellSpacing\n\t\t\t\t\t\t\t+ leftBuffer + cell.width / 2.0;\n\t\t\t\t\tj = -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tleftBuffer += leftCell.width + this.intraCellSpacing;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar rightBuffer = 0.0;\n\t\tvar rightLimit = 100000000.0;\n\n\t\tfor (var j = weightedValues[i].rankIndex + 1; j < weightedValues.length;)\n\t\t{\n\t\t\tvar weightedValue = cellMap[rank[j].id];\n\n\t\t\tif (weightedValue != null)\n\t\t\t{\n\t\t\t\tvar rightCell = weightedValue.cell;\n\n\t\t\t\tif (weightedValue.visited)\n\t\t\t\t{\n\t\t\t\t\t// The left limit is the right hand limit of that\n\t\t\t\t\t// cell plus any allowance for unallocated cells\n\t\t\t\t\t// in-between\n\t\t\t\t\trightLimit = rightCell\n\t\t\t\t\t\t\t.getGeneralPurposeVariable(rankValue)\n\t\t\t\t\t\t\t- rightCell.width\n\t\t\t\t\t\t\t/ 2.0\n\t\t\t\t\t\t\t- this.intraCellSpacing\n\t\t\t\t\t\t\t- rightBuffer - cell.width / 2.0;\n\t\t\t\t\tj = weightedValues.length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trightBuffer += rightCell.width + this.intraCellSpacing;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit)\n\t\t{\n\t\t\tcell.setGeneralPurposeVariable(rankValue, medianNextLevel);\n\t\t}\n\t\telse if (medianNextLevel < leftLimit)\n\t\t{\n\t\t\t// Couldn't place at median value, place as close to that\n\t\t\t// value as possible\n\t\t\tcell.setGeneralPurposeVariable(rankValue, leftLimit);\n\t\t\tthis.currentXDelta += leftLimit - medianNextLevel;\n\t\t}\n\t\telse if (medianNextLevel > rightLimit)\n\t\t{\n\t\t\t// Couldn't place at median value, place as close to that\n\t\t\t// value as possible\n\t\t\tcell.setGeneralPurposeVariable(rankValue, rightLimit);\n\t\t\tthis.currentXDelta += medianNextLevel - rightLimit;\n\t\t}\n\n\t\tweightedValues[i].visited = true;\n\t}\n};\n\n/**\n * Function: calculatedWeightedValue\n *\n * Calculates the priority the specified cell has based on the type of its\n * cell and the cells it is connected to on the next layer\n *\n * Parameters:\n *\n * currentCell - the cell whose weight is to be calculated\n * collection - the cells the specified cell is connected to\n */\nmxCoordinateAssignment.prototype.calculatedWeightedValue = function(currentCell, collection)\n{\n\tvar totalWeight = 0;\n\n\tfor (var i = 0; i < collection.length; i++)\n\t{\n\t\tvar cell = collection[i];\n\n\t\tif (currentCell.isVertex() && cell.isVertex())\n\t\t{\n\t\t\ttotalWeight++;\n\t\t}\n\t\telse if (currentCell.isEdge() && cell.isEdge())\n\t\t{\n\t\t\ttotalWeight += 8;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotalWeight += 2;\n\t\t}\n\t}\n\n\treturn totalWeight;\n};\n\n/**\n * Function: medianXValue\n *\n * Calculates the median position of the connected cell on the specified\n * rank\n *\n * Parameters:\n *\n * connectedCells - the cells the candidate connects to on this level\n * rankValue - the layer number of this rank\n */\nmxCoordinateAssignment.prototype.medianXValue = function(connectedCells, rankValue)\n{\n\tif (connectedCells.length == 0)\n\t{\n\t\treturn 0;\n\t}\n\n\tvar medianValues = [];\n\n\tfor (var i = 0; i < connectedCells.length; i++)\n\t{\n\t\tmedianValues[i] = connectedCells[i].getGeneralPurposeVariable(rankValue);\n\t}\n\n\tmedianValues.sort(function(a,b){return a - b;});\n\n\tif (connectedCells.length % 2 == 1)\n\t{\n\t\t// For odd numbers of adjacent vertices return the median\n\t\treturn medianValues[Math.floor(connectedCells.length / 2)];\n\t}\n\telse\n\t{\n\t\tvar medianPoint = connectedCells.length / 2;\n\t\tvar leftMedian = medianValues[medianPoint - 1];\n\t\tvar rightMedian = medianValues[medianPoint];\n\n\t\treturn ((leftMedian + rightMedian) / 2);\n\t}\n};\n\n/**\n * Function: initialCoords\n *\n * Sets up the layout in an initial positioning. The ranks are all centered\n * as much as possible along the middle vertex in each rank. The other cells\n * are then placed as close as possible on either side.\n *\n * Parameters:\n *\n * facade - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.initialCoords = function(facade, model)\n{\n\tthis.calculateWidestRank(facade, model);\n\n\t// Sweep up and down from the widest rank\n\tfor (var i = this.widestRank; i >= 0; i--)\n\t{\n\t\tif (i < model.maxRank)\n\t\t{\n\t\t\tthis.rankCoordinates(i, facade, model);\n\t\t}\n\t}\n\n\tfor (var i = this.widestRank+1; i <= model.maxRank; i++)\n\t{\n\t\tif (i > 0)\n\t\t{\n\t\t\tthis.rankCoordinates(i, facade, model);\n\t\t}\n\t}\n};\n\n/**\n * Function: rankCoordinates\n *\n * Sets up the layout in an initial positioning. All the first cells in each\n * rank are moved to the left and the rest of the rank inserted as close\n * together as their size and buffering permits. This method works on just\n * the specified rank.\n *\n * Parameters:\n *\n * rankValue - the current rank being processed\n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.rankCoordinates = function(rankValue, graph, model)\n{\n\tvar rank = model.ranks[rankValue];\n\tvar maxY = 0.0;\n\tvar localX = this.initialX + (this.widestRankValue - this.rankWidths[rankValue])\n\t\t\t/ 2;\n\n\t// Store whether or not any of the cells' bounds were unavailable so\n\t// to only issue the warning once for all cells\n\tvar boundsWarning = false;\n\n\tfor (var i = 0; i < rank.length; i++)\n\t{\n\t\tvar node = rank[i];\n\n\t\tif (node.isVertex())\n\t\t{\n\t\t\tvar bounds = this.layout.getVertexBounds(node.cell);\n\n\t\t\tif (bounds != null)\n\t\t\t{\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnode.width = bounds.width;\n\t\t\t\t\tnode.height = bounds.height;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnode.width = bounds.height;\n\t\t\t\t\tnode.height = bounds.width;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tboundsWarning = true;\n\t\t\t}\n\n\t\t\tmaxY = Math.max(maxY, node.height);\n\t\t}\n\t\telse if (node.isEdge())\n\t\t{\n\t\t\t// The width is the number of additional parallel edges\n\t\t\t// time the parallel edge spacing\n\t\t\tvar numEdges = 1;\n\n\t\t\tif (node.edges != null)\n\t\t\t{\n\t\t\t\tnumEdges = node.edges.length;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxLog.warn('edge.edges is null');\n\t\t\t}\n\n\t\t\tnode.width = (numEdges - 1) * this.parallelEdgeSpacing;\n\t\t}\n\n\t\t// Set the initial x-value as being the best result so far\n\t\tlocalX += node.width / 2.0;\n\t\tnode.setX(rankValue, localX);\n\t\tnode.setGeneralPurposeVariable(rankValue, localX);\n\t\tlocalX += node.width / 2.0;\n\t\tlocalX += this.intraCellSpacing;\n\t}\n\n\tif (boundsWarning == true)\n\t{\n\t\tmxLog.warn('At least one cell has no bounds');\n\t}\n};\n\n/**\n * Function: calculateWidestRank\n *\n * Calculates the width rank in the hierarchy. Also set the y value of each\n * rank whilst performing the calculation\n *\n * Parameters:\n *\n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.calculateWidestRank = function(graph, model)\n{\n\t// Starting y co-ordinate\n\tvar y = -this.interRankCellSpacing;\n\n\t// Track the widest cell on the last rank since the y\n\t// difference depends on it\n\tvar lastRankMaxCellHeight = 0.0;\n\tthis.rankWidths = [];\n\tthis.rankY = [];\n\n\tfor (var rankValue = model.maxRank; rankValue >= 0; rankValue--)\n\t{\n\t\t// Keep track of the widest cell on this rank\n\t\tvar maxCellHeight = 0.0;\n\t\tvar rank = model.ranks[rankValue];\n\t\tvar localX = this.initialX;\n\n\t\t// Store whether or not any of the cells' bounds were unavailable so\n\t\t// to only issue the warning once for all cells\n\t\tvar boundsWarning = false;\n\n\t\tfor (var i = 0; i < rank.length; i++)\n\t\t{\n\t\t\tvar node = rank[i];\n\n\t\t\tif (node.isVertex())\n\t\t\t{\n\t\t\t\tvar bounds = this.layout.getVertexBounds(node.cell);\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.width = bounds.width;\n\t\t\t\t\t\tnode.height = bounds.height;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.width = bounds.height;\n\t\t\t\t\t\tnode.height = bounds.width;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tboundsWarning = true;\n\t\t\t\t}\n\n\t\t\t\tmaxCellHeight = Math.max(maxCellHeight, node.height);\n\t\t\t}\n\t\t\telse if (node.isEdge())\n\t\t\t{\n\t\t\t\t// The width is the number of additional parallel edges\n\t\t\t\t// time the parallel edge spacing\n\t\t\t\tvar numEdges = 1;\n\n\t\t\t\tif (node.edges != null)\n\t\t\t\t{\n\t\t\t\t\tnumEdges = node.edges.length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmxLog.warn('edge.edges is null');\n\t\t\t\t}\n\n\t\t\t\tnode.width = (numEdges - 1) * this.parallelEdgeSpacing;\n\t\t\t}\n\n\t\t\t// Set the initial x-value as being the best result so far\n\t\t\tlocalX += node.width / 2.0;\n\t\t\tnode.setX(rankValue, localX);\n\t\t\tnode.setGeneralPurposeVariable(rankValue, localX);\n\t\t\tlocalX += node.width / 2.0;\n\t\t\tlocalX += this.intraCellSpacing;\n\n\t\t\tif (localX > this.widestRankValue)\n\t\t\t{\n\t\t\t\tthis.widestRankValue = localX;\n\t\t\t\tthis.widestRank = rankValue;\n\t\t\t}\n\n\t\t\tthis.rankWidths[rankValue] = localX;\n\t\t}\n\n\t\tif (boundsWarning == true)\n\t\t{\n\t\t\tmxLog.warn('At least one cell has no bounds');\n\t\t}\n\n\t\tthis.rankY[rankValue] = y;\n\t\tvar distanceToNextRank = maxCellHeight / 2.0\n\t\t\t\t+ lastRankMaxCellHeight / 2.0 + this.interRankCellSpacing;\n\t\tlastRankMaxCellHeight = maxCellHeight;\n\n\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\tthis.orientation == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\ty += distanceToNextRank;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty -= distanceToNextRank;\n\t\t}\n\n\t\tfor (var i = 0; i < rank.length; i++)\n\t\t{\n\t\t\tvar cell = rank[i];\n\t\t\tcell.setY(rankValue, y);\n\t\t}\n\t}\n};\n\n/**\n * Function: minPath\n *\n * Straightens out chains of virtual nodes where possibleacade to those stored after this layout\n * processing step has completed.\n *\n * Parameters:\n *\n * graph - the facade describing the input graph\n * model - an internal model of the hierarchical layout\n */\nmxCoordinateAssignment.prototype.minPath = function(graph, model)\n{\n\t// Work down and up each edge with at least 2 control points\n\t// trying to straighten each one out. If the same number of\n\t// straight segments are formed in both directions, the\n\t// preferred direction used is the one where the final\n\t// control points have the least offset from the connectable\n\t// region of the terminating vertices\n\tvar edges = model.edgeMapper.getValues();\n\n\tfor (var j = 0; j < edges.length; j++)\n\t{\n\t\tvar cell = edges[j];\n\n\t\tif (cell.maxRank - cell.minRank - 1 < 1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At least two virtual nodes in the edge\n\t\t// Check first whether the edge is already straight\n\t\tvar referenceX = cell\n\t\t\t\t.getGeneralPurposeVariable(cell.minRank + 1);\n\t\tvar edgeStraight = true;\n\t\tvar refSegCount = 0;\n\n\t\tfor (var i = cell.minRank + 2; i < cell.maxRank; i++)\n\t\t{\n\t\t\tvar x = cell.getGeneralPurposeVariable(i);\n\n\t\t\tif (referenceX != x)\n\t\t\t{\n\t\t\t\tedgeStraight = false;\n\t\t\t\treferenceX = x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trefSegCount++;\n\t\t\t}\n\t\t}\n\n\t\tif (!edgeStraight)\n\t\t{\n\t\t\tvar upSegCount = 0;\n\t\t\tvar downSegCount = 0;\n\t\t\tvar upXPositions = [];\n\t\t\tvar downXPositions = [];\n\n\t\t\tvar currentX = cell.getGeneralPurposeVariable(cell.minRank + 1);\n\n\t\t\tfor (var i = cell.minRank + 1; i < cell.maxRank - 1; i++)\n\t\t\t{\n\t\t\t\t// Attempt to straight out the control point on the\n\t\t\t\t// next segment up with the current control point.\n\t\t\t\tvar nextX = cell.getX(i + 1);\n\n\t\t\t\tif (currentX == nextX)\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = currentX;\n\t\t\t\t\tupSegCount++;\n\t\t\t\t}\n\t\t\t\telse if (this.repositionValid(model, cell, i + 1, currentX))\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = currentX;\n\t\t\t\t\tupSegCount++;\n\t\t\t\t\t// Leave currentX at same value\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tupXPositions[i - cell.minRank - 1] = nextX;\n\t\t\t\t\tcurrentX = nextX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentX = cell.getX(i);\n\n\t\t\tfor (var i = cell.maxRank - 1; i > cell.minRank + 1; i--)\n\t\t\t{\n\t\t\t\t// Attempt to straight out the control point on the\n\t\t\t\t// next segment down with the current control point.\n\t\t\t\tvar nextX = cell.getX(i - 1);\n\n\t\t\t\tif (currentX == nextX)\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = currentX;\n\t\t\t\t\tdownSegCount++;\n\t\t\t\t}\n\t\t\t\telse if (this.repositionValid(model, cell, i - 1, currentX))\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = currentX;\n\t\t\t\t\tdownSegCount++;\n\t\t\t\t\t// Leave currentX at same value\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdownXPositions[i - cell.minRank - 2] = cell.getX(i-1);\n\t\t\t\t\tcurrentX = nextX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (downSegCount > refSegCount || upSegCount > refSegCount)\n\t\t\t{\n\t\t\t\tif (downSegCount >= upSegCount)\n\t\t\t\t{\n\t\t\t\t\t// Apply down calculation values\n\t\t\t\t\tfor (var i = cell.maxRank - 2; i > cell.minRank; i--)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell.setX(i, downXPositions[i - cell.minRank - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (upSegCount > downSegCount)\n\t\t\t\t{\n\t\t\t\t\t// Apply up calculation values\n\t\t\t\t\tfor (var i = cell.minRank + 2; i < cell.maxRank; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell.setX(i, upXPositions[i - cell.minRank - 2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Neither direction provided a favourable result\n\t\t\t\t\t// But both calculations are better than the\n\t\t\t\t\t// existing solution, so apply the one with minimal\n\t\t\t\t\t// offset to attached vertices at either end.\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: repositionValid\n *\n * Determines whether or not a node may be moved to the specified x\n * position on the specified rank\n *\n * Parameters:\n *\n * model - the layout model\n * cell - the cell being analysed\n * rank - the layer of the cell\n * position - the x position being sought\n */\nmxCoordinateAssignment.prototype.repositionValid = function(model, cell, rank, position)\n{\n\tvar rankArray = model.ranks[rank];\n\tvar rankIndex = -1;\n\n\tfor (var i = 0; i < rankArray.length; i++)\n\t{\n\t\tif (cell == rankArray[i])\n\t\t{\n\t\t\trankIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (rankIndex < 0)\n\t{\n\t\treturn false;\n\t}\n\n\tvar currentX = cell.getGeneralPurposeVariable(rank);\n\n\tif (position < currentX)\n\t{\n\t\t// Trying to move node to the left.\n\t\tif (rankIndex == 0)\n\t\t{\n\t\t\t// Left-most node, can move anywhere\n\t\t\treturn true;\n\t\t}\n\n\t\tvar leftCell = rankArray[rankIndex - 1];\n\t\tvar leftLimit = leftCell.getGeneralPurposeVariable(rank);\n\t\tleftLimit = leftLimit + leftCell.width / 2\n\t\t\t\t+ this.intraCellSpacing + cell.width / 2;\n\n\t\tif (leftLimit <= position)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\telse if (position > currentX)\n\t{\n\t\t// Trying to move node to the right.\n\t\tif (rankIndex == rankArray.length - 1)\n\t\t{\n\t\t\t// Right-most node, can move anywhere\n\t\t\treturn true;\n\t\t}\n\n\t\tvar rightCell = rankArray[rankIndex + 1];\n\t\tvar rightLimit = rightCell.getGeneralPurposeVariable(rank);\n\t\trightLimit = rightLimit - rightCell.width / 2\n\t\t\t\t- this.intraCellSpacing - cell.width / 2;\n\n\t\tif (rightLimit >= position)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n\n/**\n * Function: setCellLocations\n *\n * Sets the cell locations in the facade to those stored after this layout\n * processing step has completed.\n *\n * Parameters:\n *\n * graph - the input graph\n * model - the layout model\n */\nmxCoordinateAssignment.prototype.setCellLocations = function(graph, model)\n{\n\tthis.rankTopY = [];\n\tthis.rankBottomY = [];\n\n\tfor (var i = 0; i < model.ranks.length; i++)\n\t{\n\t\tthis.rankTopY[i] = Number.MAX_VALUE;\n\t\tthis.rankBottomY[i] = -Number.MAX_VALUE;\n\t}\n\n\tvar vertices = model.vertexMapper.getValues();\n\n\t// Process vertices all first, since they define the lower and\n\t// limits of each rank. Between these limits lie the channels\n\t// where the edges can be routed across the graph\n\n\tfor (var i = 0; i < vertices.length; i++)\n\t{\n\t\tthis.setVertexLocation(vertices[i]);\n\t}\n\n\t// Post process edge styles. Needs the vertex locations set for initial\n\t// values of the top and bottoms of each rank\n\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.ORTHOGONAL\n\t\t\t|| this.layout.edgeStyle == mxHierarchicalEdgeStyle.POLYLINE\n\t\t\t|| this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t{\n\t\tthis.localEdgeProcessing(model);\n\t}\n\n\tvar edges = model.edgeMapper.getValues();\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tthis.setEdgePosition(edges[i]);\n\t}\n};\n\n/**\n * Function: localEdgeProcessing\n *\n * Separates the x position of edges as they connect to vertices\n *\n * Parameters:\n *\n * model - the layout model\n */\nmxCoordinateAssignment.prototype.localEdgeProcessing = function(model)\n{\n\t// Iterate through each vertex, look at the edges connected in\n\t// both directions.\n\tfor (var rankIndex = 0; rankIndex < model.ranks.length; rankIndex++)\n\t{\n\t\tvar rank = model.ranks[rankIndex];\n\n\t\tfor (var cellIndex = 0; cellIndex < rank.length; cellIndex++)\n\t\t{\n\t\t\tvar cell = rank[cellIndex];\n\n\t\t\tif (cell.isVertex())\n\t\t\t{\n\t\t\t\tvar currentCells = cell.getPreviousLayerConnectedCells(rankIndex);\n\n\t\t\t\tvar currentRank = rankIndex - 1;\n\n\t\t\t\t// Two loops, last connected cells, and next\n\t\t\t\tfor (var k = 0; k < 2; k++)\n\t\t\t\t{\n\t\t\t\t\tif (currentRank > -1\n\t\t\t\t\t\t\t&& currentRank < model.ranks.length\n\t\t\t\t\t\t\t&& currentCells != null\n\t\t\t\t\t\t\t&& currentCells.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar sortedCells = [];\n\n\t\t\t\t\t\tfor (var j = 0; j < currentCells.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar sorter = new WeightedCellSorter(\n\t\t\t\t\t\t\t\t\tcurrentCells[j], currentCells[j].getX(currentRank));\n\t\t\t\t\t\t\tsortedCells.push(sorter);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsortedCells.sort(WeightedCellSorter.prototype.compare);\n\n\t\t\t\t\t\tvar leftLimit = cell.x[0] - cell.width / 2;\n\t\t\t\t\t\tvar rightLimit = leftLimit + cell.width;\n\n\t\t\t\t\t\t// Connected edge count starts at 1 to allow for buffer\n\t\t\t\t\t\t// with edge of vertex\n\t\t\t\t\t\tvar connectedEdgeCount = 0;\n\t\t\t\t\t\tvar connectedEdgeGroupCount = 0;\n\t\t\t\t\t\tvar connectedEdges = [];\n\t\t\t\t\t\t// Calculate width requirements for all connected edges\n\t\t\t\t\t\tfor (var j = 0; j < sortedCells.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar innerCell = sortedCells[j].cell;\n\t\t\t\t\t\t\tvar connections;\n\n\t\t\t\t\t\t\tif (innerCell.isVertex())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Get the connecting edge\n\t\t\t\t\t\t\t\tif (k == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tconnections = cell.connectsAsSource;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tconnections = cell.connectsAsTarget;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (var connIndex = 0; connIndex < connections.length; connIndex++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (connections[connIndex].source == innerCell\n\t\t\t\t\t\t\t\t\t\t\t|| connections[connIndex].target == innerCell)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tconnectedEdgeCount += connections[connIndex].edges\n\t\t\t\t\t\t\t\t\t\t\t\t.length;\n\t\t\t\t\t\t\t\t\t\tconnectedEdgeGroupCount++;\n\n\t\t\t\t\t\t\t\t\t\tconnectedEdges.push(connections[connIndex]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconnectedEdgeCount += innerCell.edges.length;\n\t\t\t\t\t\t\t\tconnectedEdgeGroupCount++;\n\t\t\t\t\t\t\t\tconnectedEdges.push(innerCell);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar requiredWidth = (connectedEdgeCount + 1)\n\t\t\t\t\t\t\t\t* this.prefHozEdgeSep;\n\n\t\t\t\t\t\t// Add a buffer on the edges of the vertex if the edge count allows\n\t\t\t\t\t\tif (cell.width > requiredWidth\n\t\t\t\t\t\t\t\t+ (2 * this.prefHozEdgeSep))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tleftLimit += this.prefHozEdgeSep;\n\t\t\t\t\t\t\trightLimit -= this.prefHozEdgeSep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar availableWidth = rightLimit - leftLimit;\n\t\t\t\t\t\tvar edgeSpacing = availableWidth / connectedEdgeCount;\n\n\t\t\t\t\t\tvar currentX = leftLimit + edgeSpacing / 2.0;\n\t\t\t\t\t\tvar currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n\t\t\t\t\t\tvar maxYOffset = 0;\n\n\t\t\t\t\t\tfor (var j = 0; j < connectedEdges.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar numActualEdges = connectedEdges[j].edges\n\t\t\t\t\t\t\t\t\t.length;\n\t\t\t\t\t\t\tvar pos = this.jettyPositions[connectedEdges[j].ids[0]];\n\n\t\t\t\t\t\t\tif (pos == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpos = [];\n\t\t\t\t\t\t\t\tthis.jettyPositions[connectedEdges[j].ids[0]] = pos;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (j < connectedEdgeCount / 2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrentYOffset += this.prefVertEdgeOff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (j > connectedEdgeCount / 2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurrentYOffset -= this.prefVertEdgeOff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Ignore the case if equals, this means the second of 2\n\t\t\t\t\t\t\t// jettys with the same y (even number of edges)\n\n\t\t\t\t\t\t\tfor (var m = 0; m < numActualEdges; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpos[m * 4 + k * 2] = currentX;\n\t\t\t\t\t\t\t\tcurrentX += edgeSpacing;\n\t\t\t\t\t\t\t\tpos[m * 4 + k * 2 + 1] = currentYOffset;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaxYOffset = Math.max(maxYOffset,\n\t\t\t\t\t\t\t\t\tcurrentYOffset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentCells = cell.getNextLayerConnectedCells(rankIndex);\n\n\t\t\t\t\tcurrentRank = rankIndex + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: setEdgePosition\n *\n * Fixes the control points\n */\nmxCoordinateAssignment.prototype.setEdgePosition = function(cell)\n{\n\t// For parallel edges we need to seperate out the points a\n\t// little\n\tvar offsetX = 0;\n\t// Only set the edge control points once\n\n\tif (cell.temp[0] != 101207)\n\t{\n\t\tvar maxRank = cell.maxRank;\n\t\tvar minRank = cell.minRank;\n\n\t\tif (maxRank == minRank)\n\t\t{\n\t\t\tmaxRank = cell.source.maxRank;\n\t\t\tminRank = cell.target.minRank;\n\t\t}\n\n\t\tvar parallelEdgeCount = 0;\n\t\tvar jettys = this.jettyPositions[cell.ids[0]];\n\n\t\tvar source = cell.isReversed ? cell.target.cell : cell.source.cell;\n\t\tvar graph = this.layout.graph;\n\t\tvar layoutReversed = this.orientation == mxConstants.DIRECTION_EAST\n\t\t\t\t|| this.orientation == mxConstants.DIRECTION_SOUTH;\n\n\t\tfor (var i = 0; i < cell.edges.length; i++)\n\t\t{\n\t\t\tvar realEdge = cell.edges[i];\n\t\t\tvar realSource = this.layout.getVisibleTerminal(realEdge, true);\n\n\t\t\t//List oldPoints = graph.getPoints(realEdge);\n\t\t\tvar newPoints = [];\n\n\t\t\t// Single length reversed edges end up with the jettys in the wrong\n\t\t\t// places. Since single length edges only have jettys, not segment\n\t\t\t// control points, we just say the edge isn't reversed in this section\n\t\t\tvar reversed = cell.isReversed;\n\n\t\t\tif (realSource != source)\n\t\t\t{\n\t\t\t\t// The real edges include all core model edges and these can go\n\t\t\t\t// in both directions. If the source of the hierarchical model edge\n\t\t\t\t// isn't the source of the specific real edge in this iteration\n\t\t\t\t// treat if as reversed\n\t\t\t\treversed = !reversed;\n\t\t\t}\n\n\t\t\t// First jetty of edge\n\t\t\tif (jettys != null)\n\t\t\t{\n\t\t\t\tvar arrayOffset = reversed ? 2 : 0;\n\t\t\t\tvar y = reversed ?\n\t\t\t\t\t\t(layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]) :\n\t\t\t\t\t\t\t(layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]);\n\t\t\t\tvar jetty = jettys[parallelEdgeCount * 4 + 1 + arrayOffset];\n\n\t\t\t\tif (reversed != layoutReversed)\n\t\t\t\t{\n\t\t\t\t\tjetty = -jetty;\n\t\t\t\t}\n\n\t\t\t\ty += jetty;\n\t\t\t\tvar x = jettys[parallelEdgeCount * 4 + arrayOffset];\n\n\t\t\t\tvar modelSource = graph.model.getTerminal(realEdge, true);\n\n\t\t\t\tif (this.layout.isPort(modelSource) && graph.model.getParent(modelSource) == realSource)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.view.getState(modelSource);\n\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = state.x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = realSource.geometry.x + cell.source.width * modelSource.geometry.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH\n\t\t\t\t\t\t|| this.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(x, y + jetty));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(y, x));\n\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(y + jetty, x));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Declare variables to define loop through edge points and\n\t\t\t// change direction if edge is reversed\n\n\t\t\tvar loopStart = cell.x.length - 1;\n\t\t\tvar loopLimit = -1;\n\t\t\tvar loopDelta = -1;\n\t\t\tvar currentRank = cell.maxRank - 1;\n\n\t\t\tif (reversed)\n\t\t\t{\n\t\t\t\tloopStart = 0;\n\t\t\t\tloopLimit = cell.x.length;\n\t\t\t\tloopDelta = 1;\n\t\t\t\tcurrentRank = cell.minRank + 1;\n\t\t\t}\n\t\t\t// Reversed edges need the points inserted in\n\t\t\t// reverse order\n\t\t\tfor (var j = loopStart; (cell.maxRank != cell.minRank) && j != loopLimit; j += loopDelta)\n\t\t\t{\n\t\t\t\t// The horizontal position in a vertical layout\n\t\t\t\tvar positionX = cell.x[j] + offsetX;\n\n\t\t\t\t// Work out the vertical positions in a vertical layout\n\t\t\t\t// in the edge buffer channels above and below this rank\n\t\t\t\tvar topChannelY = (this.rankTopY[currentRank] + this.rankBottomY[currentRank + 1]) / 2.0;\n\t\t\t\tvar bottomChannelY = (this.rankTopY[currentRank - 1] + this.rankBottomY[currentRank]) / 2.0;\n\n\t\t\t\tif (reversed)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = topChannelY;\n\t\t\t\t\ttopChannelY = bottomChannelY;\n\t\t\t\t\tbottomChannelY = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(positionX, topChannelY));\n\t\t\t\t\tnewPoints.push(new mxPoint(positionX, bottomChannelY));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewPoints.push(new mxPoint(topChannelY, positionX));\n\t\t\t\t\tnewPoints.push(new mxPoint(bottomChannelY, positionX));\n\t\t\t\t}\n\n\t\t\t\tthis.limitX = Math.max(this.limitX, positionX);\n\t\t\t\tcurrentRank += loopDelta;\n\t\t\t}\n\n\t\t\t// Second jetty of edge\n\t\t\tif (jettys != null)\n\t\t\t{\n\t\t\t\tvar arrayOffset = reversed ? 2 : 0;\n\t\t\t\tvar rankY = reversed ?\n\t\t\t\t\t\t(layoutReversed ? this.rankTopY[maxRank] : this.rankBottomY[maxRank]) :\n\t\t\t\t\t\t\t(layoutReversed ? this.rankBottomY[minRank] : this.rankTopY[minRank]);\n\t\t\t\tvar jetty = jettys[parallelEdgeCount * 4 + 3 - arrayOffset];\n\n\t\t\t\tif (reversed != layoutReversed)\n\t\t\t\t{\n\t\t\t\t\tjetty = -jetty;\n\t\t\t\t}\n\t\t\t\tvar y = rankY - jetty;\n\t\t\t\tvar x = jettys[parallelEdgeCount * 4 + 2 - arrayOffset];\n\n\t\t\t\tvar modelTarget = graph.model.getTerminal(realEdge, false);\n\t\t\t\tvar realTarget = this.layout.getVisibleTerminal(realEdge, false);\n\n\t\t\t\tif (this.layout.isPort(modelTarget) && graph.model.getParent(modelTarget) == realTarget)\n\t\t\t\t{\n\t\t\t\t\tvar state = graph.view.getState(modelTarget);\n\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = state.x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = realTarget.geometry.x + cell.target.width * modelTarget.geometry.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\t\t\t\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(x, y - jetty));\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoints.push(new mxPoint(x, y));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (this.layout.edgeStyle == mxHierarchicalEdgeStyle.CURVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewPoints.push(new mxPoint(y - jetty, x));\n\t\t\t\t\t}\n\n\t\t\t\t\tnewPoints.push(new mxPoint(y, x));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cell.isReversed)\n\t\t\t{\n\t\t\t\tthis.processReversedEdge(cell, realEdge);\n\t\t\t}\n\n\t\t\tthis.layout.setEdgePoints(realEdge, newPoints);\n\n\t\t\t// Increase offset so next edge is drawn next to\n\t\t\t// this one\n\t\t\tif (offsetX == 0.0)\n\t\t\t{\n\t\t\t\toffsetX = this.parallelEdgeSpacing;\n\t\t\t}\n\t\t\telse if (offsetX > 0)\n\t\t\t{\n\t\t\t\toffsetX = -offsetX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toffsetX = -offsetX + this.parallelEdgeSpacing;\n\t\t\t}\n\n\t\t\tparallelEdgeCount++;\n\t\t}\n\n\t\tcell.temp[0] = 101207;\n\t}\n};\n\n\n/**\n * Function: setVertexLocation\n *\n * Fixes the position of the specified vertex.\n *\n * Parameters:\n *\n * cell - the vertex to position\n */\nmxCoordinateAssignment.prototype.setVertexLocation = function(cell)\n{\n\tvar realCell = cell.cell;\n\tvar positionX = cell.x[0] - cell.width / 2;\n\tvar positionY = cell.y[0] - cell.height / 2;\n\n\tthis.rankTopY[cell.minRank] = Math.min(this.rankTopY[cell.minRank], positionY);\n\tthis.rankBottomY[cell.minRank] = Math.max(this.rankBottomY[cell.minRank],\n\t\t\tpositionY + cell.height);\n\n\tif (this.orientation == mxConstants.DIRECTION_NORTH ||\n\t\tthis.orientation == mxConstants.DIRECTION_SOUTH)\n\t{\n\t\tthis.layout.setVertexLocation(realCell, positionX, positionY);\n\t}\n\telse\n\t{\n\t\tthis.layout.setVertexLocation(realCell, positionY, positionX);\n\t}\n\n\tthis.limitX = Math.max(this.limitX, positionX + cell.width);\n};\n\n/**\n * Function: processReversedEdge\n *\n * Hook to add additional processing\n *\n * Parameters:\n *\n * edge - the hierarchical model edge\n * realEdge - the real edge in the graph\n */\nmxCoordinateAssignment.prototype.processReversedEdge = function(graph, model)\n{\n\t// hook for subclassers\n};\n\n__mxOutput.mxCoordinateAssignment = typeof mxCoordinateAssignment !== 'undefined' ? mxCoordinateAssignment : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneOrdering\n *\n * An implementation of the first stage of the Sugiyama layout. Straightforward\n * longest path calculation of layer assignment\n *\n * Constructor: mxSwimlaneOrdering\n *\n * Creates a cycle remover for the given internal model.\n */\nfunction mxSwimlaneOrdering(layout)\n{\n\tthis.layout = layout;\n};\n\n/**\n * Extends mxHierarchicalLayoutStage.\n */\nmxSwimlaneOrdering.prototype = new mxHierarchicalLayoutStage();\nmxSwimlaneOrdering.prototype.constructor = mxSwimlaneOrdering;\n\n/**\n * Variable: layout\n *\n * Reference to the enclosing <mxHierarchicalLayout>.\n */\nmxSwimlaneOrdering.prototype.layout = null;\n\n/**\n * Function: execute\n *\n * Takes the graph detail and configuration information within the facade\n * and creates the resulting laid out graph within that facade for further\n * use.\n */\nmxSwimlaneOrdering.prototype.execute = function(parent)\n{\n\tvar model = this.layout.getModel();\n\tvar seenNodes = new Object();\n\tvar unseenNodes = mxUtils.clone(model.vertexMapper, null, true);\n\n\t// Perform a dfs through the internal model. If a cycle is found,\n\t// reverse it.\n\tvar rootsArray = null;\n\n\tif (model.roots != null)\n\t{\n\t\tvar modelRoots = model.roots;\n\t\trootsArray = [];\n\n\t\tfor (var i = 0; i < modelRoots.length; i++)\n\t\t{\n\t\t\tvar nodeId = mxCellPath.create(modelRoots[i]);\n\t\t\trootsArray[i] = model.vertexMapper.get(modelRoots[i]);\n\t\t}\n\t}\n\n\tmodel.visit(function(parent, node, connectingEdge, layer, seen)\n\t{\n\t\t// Check if the cell is in it's own ancestor list, if so\n\t\t// invert the connecting edge and reverse the target/source\n\t\t// relationship to that edge in the parent and the cell\n\t\t// Ancestor hashes only line up within a swimlane\n\t\tvar isAncestor = parent != null && parent.swimlaneIndex == node.swimlaneIndex && node.isAncestor(parent);\n\n\t\t// If the source->target swimlane indices go from higher to\n\t\t// lower, the edge is reverse\n\t\tvar reversedOverSwimlane = parent != null && connectingEdge != null &&\n\t\t\t\t\t\tparent.swimlaneIndex < node.swimlaneIndex && connectingEdge.source == node;\n\n\t\tif (isAncestor)\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsSource);\n\t\t\tnode.connectsAsSource.push(connectingEdge);\n\t\t\tparent.connectsAsTarget.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsTarget);\n\t\t}\n\t\telse if (reversedOverSwimlane)\n\t\t{\n\t\t\tconnectingEdge.invert();\n\t\t\tmxUtils.remove(connectingEdge, parent.connectsAsTarget);\n\t\t\tnode.connectsAsTarget.push(connectingEdge);\n\t\t\tparent.connectsAsSource.push(connectingEdge);\n\t\t\tmxUtils.remove(connectingEdge, node.connectsAsSource);\n\t\t}\n\n\t\tvar cellId = mxCellPath.create(node.cell);\n\t\tseenNodes[cellId] = node;\n\t\tdelete unseenNodes[cellId];\n\t}, rootsArray, true, null);\n};\n\n__mxOutput.mxSwimlaneOrdering = typeof mxSwimlaneOrdering !== 'undefined' ? mxSwimlaneOrdering : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxHierarchicalLayout\n *\n * A hierarchical layout algorithm.\n *\n * Constructor: mxHierarchicalLayout\n *\n * Constructs a new hierarchical layout algorithm.\n *\n * Arguments:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * orientation - Optional constant that defines the orientation of this\n * layout.\n * deterministic - Optional boolean that specifies if this layout should be\n * deterministic. Default is true.\n */\nfunction mxHierarchicalLayout(graph, orientation, deterministic)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.orientation = (orientation != null) ? orientation : mxConstants.DIRECTION_NORTH;\n\tthis.deterministic = (deterministic != null) ? deterministic : true;\n};\n\nvar mxHierarchicalEdgeStyle =\n{\n\tORTHOGONAL: 1,\n\tPOLYLINE: 2,\n\tSTRAIGHT: 3,\n\tCURVE: 4\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxHierarchicalLayout.prototype = new mxGraphLayout();\nmxHierarchicalLayout.prototype.constructor = mxHierarchicalLayout;\n\n/**\n * Variable: roots\n *\n * Holds the array of <mxCell> that this layout contains.\n */\nmxHierarchicalLayout.prototype.roots = null;\n\n/**\n * Variable: resizeParent\n *\n * Specifies if the parent should be resized after the layout so that it\n * contains all the child cells. Default is false. See also <parentBorder>.\n */\nmxHierarchicalLayout.prototype.resizeParent = false;\n\n/**\n * Variable: maintainParentLocation\n *\n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxHierarchicalLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: moveParent\n *\n * Specifies if the parent should be moved if <resizeParent> is enabled.\n * Default is false.\n */\nmxHierarchicalLayout.prototype.moveParent = false;\n\n/**\n * Variable: parentBorder\n *\n * The border to be added around the children if the parent is to be\n * resized using <resizeParent>. Default is 0.\n */\nmxHierarchicalLayout.prototype.parentBorder = 0;\n\n/**\n * Variable: intraCellSpacing\n *\n * The spacing buffer added between cells on the same layer. Default is 30.\n */\nmxHierarchicalLayout.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n *\n * The spacing buffer added between cell on adjacent layers. Default is 50.\n */\nmxHierarchicalLayout.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: interHierarchySpacing\n *\n * The spacing buffer between unconnected hierarchies. Default is 60.\n */\nmxHierarchicalLayout.prototype.interHierarchySpacing = 60;\n\n/**\n * Variable: parallelEdgeSpacing\n *\n * The distance between each parallel edge on each ranks for long edges\n */\nmxHierarchicalLayout.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: orientation\n *\n * The position of the root node(s) relative to the laid out graph in.\n * Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxHierarchicalLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: fineTuning\n *\n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxHierarchicalLayout.prototype.fineTuning = true;\n\n/**\n *\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxHierarchicalLayout.prototype.tightenToSource = true;\n\n/**\n * Variable: disableEdgeStyle\n *\n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxHierarchicalLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: traverseAncestors\n *\n * Whether or not to drill into child cells and layout in reverse\n * group order. This also cause the layout to navigate edges whose\n * terminal vertices have different parents but are in the same\n * ancestry chain\n */\nmxHierarchicalLayout.prototype.traverseAncestors = true;\n\n/**\n * Variable: model\n *\n * The internal <mxGraphHierarchyModel> formed of the layout.\n */\nmxHierarchicalLayout.prototype.model = null;\n\n/**\n * Variable: edgesSet\n *\n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesCache = null;\n\n/**\n * Variable: edgesSet\n *\n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgeSourceTermCache = null;\n\n/**\n * Variable: edgesSet\n *\n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesTargetTermCache = null;\n\n/**\n * Variable: edgeStyle\n *\n * The style to apply between cell layers to edge segments\n */\nmxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;\n\n/**\n * Function: getModel\n *\n * Returns the internal <mxGraphHierarchyModel> for this layout algorithm.\n */\nmxHierarchicalLayout.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: execute\n *\n * Executes the layout for the children of the specified parent.\n *\n * Parameters:\n *\n * parent - Parent <mxCell> that contains the children to be laid out.\n * roots - Optional starting roots of the layout.\n */\nmxHierarchicalLayout.prototype.execute = function(parent, roots)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.model;\n\tthis.edgesCache = new mxDictionary();\n\tthis.edgeSourceTermCache = new mxDictionary();\n\tthis.edgesTargetTermCache = new mxDictionary();\n\n\tif (roots != null && !(roots instanceof Array))\n\t{\n\t\troots = [roots];\n\t}\n\n\t// If the roots are set and the parent is set, only\n\t// use the roots that are some dependent of the that\n\t// parent.\n\t// If just the root are set, use them as-is\n\t// If just the parent is set use it's immediate\n\t// children as the initial set\n\n\tif (roots == null && parent == null)\n\t{\n\t\t// TODO indicate the problem\n\t\treturn;\n\t}\n\n\t//  Maintaining parent location\n\tthis.parentX = null;\n\tthis.parentY = null;\n\n\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(parent);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tthis.parentX = geo.x;\n\t\t\tthis.parentY = geo.y;\n\t\t}\n\t}\n\n\tif (roots != null)\n\t{\n\t\tvar rootsCopy = [];\n\n\t\tfor (var i = 0; i < roots.length; i++)\n\t\t{\n\t\t\tvar ancestor = parent != null ? model.isAncestor(parent, roots[i]) : true;\n\n\t\t\tif (ancestor && model.isVertex(roots[i]))\n\t\t\t{\n\t\t\t\trootsCopy.push(roots[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.roots = rootsCopy;\n\t}\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tthis.run(parent);\n\n\t\tif (this.resizeParent && !this.graph.isCellCollapsed(parent))\n\t\t{\n\t\t\tthis.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n\t\t}\n\n\t\t// Maintaining parent location\n\t\tif (this.parentX != null && this.parentY != null)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.x = this.parentX;\n\t\t\t\tgeo.y = this.parentY;\n\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: findRoots\n *\n * Returns all visible children in the given parent which do not have\n * incoming edges. If the result is empty then the children with the\n * maximum difference between incoming and outgoing edges are returned.\n * This takes into account edges that are being promoted to the given\n * root due to invisible children or collapsed cells.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be checked.\n * vertices - array of vertices to limit search to\n */\nmxHierarchicalLayout.prototype.findRoots = function(parent, vertices)\n{\n\tvar roots = [];\n\n\tif (parent != null && vertices != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar best = null;\n\t\tvar maxDiff = -100000;\n\n\t\tfor (var i in vertices)\n\t\t{\n\t\t\tvar cell = vertices[i];\n\n\t\t\tif (model.isVertex(cell) && this.graph.isCellVisible(cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getEdges(cell);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\n\t\t\t\tfor (var k = 0; k < conns.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.getVisibleTerminal(conns[k], true);\n\n\t\t\t\t\tif (src == cell)\n\t\t\t\t\t{\n\t\t\t\t\t\tfanOut++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfanIn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fanIn == 0 && fanOut > 0)\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\n\t\t\t\tvar diff = fanOut - fanIn;\n\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\n\treturn roots;\n};\n\n/**\n * Function: getEdges\n *\n * Returns the connected edges for the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose edges should be returned.\n */\nmxHierarchicalLayout.prototype.getEdges = function(cell)\n{\n\tvar cachedEdges = this.edgesCache.get(cell);\n\n\tif (cachedEdges != null)\n\t{\n\t\treturn cachedEdges;\n\t}\n\n\tvar model = this.graph.model;\n\tvar edges = [];\n\tvar isCollapsed = this.graph.isCellCollapsed(cell);\n\tvar childCount = model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\n\t\tif (this.isPort(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t\telse if (isCollapsed || !this.graph.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t}\n\n\tedges = edges.concat(model.getEdges(cell, true, true));\n\tvar result = [];\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar source = this.getVisibleTerminal(edges[i], true);\n\t\tvar target = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((source == target) ||\n\t\t\t\t((source != target) &&\n\t\t\t\t\t\t((target == cell && (this.parent == null || this.isAncestor(this.parent, source, this.traverseAncestors))) ||\n\t\t\t\t\t\t \t(source == cell && (this.parent == null || this.isAncestor(this.parent, target, this.traverseAncestors))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\tthis.edgesCache.put(cell, result);\n\n\treturn result;\n};\n\n/**\n * Function: getVisibleTerminal\n *\n * Helper function to return visible terminal for edge allowing for ports\n *\n * Parameters:\n *\n * edge - <mxCell> whose edges should be returned.\n * source - Boolean that specifies whether the source or target terminal is to be returned\n */\nmxHierarchicalLayout.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar terminalCache = this.edgesTargetTermCache;\n\n\tif (source)\n\t{\n\t\tterminalCache = this.edgeSourceTermCache;\n\t}\n\n\tvar term = terminalCache.get(edge);\n\n\tif (term != null)\n\t{\n\t\treturn term;\n\t}\n\n\tvar state = this.graph.view.getState(edge);\n\n\tvar terminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\n\tif (terminal == null)\n\t{\n\t\tterminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t}\n\n\tif (terminal != null)\n\t{\n\t\tif (this.isPort(terminal))\n\t\t{\n\t\t\tterminal = this.graph.model.getParent(terminal);\n\t\t}\n\n\t\tterminalCache.put(edge, terminal);\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: run\n *\n * The API method used to exercise the layout upon the graph description\n * and produce a separate description of the vertex position and edge\n * routing changes made. It runs each stage of the layout that has been\n * created.\n */\nmxHierarchicalLayout.prototype.run = function(parent)\n{\n\t// Separate out unconnected hierarchies\n\tvar hierarchyVertices = [];\n\tvar allVertexSet = [];\n\n\tif (this.roots == null && parent != null)\n\t{\n\t\tvar filledVertexSet = Object();\n\t\tthis.filterDescendants(parent, filledVertexSet);\n\n\t\tthis.roots = [];\n\t\tvar filledVertexSetEmpty = true;\n\n\t\t// Poor man's isSetEmpty\n\t\tfor (var key in filledVertexSet)\n\t\t{\n\t\t\tif (filledVertexSet[key] != null)\n\t\t\t{\n\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (!filledVertexSetEmpty)\n\t\t{\n\t\t\tvar candidateRoots = this.findRoots(parent, filledVertexSet);\n\n\t\t\t// If the candidate root is an unconnected group cell, remove it from\n\t\t\t// the layout. We may need a custom set that holds such groups and forces\n\t\t\t// them to be processed for resizing and/or moving.\n\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tvar vertexSet = Object();\n\t\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\t\tthis.traverse(candidateRoots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\t\thierarchyVertices, filledVertexSet);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tthis.roots.push(candidateRoots[i]);\n\t\t\t}\n\n\t\t\tfilledVertexSetEmpty = true;\n\n\t\t\t// Poor man's isSetEmpty\n\t\t\tfor (var key in filledVertexSet)\n\t\t\t{\n\t\t\t\tif (filledVertexSet[key] != null)\n\t\t\t\t{\n\t\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Find vertex set as directed traversal from roots\n\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar vertexSet = Object();\n\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\tthis.traverse(this.roots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\thierarchyVertices, null);\n\t\t}\n\t}\n\n\t// Iterate through the result removing parents who have children in this layout\n\n\t// Perform a layout for each seperate hierarchy\n\t// Track initial coordinate x-positioning\n\tvar initialX = 0;\n\n\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t{\n\t\tvar vertexSet = hierarchyVertices[i];\n\t\tvar tmp = [];\n\n\t\tfor (var key in vertexSet)\n\t\t{\n\t\t\ttmp.push(vertexSet[key]);\n\t\t}\n\n\t\tthis.model = new mxGraphHierarchyModel(this, tmp, this.roots,\n\t\t\tparent, this.tightenToSource);\n\n\t\tthis.cycleStage(parent);\n\t\tthis.layeringStage();\n\n\t\tthis.crossingStage(parent);\n\t\tinitialX = this.placementStage(initialX, parent);\n\t}\n};\n\n/**\n * Function: filterDescendants\n *\n * Creates an array of descendant cells\n */\nmxHierarchicalLayout.prototype.filterDescendants = function(cell, result)\n{\n\tvar model = this.graph.model;\n\n\tif (model.isVertex(cell) && cell != this.parent && this.graph.isCellVisible(cell))\n\t{\n\t\tresult[mxObjectIdentity.get(cell)] = cell;\n\t}\n\n\tif (this.traverseAncestors || cell == this.parent\n\t\t\t&& this.graph.isCellVisible(cell))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(cell, i);\n\n\t\t\t// Ignore ports in the layout vertex list, they are dealt with\n\t\t\t// in the traversal mechanisms\n\t\t\tif (!this.isPort(child))\n\t\t\t{\n\t\t\t\tthis.filterDescendants(child, result);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isPort\n *\n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, its parent is the connecting vertex in terms of graph traversal\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the port.\n */\nmxHierarchicalLayout.prototype.isPort = function(cell)\n{\n\tif (cell != null && cell.geometry != null)\n\t{\n\t\treturn cell.geometry.relative;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n};\n\n/**\n * Function: getEdgesBetween\n *\n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and ports.\n *\n * Parameters:\n *\n * source -\n * target -\n * directed -\n */\nmxHierarchicalLayout.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar src = this.getVisibleTerminal(edges[i], true);\n\t\tvar trg = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n *\n * Parameters:\n *\n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * allVertices - Array of cell paths for the visited cells.\n */\nmxHierarchicalLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp,\n\t\t\t\t\t\t\t\t\t\t\thierarchyVertices, filledVertexSet)\n{\n\tif (vertex != null && allVertices != null)\n\t{\n\t\t// Has this vertex been seen before in any traversal\n\t\t// And if the filled vertex set is populated, only\n\t\t// process vertices in that it contains\n\t\tvar vertexID = mxObjectIdentity.get(vertex);\n\n\t\tif ((allVertices[vertexID] == null)\n\t\t\t\t&& (filledVertexSet == null ? true : filledVertexSet[vertexID] != null))\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\tcurrentComp[vertexID] = vertex;\n\t\t\t}\n\t\t\tif (allVertices[vertexID] == null)\n\t\t\t{\n\t\t\t\tallVertices[vertexID] = vertex;\n\t\t\t}\n\n\t\t\tif (filledVertexSet !== null)\n\t\t\t{\n\t\t\t\tdelete filledVertexSet[vertexID];\n\t\t\t}\n\n\t\t\tvar edges = this.getEdges(vertex);\n\t\t\tvar edgeIsSource = [];\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tedgeIsSource[i] = (this.getVisibleTerminal(edges[i], true) == vertex);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tif (!directed || edgeIsSource[i])\n\t\t\t\t{\n\t\t\t\t\tvar next = this.getVisibleTerminal(edges[i], !edgeIsSource[i]);\n\n\t\t\t\t\t// Check whether there are more edges incoming from the target vertex than outgoing\n\t\t\t\t\t// The hierarchical model treats bi-directional parallel edges as being sourced\n\t\t\t\t\t// from the more \"sourced\" terminal. If the directions are equal in number, the direction\n\t\t\t\t\t// is that of the natural direction from the roots of the layout.\n\t\t\t\t\t// The checks below are slightly more verbose than need be for performance reasons\n\t\t\t\t\tvar netCount = 1;\n\n\t\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (j == i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar isSource2 = edgeIsSource[j];\n\t\t\t\t\t\t\tvar otherTerm = this.getVisibleTerminal(edges[j], !isSource2);\n\n\t\t\t\t\t\t\tif (otherTerm == next)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (isSource2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnetCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnetCount--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (netCount >= 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentComp = this.traverse(next, directed, edges[i], allVertices,\n\t\t\t\t\t\t\tcurrentComp, hierarchyVertices,\n\t\t\t\t\t\t\tfilledVertexSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\t// We've seen this vertex before, but not in the current component\n\t\t\t\t// This component and the one it's in need to be merged\n\n\t\t\t\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar comp = hierarchyVertices[i];\n\n\t\t\t\t\tif (comp[vertexID] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var key in comp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentComp[key] = comp[key];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove the current component from the hierarchy set\n\t\t\t\t\t\thierarchyVertices.splice(i, 1);\n\t\t\t\t\t\treturn currentComp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentComp;\n};\n\n/**\n * Function: cycleStage\n *\n * Executes the cycle stage using mxMinimumCycleRemover.\n */\nmxHierarchicalLayout.prototype.cycleStage = function(parent)\n{\n\tvar cycleStage = new mxMinimumCycleRemover(this);\n\tcycleStage.execute(parent);\n};\n\n/**\n * Function: layeringStage\n *\n * Implements first stage of a Sugiyama layout.\n */\nmxHierarchicalLayout.prototype.layeringStage = function()\n{\n\tthis.model.initialRank();\n\tthis.model.fixRanks();\n};\n\n/**\n * Function: crossingStage\n *\n * Executes the crossing stage using mxMedianHybridCrossingReduction.\n */\nmxHierarchicalLayout.prototype.crossingStage = function(parent)\n{\n\tvar crossingStage = new mxMedianHybridCrossingReduction(this);\n\tcrossingStage.execute(parent);\n};\n\n/**\n * Function: placementStage\n *\n * Executes the placement stage using mxCoordinateAssignment.\n */\nmxHierarchicalLayout.prototype.placementStage = function(initialX, parent)\n{\n\tvar placementStage = new mxCoordinateAssignment(this, this.intraCellSpacing,\n\t\t\tthis.interRankCellSpacing, this.orientation, initialX,\n\t\t\tthis.parallelEdgeSpacing);\n\tplacementStage.fineTuning = this.fineTuning;\n\tplacementStage.execute(parent);\n\n\treturn placementStage.limitX + this.interHierarchySpacing;\n};\n\n__mxOutput.mxHierarchicalLayout = typeof mxHierarchicalLayout !== 'undefined' ? mxHierarchicalLayout : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneLayout\n *\n * A hierarchical layout algorithm.\n *\n * Constructor: mxSwimlaneLayout\n *\n * Constructs a new hierarchical layout algorithm.\n *\n * Arguments:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * orientation - Optional constant that defines the orientation of this\n * layout.\n * deterministic - Optional boolean that specifies if this layout should be\n * deterministic. Default is true.\n */\nfunction mxSwimlaneLayout(graph, orientation, deterministic)\n{\n\tmxGraphLayout.call(this, graph);\n\tthis.orientation = (orientation != null) ? orientation : mxConstants.DIRECTION_NORTH;\n\tthis.deterministic = (deterministic != null) ? deterministic : true;\n};\n\n/**\n * Extends mxGraphLayout.\n */\nmxSwimlaneLayout.prototype = new mxGraphLayout();\nmxSwimlaneLayout.prototype.constructor = mxSwimlaneLayout;\n\n/**\n * Variable: roots\n *\n * Holds the array of <mxCell> that this layout contains.\n */\nmxSwimlaneLayout.prototype.roots = null;\n\n/**\n * Variable: swimlanes\n *\n * Holds the array of <mxCell> of the ordered swimlanes to lay out\n */\nmxSwimlaneLayout.prototype.swimlanes = null;\n\n/**\n * Variable: dummyVertices\n *\n * Holds an array of <mxCell> of dummy vertices inserted during the layout\n * to pad out empty swimlanes\n */\nmxSwimlaneLayout.prototype.dummyVertices = null;\n\n/**\n * Variable: dummyVertexWidth\n *\n * The cell width of any dummy vertices inserted\n */\nmxSwimlaneLayout.prototype.dummyVertexWidth = 50;\n\n/**\n * Variable: resizeParent\n *\n * Specifies if the parent should be resized after the layout so that it\n * contains all the child cells. Default is false. See also <parentBorder>.\n */\nmxSwimlaneLayout.prototype.resizeParent = false;\n\n/**\n * Variable: maintainParentLocation\n *\n * Specifies if the parent location should be maintained, so that the\n * top, left corner stays the same before and after execution of\n * the layout. Default is false for backwards compatibility.\n */\nmxSwimlaneLayout.prototype.maintainParentLocation = false;\n\n/**\n * Variable: moveParent\n *\n * Specifies if the parent should be moved if <resizeParent> is enabled.\n * Default is false.\n */\nmxSwimlaneLayout.prototype.moveParent = false;\n\n/**\n * Variable: parentBorder\n *\n * The border to be added around the children if the parent is to be\n * resized using <resizeParent>. Default is 0.\n */\nmxSwimlaneLayout.prototype.parentBorder = 30;\n\n/**\n * Variable: intraCellSpacing\n *\n * The spacing buffer added between cells on the same layer. Default is 30.\n */\nmxSwimlaneLayout.prototype.intraCellSpacing = 30;\n\n/**\n * Variable: interRankCellSpacing\n *\n * The spacing buffer added between cell on adjacent layers. Default is 50.\n */\nmxSwimlaneLayout.prototype.interRankCellSpacing = 100;\n\n/**\n * Variable: interHierarchySpacing\n *\n * The spacing buffer between unconnected hierarchies. Default is 60.\n */\nmxSwimlaneLayout.prototype.interHierarchySpacing = 60;\n\n/**\n * Variable: parallelEdgeSpacing\n *\n * The distance between each parallel edge on each ranks for long edges\n */\nmxSwimlaneLayout.prototype.parallelEdgeSpacing = 10;\n\n/**\n * Variable: orientation\n *\n * The position of the root node(s) relative to the laid out graph in.\n * Default is <mxConstants.DIRECTION_NORTH>.\n */\nmxSwimlaneLayout.prototype.orientation = mxConstants.DIRECTION_NORTH;\n\n/**\n * Variable: fineTuning\n *\n * Whether or not to perform local optimisations and iterate multiple times\n * through the algorithm. Default is true.\n */\nmxSwimlaneLayout.prototype.fineTuning = true;\n\n/**\n *\n * Variable: tightenToSource\n *\n * Whether or not to tighten the assigned ranks of vertices up towards\n * the source cells.\n */\nmxSwimlaneLayout.prototype.tightenToSource = true;\n\n/**\n * Variable: disableEdgeStyle\n *\n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\n * modified by the result. Default is true.\n */\nmxSwimlaneLayout.prototype.disableEdgeStyle = true;\n\n/**\n * Variable: traverseAncestors\n *\n * Whether or not to drill into child cells and layout in reverse\n * group order. This also cause the layout to navigate edges whose\n * terminal vertices  * have different parents but are in the same\n * ancestry chain\n */\nmxSwimlaneLayout.prototype.traverseAncestors = true;\n\n/**\n * Variable: model\n *\n * The internal <mxSwimlaneModel> formed of the layout.\n */\nmxSwimlaneLayout.prototype.model = null;\n\n/**\n * Variable: edgesSet\n *\n * A cache of edges whose source terminal is the key\n */\nmxSwimlaneLayout.prototype.edgesCache = null;\n\n/**\n * Variable: edgesSet\n *\n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgeSourceTermCache = null;\n\n/**\n * Variable: edgesSet\n *\n * A cache of edges whose source terminal is the key\n */\nmxHierarchicalLayout.prototype.edgesTargetTermCache = null;\n\n/**\n * Variable: edgeStyle\n *\n * The style to apply between cell layers to edge segments\n */\nmxHierarchicalLayout.prototype.edgeStyle = mxHierarchicalEdgeStyle.POLYLINE;\n\n/**\n * Function: getModel\n *\n * Returns the internal <mxSwimlaneModel> for this layout algorithm.\n */\nmxSwimlaneLayout.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: execute\n *\n * Executes the layout for the children of the specified parent.\n *\n * Parameters:\n *\n * parent - Parent <mxCell> that contains the children to be laid out.\n * swimlanes - Ordered array of swimlanes to be laid out\n */\nmxSwimlaneLayout.prototype.execute = function(parent, swimlanes)\n{\n\tthis.parent = parent;\n\tvar model = this.graph.model;\n\tthis.edgesCache = new mxDictionary();\n\tthis.edgeSourceTermCache = new mxDictionary();\n\tthis.edgesTargetTermCache = new mxDictionary();\n\n\t// If the roots are set and the parent is set, only\n\t// use the roots that are some dependent of the that\n\t// parent.\n\t// If just the root are set, use them as-is\n\t// If just the parent is set use it's immediate\n\t// children as the initial set\n\n\tif (swimlanes == null || swimlanes.length < 1)\n\t{\n\t\t// TODO indicate the problem\n\t\treturn;\n\t}\n\n\tif (parent == null)\n\t{\n\t\tparent = model.getParent(swimlanes[0]);\n\t}\n\n\t//  Maintaining parent location\n\tthis.parentX = null;\n\tthis.parentY = null;\n\n\tif (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(parent);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tthis.parentX = geo.x;\n\t\t\tthis.parentY = geo.y;\n\t\t}\n\t}\n\n\tthis.swimlanes = swimlanes;\n\tthis.dummyVertices = [];\n\t// Check the swimlanes all have vertices\n\t// in them\n\tfor (var i = 0; i < swimlanes.length; i++)\n\t{\n\t\tvar children = this.graph.getChildCells(swimlanes[i]);\n\n\t\tif (children == null || children.length == 0)\n\t\t{\n\t\t\tvar vertex = this.graph.insertVertex(swimlanes[i], null, null, 0, 0, this.dummyVertexWidth, 0);\n\t\t\tthis.dummyVertices.push(vertex);\n\t\t}\n\t}\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tthis.run(parent);\n\n\t\tif (this.resizeParent && !this.graph.isCellCollapsed(parent))\n\t\t{\n\t\t\tthis.graph.updateGroupBounds([parent], this.parentBorder, this.moveParent);\n\t\t}\n\n\t\t// Maintaining parent location\n\t\tif (this.parentX != null && this.parentY != null)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(parent);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.x = this.parentX;\n\t\t\t\tgeo.y = this.parentY;\n\t\t\t\tmodel.setGeometry(parent, geo);\n\t\t\t}\n\t\t}\n\n\t\tthis.graph.removeCells(this.dummyVertices);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: updateGroupBounds\n *\n * Updates the bounds of the given array of groups so that it includes\n * all child vertices.\n *\n */\nmxSwimlaneLayout.prototype.updateGroupBounds = function()\n{\n\t// Get all vertices and edge in the layout\n\tvar cells = [];\n\tvar model = this.model;\n\n\tfor (var key in model.edgeMapper)\n\t{\n\t\tvar edge = model.edgeMapper[key];\n\n\t\tfor (var i = 0; i < edge.edges.length; i++)\n\t\t{\n\t\t\tcells.push(edge.edges[i]);\n\t\t}\n\t}\n\n\tvar layoutBounds = this.graph.getBoundingBoxFromGeometry(cells, true);\n\tvar childBounds = [];\n\n\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t{\n\t\tvar lane = this.swimlanes[i];\n\t\tvar geo = this.graph.getCellGeometry(lane);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tvar children = this.graph.getChildCells(lane);\n\n\t\t\tvar size = (this.graph.isSwimlane(lane)) ?\n\t\t\t\t\tthis.graph.getStartSize(lane) : new mxRectangle();\n\n\t\t\tvar bounds = this.graph.getBoundingBoxFromGeometry(children);\n\t\t\tchildBounds[i] = bounds;\n\t\t\tvar childrenY = bounds.y + geo.y - size.height - this.parentBorder;\n\t\t\tvar maxChildrenY = bounds.y + geo.y + bounds.height;\n\n\t\t\tif (layoutBounds == null)\n\t\t\t{\n\t\t\t\tlayoutBounds = new mxRectangle(0, childrenY, 0, maxChildrenY - childrenY);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlayoutBounds.y = Math.min(layoutBounds.y, childrenY);\n\t\t\t\tvar maxY = Math.max(layoutBounds.y + layoutBounds.height, maxChildrenY);\n\t\t\t\tlayoutBounds.height = maxY - layoutBounds.y;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t{\n\t\tvar lane = this.swimlanes[i];\n\t\tvar geo = this.graph.getCellGeometry(lane);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tvar children = this.graph.getChildCells(lane);\n\n\t\t\tvar size = (this.graph.isSwimlane(lane)) ?\n\t\t\t\t\tthis.graph.getStartSize(lane) : new mxRectangle();\n\n\t\t\tvar newGeo = geo.clone();\n\n\t\t\tvar leftGroupBorder = (i == 0) ? this.parentBorder : this.interRankCellSpacing/2;\n\t\t\tnewGeo.x += childBounds[i].x - size.width - leftGroupBorder;\n\t\t\tnewGeo.y = newGeo.y + layoutBounds.y - geo.y - this.parentBorder;\n\n\t\t\tnewGeo.width = childBounds[i].width + size.width + this.interRankCellSpacing/2 + leftGroupBorder;\n\t\t\tnewGeo.height = layoutBounds.height + size.height + 2 * this.parentBorder;\n\n\t\t\tthis.graph.model.setGeometry(lane, newGeo);\n\t\t\tthis.graph.moveCells(children, -childBounds[i].x + size.width + leftGroupBorder,\n\t\t\t\t\tgeo.y - layoutBounds.y + this.parentBorder);\n\t\t}\n\t}\n};\n\n/**\n * Function: findRoots\n *\n * Returns all visible children in the given parent which do not have\n * incoming edges. If the result is empty then the children with the\n * maximum difference between incoming and outgoing edges are returned.\n * This takes into account edges that are being promoted to the given\n * root due to invisible children or collapsed cells.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be checked.\n * vertices - array of vertices to limit search to\n */\nmxSwimlaneLayout.prototype.findRoots = function(parent, vertices)\n{\n\tvar roots = [];\n\n\tif (parent != null && vertices != null)\n\t{\n\t\tvar model = this.graph.model;\n\t\tvar best = null;\n\t\tvar maxDiff = -100000;\n\n\t\tfor (var i in vertices)\n\t\t{\n\t\t\tvar cell = vertices[i];\n\n\t\t\tif (cell != null && model.isVertex(cell) && this.graph.isCellVisible(cell) && model.isAncestor(parent, cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getEdges(cell);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\n\t\t\t\tfor (var k = 0; k < conns.length; k++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.getVisibleTerminal(conns[k], true);\n\n\t\t\t\t\tif (src == cell)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Only count connection within this swimlane\n\t\t\t\t\t\tvar other = this.getVisibleTerminal(conns[k], false);\n\n\t\t\t\t\t\tif (model.isAncestor(parent, other))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfanOut++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (model.isAncestor(parent, src))\n\t\t\t\t\t{\n\t\t\t\t\t\tfanIn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (fanIn == 0 && fanOut > 0)\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\n\t\t\t\tvar diff = fanOut - fanIn;\n\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\n\treturn roots;\n};\n\n/**\n * Function: getEdges\n *\n * Returns the connected edges for the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose edges should be returned.\n */\nmxSwimlaneLayout.prototype.getEdges = function(cell)\n{\n\tvar cachedEdges = this.edgesCache.get(cell);\n\n\tif (cachedEdges != null)\n\t{\n\t\treturn cachedEdges;\n\t}\n\n\tvar model = this.graph.model;\n\tvar edges = [];\n\tvar isCollapsed = this.graph.isCellCollapsed(cell);\n\tvar childCount = model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\n\t\tif (this.isPort(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t\telse if (isCollapsed || !this.graph.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(model.getEdges(child, true, true));\n\t\t}\n\t}\n\n\tedges = edges.concat(model.getEdges(cell, true, true));\n\tvar result = [];\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar source = this.getVisibleTerminal(edges[i], true);\n\t\tvar target = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((source == target) || ((source != target) && ((target == cell && (this.parent == null || this.graph.isValidAncestor(source, this.parent, this.traverseAncestors))) ||\n\t\t\t(source == cell && (this.parent == null ||\n\t\t\t\t\tthis.graph.isValidAncestor(target, this.parent, this.traverseAncestors))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\tthis.edgesCache.put(cell, result);\n\n\treturn result;\n};\n\n/**\n * Function: getVisibleTerminal\n *\n * Helper function to return visible terminal for edge allowing for ports\n *\n * Parameters:\n *\n * edge - <mxCell> whose edges should be returned.\n * source - Boolean that specifies whether the source or target terminal is to be returned\n */\nmxSwimlaneLayout.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar terminalCache = this.edgesTargetTermCache;\n\n\tif (source)\n\t{\n\t\tterminalCache = this.edgeSourceTermCache;\n\t}\n\n\tvar term = terminalCache.get(edge);\n\n\tif (term != null)\n\t{\n\t\treturn term;\n\t}\n\n\tvar state = this.graph.view.getState(edge);\n\n\tvar terminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\n\tif (terminal == null)\n\t{\n\t\tterminal = (state != null) ? state.getVisibleTerminal(source) : this.graph.view.getVisibleTerminal(edge, source);\n\t}\n\n\tif (terminal != null)\n\t{\n\t\tif (this.isPort(terminal))\n\t\t{\n\t\t\tterminal = this.graph.model.getParent(terminal);\n\t\t}\n\n\t\tterminalCache.put(edge, terminal);\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: run\n *\n * The API method used to exercise the layout upon the graph description\n * and produce a separate description of the vertex position and edge\n * routing changes made. It runs each stage of the layout that has been\n * created.\n */\nmxSwimlaneLayout.prototype.run = function(parent)\n{\n\t// Separate out unconnected hierarchies\n\tvar hierarchyVertices = [];\n\tvar allVertexSet = [];\n\n\tif (this.swimlanes != null && this.swimlanes.length > 0 && parent != null)\n\t{\n\t\tvar filledVertexSet = Object();\n\n\t\tfor (var i = 0; i < this.swimlanes.length; i++)\n\t\t{\n\t\t\tthis.filterDescendants(this.swimlanes[i], filledVertexSet);\n\t\t}\n\n\t\tthis.roots = [];\n\t\tvar filledVertexSetEmpty = true;\n\n\t\t// Poor man's isSetEmpty\n\t\tfor (var key in filledVertexSet)\n\t\t{\n\t\t\tif (filledVertexSet[key] != null)\n\t\t\t{\n\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Only test for candidates in each swimlane in order\n\t\tvar laneCounter = 0;\n\n\t\twhile (!filledVertexSetEmpty && laneCounter < this.swimlanes.length)\n\t\t{\n\t\t\tvar candidateRoots = this.findRoots(this.swimlanes[laneCounter], filledVertexSet);\n\n\t\t\tif (candidateRoots.length == 0)\n\t\t\t{\n\t\t\t\tlaneCounter++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the candidate root is an unconnected group cell, remove it from\n\t\t\t// the layout. We may need a custom set that holds such groups and forces\n\t\t\t// them to be processed for resizing and/or moving.\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tvar vertexSet = Object();\n\t\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\t\tthis.traverse(candidateRoots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\t\thierarchyVertices, filledVertexSet, laneCounter);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < candidateRoots.length; i++)\n\t\t\t{\n\t\t\t\tthis.roots.push(candidateRoots[i]);\n\t\t\t}\n\n\t\t\tfilledVertexSetEmpty = true;\n\n\t\t\t// Poor man's isSetEmpty\n\t\t\tfor (var key in filledVertexSet)\n\t\t\t{\n\t\t\t\tif (filledVertexSet[key] != null)\n\t\t\t\t{\n\t\t\t\t\tfilledVertexSetEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Find vertex set as directed traversal from roots\n\n\t\tfor (var i = 0; i < this.roots.length; i++)\n\t\t{\n\t\t\tvar vertexSet = Object();\n\t\t\thierarchyVertices.push(vertexSet);\n\n\t\t\tthis.traverse(this.roots[i], true, null, allVertexSet, vertexSet,\n\t\t\t\t\thierarchyVertices, null);\n\t\t}\n\t}\n\n\tvar tmp = [];\n\n\tfor (var key in allVertexSet)\n\t{\n\t\ttmp.push(allVertexSet[key]);\n\t}\n\n\tthis.model = new mxSwimlaneModel(this, tmp, this.roots,\n\t\tparent, this.tightenToSource);\n\n\tthis.cycleStage(parent);\n\tthis.layeringStage();\n\n\tthis.crossingStage(parent);\n\tinitialX = this.placementStage(0, parent);\n};\n\n/**\n * Function: filterDescendants\n *\n * Creates an array of descendant cells\n */\nmxSwimlaneLayout.prototype.filterDescendants = function(cell, result)\n{\n\tvar model = this.graph.model;\n\n\tif (model.isVertex(cell) && cell != this.parent && model.getParent(cell) != this.parent && this.graph.isCellVisible(cell))\n\t{\n\t\tresult[mxObjectIdentity.get(cell)] = cell;\n\t}\n\n\tif (this.traverseAncestors || cell == this.parent\n\t\t\t&& this.graph.isCellVisible(cell))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(cell, i);\n\n\t\t\t// Ignore ports in the layout vertex list, they are dealt with\n\t\t\t// in the traversal mechanisms\n\t\t\tif (!this.isPort(child))\n\t\t\t{\n\t\t\t\tthis.filterDescendants(child, result);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isPort\n *\n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, its parent is the connecting vertex in terms of graph traversal\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the port.\n */\nmxSwimlaneLayout.prototype.isPort = function(cell)\n{\n\tif (cell.geometry.relative)\n\t{\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getEdgesBetween\n *\n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and ports.\n *\n * Parameters:\n *\n * source -\n * target -\n * directed -\n */\nmxSwimlaneLayout.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar src = this.getVisibleTerminal(edges[i], true);\n\t\tvar trg = this.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n *\n * Parameters:\n *\n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * allVertices - Array of cell paths for the visited cells.\n * swimlaneIndex - the laid out order index of the swimlane vertex is contained in\n */\nmxSwimlaneLayout.prototype.traverse = function(vertex, directed, edge, allVertices, currentComp,\n\t\t\t\t\t\t\t\t\t\t\thierarchyVertices, filledVertexSet, swimlaneIndex)\n{\n\tif (vertex != null && allVertices != null)\n\t{\n\t\t// Has this vertex been seen before in any traversal\n\t\t// And if the filled vertex set is populated, only\n\t\t// process vertices in that it contains\n\t\tvar vertexID = mxObjectIdentity.get(vertex);\n\n\t\tif ((allVertices[vertexID] == null)\n\t\t\t\t&& (filledVertexSet == null ? true : filledVertexSet[vertexID] != null))\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\tcurrentComp[vertexID] = vertex;\n\t\t\t}\n\t\t\tif (allVertices[vertexID] == null)\n\t\t\t{\n\t\t\t\tallVertices[vertexID] = vertex;\n\t\t\t}\n\n\t\t\tif (filledVertexSet !== null)\n\t\t\t{\n\t\t\t\tdelete filledVertexSet[vertexID];\n\t\t\t}\n\n\t\t\tvar edges = this.getEdges(vertex);\n\t\t\tvar model = this.graph.model;\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tvar otherVertex = this.getVisibleTerminal(edges[i], true);\n\t\t\t\tvar isSource = otherVertex == vertex;\n\n\t\t\t\tif (isSource)\n\t\t\t\t{\n\t\t\t\t\totherVertex = this.getVisibleTerminal(edges[i], false);\n\t\t\t\t}\n\n\t\t\t\tvar otherIndex = 0;\n\t\t\t\t// Get the swimlane index of the other terminal\n\t\t\t\tfor (otherIndex = 0; otherIndex < this.swimlanes.length; otherIndex++)\n\t\t\t\t{\n\t\t\t\t\tif (model.isAncestor(this.swimlanes[otherIndex], otherVertex))\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (otherIndex >= this.swimlanes.length)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Traverse if the other vertex is within the same swimlane as\n\t\t\t\t// as the current vertex, or if the swimlane index of the other\n\t\t\t\t// vertex is greater than that of this vertex\n\t\t\t\tif ((otherIndex > swimlaneIndex) ||\n\t\t\t\t\t\t((!directed || isSource) && otherIndex == swimlaneIndex))\n\t\t\t\t{\n\t\t\t\t\tcurrentComp = this.traverse(otherVertex, directed, edges[i], allVertices,\n\t\t\t\t\t\t\tcurrentComp, hierarchyVertices,\n\t\t\t\t\t\t\tfilledVertexSet, otherIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (currentComp[vertexID] == null)\n\t\t\t{\n\t\t\t\t// We've seen this vertex before, but not in the current component\n\t\t\t\t// This component and the one it's in need to be merged\n\t\t\t\tfor (var i = 0; i < hierarchyVertices.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar comp = hierarchyVertices[i];\n\n\t\t\t\t\tif (comp[vertexID] != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var key in comp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrentComp[key] = comp[key];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove the current component from the hierarchy set\n\t\t\t\t\t\thierarchyVertices.splice(i, 1);\n\t\t\t\t\t\treturn currentComp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentComp;\n};\n\n/**\n * Function: cycleStage\n *\n * Executes the cycle stage using mxMinimumCycleRemover.\n */\nmxSwimlaneLayout.prototype.cycleStage = function(parent)\n{\n\tvar cycleStage = new mxSwimlaneOrdering(this);\n\tcycleStage.execute(parent);\n};\n\n/**\n * Function: layeringStage\n *\n * Implements first stage of a Sugiyama layout.\n */\nmxSwimlaneLayout.prototype.layeringStage = function()\n{\n\tthis.model.initialRank();\n\tthis.model.fixRanks();\n};\n\n/**\n * Function: crossingStage\n *\n * Executes the crossing stage using mxMedianHybridCrossingReduction.\n */\nmxSwimlaneLayout.prototype.crossingStage = function(parent)\n{\n\tvar crossingStage = new mxMedianHybridCrossingReduction(this);\n\tcrossingStage.execute(parent);\n};\n\n/**\n * Function: placementStage\n *\n * Executes the placement stage using mxCoordinateAssignment.\n */\nmxSwimlaneLayout.prototype.placementStage = function(initialX, parent)\n{\n\tvar placementStage = new mxCoordinateAssignment(this, this.intraCellSpacing,\n\t\t\tthis.interRankCellSpacing, this.orientation, initialX,\n\t\t\tthis.parallelEdgeSpacing);\n\tplacementStage.fineTuning = this.fineTuning;\n\tplacementStage.execute(parent);\n\n\treturn placementStage.limitX + this.interHierarchySpacing;\n};\n\n__mxOutput.mxSwimlaneLayout = typeof mxSwimlaneLayout !== 'undefined' ? mxSwimlaneLayout : undefined;\n\n/**\n * Copyright (c) 2006-2018, JGraph Ltd\n * Copyright (c) 2006-2018, Gaudenz Alder\n */\n/**\n * Class: mxGraphModel\n *\n * Extends <mxEventSource> to implement a graph model. The graph model acts as\n * a wrapper around the cells which are in charge of storing the actual graph\n * datastructure. The model acts as a transactional wrapper with event\n * notification for all changes, whereas the cells contain the atomic\n * operations for updating the actual datastructure.\n *\n * Layers:\n *\n * The cell hierarchy in the model must have a top-level root cell which\n * contains the layers (typically one default layer), which in turn contain the\n * top-level cells of the layers. This means each cell is contained in a layer.\n * If no layers are required, then all new cells should be added to the default\n * layer.\n *\n * Layers are useful for hiding and showing groups of cells, or for placing\n * groups of cells on top of other cells in the display. To identify a layer,\n * the <isLayer> function is used. It returns true if the parent of the given\n * cell is the root of the model.\n *\n * Events:\n *\n * See events section for more details. There is a new set of events for\n * tracking transactional changes as they happen. The events are called\n * startEdit for the initial beginUpdate, executed for each executed change\n * and endEdit for the terminal endUpdate. The executed event contains a\n * property called change which represents the change after execution.\n *\n * Encoding the model:\n *\n * To encode a graph model, use the following code:\n *\n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(graph.getModel());\n * (end)\n *\n * This will create an XML node that contains all the model information.\n *\n * Encoding and decoding changes:\n *\n * For the encoding of changes, a graph model listener is required that encodes\n * each change from the given array of changes.\n *\n * (code)\n * model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n *   var nodes = [];\n *   var codec = new mxCodec();\n *\n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     nodes.push(codec.encode(changes[i]));\n *   }\n *   // do something with the nodes\n * });\n * (end)\n *\n * For the decoding and execution of changes, the codec needs a lookup function\n * that allows it to resolve cell IDs as follows:\n *\n * (code)\n * var codec = new mxCodec();\n * codec.lookup = function(id)\n * {\n *   return model.getCell(id);\n * }\n * (end)\n *\n * For each encoded change (represented by a node), the following code can be\n * used to carry out the decoding and create a change object.\n *\n * (code)\n * var changes = [];\n * var change = codec.decode(node);\n * change.model = model;\n * change.execute();\n * changes.push(change);\n * (end)\n *\n * The changes can then be dispatched using the model as follows.\n *\n * (code)\n * var edit = new mxUndoableEdit(model, false);\n * edit.changes = changes;\n *\n * edit.notify = function()\n * {\n *   edit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,\n *   \t'edit', edit, 'changes', edit.changes));\n *   edit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,\n *   \t'edit', edit, 'changes', edit.changes));\n * }\n *\n * model.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n * model.fireEvent(new mxEventObject(mxEvent.CHANGE,\n * \t\t'edit', edit, 'changes', changes));\n * (end)\n *\n * Event: mxEvent.CHANGE\n *\n * Fires when an undoable edit is dispatched. The <code>edit</code> property\n * contains the <mxUndoableEdit>. The <code>changes</code> property contains\n * the array of atomic changes inside the undoable edit. The changes property\n * is <strong>deprecated</strong>, please use edit.changes instead.\n *\n * Example:\n *\n * For finding newly inserted cells, the following code can be used:\n *\n * (code)\n * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var changes = evt.getProperty('edit').changes;\n *\n *   for (var i = 0; i < changes.length; i++)\n *   {\n *     var change = changes[i];\n *\n *     if (change instanceof mxChildChange &&\n *       change.change.previous == null)\n *     {\n *       graph.startEditingAtCell(change.child);\n *       break;\n *     }\n *   }\n * });\n * (end)\n *\n *\n * Event: mxEvent.NOTIFY\n *\n * Same as <mxEvent.CHANGE>, this event can be used for classes that need to\n * implement a sync mechanism between this model and, say, a remote model. In\n * such a setup, only local changes should trigger a notify event and all\n * changes should trigger a change event.\n *\n * Event: mxEvent.EXECUTE\n *\n * Fires between begin- and endUpdate and after an atomic change was executed\n * in the model. The <code>change</code> property contains the atomic change\n * that was executed.\n *\n * Event: mxEvent.EXECUTED\n *\n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\n * The <code>change</code> property contains the change that was executed.\n *\n * Event: mxEvent.BEGIN_UPDATE\n *\n * Fires after the <updateLevel> was incremented in <beginUpdate>. This event\n * contains no properties.\n *\n * Event: mxEvent.START_EDIT\n *\n * Fires after the <updateLevel> was changed from 0 to 1. This event\n * contains no properties.\n *\n * Event: mxEvent.END_UPDATE\n *\n * Fires after the <updateLevel> was decreased in <endUpdate> but before any\n * notification or change dispatching. The <code>edit</code> property contains\n * the <currentEdit>.\n *\n * Event: mxEvent.END_EDIT\n *\n * Fires after the <updateLevel> was changed from 1 to 0. This event\n * contains no properties.\n *\n * Event: mxEvent.BEFORE_UNDO\n *\n * Fires before the change is dispatched after the update level has reached 0\n * in <endUpdate>. The <code>edit</code> property contains the <curreneEdit>.\n *\n * Event: mxEvent.UNDO\n *\n * Fires after the change was dispatched in <endUpdate>. The <code>edit</code>\n * property contains the <currentEdit>.\n *\n * Constructor: mxGraphModel\n *\n * Constructs a new graph model. If no root is specified then a new root\n * <mxCell> with a default layer is created.\n *\n * Parameters:\n *\n * root - <mxCell> that represents the root cell.\n */\nfunction mxGraphModel(root)\n{\n\tthis.currentEdit = this.createUndoableEdit();\n\n\tif (root != null)\n\t{\n\t\tthis.setRoot(root);\n\t}\n\telse\n\t{\n\t\tthis.clear();\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxGraphModel.prototype = new mxEventSource();\nmxGraphModel.prototype.constructor = mxGraphModel;\n\n/**\n * Variable: root\n *\n * Holds the root cell, which in turn contains the cells that represent the\n * layers of the diagram as child cells. That is, the actual elements of the\n * diagram are supposed to live in the third generation of cells and below.\n */\nmxGraphModel.prototype.root = null;\n\n/**\n * Variable: cells\n *\n * Maps from Ids to cells.\n */\nmxGraphModel.prototype.cells = null;\n\n/**\n * Variable: maintainEdgeParent\n *\n * Specifies if edges should automatically be moved into the nearest common\n * ancestor of their terminals. Default is true.\n */\nmxGraphModel.prototype.maintainEdgeParent = true;\n\n/**\n * Variable: ignoreRelativeEdgeParent\n *\n * Specifies if relative edge parents should be ignored for finding the nearest\n * common ancestors of an edge's terminals. Default is true.\n */\nmxGraphModel.prototype.ignoreRelativeEdgeParent = true;\n\n/**\n * Variable: createIds\n *\n * Specifies if the model should automatically create Ids for new cells.\n * Default is true.\n */\nmxGraphModel.prototype.createIds = true;\n\n/**\n * Variable: prefix\n *\n * Defines the prefix of new Ids. Default is an empty string.\n */\nmxGraphModel.prototype.prefix = '';\n\n/**\n * Variable: postfix\n *\n * Defines the postfix of new Ids. Default is an empty string.\n */\nmxGraphModel.prototype.postfix = '';\n\n/**\n * Variable: nextId\n *\n * Specifies the next Id to be created. Initial value is 0.\n */\nmxGraphModel.prototype.nextId = 0;\n\n/**\n * Variable: currentEdit\n *\n * Holds the changes for the current transaction. If the transaction is\n * closed then a new object is created for this variable using\n * <createUndoableEdit>.\n */\nmxGraphModel.prototype.currentEdit = null;\n\n/**\n * Variable: updateLevel\n *\n * Counter for the depth of nested transactions. Each call to <beginUpdate>\n * will increment this number and each call to <endUpdate> will decrement\n * it. When the counter reaches 0, the transaction is closed and the\n * respective events are fired. Initial value is 0.\n */\nmxGraphModel.prototype.updateLevel = 0;\n\n/**\n * Variable: endingUpdate\n *\n * True if the program flow is currently inside endUpdate.\n */\nmxGraphModel.prototype.endingUpdate = false;\n\n/**\n * Function: clear\n *\n * Sets a new root using <createRoot>.\n */\nmxGraphModel.prototype.clear = function()\n{\n\tthis.setRoot(this.createRoot());\n};\n\n/**\n * Function: isCreateIds\n *\n * Returns <createIds>.\n */\nmxGraphModel.prototype.isCreateIds = function()\n{\n\treturn this.createIds;\n};\n\n/**\n * Function: setCreateIds\n *\n * Sets <createIds>.\n */\nmxGraphModel.prototype.setCreateIds = function(value)\n{\n\tthis.createIds = value;\n};\n\n/**\n * Function: createRoot\n *\n * Creates a new root cell with a default layer (child 0).\n */\nmxGraphModel.prototype.createRoot = function()\n{\n\tvar cell = new mxCell();\n\tcell.insert(new mxCell());\n\n\treturn cell;\n};\n\n/**\n * Function: getCell\n *\n * Returns the <mxCell> for the specified Id or null if no cell can be\n * found for the given Id.\n *\n * Parameters:\n *\n * id - A string representing the Id of the cell.\n */\nmxGraphModel.prototype.getCell = function(id)\n{\n\treturn (this.cells != null) ? this.cells[id] : null;\n};\n\n/**\n * Function: filterCells\n *\n * Returns the cells from the given array where the given filter function\n * returns true.\n */\nmxGraphModel.prototype.filterCells = function(cells, filter)\n{\n\tvar result = null;\n\n\tif (cells != null)\n\t{\n\t\tresult = [];\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (filter(cells[i]))\n\t\t\t{\n\t\t\t\tresult.push(cells[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getDescendants\n *\n * Returns all descendants of the given cell and the cell itself in an array.\n *\n * Parameters:\n *\n * parent - <mxCell> whose descendants should be returned.\n */\nmxGraphModel.prototype.getDescendants = function(parent)\n{\n\treturn this.filterDescendants(null, parent);\n};\n\n/**\n * Function: filterDescendants\n *\n * Visits all cells recursively and applies the specified filter function\n * to each cell. If the function returns true then the cell is added\n * to the resulting array. The parent and result paramters are optional.\n * If parent is not specified then the recursion starts at <root>.\n *\n * Example:\n * The following example extracts all vertices from a given model:\n * (code)\n * var filter = function(cell)\n * {\n * \treturn model.isVertex(cell);\n * }\n * var vertices = model.filterDescendants(filter);\n * (end)\n *\n * Parameters:\n *\n * filter - JavaScript function that takes an <mxCell> as an argument\n * and returns a boolean.\n * parent - Optional <mxCell> that is used as the root of the recursion.\n */\nmxGraphModel.prototype.filterDescendants = function(filter, parent)\n{\n\t// Creates a new array for storing the result\n\tvar result = [];\n\n\t// Recursion starts at the root of the model\n\tparent = parent || this.getRoot();\n\n\t// Checks if the filter returns true for the cell\n\t// and adds it to the result array\n\tif (filter == null || filter(parent))\n\t{\n\t\tresult.push(parent);\n\t}\n\n\t// Visits the children of the cell\n\tvar childCount = this.getChildCount(parent);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(parent, i);\n\t\tresult = result.concat(this.filterDescendants(filter, child));\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getRoot\n *\n * Returns the root of the model or the topmost parent of the given cell.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> that specifies the child.\n */\nmxGraphModel.prototype.getRoot = function(cell)\n{\n\tvar root = cell || this.root;\n\n\tif (cell != null)\n\t{\n\t\twhile (cell != null)\n\t\t{\n\t\t\troot = cell;\n\t\t\tcell = this.getParent(cell);\n\t\t}\n\t}\n\n\treturn root;\n};\n\n/**\n * Function: setRoot\n *\n * Sets the <root> of the model using <mxRootChange> and adds the change to\n * the current transaction. This resets all datastructures in the model and\n * is the preferred way of clearing an existing model. Returns the new\n * root.\n *\n * Example:\n *\n * (code)\n * var root = new mxCell();\n * root.insert(new mxCell());\n * model.setRoot(root);\n * (end)\n *\n * Parameters:\n *\n * root - <mxCell> that specifies the new root.\n */\nmxGraphModel.prototype.setRoot = function(root)\n{\n\tthis.execute(new mxRootChange(this, root));\n\n\treturn root;\n};\n\n/**\n * Function: rootChanged\n *\n * Inner callback to change the root of the model and update the internal\n * datastructures, such as <cells> and <nextId>. Returns the previous root.\n *\n * Parameters:\n *\n * root - <mxCell> that specifies the new root.\n */\nmxGraphModel.prototype.rootChanged = function(root)\n{\n\tvar oldRoot = this.root;\n\tthis.root = root;\n\n\t// Resets counters and datastructures\n\tthis.nextId = 0;\n\tthis.cells = null;\n\tthis.cellAdded(root);\n\n\treturn oldRoot;\n};\n\n/**\n * Function: isRoot\n *\n * Returns true if the given cell is the root of the model and a non-null\n * value.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the possible root.\n */\nmxGraphModel.prototype.isRoot = function(cell)\n{\n\treturn cell != null && this.root == cell;\n};\n\n/**\n * Function: isLayer\n *\n * Returns true if <isRoot> returns true for the parent of the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the possible layer.\n */\nmxGraphModel.prototype.isLayer = function(cell)\n{\n\treturn this.isRoot(this.getParent(cell));\n};\n\n/**\n * Function: isAncestor\n *\n * Returns true if the given parent is an ancestor of the given child. Note\n * returns true if child == parent.\n *\n * Parameters:\n *\n * parent - <mxCell> that specifies the parent.\n * child - <mxCell> that specifies the child.\n */\nmxGraphModel.prototype.isAncestor = function(parent, child)\n{\n\twhile (child != null && child != parent)\n\t{\n\t\tchild = this.getParent(child);\n\t}\n\n\treturn child == parent;\n};\n\n/**\n * Function: contains\n *\n * Returns true if the model contains the given <mxCell>.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the cell.\n */\nmxGraphModel.prototype.contains = function(cell)\n{\n\treturn this.isAncestor(this.root, cell);\n};\n\n/**\n * Function: getParent\n *\n * Returns the parent of the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose parent should be returned.\n */\nmxGraphModel.prototype.getParent = function(cell)\n{\n\treturn (cell != null) ? cell.getParent() : null;\n};\n\n/**\n * Function: add\n *\n * Adds the specified child to the parent at the given index using\n * <mxChildChange> and adds the change to the current transaction. If no\n * index is specified then the child is appended to the parent's array of\n * children. Returns the inserted child.\n *\n * Parameters:\n *\n * parent - <mxCell> that specifies the parent to contain the child.\n * child - <mxCell> that specifies the child to be inserted.\n * index - Optional integer that specifies the index of the child.\n */\nmxGraphModel.prototype.add = function(parent, child, index)\n{\n\tif (child != parent && parent != null && child != null)\n\t{\n\t\t// Appends the child if no index was specified\n\t\tif (index == null)\n\t\t{\n\t\t\tindex = this.getChildCount(parent);\n\t\t}\n\n\t\tvar parentChanged = parent != this.getParent(child);\n\t\tthis.execute(new mxChildChange(this, parent, child, index));\n\n\t\t// Maintains the edges parents by moving the edges\n\t\t// into the nearest common ancestor of its terminals\n\t\tif (this.maintainEdgeParent && parentChanged)\n\t\t{\n\t\t\tthis.updateEdgeParents(child);\n\t\t}\n\t}\n\n\treturn child;\n};\n\n/**\n * Function: cellAdded\n *\n * Inner callback to update <cells> when a cell has been added. This\n * implementation resolves collisions by creating new Ids. To change the\n * ID of a cell after it was inserted into the model, use the following\n * code:\n *\n * (code\n * delete model.cells[cell.getId()];\n * cell.setId(newId);\n * model.cells[cell.getId()] = cell;\n * (end)\n *\n * If the change of the ID should be part of the command history, then the\n * cell should be removed from the model and a clone with the new ID should\n * be reinserted into the model instead.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the cell that has been added.\n */\nmxGraphModel.prototype.cellAdded = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\t// Creates an Id for the cell if not Id exists\n\t\tif (cell.getId() == null && this.createIds)\n\t\t{\n\t\t\tcell.setId(this.createId(cell));\n\t\t}\n\n\t\tif (cell.getId() != null)\n\t\t{\n\t\t\tvar collision = this.getCell(cell.getId());\n\n\t\t\tif (collision != cell)\n\t\t\t{\n\t\t\t\t// Creates new Id for the cell\n\t\t\t\t// as long as there is a collision\n\t\t\t\twhile (collision != null)\n\t\t\t\t{\n\t\t\t\t\tcell.setId(this.createId(cell));\n\t\t\t\t\tcollision = this.getCell(cell.getId());\n\t\t\t\t}\n\n\t\t\t\t// Lazily creates the cells dictionary\n\t\t\t\tif (this.cells == null)\n\t\t\t\t{\n\t\t\t\t\tthis.cells = new Object();\n\t\t\t\t}\n\n\t\t\t\tthis.cells[cell.getId()] = cell;\n\t\t\t}\n\t\t}\n\n\t\t// Makes sure IDs of deleted cells are not reused\n\t\tif (mxUtils.isNumeric(cell.getId()))\n\t\t{\n\t\t\tthis.nextId = Math.max(this.nextId, cell.getId());\n\t\t}\n\n\t\t// Recursively processes child cells\n\t\tvar childCount = this.getChildCount(cell);\n\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tthis.cellAdded(this.getChildAt(cell, i));\n\t\t}\n\t}\n};\n\n/**\n * Function: createId\n *\n * Hook method to create an Id for the specified cell. This implementation\n * concatenates <prefix>, id and <postfix> to create the Id and increments\n * <nextId>. The cell is ignored by this implementation, but can be used in\n * overridden methods to prefix the Ids with eg. the cell type.\n *\n * Parameters:\n *\n * cell - <mxCell> to create the Id for.\n */\nmxGraphModel.prototype.createId = function(cell)\n{\n\tvar id = this.nextId;\n\tthis.nextId++;\n\n\treturn this.prefix + id + this.postfix;\n};\n\n/**\n * Function: updateEdgeParents\n *\n * Updates the parent for all edges that are connected to cell or one of\n * its descendants using <updateEdgeParent>.\n */\nmxGraphModel.prototype.updateEdgeParents = function(cell, root)\n{\n\t// Gets the topmost node of the hierarchy\n\troot = root || this.getRoot(cell);\n\n\t// Updates edges on children first\n\tvar childCount = this.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(cell, i);\n\t\tthis.updateEdgeParents(child, root);\n\t}\n\n\t// Updates the parents of all connected edges\n\tvar edgeCount = this.getEdgeCount(cell);\n\tvar edges = [];\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tedges.push(this.getEdgeAt(cell, i));\n\t}\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar edge = edges[i];\n\n\t\t// Updates edge parent if edge and child have\n\t\t// a common root node (does not need to be the\n\t\t// model root node)\n\t\tif (this.isAncestor(root, edge))\n\t\t{\n\t\t\tthis.updateEdgeParent(edge, root);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateEdgeParent\n *\n * Inner callback to update the parent of the specified <mxCell> to the\n * nearest-common-ancestor of its two terminals.\n *\n * Parameters:\n *\n * edge - <mxCell> that specifies the edge.\n * root - <mxCell> that represents the current root of the model.\n */\nmxGraphModel.prototype.updateEdgeParent = function(edge, root)\n{\n\tvar source = this.getTerminal(edge, true);\n\tvar target = this.getTerminal(edge, false);\n\tvar cell = null;\n\n\t// Uses the first non-relative descendants of the source terminal\n\twhile (source != null && !this.isEdge(source) &&\n\t\tsource.geometry != null && source.geometry.relative)\n\t{\n\t\tsource = this.getParent(source);\n\t}\n\n\t// Uses the first non-relative descendants of the target terminal\n\twhile (target != null && this.ignoreRelativeEdgeParent &&\n\t\t!this.isEdge(target) && target.geometry != null &&\n\t\ttarget.geometry.relative)\n\t{\n\t\ttarget = this.getParent(target);\n\t}\n\n\tif (this.isAncestor(root, source) && this.isAncestor(root, target))\n\t{\n\t\tif (source == target)\n\t\t{\n\t\t\tcell = this.getParent(source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcell = this.getNearestCommonAncestor(source, target);\n\t\t}\n\n\t\tif (cell != null && (this.getParent(cell) != this.root ||\n\t\t\tthis.isAncestor(cell, edge)) && this.getParent(edge) != cell)\n\t\t{\n\t\t\tvar geo = this.getGeometry(edge);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar origin1 = this.getOrigin(this.getParent(edge));\n\t\t\t\tvar origin2 = this.getOrigin(cell);\n\n\t\t\t\tvar dx = origin2.x - origin1.x;\n\t\t\t\tvar dy = origin2.y - origin1.y;\n\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.translate(-dx, -dy);\n\t\t\t\tthis.setGeometry(edge, geo);\n\t\t\t}\n\n\t\t\tthis.add(cell, edge, this.getChildCount(cell));\n\t\t}\n\t}\n};\n\n/**\n * Function: getOrigin\n *\n * Returns the absolute, accumulated origin for the children inside the\n * given parent as an <mxPoint>.\n */\nmxGraphModel.prototype.getOrigin = function(cell)\n{\n\tvar result = null;\n\n\tif (cell != null)\n\t{\n\t\tresult = this.getOrigin(this.getParent(cell));\n\n\t\tif (!this.isEdge(cell))\n\t\t{\n\t\t\tvar geo = this.getGeometry(cell);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tresult.x += geo.x;\n\t\t\t\tresult.y += geo.y;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = new mxPoint();\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getNearestCommonAncestor\n *\n * Returns the nearest common ancestor for the specified cells.\n *\n * Parameters:\n *\n * cell1 - <mxCell> that specifies the first cell in the tree.\n * cell2 - <mxCell> that specifies the second cell in the tree.\n */\nmxGraphModel.prototype.getNearestCommonAncestor = function(cell1, cell2)\n{\n\tif (cell1 != null && cell2 != null)\n\t{\n\t\t// Creates the cell path for the second cell\n\t\tvar path = mxCellPath.create(cell2);\n\n\t\tif (path != null && path.length > 0)\n\t\t{\n\t\t\t// Bubbles through the ancestors of the first\n\t\t\t// cell to find the nearest common ancestor.\n\t\t\tvar cell = cell1;\n\t\t\tvar current = mxCellPath.create(cell);\n\n\t\t\t// Inverts arguments\n\t\t\tif (path.length < current.length)\n\t\t\t{\n\t\t\t\tcell = cell2;\n\t\t\t\tvar tmp = current;\n\t\t\t\tcurrent = path;\n\t\t\t\tpath = tmp;\n\t\t\t}\n\n\t\t\twhile (cell != null)\n\t\t\t{\n\t\t\t\tvar parent = this.getParent(cell);\n\n\t\t\t\t// Checks if the cell path is equal to the beginning of the given cell path\n\t\t\t\tif (path.indexOf(current + mxCellPath.PATH_SEPARATOR) == 0 && parent != null)\n\t\t\t\t{\n\t\t\t\t\treturn cell;\n\t\t\t\t}\n\n\t\t\t\tcurrent = mxCellPath.getParentPath(current);\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: remove\n *\n * Removes the specified cell from the model using <mxChildChange> and adds\n * the change to the current transaction. This operation will remove the\n * cell and all of its children from the model. Returns the removed cell.\n *\n * Parameters:\n *\n * cell - <mxCell> that should be removed.\n */\nmxGraphModel.prototype.remove = function(cell)\n{\n\tif (cell == this.root)\n\t{\n\t\tthis.setRoot(null);\n\t}\n\telse if (this.getParent(cell) != null)\n\t{\n\t\tthis.execute(new mxChildChange(this, null, cell));\n\t}\n\n\treturn cell;\n};\n\n/**\n * Function: cellRemoved\n *\n * Inner callback to update <cells> when a cell has been removed.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the cell that has been removed.\n */\nmxGraphModel.prototype.cellRemoved = function(cell)\n{\n\tif (cell != null && this.cells != null)\n\t{\n\t\t// Recursively processes child cells\n\t\tvar childCount = this.getChildCount(cell);\n\n\t\tfor (var i = childCount - 1; i >= 0; i--)\n\t\t{\n\t\t\tthis.cellRemoved(this.getChildAt(cell, i));\n\t\t}\n\n\t\t// Removes the dictionary entry for the cell\n\t\tif (this.cells != null && cell.getId() != null)\n\t\t{\n\t\t\tdelete this.cells[cell.getId()];\n\t\t}\n\t}\n};\n\n/**\n * Function: parentForCellChanged\n *\n * Inner callback to update the parent of a cell using <mxCell.insert>\n * on the parent and return the previous parent.\n *\n * Parameters:\n *\n * cell - <mxCell> to update the parent for.\n * parent - <mxCell> that specifies the new parent of the cell.\n * index - Optional integer that defines the index of the child\n * in the parent's child array.\n */\nmxGraphModel.prototype.parentForCellChanged = function(cell, parent, index)\n{\n\tvar previous = this.getParent(cell);\n\n\tif (parent != null)\n\t{\n\t\tif (parent != previous || previous.getIndex(cell) != index)\n\t\t{\n\t\t\tparent.insert(cell, index);\n\t\t}\n\t}\n\telse if (previous != null)\n\t{\n\t\tvar oldIndex = previous.getIndex(cell);\n\t\tprevious.remove(oldIndex);\n\t}\n\n\t// Adds or removes the cell from the model\n\tvar par = this.contains(parent);\n\tvar pre = this.contains(previous);\n\n\tif (par && !pre)\n\t{\n\t\tthis.cellAdded(cell);\n\t}\n\telse if (pre && !par)\n\t{\n\t\tthis.cellRemoved(cell);\n\t}\n\n\treturn previous;\n};\n\n/**\n * Function: getChildCount\n *\n * Returns the number of children in the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose number of children should be returned.\n */\nmxGraphModel.prototype.getChildCount = function(cell)\n{\n\treturn (cell != null) ? cell.getChildCount() : 0;\n};\n\n/**\n * Function: getChildAt\n *\n * Returns the child of the given <mxCell> at the given index.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the parent.\n * index - Integer that specifies the index of the child to be returned.\n */\nmxGraphModel.prototype.getChildAt = function(cell, index)\n{\n\treturn (cell != null) ? cell.getChildAt(index) : null;\n};\n\n/**\n * Function: getChildren\n *\n * Returns all children of the given <mxCell> as an array of <mxCells>. The\n * return value should be only be read.\n *\n * Parameters:\n *\n * cell - <mxCell> the represents the parent.\n */\nmxGraphModel.prototype.getChildren = function(cell)\n{\n\treturn (cell != null) ? cell.children : null;\n};\n\n/**\n * Function: getChildVertices\n *\n * Returns the child vertices of the given parent.\n *\n * Parameters:\n *\n * cell - <mxCell> whose child vertices should be returned.\n */\nmxGraphModel.prototype.getChildVertices = function(parent)\n{\n\treturn this.getChildCells(parent, true, false);\n};\n\n/**\n * Function: getChildEdges\n *\n * Returns the child edges of the given parent.\n *\n * Parameters:\n *\n * cell - <mxCell> whose child edges should be returned.\n */\nmxGraphModel.prototype.getChildEdges = function(parent)\n{\n\treturn this.getChildCells(parent, false, true);\n};\n\n/**\n * Function: getChildCells\n *\n * Returns the children of the given cell that are vertices and/or edges\n * depending on the arguments.\n *\n * Parameters:\n *\n * cell - <mxCell> the represents the parent.\n * vertices - Boolean indicating if child vertices should be returned.\n * Default is false.\n * edges - Boolean indicating if child edges should be returned.\n * Default is false.\n */\nmxGraphModel.prototype.getChildCells = function(parent, vertices, edges)\n{\n\tvertices = (vertices != null) ? vertices : false;\n\tedges = (edges != null) ? edges : false;\n\n\tvar childCount = this.getChildCount(parent);\n\tvar result = [];\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.getChildAt(parent, i);\n\n\t\tif ((!edges && !vertices) || (edges && this.isEdge(child)) ||\n\t\t\t(vertices && this.isVertex(child)))\n\t\t{\n\t\t\tresult.push(child);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getTerminal\n *\n * Returns the source or target <mxCell> of the given edge depending on the\n * value of the boolean parameter.\n *\n * Parameters:\n *\n * edge - <mxCell> that specifies the edge.\n * isSource - Boolean indicating which end of the edge should be returned.\n */\nmxGraphModel.prototype.getTerminal = function(edge, isSource)\n{\n\treturn (edge != null) ? edge.getTerminal(isSource) : null;\n};\n\n/**\n * Function: setTerminal\n *\n * Sets the source or target terminal of the given <mxCell> using\n * <mxTerminalChange> and adds the change to the current transaction.\n * This implementation updates the parent of the edge using <updateEdgeParent>\n * if required.\n *\n * Parameters:\n *\n * edge - <mxCell> that specifies the edge.\n * terminal - <mxCell> that specifies the new terminal.\n * isSource - Boolean indicating if the terminal is the new source or\n * target terminal of the edge.\n */\nmxGraphModel.prototype.setTerminal = function(edge, terminal, isSource)\n{\n\tvar terminalChanged = terminal != this.getTerminal(edge, isSource);\n\tthis.execute(new mxTerminalChange(this, edge, terminal, isSource));\n\n\tif (this.maintainEdgeParent && terminalChanged)\n\t{\n\t\tthis.updateEdgeParent(edge, this.getRoot());\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: setTerminals\n *\n * Sets the source and target <mxCell> of the given <mxCell> in a single\n * transaction using <setTerminal> for each end of the edge.\n *\n * Parameters:\n *\n * edge - <mxCell> that specifies the edge.\n * source - <mxCell> that specifies the new source terminal.\n * target - <mxCell> that specifies the new target terminal.\n */\nmxGraphModel.prototype.setTerminals = function(edge, source, target)\n{\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tthis.setTerminal(edge, source, true);\n\t\tthis.setTerminal(edge, target, false);\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: terminalForCellChanged\n *\n * Inner helper function to update the terminal of the edge using\n * <mxCell.insertEdge> and return the previous terminal.\n *\n * Parameters:\n *\n * edge - <mxCell> that specifies the edge to be updated.\n * terminal - <mxCell> that specifies the new terminal.\n * isSource - Boolean indicating if the terminal is the new source or\n * target terminal of the edge.\n */\nmxGraphModel.prototype.terminalForCellChanged = function(edge, terminal, isSource)\n{\n\tvar previous = this.getTerminal(edge, isSource);\n\n\tif (terminal != null)\n\t{\n\t\tterminal.insertEdge(edge, isSource);\n\t}\n\telse if (previous != null)\n\t{\n\t\tprevious.removeEdge(edge, isSource);\n\t}\n\n\treturn previous;\n};\n\n/**\n * Function: getEdgeCount\n *\n * Returns the number of distinct edges connected to the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the vertex.\n */\nmxGraphModel.prototype.getEdgeCount = function(cell)\n{\n\treturn (cell != null) ? cell.getEdgeCount() : 0;\n};\n\n/**\n * Function: getEdgeAt\n *\n * Returns the edge of cell at the given index.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the vertex.\n * index - Integer that specifies the index of the edge\n * to return.\n */\nmxGraphModel.prototype.getEdgeAt = function(cell, index)\n{\n\treturn (cell != null) ? cell.getEdgeAt(index) : null;\n};\n\n/**\n * Function: getDirectedEdgeCount\n *\n * Returns the number of incoming or outgoing edges, ignoring the given\n * edge.\n *\n * Parameters:\n *\n * cell - <mxCell> whose edge count should be returned.\n * outgoing - Boolean that specifies if the number of outgoing or\n * incoming edges should be returned.\n * ignoredEdge - <mxCell> that represents an edge to be ignored.\n */\nmxGraphModel.prototype.getDirectedEdgeCount = function(cell, outgoing, ignoredEdge)\n{\n\tvar count = 0;\n\tvar edgeCount = this.getEdgeCount(cell);\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(cell, i);\n\n\t\tif (edge != ignoredEdge && this.getTerminal(edge, outgoing) == cell)\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\n\treturn count;\n};\n\n/**\n * Function: getConnections\n *\n * Returns all edges of the given cell without loops.\n *\n * Parameters:\n *\n * cell - <mxCell> whose edges should be returned.\n *\n */\nmxGraphModel.prototype.getConnections = function(cell)\n{\n\treturn this.getEdges(cell, true, true, false);\n};\n\n/**\n * Function: getIncomingEdges\n *\n * Returns the incoming edges of the given cell without loops.\n *\n * Parameters:\n *\n * cell - <mxCell> whose incoming edges should be returned.\n *\n */\nmxGraphModel.prototype.getIncomingEdges = function(cell)\n{\n\treturn this.getEdges(cell, true, false, false);\n};\n\n/**\n * Function: getOutgoingEdges\n *\n * Returns the outgoing edges of the given cell without loops.\n *\n * Parameters:\n *\n * cell - <mxCell> whose outgoing edges should be returned.\n *\n */\nmxGraphModel.prototype.getOutgoingEdges = function(cell)\n{\n\treturn this.getEdges(cell, false, true, false);\n};\n\n/**\n * Function: getEdges\n *\n * Returns all distinct edges connected to this cell as a new array of\n * <mxCells>. If at least one of incoming or outgoing is true, then loops\n * are ignored, otherwise if both are false, then all edges connected to\n * the given cell are returned including loops.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the cell.\n * incoming - Optional boolean that specifies if incoming edges should be\n * returned. Default is true.\n * outgoing - Optional boolean that specifies if outgoing edges should be\n * returned. Default is true.\n * includeLoops - Optional boolean that specifies if loops should be returned.\n * Default is true.\n */\nmxGraphModel.prototype.getEdges = function(cell, incoming, outgoing, includeLoops)\n{\n\tincoming = (incoming != null) ? incoming : true;\n\toutgoing = (outgoing != null) ? outgoing : true;\n\tincludeLoops = (includeLoops != null) ? includeLoops : true;\n\n\tvar edgeCount = this.getEdgeCount(cell);\n\tvar result = [];\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(cell, i);\n\t\tvar source = this.getTerminal(edge, true);\n\t\tvar target = this.getTerminal(edge, false);\n\n\t\tif ((includeLoops && source == target) || ((source != target) && ((incoming && target == cell) ||\n\t\t\t(outgoing && source == cell))))\n\t\t{\n\t\t\tresult.push(edge);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getEdgesBetween\n *\n * Returns all edges between the given source and target pair. If directed\n * is true, then only edges from the source to the target are returned,\n * otherwise, all edges between the two cells are returned.\n *\n * Parameters:\n *\n * source - <mxCell> that defines the source terminal of the edge to be\n * returned.\n * target - <mxCell> that defines the target terminal of the edge to be\n * returned.\n * directed - Optional boolean that specifies if the direction of the\n * edge should be taken into account. Default is false.\n */\nmxGraphModel.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\n\tvar tmp1 = this.getEdgeCount(source);\n\tvar tmp2 = this.getEdgeCount(target);\n\n\t// Assumes the source has less connected edges\n\tvar terminal = source;\n\tvar edgeCount = tmp1;\n\n\t// Uses the smaller array of connected edges\n\t// for searching the edge\n\tif (tmp2 < tmp1)\n\t{\n\t\tedgeCount = tmp2;\n\t\tterminal = target;\n\t}\n\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar edge = this.getEdgeAt(terminal, i);\n\t\tvar src = this.getTerminal(edge, true);\n\t\tvar trg = this.getTerminal(edge, false);\n\t\tvar directedMatch = (src == source) && (trg == target);\n\t\tvar oppositeMatch = (trg == source) && (src == target);\n\n\t\tif (directedMatch || (!directed && oppositeMatch))\n\t\t{\n\t\t\tresult.push(edge);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getOpposites\n *\n * Returns all opposite vertices wrt terminal for the given edges, only\n * returning sources and/or targets as specified. The result is returned\n * as an array of <mxCells>.\n *\n * Parameters:\n *\n * edges - Array of <mxCells> that contain the edges to be examined.\n * terminal - <mxCell> that specifies the known end of the edges.\n * sources - Boolean that specifies if source terminals should be contained\n * in the result. Default is true.\n * targets - Boolean that specifies if target terminals should be contained\n * in the result. Default is true.\n */\nmxGraphModel.prototype.getOpposites = function(edges, terminal, sources, targets)\n{\n\tsources = (sources != null) ? sources : true;\n\ttargets = (targets != null) ? targets : true;\n\n\tvar terminals = [];\n\n\tif (edges != null)\n\t{\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tvar source = this.getTerminal(edges[i], true);\n\t\t\tvar target = this.getTerminal(edges[i], false);\n\n\t\t\t// Checks if the terminal is the source of\n\t\t\t// the edge and if the target should be\n\t\t\t// stored in the result\n\t\t\tif (source == terminal && target != null && target != terminal && targets)\n\t\t\t{\n\t\t\t\tterminals.push(target);\n\t\t\t}\n\n\t\t\t// Checks if the terminal is the taget of\n\t\t\t// the edge and if the source should be\n\t\t\t// stored in the result\n\t\t\telse if (target == terminal && source != null && source != terminal && sources)\n\t\t\t{\n\t\t\t\tterminals.push(source);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn terminals;\n};\n\n/**\n * Function: getTopmostCells\n *\n * Returns the topmost cells of the hierarchy in an array that contains no\n * descendants for each <mxCell> that it contains. Duplicates should be\n * removed in the cells array to improve performance.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose topmost ancestors should be returned.\n */\nmxGraphModel.prototype.getTopmostCells = function(cells)\n{\n\tvar dict = new mxDictionary();\n\tvar tmp = [];\n\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tdict.put(cells[i], true);\n\t}\n\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tvar cell = cells[i];\n\t\tvar topmost = true;\n\t\tvar parent = this.getParent(cell);\n\n\t\twhile (parent != null)\n\t\t{\n\t\t\tif (dict.get(parent))\n\t\t\t{\n\t\t\t\ttopmost = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparent = this.getParent(parent);\n\t\t}\n\n\t\tif (topmost)\n\t\t{\n\t\t\ttmp.push(cell);\n\t\t}\n\t}\n\n\treturn tmp;\n};\n\n/**\n * Function: isVertex\n *\n * Returns true if the given cell is a vertex.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the possible vertex.\n */\nmxGraphModel.prototype.isVertex = function(cell)\n{\n\treturn (cell != null) ? cell.isVertex() : false;\n};\n\n/**\n * Function: isEdge\n *\n * Returns true if the given cell is an edge.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the possible edge.\n */\nmxGraphModel.prototype.isEdge = function(cell)\n{\n\treturn (cell != null) ? cell.isEdge() : false;\n};\n\n/**\n * Function: isConnectable\n *\n * Returns true if the given <mxCell> is connectable. If <edgesConnectable>\n * is false, then this function returns false for all edges else it returns\n * the return value of <mxCell.isConnectable>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose connectable state should be returned.\n */\nmxGraphModel.prototype.isConnectable = function(cell)\n{\n\treturn (cell != null) ? cell.isConnectable() : false;\n};\n\n/**\n * Function: getValue\n *\n * Returns the user object of the given <mxCell> using <mxCell.getValue>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose user object should be returned.\n */\nmxGraphModel.prototype.getValue = function(cell)\n{\n\treturn (cell != null) ? cell.getValue() : null;\n};\n\n/**\n * Function: setValue\n *\n * Sets the user object of then given <mxCell> using <mxValueChange>\n * and adds the change to the current transaction.\n *\n * Parameters:\n *\n * cell - <mxCell> whose user object should be changed.\n * value - Object that defines the new user object.\n */\nmxGraphModel.prototype.setValue = function(cell, value)\n{\n\tthis.execute(new mxValueChange(this, cell, value));\n\n\treturn value;\n};\n\n/**\n * Function: valueForCellChanged\n *\n * Inner callback to update the user object of the given <mxCell>\n * using <mxCell.valueChanged> and return the previous value,\n * that is, the return value of <mxCell.valueChanged>.\n *\n * To change a specific attribute in an XML node, the following code can be\n * used.\n *\n * (code)\n * graph.getModel().valueForCellChanged = function(cell, value)\n * {\n *   var previous = cell.value.getAttribute('label');\n *   cell.value.setAttribute('label', value);\n *\n *   return previous;\n * };\n * (end)\n */\nmxGraphModel.prototype.valueForCellChanged = function(cell, value)\n{\n\treturn cell.valueChanged(value);\n};\n\n/**\n * Function: getGeometry\n *\n * Returns the <mxGeometry> of the given <mxCell>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose geometry should be returned.\n */\nmxGraphModel.prototype.getGeometry = function(cell)\n{\n\treturn (cell != null) ? cell.getGeometry() : null;\n};\n\n/**\n * Function: setGeometry\n *\n * Sets the <mxGeometry> of the given <mxCell>. The actual update\n * of the cell is carried out in <geometryForCellChanged>. The\n * <mxGeometryChange> action is used to encapsulate the change.\n *\n * Parameters:\n *\n * cell - <mxCell> whose geometry should be changed.\n * geometry - <mxGeometry> that defines the new geometry.\n */\nmxGraphModel.prototype.setGeometry = function(cell, geometry)\n{\n\tif (geometry != this.getGeometry(cell))\n\t{\n\t\tthis.execute(new mxGeometryChange(this, cell, geometry));\n\t}\n\n\treturn geometry;\n};\n\n/**\n * Function: geometryForCellChanged\n *\n * Inner callback to update the <mxGeometry> of the given <mxCell> using\n * <mxCell.setGeometry> and return the previous <mxGeometry>.\n */\nmxGraphModel.prototype.geometryForCellChanged = function(cell, geometry)\n{\n\tvar previous = this.getGeometry(cell);\n\tcell.setGeometry(geometry);\n\n\treturn previous;\n};\n\n/**\n * Function: getStyle\n *\n * Returns the style of the given <mxCell>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose style should be returned.\n */\nmxGraphModel.prototype.getStyle = function(cell)\n{\n\treturn (cell != null) ? cell.getStyle() : null;\n};\n\n/**\n * Function: setStyle\n *\n * Sets the style of the given <mxCell> using <mxStyleChange> and\n * adds the change to the current transaction.\n *\n * Parameters:\n *\n * cell - <mxCell> whose style should be changed.\n * style - String of the form [stylename;|key=value;] to specify\n * the new cell style.\n */\nmxGraphModel.prototype.setStyle = function(cell, style)\n{\n\tif (style != this.getStyle(cell))\n\t{\n\t\tthis.execute(new mxStyleChange(this, cell, style));\n\t}\n\n\treturn style;\n};\n\n/**\n * Function: styleForCellChanged\n *\n * Inner callback to update the style of the given <mxCell>\n * using <mxCell.setStyle> and return the previous style.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the cell to be updated.\n * style - String of the form [stylename;|key=value;] to specify\n * the new cell style.\n */\nmxGraphModel.prototype.styleForCellChanged = function(cell, style)\n{\n\tvar previous = this.getStyle(cell);\n\tcell.setStyle(style);\n\n\treturn previous;\n};\n\n/**\n * Function: isCollapsed\n *\n * Returns true if the given <mxCell> is collapsed.\n *\n * Parameters:\n *\n * cell - <mxCell> whose collapsed state should be returned.\n */\nmxGraphModel.prototype.isCollapsed = function(cell)\n{\n\treturn (cell != null) ? cell.isCollapsed() : false;\n};\n\n/**\n * Function: setCollapsed\n *\n * Sets the collapsed state of the given <mxCell> using <mxCollapseChange>\n * and adds the change to the current transaction.\n *\n * Parameters:\n *\n * cell - <mxCell> whose collapsed state should be changed.\n * collapsed - Boolean that specifies the new collpased state.\n */\nmxGraphModel.prototype.setCollapsed = function(cell, collapsed)\n{\n\tif (collapsed != this.isCollapsed(cell))\n\t{\n\t\tthis.execute(new mxCollapseChange(this, cell, collapsed));\n\t}\n\n\treturn collapsed;\n};\n\n/**\n * Function: collapsedStateForCellChanged\n *\n * Inner callback to update the collapsed state of the\n * given <mxCell> using <mxCell.setCollapsed> and return\n * the previous collapsed state.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the cell to be updated.\n * collapsed - Boolean that specifies the new collpased state.\n */\nmxGraphModel.prototype.collapsedStateForCellChanged = function(cell, collapsed)\n{\n\tvar previous = this.isCollapsed(cell);\n\tcell.setCollapsed(collapsed);\n\n\treturn previous;\n};\n\n/**\n * Function: isVisible\n *\n * Returns true if the given <mxCell> is visible.\n *\n * Parameters:\n *\n * cell - <mxCell> whose visible state should be returned.\n */\nmxGraphModel.prototype.isVisible = function(cell)\n{\n\treturn (cell != null) ? cell.isVisible() : false;\n};\n\n/**\n * Function: setVisible\n *\n * Sets the visible state of the given <mxCell> using <mxVisibleChange> and\n * adds the change to the current transaction.\n *\n * Parameters:\n *\n * cell - <mxCell> whose visible state should be changed.\n * visible - Boolean that specifies the new visible state.\n */\nmxGraphModel.prototype.setVisible = function(cell, visible)\n{\n\tif (visible != this.isVisible(cell))\n\t{\n\t\tthis.execute(new mxVisibleChange(this, cell, visible));\n\t}\n\n\treturn visible;\n};\n\n/**\n * Function: visibleStateForCellChanged\n *\n * Inner callback to update the visible state of the\n * given <mxCell> using <mxCell.setCollapsed> and return\n * the previous visible state.\n *\n * Parameters:\n *\n * cell - <mxCell> that specifies the cell to be updated.\n * visible - Boolean that specifies the new visible state.\n */\nmxGraphModel.prototype.visibleStateForCellChanged = function(cell, visible)\n{\n\tvar previous = this.isVisible(cell);\n\tcell.setVisible(visible);\n\n\treturn previous;\n};\n\n/**\n * Function: execute\n *\n * Executes the given edit and fires events if required. The edit object\n * requires an execute function which is invoked. The edit is added to the\n * <currentEdit> between <beginUpdate> and <endUpdate> calls, so that\n * events will be fired if this execute is an individual transaction, that\n * is, if no previous <beginUpdate> calls have been made without calling\n * <endUpdate>. This implementation fires an <execute> event before\n * executing the given change.\n *\n * Parameters:\n *\n * change - Object that described the change.\n */\nmxGraphModel.prototype.execute = function(change)\n{\n\tchange.execute();\n\tthis.beginUpdate();\n\tthis.currentEdit.add(change);\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTE, 'change', change));\n\t// New global executed event\n\tthis.fireEvent(new mxEventObject(mxEvent.EXECUTED, 'change', change));\n\tthis.endUpdate();\n};\n\n/**\n * Function: beginUpdate\n *\n * Increments the <updateLevel> by one. The event notification\n * is queued until <updateLevel> reaches 0 by use of\n * <endUpdate>.\n *\n * All changes on <mxGraphModel> are transactional,\n * that is, they are executed in a single undoable change\n * on the model (without transaction isolation).\n * Therefore, if you want to combine any\n * number of changes into a single undoable change,\n * you should group any two or more API calls that\n * modify the graph model between <beginUpdate>\n * and <endUpdate> calls as shown here:\n *\n * (code)\n * var model = graph.getModel();\n * var parent = graph.getDefaultParent();\n * var index = model.getChildCount(parent);\n * model.beginUpdate();\n * try\n * {\n *   model.add(parent, v1, index);\n *   model.add(parent, v2, index+1);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * (end)\n *\n * Of course there is a shortcut for appending a\n * sequence of cells into the default parent:\n *\n * (code)\n * graph.addCells([v1, v2]).\n * (end)\n */\nmxGraphModel.prototype.beginUpdate = function()\n{\n\tthis.updateLevel++;\n\tthis.fireEvent(new mxEventObject(mxEvent.BEGIN_UPDATE));\n\n\tif (this.updateLevel == 1)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.START_EDIT));\n\t}\n};\n\n/**\n * Function: endUpdate\n *\n * Decrements the <updateLevel> by one and fires an <undo>\n * event if the <updateLevel> reaches 0. This function\n * indirectly fires a <change> event by invoking the notify\n * function on the <currentEdit> und then creates a new\n * <currentEdit> using <createUndoableEdit>.\n *\n * The <undo> event is fired only once per edit, whereas\n * the <change> event is fired whenever the notify\n * function is invoked, that is, on undo and redo of\n * the edit.\n */\nmxGraphModel.prototype.endUpdate = function()\n{\n\tthis.updateLevel--;\n\n\tif (this.updateLevel == 0)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.END_EDIT));\n\t}\n\n\tif (!this.endingUpdate)\n\t{\n\t\tthis.endingUpdate = this.updateLevel == 0;\n\t\tthis.fireEvent(new mxEventObject(mxEvent.END_UPDATE, 'edit', this.currentEdit));\n\n\t\ttry\n\t\t{\n\t\t\tif (this.endingUpdate && !this.currentEdit.isEmpty())\n\t\t\t{\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.BEFORE_UNDO, 'edit', this.currentEdit));\n\t\t\t\tvar tmp = this.currentEdit;\n\t\t\t\tthis.currentEdit = this.createUndoableEdit();\n\t\t\t\ttmp.notify();\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', tmp));\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.endingUpdate = false;\n\t\t}\n\t}\n};\n\n/**\n * Function: createUndoableEdit\n *\n * Creates a new <mxUndoableEdit> that implements the\n * notify function to fire a <change> and <notify> event\n * through the <mxUndoableEdit>'s source.\n *\n * Parameters:\n *\n * significant - Optional boolean that specifies if the edit to be created is\n * significant. Default is true.\n */\nmxGraphModel.prototype.createUndoableEdit = function(significant)\n{\n\tvar edit = new mxUndoableEdit(this, (significant != null) ? significant : true);\n\n\tedit.notify = function()\n\t{\n\t\t// LATER: Remove changes property (deprecated)\n\t\tedit.source.fireEvent(new mxEventObject(mxEvent.CHANGE,\n\t\t\t'edit', edit, 'changes', edit.changes));\n\t\tedit.source.fireEvent(new mxEventObject(mxEvent.NOTIFY,\n\t\t\t'edit', edit, 'changes', edit.changes));\n\t};\n\n\treturn edit;\n};\n\n/**\n * Function: mergeChildren\n *\n * Merges the children of the given cell into the given target cell inside\n * this model. All cells are cloned unless there is a corresponding cell in\n * the model with the same id, in which case the source cell is ignored and\n * all edges are connected to the corresponding cell in this model. Edges\n * are considered to have no identity and are always cloned unless the\n * cloneAllEdges flag is set to false, in which case edges with the same\n * id in the target model are reconnected to reflect the terminals of the\n * source edges.\n */\nmxGraphModel.prototype.mergeChildren = function(from, to, cloneAllEdges)\n{\n\tcloneAllEdges = (cloneAllEdges != null) ? cloneAllEdges : true;\n\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tvar mapping = new Object();\n\t\tthis.mergeChildrenImpl(from, to, cloneAllEdges, mapping);\n\n\t\t// Post-processes all edges in the mapping and\n\t\t// reconnects the terminals to the corresponding\n\t\t// cells in the target model\n\t\tfor (var key in mapping)\n\t\t{\n\t\t\tvar cell = mapping[key];\n\t\t\tvar terminal = this.getTerminal(cell, true);\n\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tterminal = mapping[mxCellPath.create(terminal)];\n\t\t\t\tthis.setTerminal(cell, terminal, true);\n\t\t\t}\n\n\t\t\tterminal = this.getTerminal(cell, false);\n\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tterminal = mapping[mxCellPath.create(terminal)];\n\t\t\t\tthis.setTerminal(cell, terminal, false);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: mergeChildren\n *\n * Clones the children of the source cell into the given target cell in\n * this model and adds an entry to the mapping that maps from the source\n * cell to the target cell with the same id or the clone of the source cell\n * that was inserted into this model.\n */\nmxGraphModel.prototype.mergeChildrenImpl = function(from, to, cloneAllEdges, mapping)\n{\n\tthis.beginUpdate();\n\ttry\n\t{\n\t\tvar childCount = from.getChildCount();\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar cell = from.getChildAt(i);\n\n\t\t\tif (typeof(cell.getId) == 'function')\n\t\t\t{\n\t\t\t\tvar id = cell.getId();\n\t\t\t\tvar target = (id != null && (!this.isEdge(cell) || !cloneAllEdges)) ?\n\t\t\t\t\t\tthis.getCell(id) : null;\n\n\t\t\t\t// Clones and adds the child if no cell exists for the id\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\tvar clone = cell.clone();\n\t\t\t\t\tclone.setId(id);\n\n\t\t\t\t\t// Sets the terminals from the original cell to the clone\n\t\t\t\t\t// because the lookup uses strings not cells in JS\n\t\t\t\t\tclone.setTerminal(cell.getTerminal(true), true);\n\t\t\t\t\tclone.setTerminal(cell.getTerminal(false), false);\n\n\t\t\t\t\t// Do *NOT* use model.add as this will move the edge away\n\t\t\t\t\t// from the parent in updateEdgeParent if maintainEdgeParent\n\t\t\t\t\t// is enabled in the target model\n\t\t\t\t\ttarget = to.insert(clone);\n\t\t\t\t\tthis.cellAdded(target);\n\t\t\t\t}\n\n\t\t\t\t// Stores the mapping for later reconnecting edges\n\t\t\t\tmapping[mxCellPath.create(cell)] = target;\n\n\t\t\t\t// Recurses\n\t\t\t\tthis.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.endUpdate();\n\t}\n};\n\n/**\n * Function: getParents\n *\n * Returns an array that represents the set (no duplicates) of all parents\n * for the given array of cells.\n *\n * Parameters:\n *\n * cells - Array of cells whose parents should be returned.\n */\nmxGraphModel.prototype.getParents = function(cells)\n{\n\tvar parents = [];\n\n\tif (cells != null)\n\t{\n\t\tvar dict = new mxDictionary();\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar parent = this.getParent(cells[i]);\n\n\t\t\tif (parent != null && !dict.get(parent))\n\t\t\t{\n\t\t\t\tdict.put(parent, true);\n\t\t\t\tparents.push(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn parents;\n};\n\n//\n// Cell Cloning\n//\n\n/**\n * Function: cloneCell\n *\n * Returns a deep clone of the given <mxCell> (including\n * the children) which is created using <cloneCells>.\n *\n * Parameters:\n *\n * cell - <mxCell> to be cloned.\n */\nmxGraphModel.prototype.cloneCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\treturn this.cloneCells([cell], true)[0];\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: cloneCells\n *\n * Returns an array of clones for the given array of <mxCells>.\n * Depending on the value of includeChildren, a deep clone is created for\n * each cell. Connections are restored based if the corresponding\n * cell is contained in the passed in array.\n *\n * Parameters:\n *\n * cells - Array of <mxCell> to be cloned.\n * includeChildren - Boolean indicating if the cells should be cloned\n * with all descendants.\n * mapping - Optional mapping for existing clones.\n */\nmxGraphModel.prototype.cloneCells = function(cells, includeChildren, mapping)\n{\n\tmapping = (mapping != null) ? mapping : new Object();\n\tvar clones = [];\n\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (cells[i] != null)\n\t\t{\n\t\t\tclones.push(this.cloneCellImpl(cells[i], mapping, includeChildren));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclones.push(null);\n\t\t}\n\t}\n\n\tfor (var i = 0; i < clones.length; i++)\n\t{\n\t\tif (clones[i] != null)\n\t\t{\n\t\t\tthis.restoreClone(clones[i], cells[i], mapping);\n\t\t}\n\t}\n\n\treturn clones;\n};\n\n/**\n * Function: cloneCellImpl\n *\n * Inner helper method for cloning cells recursively.\n */\nmxGraphModel.prototype.cloneCellImpl = function(cell, mapping, includeChildren)\n{\n\tvar ident = mxObjectIdentity.get(cell);\n\tvar clone = mapping[ident];\n\n\tif (clone == null)\n\t{\n\t\tclone = this.cellCloned(cell);\n\t\tmapping[ident] = clone;\n\n\t\tif (includeChildren)\n\t\t{\n\t\t\tvar childCount = this.getChildCount(cell);\n\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar cloneChild = this.cloneCellImpl(\n\t\t\t\t\tthis.getChildAt(cell, i), mapping, true);\n\t\t\t\tclone.insert(cloneChild);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn clone;\n};\n\n/**\n * Function: cellCloned\n *\n * Hook for cloning the cell. This returns cell.clone() or\n * any possible exceptions.\n */\nmxGraphModel.prototype.cellCloned = function(cell)\n{\n\treturn cell.clone();\n};\n\n/**\n * Function: restoreClone\n *\n * Inner helper method for restoring the connections in\n * a network of cloned cells.\n */\nmxGraphModel.prototype.restoreClone = function(clone, cell, mapping)\n{\n\tvar source = this.getTerminal(cell, true);\n\n\tif (source != null)\n\t{\n\t\tvar tmp = mapping[mxObjectIdentity.get(source)];\n\n\t\tif (tmp != null)\n\t\t{\n\t\t\ttmp.insertEdge(clone, true);\n\t\t}\n\t}\n\n\tvar target = this.getTerminal(cell, false);\n\n\tif (target != null)\n\t{\n\t\tvar tmp = mapping[mxObjectIdentity.get(target)];\n\n\t\tif (tmp != null)\n\t\t{\n\t\t\ttmp.insertEdge(clone, false);\n\t\t}\n\t}\n\n\tvar childCount = this.getChildCount(clone);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.restoreClone(this.getChildAt(clone, i),\n\t\t\tthis.getChildAt(cell, i), mapping);\n\t}\n};\n\n//\n// Atomic changes\n//\n\n/**\n * Class: mxRootChange\n *\n * Action to change the root in a model.\n *\n * Constructor: mxRootChange\n *\n * Constructs a change of the root in the\n * specified model.\n */\nfunction mxRootChange(model, root)\n{\n\tthis.model = model;\n\tthis.root = root;\n\tthis.previous = root;\n};\n\n/**\n * Function: execute\n *\n * Carries out a change of the root using\n * <mxGraphModel.rootChanged>.\n */\nmxRootChange.prototype.execute = function()\n{\n\tthis.root = this.previous;\n\tthis.previous = this.model.rootChanged(this.previous);\n};\n\n/**\n * Class: mxChildChange\n *\n * Action to add or remove a child in a model.\n *\n * Constructor: mxChildChange\n *\n * Constructs a change of a child in the\n * specified model.\n */\nfunction mxChildChange(model, parent, child, index)\n{\n\tthis.model = model;\n\tthis.parent = parent;\n\tthis.previous = parent;\n\tthis.child = child;\n\tthis.index = index;\n\tthis.previousIndex = index;\n};\n\n/**\n * Function: execute\n *\n * Changes the parent of <child> using\n * <mxGraphModel.parentForCellChanged> and\n * removes or restores the cell's\n * connections.\n */\nmxChildChange.prototype.execute = function()\n{\n\tif (this.child != null)\n\t{\n\t\tvar tmp = this.model.getParent(this.child);\n\t\tvar tmp2 = (tmp != null) ? tmp.getIndex(this.child) : 0;\n\n\t\tif (this.previous == null)\n\t\t{\n\t\t\tthis.connect(this.child, false);\n\t\t}\n\n\t\ttmp = this.model.parentForCellChanged(\n\t\t\tthis.child, this.previous, this.previousIndex);\n\n\t\tif (this.previous != null)\n\t\t{\n\t\t\tthis.connect(this.child, true);\n\t\t}\n\n\t\tthis.parent = this.previous;\n\t\tthis.previous = tmp;\n\t\tthis.index = this.previousIndex;\n\t\tthis.previousIndex = tmp2;\n\t}\n};\n\n/**\n * Function: disconnect\n *\n * Disconnects the given cell recursively from its\n * terminals and stores the previous terminal in the\n * cell's terminals.\n */\nmxChildChange.prototype.connect = function(cell, isConnect)\n{\n\tisConnect = (isConnect != null) ? isConnect : true;\n\n\tvar source = cell.getTerminal(true);\n\tvar target = cell.getTerminal(false);\n\n\tif (source != null)\n\t{\n\t\tif (isConnect)\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, source, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, null, true);\n\t\t}\n\t}\n\n\tif (target != null)\n\t{\n\t\tif (isConnect)\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, target, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.terminalForCellChanged(cell, null, false);\n\t\t}\n\t}\n\n\tcell.setTerminal(source, true);\n\tcell.setTerminal(target, false);\n\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i=0; i<childCount; i++)\n\t{\n\t\tthis.connect(this.model.getChildAt(cell, i), isConnect);\n\t}\n};\n\n/**\n * Class: mxTerminalChange\n *\n * Action to change a terminal in a model.\n *\n * Constructor: mxTerminalChange\n *\n * Constructs a change of a terminal in the\n * specified model.\n */\nfunction mxTerminalChange(model, cell, terminal, source)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.terminal = terminal;\n\tthis.previous = terminal;\n\tthis.source = source;\n};\n\n/**\n * Function: execute\n *\n * Changes the terminal of <cell> to <previous> using\n * <mxGraphModel.terminalForCellChanged>.\n */\nmxTerminalChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.terminal = this.previous;\n\t\tthis.previous = this.model.terminalForCellChanged(\n\t\t\tthis.cell, this.previous, this.source);\n\t}\n};\n\n/**\n * Class: mxValueChange\n *\n * Action to change a user object in a model.\n *\n * Constructor: mxValueChange\n *\n * Constructs a change of a user object in the\n * specified model.\n */\nfunction mxValueChange(model, cell, value)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.value = value;\n\tthis.previous = value;\n};\n\n/**\n * Function: execute\n *\n * Changes the value of <cell> to <previous> using\n * <mxGraphModel.valueForCellChanged>.\n */\nmxValueChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.value = this.previous;\n\t\tthis.previous = this.model.valueForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxStyleChange\n *\n * Action to change a cell's style in a model.\n *\n * Constructor: mxStyleChange\n *\n * Constructs a change of a style in the\n * specified model.\n */\nfunction mxStyleChange(model, cell, style)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.style = style;\n\tthis.previous = style;\n};\n\n/**\n * Function: execute\n *\n * Changes the style of <cell> to <previous> using\n * <mxGraphModel.styleForCellChanged>.\n */\nmxStyleChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.style = this.previous;\n\t\tthis.previous = this.model.styleForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxGeometryChange\n *\n * Action to change a cell's geometry in a model.\n *\n * Constructor: mxGeometryChange\n *\n * Constructs a change of a geometry in the\n * specified model.\n */\nfunction mxGeometryChange(model, cell, geometry)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.geometry = geometry;\n\tthis.previous = geometry;\n};\n\n/**\n * Function: execute\n *\n * Changes the geometry of <cell> ro <previous> using\n * <mxGraphModel.geometryForCellChanged>.\n */\nmxGeometryChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.geometry = this.previous;\n\t\tthis.previous = this.model.geometryForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxCollapseChange\n *\n * Action to change a cell's collapsed state in a model.\n *\n * Constructor: mxCollapseChange\n *\n * Constructs a change of a collapsed state in the\n * specified model.\n */\nfunction mxCollapseChange(model, cell, collapsed)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.collapsed = collapsed;\n\tthis.previous = collapsed;\n};\n\n/**\n * Function: execute\n *\n * Changes the collapsed state of <cell> to <previous> using\n * <mxGraphModel.collapsedStateForCellChanged>.\n */\nmxCollapseChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.collapsed = this.previous;\n\t\tthis.previous = this.model.collapsedStateForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxVisibleChange\n *\n * Action to change a cell's visible state in a model.\n *\n * Constructor: mxVisibleChange\n *\n * Constructs a change of a visible state in the\n * specified model.\n */\nfunction mxVisibleChange(model, cell, visible)\n{\n\tthis.model = model;\n\tthis.cell = cell;\n\tthis.visible = visible;\n\tthis.previous = visible;\n};\n\n/**\n * Function: execute\n *\n * Changes the visible state of <cell> to <previous> using\n * <mxGraphModel.visibleStateForCellChanged>.\n */\nmxVisibleChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tthis.visible = this.previous;\n\t\tthis.previous = this.model.visibleStateForCellChanged(\n\t\t\tthis.cell, this.previous);\n\t}\n};\n\n/**\n * Class: mxCellAttributeChange\n *\n * Action to change the attribute of a cell's user object.\n * There is no method on the graph model that uses this\n * action. To use the action, you can use the code shown\n * in the example below.\n *\n * Example:\n *\n * To change the attributeName in the cell's user object\n * to attributeValue, use the following code:\n *\n * (code)\n * model.beginUpdate();\n * try\n * {\n *   var edit = new mxCellAttributeChange(\n *     cell, attributeName, attributeValue);\n *   model.execute(edit);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * (end)\n *\n * Constructor: mxCellAttributeChange\n *\n * Constructs a change of a attribute of the DOM node\n * stored as the value of the given <mxCell>.\n */\nfunction mxCellAttributeChange(cell, attribute, value)\n{\n\tthis.cell = cell;\n\tthis.attribute = attribute;\n\tthis.value = value;\n\tthis.previous = value;\n};\n\n/**\n * Function: execute\n *\n * Changes the attribute of the cell's user object by\n * using <mxCell.setAttribute>.\n */\nmxCellAttributeChange.prototype.execute = function()\n{\n\tif (this.cell != null)\n\t{\n\t\tvar tmp = this.cell.getAttribute(this.attribute);\n\n\t\tif (this.previous == null)\n\t\t{\n\t\t\tthis.cell.value.removeAttribute(this.attribute);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.cell.setAttribute(this.attribute, this.previous);\n\t\t}\n\n\t\tthis.previous = tmp;\n\t}\n};\n\n__mxOutput.mxGraphModel = typeof mxGraphModel !== 'undefined' ? mxGraphModel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCell\n *\n * Cells are the elements of the graph model. They represent the state\n * of the groups, vertices and edges in a graph.\n *\n * Custom attributes:\n *\n * For custom attributes we recommend using an XML node as the value of a cell.\n * The following code can be used to create a cell with an XML node as the\n * value:\n *\n * (code)\n * var doc = mxUtils.createXmlDocument();\n * var node = doc.createElement('MyNode')\n * node.setAttribute('label', 'MyLabel');\n * node.setAttribute('attribute1', 'value1');\n * graph.insertVertex(graph.getDefaultParent(), null, node, 40, 40, 80, 30);\n * (end)\n *\n * For the label to work, <mxGraph.convertValueToString> and\n * <mxGraph.cellLabelChanged> should be overridden as follows:\n *\n * (code)\n * graph.convertValueToString = function(cell)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     return cell.getAttribute('label', '')\n *   }\n * };\n *\n * var cellLabelChanged = graph.cellLabelChanged;\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\n * {\n *   if (mxUtils.isNode(cell.value))\n *   {\n *     // Clones the value for correct undo/redo\n *     var elt = cell.value.cloneNode(true);\n *     elt.setAttribute('label', newValue);\n *     newValue = elt;\n *   }\n *\n *   cellLabelChanged.apply(this, arguments);\n * };\n * (end)\n *\n * Callback: onInit\n *\n * Called from within the constructor.\n *\n * Constructor: mxCell\n *\n * Constructs a new cell to be used in a graph model.\n * This method invokes <onInit> upon completion.\n *\n * Parameters:\n *\n * value - Optional object that represents the cell value.\n * geometry - Optional <mxGeometry> that specifies the geometry.\n * style - Optional formatted string that defines the style.\n */\nfunction mxCell(value, geometry, style)\n{\n\tthis.value = value;\n\tthis.setGeometry(geometry);\n\tthis.setStyle(style);\n\n\tif (this.onInit != null)\n\t{\n\t\tthis.onInit();\n\t}\n};\n\n/**\n * Variable: id\n *\n * Holds the Id. Default is null.\n */\nmxCell.prototype.id = null;\n\n/**\n * Variable: value\n *\n * Holds the user object. Default is null.\n */\nmxCell.prototype.value = null;\n\n/**\n * Variable: geometry\n *\n * Holds the <mxGeometry>. Default is null.\n */\nmxCell.prototype.geometry = null;\n\n/**\n * Variable: style\n *\n * Holds the style as a string of the form [(stylename|key=value);]. Default is\n * null.\n */\nmxCell.prototype.style = null;\n\n/**\n * Variable: vertex\n *\n * Specifies whether the cell is a vertex. Default is false.\n */\nmxCell.prototype.vertex = false;\n\n/**\n * Variable: edge\n *\n * Specifies whether the cell is an edge. Default is false.\n */\nmxCell.prototype.edge = false;\n\n/**\n * Variable: connectable\n *\n * Specifies whether the cell is connectable. Default is true.\n */\nmxCell.prototype.connectable = true;\n\n/**\n * Variable: visible\n *\n * Specifies whether the cell is visible. Default is true.\n */\nmxCell.prototype.visible = true;\n\n/**\n * Variable: collapsed\n *\n * Specifies whether the cell is collapsed. Default is false.\n */\nmxCell.prototype.collapsed = false;\n\n/**\n * Variable: parent\n *\n * Reference to the parent cell.\n */\nmxCell.prototype.parent = null;\n\n/**\n * Variable: source\n *\n * Reference to the source terminal.\n */\nmxCell.prototype.source = null;\n\n/**\n * Variable: target\n *\n * Reference to the target terminal.\n */\nmxCell.prototype.target = null;\n\n/**\n * Variable: children\n *\n * Holds the child cells.\n */\nmxCell.prototype.children = null;\n\n/**\n * Variable: edges\n *\n * Holds the edges.\n */\nmxCell.prototype.edges = null;\n\n/**\n * Variable: mxTransient\n *\n * List of members that should not be cloned inside <clone>. This field is\n * passed to <mxUtils.clone> and is not made persistent in <mxCellCodec>.\n * This is not a convention for all classes, it is only used in this class\n * to mark transient fields since transient modifiers are not supported by\n * the language.\n */\nmxCell.prototype.mxTransient = ['id', 'value', 'parent', 'source',\n                                'target', 'children', 'edges'];\n\n/**\n * Function: getId\n *\n * Returns the Id of the cell as a string.\n */\nmxCell.prototype.getId = function()\n{\n\treturn this.id;\n};\n\n/**\n * Function: setId\n *\n * Sets the Id of the cell to the given string.\n */\nmxCell.prototype.setId = function(id)\n{\n\tthis.id = id;\n};\n\n/**\n * Function: getValue\n *\n * Returns the user object of the cell. The user\n * object is stored in <value>.\n */\nmxCell.prototype.getValue = function()\n{\n\treturn this.value;\n};\n\n/**\n * Function: setValue\n *\n * Sets the user object of the cell. The user object\n * is stored in <value>.\n */\nmxCell.prototype.setValue = function(value)\n{\n\tthis.value = value;\n};\n\n/**\n * Function: valueChanged\n *\n * Changes the user object after an in-place edit\n * and returns the previous value. This implementation\n * replaces the user object with the given value and\n * returns the old user object.\n */\nmxCell.prototype.valueChanged = function(newValue)\n{\n\tvar previous = this.getValue();\n\tthis.setValue(newValue);\n\n\treturn previous;\n};\n\n/**\n * Function: getGeometry\n *\n * Returns the <mxGeometry> that describes the <geometry>.\n */\nmxCell.prototype.getGeometry = function()\n{\n\treturn this.geometry;\n};\n\n/**\n * Function: setGeometry\n *\n * Sets the <mxGeometry> to be used as the <geometry>.\n */\nmxCell.prototype.setGeometry = function(geometry)\n{\n\tthis.geometry = geometry;\n};\n\n/**\n * Function: getStyle\n *\n * Returns a string that describes the <style>.\n */\nmxCell.prototype.getStyle = function()\n{\n\treturn this.style;\n};\n\n/**\n * Function: setStyle\n *\n * Sets the string to be used as the <style>.\n */\nmxCell.prototype.setStyle = function(style)\n{\n\tthis.style = style;\n};\n\n/**\n * Function: isVertex\n *\n * Returns true if the cell is a vertex.\n */\nmxCell.prototype.isVertex = function()\n{\n\treturn this.vertex != 0;\n};\n\n/**\n * Function: setVertex\n *\n * Specifies if the cell is a vertex. This should only be assigned at\n * construction of the cell and not be changed during its lifecycle.\n *\n * Parameters:\n *\n * vertex - Boolean that specifies if the cell is a vertex.\n */\nmxCell.prototype.setVertex = function(vertex)\n{\n\tthis.vertex = vertex;\n};\n\n/**\n * Function: isEdge\n *\n * Returns true if the cell is an edge.\n */\nmxCell.prototype.isEdge = function()\n{\n\treturn this.edge != 0;\n};\n\n/**\n * Function: setEdge\n *\n * Specifies if the cell is an edge. This should only be assigned at\n * construction of the cell and not be changed during its lifecycle.\n *\n * Parameters:\n *\n * edge - Boolean that specifies if the cell is an edge.\n */\nmxCell.prototype.setEdge = function(edge)\n{\n\tthis.edge = edge;\n};\n\n/**\n * Function: isConnectable\n *\n * Returns true if the cell is connectable.\n */\nmxCell.prototype.isConnectable = function()\n{\n\treturn this.connectable != 0;\n};\n\n/**\n * Function: setConnectable\n *\n * Sets the connectable state.\n *\n * Parameters:\n *\n * connectable - Boolean that specifies the new connectable state.\n */\nmxCell.prototype.setConnectable = function(connectable)\n{\n\tthis.connectable = connectable;\n};\n\n/**\n * Function: isVisible\n *\n * Returns true if the cell is visibile.\n */\nmxCell.prototype.isVisible = function()\n{\n\treturn this.visible != 0;\n};\n\n/**\n * Function: setVisible\n *\n * Specifies if the cell is visible.\n *\n * Parameters:\n *\n * visible - Boolean that specifies the new visible state.\n */\nmxCell.prototype.setVisible = function(visible)\n{\n\tthis.visible = visible;\n};\n\n/**\n * Function: isCollapsed\n *\n * Returns true if the cell is collapsed.\n */\nmxCell.prototype.isCollapsed = function()\n{\n\treturn this.collapsed != 0;\n};\n\n/**\n * Function: setCollapsed\n *\n * Sets the collapsed state.\n *\n * Parameters:\n *\n * collapsed - Boolean that specifies the new collapsed state.\n */\nmxCell.prototype.setCollapsed = function(collapsed)\n{\n\tthis.collapsed = collapsed;\n};\n\n/**\n * Function: getParent\n *\n * Returns the cell's parent.\n */\nmxCell.prototype.getParent = function()\n{\n\treturn this.parent;\n};\n\n/**\n * Function: setParent\n *\n * Sets the parent cell.\n *\n * Parameters:\n *\n * parent - <mxCell> that represents the new parent.\n */\nmxCell.prototype.setParent = function(parent)\n{\n\tthis.parent = parent;\n};\n\n/**\n * Function: getTerminal\n *\n * Returns the source or target terminal.\n *\n * Parameters:\n *\n * source - Boolean that specifies if the source terminal should be\n * returned.\n */\nmxCell.prototype.getTerminal = function(source)\n{\n\treturn (source) ? this.source : this.target;\n};\n\n/**\n * Function: setTerminal\n *\n * Sets the source or target terminal and returns the new terminal.\n *\n * Parameters:\n *\n * terminal - <mxCell> that represents the new source or target terminal.\n * isSource - Boolean that specifies if the source or target terminal\n * should be set.\n */\nmxCell.prototype.setTerminal = function(terminal, isSource)\n{\n\tif (isSource)\n\t{\n\t\tthis.source = terminal;\n\t}\n\telse\n\t{\n\t\tthis.target = terminal;\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: getChildCount\n *\n * Returns the number of child cells.\n */\nmxCell.prototype.getChildCount = function()\n{\n\treturn (this.children == null) ? 0 : this.children.length;\n};\n\n/**\n * Function: getIndex\n *\n * Returns the index of the specified child in the child array.\n *\n * Parameters:\n *\n * child - Child whose index should be returned.\n */\nmxCell.prototype.getIndex = function(child)\n{\n\treturn mxUtils.indexOf(this.children, child);\n};\n\n/**\n * Function: getChildAt\n *\n * Returns the child at the specified index.\n *\n * Parameters:\n *\n * index - Integer that specifies the child to be returned.\n */\nmxCell.prototype.getChildAt = function(index)\n{\n\treturn (this.children == null) ? null : this.children[index];\n};\n\n/**\n * Function: insert\n *\n * Inserts the specified child into the child array at the specified index\n * and updates the parent reference of the child. If not childIndex is\n * specified then the child is appended to the child array. Returns the\n * inserted child.\n *\n * Parameters:\n *\n * child - <mxCell> to be inserted or appended to the child array.\n * index - Optional integer that specifies the index at which the child\n * should be inserted into the child array.\n */\nmxCell.prototype.insert = function(child, index)\n{\n\tif (child != null)\n\t{\n\t\tif (index == null)\n\t\t{\n\t\t\tindex = this.getChildCount();\n\n\t\t\tif (child.getParent() == this)\n\t\t\t{\n\t\t\t\tindex--;\n\t\t\t}\n\t\t}\n\n\t\tchild.removeFromParent();\n\t\tchild.setParent(this);\n\n\t\tif (this.children == null)\n\t\t{\n\t\t\tthis.children = [];\n\t\t\tthis.children.push(child);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.children.splice(index, 0, child);\n\t\t}\n\t}\n\n\treturn child;\n};\n\n/**\n * Function: remove\n *\n * Removes the child at the specified index from the child array and\n * returns the child that was removed. Will remove the parent reference of\n * the child.\n *\n * Parameters:\n *\n * index - Integer that specifies the index of the child to be\n * removed.\n */\nmxCell.prototype.remove = function(index)\n{\n\tvar child = null;\n\n\tif (this.children != null && index >= 0)\n\t{\n\t\tchild = this.getChildAt(index);\n\n\t\tif (child != null)\n\t\t{\n\t\t\tthis.children.splice(index, 1);\n\t\t\tchild.setParent(null);\n\t\t}\n\t}\n\n\treturn child;\n};\n\n/**\n * Function: removeFromParent\n *\n * Removes the cell from its parent.\n */\nmxCell.prototype.removeFromParent = function()\n{\n\tif (this.parent != null)\n\t{\n\t\tvar index = this.parent.getIndex(this);\n\t\tthis.parent.remove(index);\n\t}\n};\n\n/**\n * Function: getEdgeCount\n *\n * Returns the number of edges in the edge array.\n */\nmxCell.prototype.getEdgeCount = function()\n{\n\treturn (this.edges == null) ? 0 : this.edges.length;\n};\n\n/**\n * Function: getEdgeIndex\n *\n * Returns the index of the specified edge in <edges>.\n *\n * Parameters:\n *\n * edge - <mxCell> whose index in <edges> should be returned.\n */\nmxCell.prototype.getEdgeIndex = function(edge)\n{\n\treturn mxUtils.indexOf(this.edges, edge);\n};\n\n/**\n * Function: getEdgeAt\n *\n * Returns the edge at the specified index in <edges>.\n *\n * Parameters:\n *\n * index - Integer that specifies the index of the edge to be returned.\n */\nmxCell.prototype.getEdgeAt = function(index)\n{\n\treturn (this.edges == null) ? null : this.edges[index];\n};\n\n/**\n * Function: insertEdge\n *\n * Inserts the specified edge into the edge array and returns the edge.\n * Will update the respective terminal reference of the edge.\n *\n * Parameters:\n *\n * edge - <mxCell> to be inserted into the edge array.\n * isOutgoing - Boolean that specifies if the edge is outgoing.\n */\nmxCell.prototype.insertEdge = function(edge, isOutgoing)\n{\n\tif (edge != null)\n\t{\n\t\tedge.removeFromTerminal(isOutgoing);\n\t\tedge.setTerminal(this, isOutgoing);\n\n\t\tif (this.edges == null ||\n\t\t\tedge.getTerminal(!isOutgoing) != this ||\n\t\t\tmxUtils.indexOf(this.edges, edge) < 0)\n\t\t{\n\t\t\tif (this.edges == null)\n\t\t\t{\n\t\t\t\tthis.edges = [];\n\t\t\t}\n\n\t\t\tthis.edges.push(edge);\n\t\t}\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: removeEdge\n *\n * Removes the specified edge from the edge array and returns the edge.\n * Will remove the respective terminal reference from the edge.\n *\n * Parameters:\n *\n * edge - <mxCell> to be removed from the edge array.\n * isOutgoing - Boolean that specifies if the edge is outgoing.\n */\nmxCell.prototype.removeEdge = function(edge, isOutgoing)\n{\n\tif (edge != null)\n\t{\n\t\tif (edge.getTerminal(!isOutgoing) != this &&\n\t\t\tthis.edges != null)\n\t\t{\n\t\t\tvar index = this.getEdgeIndex(edge);\n\n\t\t\tif (index >= 0)\n\t\t\t{\n\t\t\t\tthis.edges.splice(index, 1);\n\t\t\t}\n\t\t}\n\n\t\tedge.setTerminal(null, isOutgoing);\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: removeFromTerminal\n *\n * Removes the edge from its source or target terminal.\n *\n * Parameters:\n *\n * isSource - Boolean that specifies if the edge should be removed from its\n * source or target terminal.\n */\nmxCell.prototype.removeFromTerminal = function(isSource)\n{\n\tvar terminal = this.getTerminal(isSource);\n\n\tif (terminal != null)\n\t{\n\t\tterminal.removeEdge(this, isSource);\n\t}\n};\n\n/**\n * Function: hasAttribute\n *\n * Returns true if the user object is an XML node that contains the given\n * attribute.\n *\n * Parameters:\n *\n * name - Name of the attribute.\n */\nmxCell.prototype.hasAttribute = function(name)\n{\n\tvar userObject = this.getValue();\n\n\treturn (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT && userObject.hasAttribute) ?\n\t\tuserObject.hasAttribute(name) : userObject.getAttribute(name) != null;\n};\n\n/**\n * Function: getAttribute\n *\n * Returns the specified attribute from the user object if it is an XML\n * node.\n *\n * Parameters:\n *\n * name - Name of the attribute whose value should be returned.\n * defaultValue - Optional default value to use if the attribute has no\n * value.\n */\nmxCell.prototype.getAttribute = function(name, defaultValue)\n{\n\tvar userObject = this.getValue();\n\n\tvar val = (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT) ?\n\t\tuserObject.getAttribute(name) : null;\n\n\treturn val || defaultValue;\n};\n\n/**\n * Function: setAttribute\n *\n * Sets the specified attribute on the user object if it is an XML node.\n *\n * Parameters:\n *\n * name - Name of the attribute whose value should be set.\n * value - New value of the attribute.\n */\nmxCell.prototype.setAttribute = function(name, value)\n{\n\tvar userObject = this.getValue();\n\n\tif (userObject != null &&\n\t\tuserObject.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tuserObject.setAttribute(name, value);\n\t}\n};\n\n/**\n * Function: clone\n *\n * Returns a clone of the cell. Uses <cloneValue> to clone\n * the user object. All fields in <mxTransient> are ignored\n * during the cloning.\n */\nmxCell.prototype.clone = function()\n{\n\tvar clone = mxUtils.clone(this, this.mxTransient);\n\tclone.setValue(this.cloneValue());\n\n\treturn clone;\n};\n\n/**\n * Function: cloneValue\n *\n * Returns a clone of the cell's user object.\n */\nmxCell.prototype.cloneValue = function()\n{\n\tvar value = this.getValue();\n\n\tif (value != null)\n\t{\n\t\tif (typeof(value.clone) == 'function')\n\t\t{\n\t\t\tvalue = value.clone();\n\t\t}\n\t\telse if (!isNaN(value.nodeType))\n\t\t{\n\t\t\tvalue = value.cloneNode(true);\n\t\t}\n\t}\n\n\treturn value;\n};\n\n__mxOutput.mxCell = typeof mxCell !== 'undefined' ? mxCell : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGeometry\n *\n * Extends <mxRectangle> to represent the geometry of a cell.\n *\n * For vertices, the geometry consists of the x- and y-location, and the width\n * and height. For edges, the geometry consists of the optional terminal- and\n * control points. The terminal points are only required if an edge is\n * unconnected, and are stored in the sourcePoint> and <targetPoint>\n * variables, respectively.\n *\n * Example:\n *\n * If an edge is unconnected, that is, it has no source or target terminal,\n * then a geometry with terminal points for a new edge can be defined as\n * follows.\n *\n * (code)\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\n * geometry.points = [new mxPoint(x2, y2)];\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\n * (end)\n *\n * Control points are used regardless of the connected state of an edge and may\n * be ignored or interpreted differently depending on the edge's <mxEdgeStyle>.\n *\n * To disable automatic reset of control points after a cell has been moved or\n * resized, the the <mxGraph.resizeEdgesOnMove> and\n * <mxGraph.resetEdgesOnResize> may be used.\n *\n * Edge Labels:\n *\n * Using the x- and y-coordinates of a cell's geometry, it is possible to\n * position the label on edges on a specific location on the actual edge shape\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\n * to describe the distance from the center of the edge from -1 to 1 with 0\n * being the center of the edge and the default value. The y-coordinate of an\n * edge's geometry is used to describe the absolute, orthogonal distance in\n * pixels from that point. In addition, the <mxGeometry.offset> is used as an\n * absolute offset vector from the resulting point.\n *\n * This coordinate system is applied if <relative> is true, otherwise the\n * offset defines the absolute vector from the edge's center point to the\n * label and the values for <x> and <y> are ignored.\n *\n * The width and height parameter for edge geometries can be used to set the\n * label width and height (eg. for word wrapping).\n *\n * Ports:\n *\n * The term \"port\" refers to a relatively positioned, connectable child cell,\n * which is used to specify the connection between the parent and another cell\n * in the graph. Ports are typically modeled as vertices with relative\n * geometries.\n *\n * Offsets:\n *\n * The <offset> field is interpreted in 3 different ways, depending on the cell\n * and the geometry. For edges, the offset defines the absolute offset for the\n * edge label. For relative geometries, the offset defines the absolute offset\n * for the origin (top, left corner) of the vertex, otherwise the offset\n * defines the absolute offset for the label inside the vertex or group.\n *\n * Constructor: mxGeometry\n *\n * Constructs a new object to describe the size and location of a vertex or\n * the control points of an edge.\n */\nfunction mxGeometry(x, y, width, height)\n{\n\tmxRectangle.call(this, x, y, width, height);\n};\n\n/**\n * Extends mxRectangle.\n */\nmxGeometry.prototype = new mxRectangle();\nmxGeometry.prototype.constructor = mxGeometry;\n\n/**\n * Variable: TRANSLATE_CONTROL_POINTS\n *\n * Global switch to translate the points in translate. Default is true.\n */\nmxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;\n\n/**\n * Variable: alternateBounds\n *\n * Stores alternate values for x, y, width and height in a rectangle. See\n * <swap> to exchange the values. Default is null.\n */\nmxGeometry.prototype.alternateBounds = null;\n\n/**\n * Variable: sourcePoint\n *\n * Defines the source <mxPoint> of the edge. This is used if the\n * corresponding edge does not have a source vertex. Otherwise it is\n * ignored. Default is  null.\n */\nmxGeometry.prototype.sourcePoint = null;\n\n/**\n * Variable: targetPoint\n *\n * Defines the target <mxPoint> of the edge. This is used if the\n * corresponding edge does not have a target vertex. Otherwise it is\n * ignored. Default is null.\n */\nmxGeometry.prototype.targetPoint = null;\n\n/**\n * Variable: points\n *\n * Array of <mxPoints> which specifies the control points along the edge.\n * These points are the intermediate points on the edge, for the endpoints\n * use <targetPoint> and <sourcePoint> or set the terminals of the edge to\n * a non-null value. Default is null.\n */\nmxGeometry.prototype.points = null;\n\n/**\n * Variable: offset\n *\n * For edges, this holds the offset (in pixels) from the position defined\n * by <x> and <y> on the edge. For relative geometries (for vertices), this\n * defines the absolute offset from the point defined by the relative\n * coordinates. For absolute geometries (for vertices), this defines the\n * offset for the label. Default is null.\n */\nmxGeometry.prototype.offset = null;\n\n/**\n * Variable: relative\n *\n * Specifies if the coordinates in the geometry are to be interpreted as\n * relative coordinates. For edges, this is used to define the location of\n * the edge label relative to the edge as rendered on the display. For\n * vertices, this specifies the relative location inside the bounds of the\n * parent cell.\n *\n * If this is false, then the coordinates are relative to the origin of the\n * parent cell or, for edges, the edge label position is relative to the\n * center of the edge as rendered on screen.\n *\n * Default is false.\n */\nmxGeometry.prototype.relative = false;\n\n/**\n * Function: swap\n *\n * Swaps the x, y, width and height with the values stored in\n * <alternateBounds> and puts the previous values into <alternateBounds> as\n * a rectangle. This operation is carried-out in-place, that is, using the\n * existing geometry instance. If this operation is called during a graph\n * model transactional change, then the geometry should be cloned before\n * calling this method and setting the geometry of the cell using\n * <mxGraphModel.setGeometry>.\n */\nmxGeometry.prototype.swap = function()\n{\n\tif (this.alternateBounds != null)\n\t{\n\t\tvar old = new mxRectangle(\n\t\t\tthis.x, this.y, this.width, this.height);\n\n\t\tthis.x = this.alternateBounds.x;\n\t\tthis.y = this.alternateBounds.y;\n\t\tthis.width = this.alternateBounds.width;\n\t\tthis.height = this.alternateBounds.height;\n\n\t\tthis.alternateBounds = old;\n\t}\n};\n\n/**\n * Function: getTerminalPoint\n *\n * Returns the <mxPoint> representing the source or target point of this\n * edge. This is only used if the edge has no source or target vertex.\n *\n * Parameters:\n *\n * isSource - Boolean that specifies if the source or target point\n * should be returned.\n */\nmxGeometry.prototype.getTerminalPoint = function(isSource)\n{\n\treturn (isSource) ? this.sourcePoint : this.targetPoint;\n};\n\n/**\n * Function: setTerminalPoint\n *\n * Sets the <sourcePoint> or <targetPoint> to the given <mxPoint> and\n * returns the new point.\n *\n * Parameters:\n *\n * point - Point to be used as the new source or target point.\n * isSource - Boolean that specifies if the source or target point\n * should be set.\n */\nmxGeometry.prototype.setTerminalPoint = function(point, isSource)\n{\n\tif (isSource)\n\t{\n\t\tthis.sourcePoint = point;\n\t}\n\telse\n\t{\n\t\tthis.targetPoint = point;\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: rotate\n *\n * Rotates the geometry by the given angle around the given center. That is,\n * <x> and <y> of the geometry, the <sourcePoint>, <targetPoint> and all\n * <points> are translated by the given amount. <x> and <y> are only\n * translated if <relative> is false.\n *\n * Parameters:\n *\n * angle - Number that specifies the rotation angle in degrees.\n * cx - <mxPoint> that specifies the center of the rotation.\n */\nmxGeometry.prototype.rotate = function(angle, cx)\n{\n\tvar rad = mxUtils.toRadians(angle);\n\tvar cos = Math.cos(rad);\n\tvar sin = Math.sin(rad);\n\n\t// Rotates the geometry\n\tif (!this.relative)\n\t{\n\t\tvar ct = new mxPoint(this.getCenterX(), this.getCenterY());\n\t\tvar pt = mxUtils.getRotatedPoint(ct, cos, sin, cx);\n\n\t\tthis.x = Math.round(pt.x - this.width / 2);\n\t\tthis.y = Math.round(pt.y - this.height / 2);\n\t}\n\n\t// Rotates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tvar pt = mxUtils.getRotatedPoint(this.sourcePoint, cos, sin, cx);\n\t\tthis.sourcePoint.x = Math.round(pt.x);\n\t\tthis.sourcePoint.y = Math.round(pt.y);\n\t}\n\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tvar pt = mxUtils.getRotatedPoint(this.targetPoint, cos, sin, cx);\n\t\tthis.targetPoint.x = Math.round(pt.x);\n\t\tthis.targetPoint.y = Math.round(pt.y);\n\t}\n\n\t// Translate the control points\n\tif (this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(this.points[i], cos, sin, cx);\n\t\t\t\tthis.points[i].x = Math.round(pt.x);\n\t\t\t\tthis.points[i].y = Math.round(pt.y);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: translate\n *\n * Translates the geometry by the specified amount. That is, <x> and <y> of the\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are translated\n * by the given amount. <x> and <y> are only translated if <relative> is false.\n * If <TRANSLATE_CONTROL_POINTS> is false, then <points> are not modified by\n * this function.\n *\n * Parameters:\n *\n * dx - Number that specifies the x-coordinate of the translation.\n * dy - Number that specifies the y-coordinate of the translation.\n */\nmxGeometry.prototype.translate = function(dx, dy)\n{\n\tdx = parseFloat(dx);\n\tdy = parseFloat(dy);\n\n\t// Translates the geometry\n\tif (!this.relative)\n\t{\n\t\tthis.x = parseFloat(this.x) + dx;\n\t\tthis.y = parseFloat(this.y) + dy;\n\t}\n\n\t// Translates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tthis.sourcePoint.x = parseFloat(this.sourcePoint.x) + dx;\n\t\tthis.sourcePoint.y = parseFloat(this.sourcePoint.y) + dy;\n\t}\n\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tthis.targetPoint.x = parseFloat(this.targetPoint.x) + dx;\n\t\tthis.targetPoint.y = parseFloat(this.targetPoint.y) + dy;\n\t}\n\n\t// Translate the control points\n\tif (this.TRANSLATE_CONTROL_POINTS && this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tthis.points[i].x = parseFloat(this.points[i].x) + dx;\n\t\t\t\tthis.points[i].y = parseFloat(this.points[i].y) + dy;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: scale\n *\n * Scales the geometry by the given amount. That is, <x> and <y> of the\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are scaled\n * by the given amount. <x>, <y>, <width> and <height> are only scaled if\n * <relative> is false. If <fixedAspect> is true, then the smaller value\n * is used to scale the width and the height.\n *\n * Parameters:\n *\n * sx - Number that specifies the horizontal scale factor.\n * sy - Number that specifies the vertical scale factor.\n * fixedAspect - Optional boolean to keep the aspect ratio fixed.\n */\nmxGeometry.prototype.scale = function(sx, sy, fixedAspect)\n{\n\tsx = parseFloat(sx);\n\tsy = parseFloat(sy);\n\n\t// Translates the source point\n\tif (this.sourcePoint != null)\n\t{\n\t\tthis.sourcePoint.x = parseFloat(this.sourcePoint.x) * sx;\n\t\tthis.sourcePoint.y = parseFloat(this.sourcePoint.y) * sy;\n\t}\n\n\t// Translates the target point\n\tif (this.targetPoint != null)\n\t{\n\t\tthis.targetPoint.x = parseFloat(this.targetPoint.x) * sx;\n\t\tthis.targetPoint.y = parseFloat(this.targetPoint.y) * sy;\n\t}\n\n\t// Translate the control points\n\tif (this.points != null)\n\t{\n\t\tfor (var i = 0; i < this.points.length; i++)\n\t\t{\n\t\t\tif (this.points[i] != null)\n\t\t\t{\n\t\t\t\tthis.points[i].x = parseFloat(this.points[i].x) * sx;\n\t\t\t\tthis.points[i].y = parseFloat(this.points[i].y) * sy;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Translates the geometry\n\tif (!this.relative)\n\t{\n\t\tthis.x = parseFloat(this.x) * sx;\n\t\tthis.y = parseFloat(this.y) * sy;\n\n\t\tif (fixedAspect)\n\t\t{\n\t\t\tsy = sx = Math.min(sx, sy);\n\t\t}\n\n\t\tthis.width = parseFloat(this.width) * sx;\n\t\tthis.height = parseFloat(this.height) * sy;\n\t}\n};\n\n/**\n * Function: equals\n *\n * Returns true if the given object equals this geometry.\n */\nmxGeometry.prototype.equals = function(obj)\n{\n\treturn mxRectangle.prototype.equals.apply(this, arguments) &&\n\t\tthis.relative == obj.relative &&\n\t\t((this.sourcePoint == null && obj.sourcePoint == null) || (this.sourcePoint != null && this.sourcePoint.equals(obj.sourcePoint))) &&\n\t\t((this.targetPoint == null && obj.targetPoint == null) || (this.targetPoint != null && this.targetPoint.equals(obj.targetPoint))) &&\n\t\t((this.points == null && obj.points == null) || (this.points != null && mxUtils.equalPoints(this.points, obj.points))) &&\n\t\t((this.alternateBounds == null && obj.alternateBounds == null) || (this.alternateBounds != null && this.alternateBounds.equals(obj.alternateBounds))) &&\n\t\t((this.offset == null && obj.offset == null) || (this.offset != null && this.offset.equals(obj.offset)));\n};\n\n__mxOutput.mxGeometry = typeof mxGeometry !== 'undefined' ? mxGeometry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxCellPath =\n{\n\n\t/**\n\t * Class: mxCellPath\n\t *\n\t * Implements a mechanism for temporary cell Ids.\n\t *\n\t * Variable: PATH_SEPARATOR\n\t *\n\t * Defines the separator between the path components. Default is \".\".\n\t */\n\tPATH_SEPARATOR: '.',\n\n\t/**\n\t * Function: create\n\t *\n\t * Creates the cell path for the given cell. The cell path is a\n\t * concatenation of the indices of all ancestors on the (finite) path to\n\t * the root, eg. \"0.0.0.1\".\n\t *\n\t * Parameters:\n\t *\n\t * cell - Cell whose path should be returned.\n\t */\n\tcreate: function(cell)\n\t{\n\t\tvar result = '';\n\n\t\tif (cell != null)\n\t\t{\n\t\t\tvar parent = cell.getParent();\n\n\t\t\twhile (parent != null)\n\t\t\t{\n\t\t\t\tvar index = parent.getIndex(cell);\n\t\t\t\tresult = index + mxCellPath.PATH_SEPARATOR + result;\n\n\t\t\t\tcell = parent;\n\t\t\t\tparent = cell.getParent();\n\t\t\t}\n\t\t}\n\n\t\t// Removes trailing separator\n\t\tvar n = result.length;\n\n\t\tif (n > 1)\n\t\t{\n\t\t\tresult = result.substring(0, n - 1);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: getParentPath\n\t *\n\t * Returns the path for the parent of the cell represented by the given\n\t * path. Returns null if the given path has no parent.\n\t *\n\t * Parameters:\n\t *\n\t * path - Path whose parent path should be returned.\n\t */\n\tgetParentPath: function(path)\n\t{\n\t\tif (path != null)\n\t\t{\n\t\t\tvar index = path.lastIndexOf(mxCellPath.PATH_SEPARATOR);\n\n\t\t\tif (index >= 0)\n\t\t\t{\n\t\t\t\treturn path.substring(0, index);\n\t\t\t}\n\t\t\telse if (path.length > 0)\n\t\t\t{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Function: resolve\n\t *\n\t * Returns the cell for the specified cell path using the given root as the\n\t * root of the path.\n\t *\n\t * Parameters:\n\t *\n\t * root - Root cell of the path to be resolved.\n\t * path - String that defines the path.\n\t */\n\tresolve: function(root, path)\n\t{\n\t\tvar parent = root;\n\n\t\tif (path != null)\n\t\t{\n\t\t\tvar tokens = path.split(mxCellPath.PATH_SEPARATOR);\n\n\t\t\tfor (var i=0; i<tokens.length; i++)\n\t\t\t{\n\t\t\t\tparent = parent.getChildAt(parseInt(tokens[i]));\n\t\t\t}\n\t\t}\n\n\t\treturn parent;\n\t},\n\n\t/**\n\t * Function: compare\n\t *\n\t * Compares the given cell paths and returns -1 if p1 is smaller, 0 if\n\t * p1 is equal and 1 if p1 is greater than p2.\n\t */\n\tcompare: function(p1, p2)\n\t{\n\t\tvar min = Math.min(p1.length, p2.length);\n\t\tvar comp = 0;\n\n\t\tfor (var i = 0; i < min; i++)\n\t\t{\n\t\t\tif (p1[i] != p2[i])\n\t\t\t{\n\t\t\t\tif (p1[i].length == 0 ||\n\t\t\t\t\tp2[i].length == 0)\n\t\t\t\t{\n\t\t\t\t\tcomp = (p1[i] == p2[i]) ? 0 : ((p1[i] > p2[i]) ? 1 : -1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar t1 = parseInt(p1[i]);\n\t\t\t\t\tvar t2 = parseInt(p2[i]);\n\n\t\t\t\t\tcomp = (t1 == t2) ? 0 : ((t1 > t2) ? 1 : -1);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Compares path length if both paths are equal to this point\n\t\tif (comp == 0)\n\t\t{\n\t\t\tvar t1 = p1.length;\n\t\t\tvar t2 = p2.length;\n\n\t\t\tif (t1 != t2)\n\t\t\t{\n\t\t\t\tcomp = (t1 > t2) ? 1 : -1;\n\t\t\t}\n\t\t}\n\n\t\treturn comp;\n\t}\n\n};\n\n__mxOutput.mxCellPath = typeof mxCellPath !== 'undefined' ? mxCellPath : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxPerimeter =\n{\n\t/**\n\t * Class: mxPerimeter\n\t *\n\t * Provides various perimeter functions to be used in a style\n\t * as the value of <mxConstants.STYLE_PERIMETER>. Perimeters for\n\t * rectangle, circle, rhombus and triangle are available.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>\n\t * (end)\n\t *\n\t * Or programmatically:\n\t *\n\t * (code)\n\t * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n\t * (end)\n\t *\n\t * When adding new perimeter functions, it is recommended to use the\n\t * mxPerimeter-namespace as follows:\n\t *\n\t * (code)\n\t * mxPerimeter.CustomPerimeter = function (bounds, vertex, next, orthogonal)\n\t * {\n\t *   var x = 0; // Calculate x-coordinate\n\t *   var y = 0; // Calculate y-coordainte\n\t *\n\t *   return new mxPoint(x, y);\n\t * }\n\t * (end)\n\t *\n\t * The new perimeter should then be registered in the <mxStyleRegistry> as follows:\n\t * (code)\n\t * mxStyleRegistry.putValue('customPerimeter', mxPerimeter.CustomPerimeter);\n\t * (end)\n\t *\n\t * The custom perimeter above can now be used in a specific vertex as follows:\n\t *\n\t * (code)\n\t * model.setStyle(vertex, 'perimeter=customPerimeter');\n\t * (end)\n\t *\n\t * Note that the key of the <mxStyleRegistry> entry for the function should\n\t * be used in string values, unless <mxGraphView.allowEval> is true, in\n\t * which case you can also use mxPerimeter.CustomPerimeter for the value in\n\t * the cell style above.\n\t *\n\t * Or it can be used for all vertices in the graph as follows:\n\t *\n\t * (code)\n\t * var style = graph.getStylesheet().getDefaultVertexStyle();\n\t * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.CustomPerimeter;\n\t * (end)\n\t *\n\t * Note that the object can be used directly when programmatically setting\n\t * the value, but the key in the <mxStyleRegistry> should be used when\n\t * setting the value via a key, value pair in a cell style.\n\t *\n\t * The parameters are explained in <RectanglePerimeter>.\n\t *\n\t * Function: RectanglePerimeter\n\t *\n\t * Describes a rectangular perimeter for the given bounds.\n\t *\n\t * Parameters:\n\t *\n\t * bounds - <mxRectangle> that represents the absolute bounds of the\n\t * vertex.\n\t * vertex - <mxCellState> that represents the vertex.\n\t * next - <mxPoint> that represents the nearest neighbour point on the\n\t * given edge.\n\t * orthogonal - Boolean that specifies if the orthogonal projection onto\n\t * the perimeter should be returned. If this is false then the intersection\n\t * of the perimeter and the line between the next and the center point is\n\t * returned.\n\t */\n\tRectanglePerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar cx = bounds.getCenterX();\n\t\tvar cy = bounds.getCenterY();\n\t\tvar dx = next.x - cx;\n\t\tvar dy = next.y - cy;\n\t\tvar alpha = Math.atan2(dy, dx);\n\t\tvar p = new mxPoint(0, 0);\n\t\tvar pi = Math.PI;\n\t\tvar pi2 = Math.PI/2;\n\t\tvar beta = pi2 - alpha;\n\t\tvar t = Math.atan2(bounds.height, bounds.width);\n\n\t\tif (alpha < -pi + t || alpha > pi - t)\n\t\t{\n\t\t\t// Left edge\n\t\t\tp.x = bounds.x;\n\t\t\tp.y = cy - bounds.width * Math.tan(alpha) / 2;\n\t\t}\n\t\telse if (alpha < -t)\n\t\t{\n\t\t\t// Top Edge\n\t\t\tp.y = bounds.y;\n\t\t\tp.x = cx - bounds.height * Math.tan(beta) / 2;\n\t\t}\n\t\telse if (alpha < t)\n\t\t{\n\t\t\t// Right Edge\n\t\t\tp.x = bounds.x + bounds.width;\n\t\t\tp.y = cy + bounds.width * Math.tan(alpha) / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Bottom Edge\n\t\t\tp.y = bounds.y + bounds.height;\n\t\t\tp.x = cx + bounds.height * Math.tan(beta) / 2;\n\t\t}\n\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (next.x >= bounds.x &&\n\t\t\t\tnext.x <= bounds.x + bounds.width)\n\t\t\t{\n\t\t\t\tp.x = next.x;\n\t\t\t}\n\t\t\telse if (next.y >= bounds.y &&\n\t\t\t\t\t   next.y <= bounds.y + bounds.height)\n\t\t\t{\n\t\t\t\tp.y = next.y;\n\t\t\t}\n\t\t\tif (next.x < bounds.x)\n\t\t\t{\n\t\t\t\tp.x = bounds.x;\n\t\t\t}\n\t\t\telse if (next.x > bounds.x + bounds.width)\n\t\t\t{\n\t\t\t\tp.x = bounds.x + bounds.width;\n\t\t\t}\n\t\t\tif (next.y < bounds.y)\n\t\t\t{\n\t\t\t\tp.y = bounds.y;\n\t\t\t}\n\t\t\telse if (next.y > bounds.y + bounds.height)\n\t\t\t{\n\t\t\t\tp.y = bounds.y + bounds.height;\n\t\t\t}\n\t\t}\n\n\t\treturn p;\n\t},\n\n\t/**\n\t * Function: EllipsePerimeter\n\t *\n\t * Describes an elliptic perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tEllipsePerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar a = bounds.width / 2;\n\t\tvar b = bounds.height / 2;\n\t\tvar cx = x + a;\n\t\tvar cy = y + b;\n\t\tvar px = next.x;\n\t\tvar py = next.y;\n\n\t\t// Calculates straight line equation through\n\t\t// point and ellipse center y = d * x + h\n\t\tvar dx = parseInt(px - cx);\n\t\tvar dy = parseInt(py - cy);\n\n\t\tif (dx == 0 && dy != 0)\n\t\t{\n\t\t\treturn new mxPoint(cx, cy + b * dy / Math.abs(dy));\n\t\t}\n\t\telse if (dx == 0 && dy == 0)\n\t\t{\n\t\t\treturn new mxPoint(px, py);\n\t\t}\n\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (py >= y && py <= y + bounds.height)\n\t\t\t{\n\t\t\t\tvar ty = py - cy;\n\t\t\t\tvar tx = Math.sqrt(a*a*(1-(ty*ty)/(b*b))) || 0;\n\n\t\t\t\tif (px <= x)\n\t\t\t\t{\n\t\t\t\t\ttx = -tx;\n\t\t\t\t}\n\n\t\t\t\treturn new mxPoint(cx+tx, py);\n\t\t\t}\n\n\t\t\tif (px >= x && px <= x + bounds.width)\n\t\t\t{\n\t\t\t\tvar tx = px - cx;\n\t\t\t\tvar ty = Math.sqrt(b*b*(1-(tx*tx)/(a*a))) || 0;\n\n\t\t\t\tif (py <= y)\n\t\t\t\t{\n\t\t\t\t\tty = -ty;\n\t\t\t\t}\n\n\t\t\t\treturn new mxPoint(px, cy+ty);\n\t\t\t}\n\t\t}\n\n\t\t// Calculates intersection\n\t\tvar d = dy / dx;\n\t\tvar h = cy - d * cx;\n\t\tvar e = a * a * d * d + b * b;\n\t\tvar f = -2 * cx * e;\n\t\tvar g = a * a * d * d * cx * cx +\n\t\t\t\tb * b * cx * cx -\n\t\t\t\ta * a * b * b;\n\t\tvar det = Math.sqrt(f * f - 4 * e * g);\n\n\t\t// Two solutions (perimeter points)\n\t\tvar xout1 = (-f + det) / (2 * e);\n\t\tvar xout2 = (-f - det) / (2 * e);\n\t\tvar yout1 = d * xout1 + h;\n\t\tvar yout2 = d * xout2 + h;\n\t\tvar dist1 = Math.sqrt(Math.pow((xout1 - px), 2)\n\t\t\t\t\t+ Math.pow((yout1 - py), 2));\n\t\tvar dist2 = Math.sqrt(Math.pow((xout2 - px), 2)\n\t\t\t\t\t+ Math.pow((yout2 - py), 2));\n\n\t\t// Correct solution\n\t\tvar xout = 0;\n\t\tvar yout = 0;\n\n\t\tif (dist1 < dist2)\n\t\t{\n\t\t\txout = xout1;\n\t\t\tyout = yout1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\txout = xout2;\n\t\t\tyout = yout2;\n\t\t}\n\n\t\treturn new mxPoint(xout, yout);\n\t},\n\n\t/**\n\t * Function: RhombusPerimeter\n\t *\n\t * Describes a rhombus (aka diamond) perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tRhombusPerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar w = bounds.width;\n\t\tvar h = bounds.height;\n\n\t\tvar cx = x + w / 2;\n\t\tvar cy = y + h / 2;\n\n\t\tvar px = next.x;\n\t\tvar py = next.y;\n\n\t\t// Special case for intersecting the diamond's corners\n\t\tif (cx == px)\n\t\t{\n\t\t\tif (cy > py)\n\t\t\t{\n\t\t\t\treturn new mxPoint(cx, y); // top\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new mxPoint(cx, y + h); // bottom\n\t\t\t}\n\t\t}\n\t\telse if (cy == py)\n\t\t{\n\t\t\tif (cx > px)\n\t\t\t{\n\t\t\t\treturn new mxPoint(x, cy); // left\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new mxPoint(x + w, cy); // right\n\t\t\t}\n\t\t}\n\n\t\tvar tx = cx;\n\t\tvar ty = cy;\n\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (px >= x && px <= x + w)\n\t\t\t{\n\t\t\t\ttx = px;\n\t\t\t}\n\t\t\telse if (py >= y && py <= y + h)\n\t\t\t{\n\t\t\t\tty = py;\n\t\t\t}\n\t\t}\n\n\t\t// In which quadrant will the intersection be?\n\t\t// set the slope and offset of the border line accordingly\n\t\tif (px < cx)\n\t\t{\n\t\t\tif (py < cy)\n\t\t\t{\n\t\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y, x, cy);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y + h, x, cy);\n\t\t\t}\n\t\t}\n\t\telse if (py < cy)\n\t\t{\n\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y, x + w, cy);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn mxUtils.intersection(px, py, tx, ty, cx, y + h, x + w, cy);\n\t\t}\n\t},\n\n\t/**\n\t * Function: TrianglePerimeter\n\t *\n\t * Describes a triangle perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tTrianglePerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar direction = (vertex != null) ?\n\t\t\tvertex.style[mxConstants.STYLE_DIRECTION] : null;\n\t\tvar vertical = direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tdirection == mxConstants.DIRECTION_SOUTH;\n\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar w = bounds.width;\n\t\tvar h = bounds.height;\n\n\t\tvar cx = x + w / 2;\n\t\tvar cy = y + h / 2;\n\n\t\tvar start = new mxPoint(x, y);\n\t\tvar corner = new mxPoint(x + w, cy);\n\t\tvar end = new mxPoint(x, y + h);\n\n\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t{\n\t\t\tstart = end;\n\t\t\tcorner = new mxPoint(cx, y);\n\t\t\tend = new mxPoint(x + w, y + h);\n\t\t}\n\t\telse if (direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tcorner = new mxPoint(cx, y + h);\n\t\t\tend = new mxPoint(x + w, y);\n\t\t}\n\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tstart = new mxPoint(x + w, y);\n\t\t\tcorner = new mxPoint(x, cy);\n\t\t\tend = new mxPoint(x + w, y + h);\n\t\t}\n\n\t\tvar dx = next.x - cx;\n\t\tvar dy = next.y - cy;\n\n\t\tvar alpha = (vertical) ? Math.atan2(dx, dy) : Math.atan2(dy, dx);\n\t\tvar t = (vertical) ? Math.atan2(w, h) : Math.atan2(h, w);\n\n\t\tvar base = false;\n\n\t\tif (direction == mxConstants.DIRECTION_NORTH ||\n\t\t\tdirection == mxConstants.DIRECTION_WEST)\n\t\t{\n\t\t\tbase = alpha > -t && alpha < t;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbase = alpha < -Math.PI + t || alpha > Math.PI - t;\n\t\t}\n\n\t\tvar result = null;\n\n\t\tif (base)\n\t\t{\n\t\t\tif (orthogonal && ((vertical && next.x >= start.x && next.x <= end.x) ||\n\t\t\t\t(!vertical && next.y >= start.y && next.y <= end.y)))\n\t\t\t{\n\t\t\t\tif (vertical)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(next.x, start.y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(start.x, next.y);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x + w / 2 + h * Math.tan(alpha) / 2,\n\t\t\t\t\t\ty + h);\n\t\t\t\t}\n\t\t\t\telse if (direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x + w / 2 - h * Math.tan(alpha) / 2,\n\t\t\t\t\t\ty);\n\t\t\t\t}\n\t\t\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x + w, y + h / 2 +\n\t\t\t\t\t\tw * Math.tan(alpha) / 2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult = new mxPoint(x, y + h / 2 -\n\t\t\t\t\t\tw * Math.tan(alpha) / 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (orthogonal)\n\t\t\t{\n\t\t\t\tvar pt = new mxPoint(cx, cy);\n\n\t\t\t\tif (next.y >= y && next.y <= y + h)\n\t\t\t\t{\n\t\t\t\t\tpt.x = (vertical) ? cx : (\n\t\t\t\t\t\t(direction == mxConstants.DIRECTION_WEST) ?\n\t\t\t\t\t\t\tx + w : x);\n\t\t\t\t\tpt.y = next.y;\n\t\t\t\t}\n\t\t\t\telse if (next.x >= x && next.x <= x + w)\n\t\t\t\t{\n\t\t\t\t\tpt.x = next.x;\n\t\t\t\t\tpt.y = (!vertical) ? cy : (\n\t\t\t\t\t\t(direction == mxConstants.DIRECTION_NORTH) ?\n\t\t\t\t\t\t\ty + h : y);\n\t\t\t\t}\n\n\t\t\t\t// Compute angle\n\t\t\t\tdx = next.x - pt.x;\n\t\t\t\tdy = next.y - pt.y;\n\n\t\t\t\tcx = pt.x;\n\t\t\t\tcy = pt.y;\n\t\t\t}\n\n\t\t\tif ((vertical && next.x <= x + w / 2) ||\n\t\t\t\t(!vertical && next.y <= y + h / 2))\n\t\t\t{\n\t\t\t\tresult = mxUtils.intersection(next.x, next.y, cx, cy,\n\t\t\t\t\tstart.x, start.y, corner.x, corner.y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = mxUtils.intersection(next.x, next.y, cx, cy,\n\t\t\t\t\tcorner.x, corner.y, end.x, end.y);\n\t\t\t}\n\t\t}\n\n\t\tif (result == null)\n\t\t{\n\t\t\tresult = new mxPoint(cx, cy);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\t/**\n\t * Function: HexagonPerimeter\n\t *\n\t * Describes a hexagon perimeter. See <RectanglePerimeter>\n\t * for a description of the parameters.\n\t */\n\tHexagonPerimeter: function (bounds, vertex, next, orthogonal)\n\t{\n\t\tvar x = bounds.x;\n\t\tvar y = bounds.y;\n\t\tvar w = bounds.width;\n\t\tvar h = bounds.height;\n\n\t\tvar cx = bounds.getCenterX();\n\t\tvar cy = bounds.getCenterY();\n\t\tvar px = next.x;\n\t\tvar py = next.y;\n\t\tvar dx = px - cx;\n\t\tvar dy = py - cy;\n\t\tvar alpha = -Math.atan2(dy, dx);\n\t\tvar pi = Math.PI;\n\t\tvar pi2 = Math.PI / 2;\n\n\t\tvar result = new mxPoint(cx, cy);\n\n\t\tvar direction = (vertex != null) ? mxUtils.getValue(\n\t\t\t\tvertex.style, mxConstants.STYLE_DIRECTION,\n\t\t\t\tmxConstants.DIRECTION_EAST) : mxConstants.DIRECTION_EAST;\n\t\tvar vertical = direction == mxConstants.DIRECTION_NORTH\n\t\t\t\t|| direction == mxConstants.DIRECTION_SOUTH;\n\t\tvar a = new mxPoint();\n\t\tvar b = new mxPoint();\n\n\t\t//Only consider corrects quadrants for the orthogonal case.\n\t\tif ((px < x) && (py < y) || (px < x) && (py > y + h)\n\t\t\t\t|| (px > x + w) && (py < y) || (px > x + w) && (py > y + h))\n\t\t{\n\t\t\torthogonal = false;\n\t\t}\n\n\t\tif (orthogonal)\n\t\t{\n\t\t\tif (vertical)\n\t\t\t{\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (px == cx)\n\t\t\t\t{\n\t\t\t\t\tif (py <= y)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(cx, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py >= y + h)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(cx, y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px < x)\n\t\t\t\t{\n\t\t\t\t\tif (py == y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py == y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px > x + w)\n\t\t\t\t{\n\t\t\t\t\tif (py == y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py == y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px == x)\n\t\t\t\t{\n\t\t\t\t\tif (py < cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px == x + w)\n\t\t\t\t{\n\t\t\t\t\tif (py < cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + h / 4);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + 3 * h / 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (py == y)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(cx, y);\n\t\t\t\t}\n\t\t\t\telse if (py == y + h)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(cx, y + h);\n\t\t\t\t}\n\n\t\t\t\tif (px < cx)\n\t\t\t\t{\n\t\t\t\t\tif ((py > y + h / 4) && (py < y + 3 * h / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\t\tb = new mxPoint(x, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py < y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + w, y - Math.floor(0.25 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + w, y + Math.floor(1.25 * h));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (px > cx)\n\t\t\t\t{\n\t\t\t\t\tif ((py > y + h / 4) && (py < y + 3 * h / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + w, y);\n\t\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py < y + h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y - Math.floor(0.25 * h));\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > y + 3 * h / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x, y + Math.floor(1.25 * h));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (py == cy)\n\t\t\t\t{\n\t\t\t\t\tif (px <= x)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x, y + h / 2);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px >= x + w)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w, y + h / 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py < y)\n\t\t\t\t{\n\t\t\t\t\tif (px == x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px == x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py > y + h)\n\t\t\t\t{\n\t\t\t\t\tif (px == x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px == x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py == y)\n\t\t\t\t{\n\t\t\t\t\tif (px < cx)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px > cx)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py == y + h)\n\t\t\t\t{\n\t\t\t\t\tif (px < cx)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (py > cy)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn new mxPoint(x + 3 * w / 4, y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (px == x)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, cy);\n\t\t\t\t}\n\t\t\t\telse if (px == x + w)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, cy);\n\t\t\t\t}\n\n\t\t\t\tif (py < cy)\n\t\t\t\t{\n\t\t\t\t\tif ((px > x + w / 4) && (px < x + 3 * w / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\t\tb = new mxPoint(x + w, y);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px < x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y + h);\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (px > x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y + h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (py > cy)\n\t\t\t\t{\n\t\t\t\t\tif ((px > x + w / 4) && (px < x + 3 * w / 4))\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x, y + h);\n\t\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t\t}\n\t\t\t\t\telse if (px < x + w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y);\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t\t}\n\t\t\t\t\telse if (px > x + 3 * w / 4)\n\t\t\t\t\t{\n\t\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar tx = cx;\n\t\t\tvar ty = cy;\n\n\t\t\tif (px >= x && px <= x + w)\n\t\t\t{\n\t\t\t\ttx = px;\n\n\t\t\t\tif (py < cy)\n\t\t\t\t{\n\t\t\t\t\tty = y + h;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tty = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (py >= y && py <= y + h)\n\t\t\t{\n\t\t\t\tty = py;\n\n\t\t\t\tif (px < cx)\n\t\t\t\t{\n\t\t\t\t\ttx = x + w;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttx = x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = mxUtils.intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (vertical)\n\t\t\t{\n\t\t\t\tvar beta = Math.atan2(h / 4, w / 2);\n\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (alpha == beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, y + Math.floor(0.25 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == pi2)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.5 * w), y);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (pi - beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, y + Math.floor(0.25 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == -beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, y + Math.floor(0.75 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == (-pi2))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.5 * w), y + h);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (-pi + beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, y + Math.floor(0.75 * h));\n\t\t\t\t}\n\n\t\t\t\tif ((alpha < beta) && (alpha > -beta))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + w, y);\n\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha > beta) && (alpha < pi2))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y - Math.floor(0.25 * h));\n\t\t\t\t\tb = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if ((alpha > pi2) && (alpha < (pi - beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x + w, y - Math.floor(0.25 * h));\n\t\t\t\t}\n\t\t\t\telse if (((alpha > (pi - beta)) && (alpha <= pi))\n\t\t\t\t\t\t|| ((alpha < (-pi + beta)) && (alpha >= -pi)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\tb = new mxPoint(x, y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha < -beta) && (alpha > -pi2))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + Math.floor(1.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x, y + Math.floor(1.25 * h));\n\t\t\t\t}\n\t\t\t\telse if ((alpha < -pi2) && (alpha > (-pi + beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x + w, y + Math.floor(1.25 * h));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar beta = Math.atan2(h / 2, w / 4);\n\n\t\t\t\t//Special cases where intersects with hexagon corners\n\t\t\t\tif (alpha == beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.75 * w), y);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (pi - beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.25 * w), y);\n\t\t\t\t}\n\t\t\t\telse if ((alpha == pi) || (alpha == -pi))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x, y + Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == 0)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + w, y + Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if (alpha == -beta)\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.75 * w), y + h);\n\t\t\t\t}\n\t\t\t\telse if (alpha == (-pi + beta))\n\t\t\t\t{\n\t\t\t\t\treturn new mxPoint(x + Math.floor(0.25 * w), y + h);\n\t\t\t\t}\n\n\t\t\t\tif ((alpha > 0) && (alpha < beta))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha > beta) && (alpha < (pi - beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y);\n\t\t\t\t\tb = new mxPoint(x + w, y);\n\t\t\t\t}\n\t\t\t\telse if ((alpha > (pi - beta)) && (alpha < pi))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y + h);\n\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t- Math.floor(0.5 * h));\n\t\t\t\t}\n\t\t\t\telse if ((alpha < 0) && (alpha > -beta))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t\tb = new mxPoint(x + Math.floor(1.25 * w), y);\n\t\t\t\t}\n\t\t\t\telse if ((alpha < -beta) && (alpha > (-pi + beta)))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x, y + h);\n\t\t\t\t\tb = new mxPoint(x + w, y + h);\n\t\t\t\t}\n\t\t\t\telse if ((alpha < (-pi + beta)) && (alpha > -pi))\n\t\t\t\t{\n\t\t\t\t\ta = new mxPoint(x - Math.floor(0.25 * w), y);\n\t\t\t\t\tb = new mxPoint(x + Math.floor(0.5 * w), y\n\t\t\t\t\t\t\t+ Math.floor(1.5 * h));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = mxUtils.intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);\n\t\t}\n\n\t\tif (result == null)\n\t\t{\n\t\t\treturn new mxPoint(cx, cy);\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\n__mxOutput.mxPerimeter = typeof mxPerimeter !== 'undefined' ? mxPerimeter : undefined;\n\n/**\n * Copyright (c) 2006-2017, JGraph Ltd\n * Copyright (c) 2006-2017, Gaudenz Alder\n */\n/**\n * Class: mxPrintPreview\n *\n * Implements printing of a diagram across multiple pages. The following opens\n * a print preview for an existing graph:\n *\n * (code)\n * var preview = new mxPrintPreview(graph);\n * preview.open();\n * (end)\n *\n * Use <mxUtils.getScaleForPageCount> as follows in order to print the graph\n * across a given number of pages:\n *\n * (code)\n * var pageCount = mxUtils.prompt('Enter page count', '1');\n *\n * if (pageCount != null)\n * {\n *   var scale = mxUtils.getScaleForPageCount(pageCount, graph);\n *   var preview = new mxPrintPreview(graph, scale);\n *   preview.open();\n * }\n * (end)\n *\n * Additional pages:\n *\n * To add additional pages before and after the output, <getCoverPages> and\n * <getAppendices> can be used, respectively.\n *\n * (code)\n * var preview = new mxPrintPreview(graph, 1);\n *\n * preview.getCoverPages = function(w, h)\n * {\n *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n *   {\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'\n *   }))];\n * };\n *\n * preview.getAppendices = function(w, h)\n * {\n *   return [this.renderPage(w, h, 0, 0, mxUtils.bind(this, function(div)\n *   {\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'\n *   }))];\n * };\n *\n * preview.open();\n * (end)\n *\n * CSS:\n *\n * The CSS from the original page is not carried over to the print preview.\n * To add CSS to the page, use the css argument in the <open> function or\n * override <writeHead> to add the respective link tags as follows:\n *\n * (code)\n * var writeHead = preview.writeHead;\n * preview.writeHead = function(doc, css)\n * {\n *   writeHead.apply(this, arguments);\n *   doc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');\n * };\n * (end)\n *\n * Padding:\n *\n * To add a padding to the page in the preview (but not the print output), use\n * the following code:\n *\n * (code)\n * preview.writeHead = function(doc)\n * {\n *   writeHead.apply(this, arguments);\n *\n *   doc.writeln('<style type=\"text/css\">');\n *   doc.writeln('@media screen {');\n *   doc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');\n *   doc.writeln('}');\n *   doc.writeln('</style>');\n * };\n * (end)\n *\n * Headers:\n *\n * Apart from setting the title argument in the mxPrintPreview constructor you\n * can override <renderPage> as follows to add a header to any page:\n *\n * (code)\n * var oldRenderPage = mxPrintPreview.prototype.renderPage;\n * mxPrintPreview.prototype.renderPage = function(w, h, x, y, content, pageNumber)\n * {\n *   var div = oldRenderPage.apply(this, arguments);\n *\n *   var header = document.createElement('div');\n *   header.style.position = 'absolute';\n *   header.style.top = '0px';\n *   header.style.width = '100%';\n *   header.style.textAlign = 'right';\n *   mxUtils.write(header, 'Your header here');\n *   div.firstChild.appendChild(header);\n *\n *   return div;\n * };\n * (end)\n *\n * The pageNumber argument contains the number of the current page, starting at\n * 1. To display a header on the first page only, check pageNumber and add a\n * vertical offset in the constructor call for the height of the header.\n *\n * Page Format:\n *\n * For landscape printing, use <mxConstants.PAGE_FORMAT_A4_LANDSCAPE> as\n * the pageFormat in <mxUtils.getScaleForPageCount> and <mxPrintPreview>.\n * Keep in mind that one can not set the defaults for the print dialog\n * of the operating system from JavaScript so the user must manually choose\n * a page format that matches this setting.\n *\n * You can try passing the following CSS directive to <open> to set the\n * page format in the print dialog to landscape. However, this CSS\n * directive seems to be ignored in most major browsers, including IE.\n *\n * (code)\n * @page {\n *   size: landscape;\n * }\n * (end)\n *\n * Note that the print preview behaves differently in IE when used from the\n * filesystem or via HTTP so printing should always be tested via HTTP.\n *\n * If you are using a DOCTYPE in the source page you can override <getDoctype>\n * and provide the same DOCTYPE for the print preview if required. Here is\n * an example for IE8 standards mode.\n *\n * (code)\n * var preview = new mxPrintPreview(graph);\n * preview.getDoctype = function()\n * {\n *   return '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=5,IE=8\" ><![endif]-->';\n * };\n * preview.open();\n * (end)\n *\n * Constructor: mxPrintPreview\n *\n * Constructs a new print preview for the given parameters.\n *\n * Parameters:\n *\n * graph - <mxGraph> to be previewed.\n * scale - Optional scale of the output. Default is 1 / <mxGraph.pageScale>.\n * border - Border in pixels along each side of every page. Note that the\n * actual print function in the browser will add another border for\n * printing.\n * pageFormat - <mxRectangle> that specifies the page format (in pixels).\n * This should match the page format of the printer. Default uses the\n * <mxGraph.pageFormat> of the given graph.\n * x0 - Optional left offset of the output. Default is 0.\n * y0 - Optional top offset of the output. Default is 0.\n * borderColor - Optional color of the page border. Default is no border.\n * Note that a border is sometimes useful to highlight the printed page\n * border in the print preview of the browser.\n * title - Optional string that is used for the window title. Default\n * is 'Printer-friendly version'.\n * pageSelector - Optional boolean that specifies if the page selector\n * should appear in the window with the print preview. Default is true.\n */\nfunction mxPrintPreview(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector)\n{\n\tthis.graph = graph;\n\tthis.scale = (scale != null) ? scale : 1 / graph.pageScale;\n\tthis.border = (border != null) ? border : 0;\n\tthis.pageFormat = mxRectangle.fromRectangle((pageFormat != null) ? pageFormat : graph.pageFormat);\n\tthis.title = (title != null) ? title : 'Printer-friendly version';\n\tthis.x0 = (x0 != null) ? x0 : 0;\n\tthis.y0 = (y0 != null) ? y0 : 0;\n\tthis.borderColor = borderColor;\n\tthis.pageSelector = (pageSelector != null) ? pageSelector : true;\n};\n\n/**\n * Variable: graph\n *\n * Reference to the <mxGraph> that should be previewed.\n */\nmxPrintPreview.prototype.graph = null;\n\n/**\n * Variable: pageFormat\n *\n * Holds the <mxRectangle> that defines the page format.\n */\nmxPrintPreview.prototype.pageFormat = null;\n\n/**\n * Variable: scale\n *\n * Holds the scale of the print preview.\n */\nmxPrintPreview.prototype.scale = null;\n\n/**\n * Variable: border\n *\n * The border inset around each side of every page in the preview. This is set\n * to 0 if autoOrigin is false.\n */\nmxPrintPreview.prototype.border = 0;\n\n/**\n * Variable: marginTop\n *\n * The margin at the top of the page (number). Default is 0.\n */\nmxPrintPreview.prototype.marginTop = 0;\n\n/**\n * Variable: marginBottom\n *\n * The margin at the bottom of the page (number). Default is 0.\n */\nmxPrintPreview.prototype.marginBottom = 0;\n\n/**\n * Variable: x0\n *\n * Holds the horizontal offset of the output.\n */\nmxPrintPreview.prototype.x0 = 0;\n\n/**\n * Variable: y0\n *\n * Holds the vertical offset of the output.\n */\nmxPrintPreview.prototype.y0 = 0;\n\n/**\n * Variable: autoOrigin\n *\n * Specifies if the origin should be automatically computed based on the top,\n * left corner of the actual diagram contents. The required offset will be added\n * to <x0> and <y0> in <open>. Default is true.\n */\nmxPrintPreview.prototype.autoOrigin = true;\n\n/**\n * Variable: printOverlays\n *\n * Specifies if overlays should be printed. Default is false.\n */\nmxPrintPreview.prototype.printOverlays = false;\n\n/**\n * Variable: printControls\n *\n * Specifies if controls (such as folding icons) should be printed. Default is\n * false.\n */\nmxPrintPreview.prototype.printControls = false;\n\n/**\n * Variable: printBackgroundImage\n *\n * Specifies if the background image should be printed. Default is false.\n */\nmxPrintPreview.prototype.printBackgroundImage = false;\n\n/**\n * Variable: backgroundColor\n *\n * Holds the color value for the page background color. Default is #ffffff.\n */\nmxPrintPreview.prototype.backgroundColor = '#ffffff';\n\n/**\n * Variable: borderColor\n *\n * Holds the color value for the page border.\n */\nmxPrintPreview.prototype.borderColor = null;\n\n/**\n * Variable: title\n *\n * Holds the title of the preview window.\n */\nmxPrintPreview.prototype.title = null;\n\n/**\n * Variable: pageSelector\n *\n * Boolean that specifies if the page selector should be\n * displayed. Default is true.\n */\nmxPrintPreview.prototype.pageSelector = null;\n\n/**\n * Variable: wnd\n *\n * Reference to the preview window.\n */\nmxPrintPreview.prototype.wnd = null;\n\n/**\n * Variable: targetWindow\n *\n * Assign any window here to redirect the rendering in <open>.\n */\nmxPrintPreview.prototype.targetWindow = null;\n\n/**\n * Variable: pageCount\n *\n * Holds the actual number of pages in the preview.\n */\nmxPrintPreview.prototype.pageCount = 0;\n\n/**\n * Variable: clipping\n *\n * Specifies is clipping should be used to avoid creating too many cell states\n * in large diagrams. The bounding box of the cells in the original diagram is\n * used if this is enabled. Default is true.\n */\nmxPrintPreview.prototype.clipping = true;\n\n/**\n * Function: getWindow\n *\n * Returns <wnd>.\n */\nmxPrintPreview.prototype.getWindow = function()\n{\n\treturn this.wnd;\n};\n\n/**\n * Function: getDocType\n *\n * Returns the string that should go before the HTML tag in the print preview\n * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,\n * IE8 in IE8 standards mode and edge in IE9 standards mode.\n */\nmxPrintPreview.prototype.getDoctype = function()\n{\n\tvar dt = '';\n\n\tif (document.documentMode == 5)\n\t{\n\t\tdt = '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=5\">';\n\t}\n\telse if (document.documentMode == 8)\n\t{\n\t\tdt = '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\">';\n\t}\n\telse if (document.documentMode > 8)\n\t{\n\t\t// Comment needed to make standards doctype apply in IE\n\t\tdt = '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><![endif]-->';\n\t}\n\n\treturn dt;\n};\n\n/**\n * Function: appendGraph\n *\n * Adds the given graph to the existing print preview.\n *\n * Parameters:\n *\n * css - Optional CSS string to be used in the head section.\n * targetWindow - Optional window that should be used for rendering. If\n * this is specified then no HEAD tag, CSS and BODY tag will be written.\n */\nmxPrintPreview.prototype.appendGraph = function(graph, scale, x0, y0, forcePageBreaks, keepOpen)\n{\n\tthis.graph = graph;\n\tthis.scale = (scale != null) ? scale : 1 / graph.pageScale;\n\tthis.x0 = x0;\n\tthis.y0 = y0;\n\tthis.open(null, null, forcePageBreaks, keepOpen);\n};\n\n/**\n * Function: open\n *\n * Shows the print preview window. The window is created here if it does\n * not exist.\n *\n * Parameters:\n *\n * css - Optional CSS string to be used in the head section.\n * targetWindow - Optional window that should be used for rendering. If\n * this is specified then no HEAD tag, CSS and BODY tag will be written.\n */\nmxPrintPreview.prototype.open = function(css, targetWindow, forcePageBreaks, keepOpen)\n{\n\t// Closing the window while the page is being rendered may cause an\n\t// exception in IE. This and any other exceptions are simply ignored.\n\tvar previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;\n\tvar div = null;\n\n\ttry\n\t{\n\t\t// Temporarily overrides the method to redirect rendering of overlays\n\t\t// to the draw pane so that they are visible in the printout\n\t\tif (this.printOverlays)\n\t\t{\n\t\t\tthis.graph.cellRenderer.initializeOverlay = function(state, overlay)\n\t\t\t{\n\t\t\t\toverlay.init(state.view.getDrawPane());\n\t\t\t};\n\t\t}\n\n\t\tif (this.printControls)\n\t\t{\n\t\t\tthis.graph.cellRenderer.initControl = function(state, control, handleEvents, clickHandler)\n\t\t\t{\n\t\t\t\tcontrol.dialect = state.view.graph.dialect;\n\t\t\t\tcontrol.init(state.view.getDrawPane());\n\t\t\t};\n\t\t}\n\n\t\tthis.wnd = (targetWindow != null) ? targetWindow : this.wnd;\n\t\tvar isNewWindow = false;\n\n\t\tif (this.wnd == null)\n\t\t{\n\t\t\tisNewWindow = true;\n\t\t\tthis.wnd = window.open();\n\t\t}\n\n\t\tvar doc = this.wnd.document;\n\n\t\tif (isNewWindow)\n\t\t{\n\t\t\tvar dt = this.getDoctype();\n\n\t\t\tif (dt != null && dt.length > 0)\n\t\t\t{\n\t\t\t\tdoc.writeln(dt);\n\t\t\t}\n\n\t\t\tif (mxClient.IS_VML)\n\t\t\t{\n\t\t\t\tdoc.writeln('<html xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\">');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (document.compatMode === 'CSS1Compat')\n\t\t\t\t{\n\t\t\t\t\tdoc.writeln('<!DOCTYPE html>');\n\t\t\t\t}\n\n\t\t\t\tdoc.writeln('<html>');\n\t\t\t}\n\n\t\t\tdoc.writeln('<head>');\n\t\t\tthis.writeHead(doc, css);\n\t\t\tdoc.writeln('</head>');\n\t\t\tdoc.writeln('<body class=\"mxPage\">');\n\t\t}\n\n\t\t// Computes the horizontal and vertical page count\n\t\tvar bounds = this.graph.getGraphBounds().clone();\n\t\tvar currentScale = this.graph.getView().getScale();\n\t\tvar sc = currentScale / this.scale;\n\t\tvar tr = this.graph.getView().getTranslate();\n\n\t\t// Uses the absolute origin with no offset for all printing\n\t\tif (!this.autoOrigin)\n\t\t{\n\t\t\tthis.x0 -= tr.x * this.scale;\n\t\t\tthis.y0 -= tr.y * this.scale;\n\t\t\tbounds.width += bounds.x;\n\t\t\tbounds.height += bounds.y;\n\t\t\tbounds.x = 0;\n\t\t\tbounds.y = 0;\n\t\t\tthis.border = 0;\n\t\t}\n\n\t\t// Store the available page area\n\t\tvar availableWidth = this.pageFormat.width - (this.border * 2);\n\t\tvar availableHeight = this.pageFormat.height - (this.border * 2);\n\n\t\t// Adds margins to page format\n\t\tthis.pageFormat.height += this.marginTop + this.marginBottom;\n\n\t\t// Compute the unscaled, untranslated bounds to find\n\t\t// the number of vertical and horizontal pages\n\t\tbounds.width /= sc;\n\t\tbounds.height /= sc;\n\n\t\tvar hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));\n\t\tvar vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));\n\t\tthis.pageCount = hpages * vpages;\n\n\t\tvar writePageSelector = mxUtils.bind(this, function()\n\t\t{\n\t\t\tif (this.pageSelector && (vpages > 1 || hpages > 1))\n\t\t\t{\n\t\t\t\tvar table = this.createPageSelector(vpages, hpages);\n\t\t\t\tdoc.body.appendChild(table);\n\n\t\t\t\t// Implements position: fixed in IE quirks mode\n\t\t\t\tif (mxClient.IS_IE && doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7)\n\t\t\t\t{\n\t\t\t\t\ttable.style.position = 'absolute';\n\n\t\t\t\t\tvar update = function()\n\t\t\t\t\t{\n\t\t\t\t\t\ttable.style.top = ((doc.body.scrollTop || doc.documentElement.scrollTop) + 10) + 'px';\n\t\t\t\t\t};\n\n\t\t\t\t\tmxEvent.addListener(this.wnd, 'scroll', function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t});\n\n\t\t\t\t\tmxEvent.addListener(this.wnd, 'resize', function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdate();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar addPage = mxUtils.bind(this, function(div, addBreak)\n\t\t{\n\t\t\t// Border of the DIV (aka page) inside the document\n\t\t\tif (this.borderColor != null)\n\t\t\t{\n\t\t\t\tdiv.style.borderColor = this.borderColor;\n\t\t\t\tdiv.style.borderStyle = 'solid';\n\t\t\t\tdiv.style.borderWidth = '1px';\n\t\t\t}\n\n\t\t\t// Needs to be assigned directly because IE doesn't support\n\t\t\t// child selectors, eg. body > div { background: white; }\n\t\t\tdiv.style.background = this.backgroundColor;\n\n\t\t\tif (forcePageBreaks || addBreak)\n\t\t\t{\n\t\t\t\tdiv.style.pageBreakAfter = 'always';\n\t\t\t}\n\n\t\t\t// NOTE: We are dealing with cross-window DOM here, which\n\t\t\t// is a problem in IE, so we copy the HTML markup instead.\n\t\t\t// The underlying problem is that the graph display markup\n\t\t\t// creation (in mxShape, mxGraphView) is hardwired to using\n\t\t\t// document.createElement and hence we must use this document\n\t\t\t// to create the complete page and then copy it over to the\n\t\t\t// new window.document. This can be fixed later by using the\n\t\t\t// ownerDocument of the container in mxShape and mxGraphView.\n\t\t\tif (isNewWindow && (mxClient.IS_IE || document.documentMode >= 11 || mxClient.IS_EDGE))\n\t\t\t{\n\t\t\t\t// For some obscure reason, removing the DIV from the\n\t\t\t\t// parent before fetching its outerHTML has missing\n\t\t\t\t// fillcolor properties and fill children, so the div\n\t\t\t\t// must be removed afterwards to keep the fillcolors.\n\t\t\t\tdoc.writeln(div.outerHTML);\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t}\n\t\t\telse if (mxClient.IS_IE || document.documentMode >= 11 || mxClient.IS_EDGE)\n\t\t\t{\n\t\t\t\tvar clone = doc.createElement('div');\n\t\t\t\tclone.innerHTML = div.outerHTML;\n\t\t\t\tclone = clone.getElementsByTagName('div')[0];\n\t\t\t\tdoc.body.appendChild(clone);\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t\tdoc.body.appendChild(div);\n\t\t\t}\n\n\t\t\tif (forcePageBreaks || addBreak)\n\t\t\t{\n\t\t\t\tthis.addPageBreak(doc);\n\t\t\t}\n\t\t});\n\n\t\tvar cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);\n\n\t\tif (cov != null)\n\t\t{\n\t\t\tfor (var i = 0; i < cov.length; i++)\n\t\t\t{\n\t\t\t\taddPage(cov[i], true);\n\t\t\t}\n\t\t}\n\n\t\tvar apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);\n\n\t\t// Appends each page to the page output for printing, making\n\t\t// sure there will be a page break after each page (ie. div)\n\t\tfor (var i = 0; i < vpages; i++)\n\t\t{\n\t\t\tvar dy = i * availableHeight / this.scale - this.y0 / this.scale +\n\t\t\t\t\t(bounds.y - tr.y * currentScale) / currentScale;\n\n\t\t\tfor (var j = 0; j < hpages; j++)\n\t\t\t{\n\t\t\t\tif (this.wnd == null)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tvar dx = j * availableWidth / this.scale - this.x0 / this.scale +\n\t\t\t\t\t\t(bounds.x - tr.x * currentScale) / currentScale;\n\t\t\t\tvar pageNum = i * hpages + j + 1;\n\t\t\t\tvar clip = new mxRectangle(dx, dy, availableWidth, availableHeight);\n\t\t\t\tdiv = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, mxUtils.bind(this, function(div)\n\t\t\t\t{\n\t\t\t\t\tthis.addGraphFragment(-dx, -dy, this.scale, pageNum, div, clip);\n\n\t\t\t\t\tif (this.printBackgroundImage)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.insertBackgroundImage(div, -dx, -dy);\n\t\t\t\t\t}\n\t\t\t\t}), pageNum);\n\n\t\t\t\t// Gives the page a unique ID for later accessing the page\n\t\t\t\tdiv.setAttribute('id', 'mxPage-'+pageNum);\n\n\t\t\t\taddPage(div, apx != null || i < vpages - 1 || j < hpages - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (apx != null)\n\t\t{\n\t\t\tfor (var i = 0; i < apx.length; i++)\n\t\t\t{\n\t\t\t\taddPage(apx[i], i < apx.length - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (isNewWindow && !keepOpen)\n\t\t{\n\t\t\tthis.closeDocument();\n\t\t\twritePageSelector();\n\t\t}\n\n\t\tthis.wnd.focus();\n\t}\n\tcatch (e)\n\t{\n\t\t// Removes the DIV from the document in case of an error\n\t\tif (div != null && div.parentNode != null)\n\t\t{\n\t\t\tdiv.parentNode.removeChild(div);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;\n\t}\n\n\treturn this.wnd;\n};\n\n/**\n * Function: addPageBreak\n *\n * Adds a page break to the given document.\n */\nmxPrintPreview.prototype.addPageBreak = function(doc)\n{\n\tvar hr = doc.createElement('hr');\n\thr.className = 'mxPageBreak';\n\tdoc.body.appendChild(hr);\n};\n\n/**\n * Function: closeDocument\n *\n * Writes the closing tags for body and page after calling <writePostfix>.\n */\nmxPrintPreview.prototype.closeDocument = function()\n{\n\ttry\n\t{\n\t\tif (this.wnd != null && this.wnd.document != null)\n\t\t{\n\t\t\tvar doc = this.wnd.document;\n\n\t\t\tthis.writePostfix(doc);\n\t\t\tdoc.writeln('</body>');\n\t\t\tdoc.writeln('</html>');\n\t\t\tdoc.close();\n\n\t\t\t// Removes all event handlers in the print output\n\t\t\tmxEvent.release(doc.body);\n\t\t}\n\t}\n\tcatch (e)\n\t{\n\t\t// ignore any errors resulting from wnd no longer being available\n\t}\n};\n\n/**\n * Function: writeHead\n *\n * Writes the HEAD section into the given document, without the opening\n * and closing HEAD tags.\n */\nmxPrintPreview.prototype.writeHead = function(doc, css)\n{\n\tif (this.title != null)\n\t{\n\t\tdoc.writeln('<title>' + this.title + '</title>');\n\t}\n\n\t// Adds required namespaces\n\tif (mxClient.IS_VML)\n\t{\n\t\tdoc.writeln('<style type=\"text/css\">v\\\\:*{behavior:url(#default#VML)}o\\\\:*{behavior:url(#default#VML)}</style>');\n\t}\n\n\t// Adds all required stylesheets\n\tmxClient.link('stylesheet', mxClient.basePath + '/css/common.css', doc);\n\n\t// Removes horizontal rules and page selector from print output\n\tdoc.writeln('<style type=\"text/css\">');\n\tdoc.writeln('@media print {');\n\tdoc.writeln('  * { -webkit-print-color-adjust: exact; }');\n\tdoc.writeln('  table.mxPageSelector { display: none; }');\n\tdoc.writeln('  hr.mxPageBreak { display: none; }');\n\tdoc.writeln('}');\n\tdoc.writeln('@media screen {');\n\n\t// NOTE: position: fixed is not supported in IE, so the page selector\n\t// position (absolute) needs to be updated in IE (see below)\n\tdoc.writeln('  table.mxPageSelector { position: fixed; right: 10px; top: 10px;' +\n\t\t\t'font-family: Arial; font-size:10pt; border: solid 1px darkgray;' +\n\t\t\t'background: white; border-collapse:collapse; }');\n\tdoc.writeln('  table.mxPageSelector td { border: solid 1px gray; padding:4px; }');\n\tdoc.writeln('  body.mxPage { background: gray; }');\n\tdoc.writeln('}');\n\n\tif (css != null)\n\t{\n\t\tdoc.writeln(css);\n\t}\n\n\tdoc.writeln('</style>');\n};\n\n/**\n * Function: writePostfix\n *\n * Called before closing the body of the page. This implementation is empty.\n */\nmxPrintPreview.prototype.writePostfix = function(doc)\n{\n\t// empty\n};\n\n/**\n * Function: createPageSelector\n *\n * Creates the page selector table.\n */\nmxPrintPreview.prototype.createPageSelector = function(vpages, hpages)\n{\n\tvar doc = this.wnd.document;\n\tvar table = doc.createElement('table');\n\ttable.className = 'mxPageSelector';\n\ttable.setAttribute('border', '0');\n\n\tvar tbody = doc.createElement('tbody');\n\n\tfor (var i = 0; i < vpages; i++)\n\t{\n\t\tvar row = doc.createElement('tr');\n\n\t\tfor (var j = 0; j < hpages; j++)\n\t\t{\n\t\t\tvar pageNum = i * hpages + j + 1;\n\t\t\tvar cell = doc.createElement('td');\n\t\t\tvar a = doc.createElement('a');\n\t\t\ta.setAttribute('href', '#mxPage-' + pageNum);\n\n\t\t\t// Workaround for FF where the anchor is appended to the URL of the original document\n\t\t\tif (mxClient.IS_NS && !mxClient.IS_SF && !mxClient.IS_GC)\n\t\t\t{\n\t\t\t\tvar js = 'var page = document.getElementById(\\'mxPage-' + pageNum + '\\');page.scrollIntoView(true);event.preventDefault();';\n\t\t\t\ta.setAttribute('onclick', js);\n\t\t\t}\n\n\t\t\tmxUtils.write(a, pageNum, doc);\n\t\t\tcell.appendChild(a);\n\t\t\trow.appendChild(cell);\n\t\t}\n\n\t\ttbody.appendChild(row);\n\t}\n\n\ttable.appendChild(tbody);\n\n\treturn table;\n};\n\n/**\n * Function: renderPage\n *\n * Creates a DIV that prints a single page of the given\n * graph using the given scale and returns the DIV that\n * represents the page.\n *\n * Parameters:\n *\n * w - Width of the page in pixels.\n * h - Height of the page in pixels.\n * dx - Optional horizontal page offset in pixels (used internally).\n * dy - Optional vertical page offset in pixels (used internally).\n * content - Callback that adds the HTML content to the inner div of a page.\n * Takes the inner div as the argument.\n * pageNumber - Integer representing the page number.\n */\nmxPrintPreview.prototype.renderPage = function(w, h, dx, dy, content, pageNumber)\n{\n\tvar doc = this.wnd.document;\n\tvar div = document.createElement('div');\n\tvar arg = null;\n\n\ttry\n\t{\n\t\t// Workaround for ignored clipping in IE 9 standards\n\t\t// when printing with page breaks and HTML labels.\n\t\tif (dx != 0 || dy != 0)\n\t\t{\n\t\t\tdiv.style.position = 'relative';\n\t\t\tdiv.style.width = w + 'px';\n\t\t\tdiv.style.height = h + 'px';\n\t\t\tdiv.style.pageBreakInside = 'avoid';\n\n\t\t\tvar innerDiv = document.createElement('div');\n\t\t\tinnerDiv.style.position = 'relative';\n\t\t\tinnerDiv.style.top = this.border + 'px';\n\t\t\tinnerDiv.style.left = this.border + 'px';\n\t\t\tinnerDiv.style.width = (w - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.height = (h - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.overflow = 'hidden';\n\n\t\t\tvar viewport = document.createElement('div');\n\t\t\tviewport.style.position = 'relative';\n\t\t\tviewport.style.marginLeft = dx + 'px';\n\t\t\tviewport.style.marginTop = dy + 'px';\n\n\t\t\t// FIXME: IE8 standards output problems\n\t\t\tif (doc.documentMode == 8)\n\t\t\t{\n\t\t\t\tinnerDiv.style.position = 'absolute';\n\t\t\t\tviewport.style.position = 'absolute';\n\t\t\t}\n\n\t\t\tif (doc.documentMode == 10)\n\t\t\t{\n\t\t\t\tviewport.style.width = '100%';\n\t\t\t\tviewport.style.height = '100%';\n\t\t\t}\n\n\t\t\tinnerDiv.appendChild(viewport);\n\t\t\tdiv.appendChild(innerDiv);\n\t\t\tdocument.body.appendChild(div);\n\t\t\targ = viewport;\n\t\t}\n\t\t// FIXME: IE10/11 too many pages\n\t\telse\n\t\t{\n\t\t\tdiv.style.width = w + 'px';\n\t\t\tdiv.style.height = h + 'px';\n\t\t\tdiv.style.overflow = 'hidden';\n\t\t\tdiv.style.pageBreakInside = 'avoid';\n\n\t\t\t// IE8 uses above branch currently\n\t\t\tif (doc.documentMode == 8)\n\t\t\t{\n\t\t\t\tdiv.style.position = 'relative';\n\t\t\t}\n\n\t\t\tvar innerDiv = document.createElement('div');\n\t\t\tinnerDiv.style.width = (w - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.height = (h - 2 * this.border) + 'px';\n\t\t\tinnerDiv.style.overflow = 'hidden';\n\n\t\t\tif (mxClient.IS_IE && (doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7))\n\t\t\t{\n\t\t\t\tinnerDiv.style.marginTop = this.border + 'px';\n\t\t\t\tinnerDiv.style.marginLeft = this.border + 'px';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinnerDiv.style.top = this.border + 'px';\n\t\t\t\tinnerDiv.style.left = this.border + 'px';\n\t\t\t}\n\n\t\t\tif (this.graph.dialect == mxConstants.DIALECT_VML)\n\t\t\t{\n\t\t\t\tinnerDiv.style.position = 'absolute';\n\t\t\t}\n\n\t\t\tdiv.appendChild(innerDiv);\n\t\t\tdocument.body.appendChild(div);\n\t\t\targ = innerDiv;\n\t\t}\n\t}\n\tcatch (e)\n\t{\n\t\tdiv.parentNode.removeChild(div);\n\t\tdiv = null;\n\n\t\tthrow e;\n\t}\n\n\tcontent(arg);\n\n\treturn div;\n};\n\n/**\n * Function: getRoot\n *\n * Returns the root cell for painting the graph.\n */\nmxPrintPreview.prototype.getRoot = function()\n{\n\tvar root = this.graph.view.currentRoot;\n\n\tif (root == null)\n\t{\n\t\troot = this.graph.getModel().getRoot();\n\t}\n\n\treturn root;\n};\n\n/**\n * Function: addGraphFragment\n *\n * Adds a graph fragment to the given div.\n *\n * Parameters:\n *\n * dx - Horizontal translation for the diagram.\n * dy - Vertical translation for the diagram.\n * scale - Scale for the diagram.\n * pageNumber - Number of the page to be rendered.\n * div - Div that contains the output.\n * clip - Contains the clipping rectangle as an <mxRectangle>.\n */\nmxPrintPreview.prototype.addGraphFragment = function(dx, dy, scale, pageNumber, div, clip)\n{\n\tvar view = this.graph.getView();\n\tvar previousContainer = this.graph.container;\n\tthis.graph.container = div;\n\n\tvar canvas = view.getCanvas();\n\tvar backgroundPane = view.getBackgroundPane();\n\tvar drawPane = view.getDrawPane();\n\tvar overlayPane = view.getOverlayPane();\n\n\tif (this.graph.dialect == mxConstants.DIALECT_SVG)\n\t{\n\t\tview.createSvg();\n\n\t\t// Uses CSS transform for scaling\n\t\tif (!mxClient.NO_FO)\n\t\t{\n\t\t\tvar g = view.getDrawPane().parentNode;\n\t\t\tvar prev = g.getAttribute('transform');\n\t\t\tg.setAttribute('transformOrigin', '0 0');\n\t\t\tg.setAttribute('transform', 'scale(' + scale + ',' + scale + ')' +\n\t\t\t\t'translate(' + dx + ',' + dy + ')');\n\n\t\t\tscale = 1;\n\t\t\tdx = 0;\n\t\t\tdy = 0;\n\t\t}\n\t}\n\telse if (this.graph.dialect == mxConstants.DIALECT_VML)\n\t{\n\t\tview.createVml();\n\t}\n\telse\n\t{\n\t\tview.createHtml();\n\t}\n\n\t// Disables events on the view\n\tvar eventsEnabled = view.isEventsEnabled();\n\tview.setEventsEnabled(false);\n\n\t// Disables the graph to avoid cursors\n\tvar graphEnabled = this.graph.isEnabled();\n\tthis.graph.setEnabled(false);\n\n\t// Resets the translation\n\tvar translate = view.getTranslate();\n\tview.translate = new mxPoint(dx, dy);\n\n\t// Redraws only states that intersect the clip\n\tvar redraw = this.graph.cellRenderer.redraw;\n\tvar states = view.states;\n\tvar s = view.scale;\n\n\t// Gets the transformed clip for intersection check below\n\tif (this.clipping)\n\t{\n\t\tvar tempClip = new mxRectangle((clip.x + translate.x) * s, (clip.y + translate.y) * s,\n\t\t\t\tclip.width * s / scale, clip.height * s / scale);\n\n\t\t// Checks clipping rectangle for speedup\n\t\t// Must create terminal states for edge clipping even if terminal outside of clip\n\t\tthis.graph.cellRenderer.redraw = function(state, force, rendering)\n\t\t{\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\t// Gets original state from graph to find bounding box\n\t\t\t\tvar orig = states.get(state.cell);\n\n\t\t\t\tif (orig != null)\n\t\t\t\t{\n\t\t\t\t\tvar bbox = view.getBoundingBox(orig, false);\n\n\t\t\t\t\t// Stops rendering if outside clip for speedup\n\t\t\t\t\tif (bbox != null && !mxUtils.intersects(tempClip, bbox))\n\t\t\t\t\t{\n\t\t\t\t\t\t//return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tredraw.apply(this, arguments);\n\t\t};\n\t}\n\n\tvar temp = null;\n\n\ttry\n\t{\n\t\t// Creates the temporary cell states in the view and\n\t\t// draws them onto the temporary DOM nodes in the view\n\t\tvar cells = [this.getRoot()];\n\t\ttemp = new mxTemporaryCellStates(view, scale, cells, null, mxUtils.bind(this, function(state)\n\t\t{\n\t\t\treturn this.getLinkForCellState(state);\n\t\t}));\n\t}\n\tfinally\n\t{\n\t\t// Removes overlay pane with selection handles\n\t\t// controls and icons from the print output\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tview.overlayPane.innerHTML = '';\n\t\t\tview.canvas.style.overflow = 'hidden';\n\t\t\tview.canvas.style.position = 'relative';\n\t\t\tview.canvas.style.top = this.marginTop + 'px';\n\t\t\tview.canvas.style.width = clip.width + 'px';\n\t\t\tview.canvas.style.height = clip.height + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Removes everything but the SVG node\n\t\t\tvar tmp = div.firstChild;\n\n\t\t\twhile (tmp != null)\n\t\t\t{\n\t\t\t\tvar next = tmp.nextSibling;\n\t\t\t\tvar name = tmp.nodeName.toLowerCase();\n\n\t\t\t\t// Note: Width and height are required in FF 11\n\t\t\t\tif (name == 'svg')\n\t\t\t\t{\n\t\t\t\t\ttmp.style.overflow = 'hidden';\n\t\t\t\t\ttmp.style.position = 'relative';\n\t\t\t\t\ttmp.style.top = this.marginTop + 'px';\n\t\t\t\t\ttmp.setAttribute('width', clip.width);\n\t\t\t\t\ttmp.setAttribute('height', clip.height);\n\t\t\t\t\ttmp.style.width = '';\n\t\t\t\t\ttmp.style.height = '';\n\t\t\t\t}\n\t\t\t\t// Tries to fetch all text labels and only text labels\n\t\t\t\telse if (tmp.style.cursor != 'default' && name != 'div')\n\t\t\t\t{\n\t\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\t}\n\n\t\t\t\ttmp = next;\n\t\t\t}\n\t\t}\n\n\t\t// Puts background image behind SVG output\n\t\tif (this.printBackgroundImage)\n\t\t{\n\t\t\tvar svgs = div.getElementsByTagName('svg');\n\n\t\t\tif (svgs.length > 0)\n\t\t\t{\n\t\t\t\tsvgs[0].style.position = 'absolute';\n\t\t\t}\n\t\t}\n\n\t\t// Completely removes the overlay pane to remove more handles\n\t\tview.overlayPane.parentNode.removeChild(view.overlayPane);\n\n\t\t// Restores the state of the view\n\t\tthis.graph.setEnabled(graphEnabled);\n\t\tthis.graph.container = previousContainer;\n\t\tthis.graph.cellRenderer.redraw = redraw;\n\t\tview.canvas = canvas;\n\t\tview.backgroundPane = backgroundPane;\n\t\tview.drawPane = drawPane;\n\t\tview.overlayPane = overlayPane;\n\t\tview.translate = translate;\n\t\ttemp.destroy();\n\t\tview.setEventsEnabled(eventsEnabled);\n\t}\n};\n\n/**\n * Function: getLinkForCellState\n *\n * Returns the link for the given cell state. This returns null.\n */\nmxPrintPreview.prototype.getLinkForCellState = function(state)\n{\n\treturn this.graph.getLinkForCell(state.cell);\n};\n\n/**\n * Function: insertBackgroundImage\n *\n * Inserts the background image into the given div.\n */\nmxPrintPreview.prototype.insertBackgroundImage = function(div, dx, dy)\n{\n\tvar bg = this.graph.backgroundImage;\n\n\tif (bg != null)\n\t{\n\t\tvar img = document.createElement('img');\n\t\timg.style.position = 'absolute';\n\t\timg.style.marginLeft = Math.round(dx * this.scale) + 'px';\n\t\timg.style.marginTop = Math.round(dy * this.scale) + 'px';\n\t\timg.setAttribute('width', Math.round(this.scale * bg.width));\n\t\timg.setAttribute('height', Math.round(this.scale * bg.height));\n\t\timg.src = bg.src;\n\n\t\tdiv.insertBefore(img, div.firstChild);\n\t}\n};\n\n/**\n * Function: getCoverPages\n *\n * Returns the pages to be added before the print output. This returns null.\n */\nmxPrintPreview.prototype.getCoverPages = function()\n{\n\treturn null;\n};\n\n/**\n * Function: getAppendices\n *\n * Returns the pages to be added after the print output. This returns null.\n */\nmxPrintPreview.prototype.getAppendices = function()\n{\n\treturn null;\n};\n\n/**\n * Function: print\n *\n * Opens the print preview and shows the print dialog.\n *\n * Parameters:\n *\n * css - Optional CSS string to be used in the head section.\n */\nmxPrintPreview.prototype.print = function(css)\n{\n\tvar wnd = this.open(css);\n\n\tif (wnd != null)\n\t{\n\t\twnd.print();\n\t}\n};\n\n/**\n * Function: close\n *\n * Closes the print preview window.\n */\nmxPrintPreview.prototype.close = function()\n{\n\tif (this.wnd != null)\n\t{\n\t\tthis.wnd.close();\n\t\tthis.wnd = null;\n\t}\n};\n\n__mxOutput.mxPrintPreview = typeof mxPrintPreview !== 'undefined' ? mxPrintPreview : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStylesheet\n *\n * Defines the appearance of the cells in a graph. See <putCellStyle> for an\n * example of creating a new cell style. It is recommended to use objects, not\n * arrays for holding cell styles. Existing styles can be cloned using\n * <mxUtils.clone> and turned into a string for debugging using\n * <mxUtils.toString>.\n *\n * Default Styles:\n *\n * The stylesheet contains two built-in styles, which are used if no style is\n * defined for a cell:\n *\n *   defaultVertex - Default style for vertices\n *   defaultEdge - Default style for edges\n *\n * Example:\n *\n * (code)\n * var vertexStyle = stylesheet.getDefaultVertexStyle();\n * vertexStyle[mxConstants.ROUNDED] = true;\n * var edgeStyle = stylesheet.getDefaultEdgeStyle();\n * edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;\n * (end)\n *\n * Modifies the built-in default styles.\n *\n * To avoid the default style for a cell, add a leading semicolon\n * to the style definition, eg.\n *\n * (code)\n * ;shadow=1\n * (end)\n *\n * Removing keys:\n *\n * For removing a key in a cell style of the form [stylename;|key=value;] the\n * special value none can be used, eg. highlight;fillColor=none\n *\n * See also the helper methods in mxUtils to modify strings of this format,\n * namely <mxUtils.setStyle>, <mxUtils.indexOfStylename>,\n * <mxUtils.addStylename>, <mxUtils.removeStylename>,\n * <mxUtils.removeAllStylenames> and <mxUtils.setStyleFlag>.\n *\n * Constructor: mxStylesheet\n *\n * Constructs a new stylesheet and assigns default styles.\n */\nfunction mxStylesheet()\n{\n\tthis.styles = new Object();\n\n\tthis.putDefaultVertexStyle(this.createDefaultVertexStyle());\n\tthis.putDefaultEdgeStyle(this.createDefaultEdgeStyle());\n};\n\n/**\n * Function: styles\n *\n * Maps from names to cell styles. Each cell style is a map of key,\n * value pairs.\n */\nmxStylesheet.prototype.styles;\n\n/**\n * Function: createDefaultVertexStyle\n *\n * Creates and returns the default vertex style.\n */\nmxStylesheet.prototype.createDefaultVertexStyle = function()\n{\n\tvar style = new Object();\n\n\tstyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\n\tstyle[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n\tstyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;\n\tstyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;\n\tstyle[mxConstants.STYLE_FILLCOLOR] = '#C3D9FF';\n\tstyle[mxConstants.STYLE_STROKECOLOR] = '#6482B9';\n\tstyle[mxConstants.STYLE_FONTCOLOR] = '#774400';\n\n\treturn style;\n};\n\n/**\n * Function: createDefaultEdgeStyle\n *\n * Creates and returns the default edge style.\n */\nmxStylesheet.prototype.createDefaultEdgeStyle = function()\n{\n\tvar style = new Object();\n\n\tstyle[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_CONNECTOR;\n\tstyle[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;\n\tstyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_MIDDLE;\n\tstyle[mxConstants.STYLE_ALIGN] = mxConstants.ALIGN_CENTER;\n\tstyle[mxConstants.STYLE_STROKECOLOR] = '#6482B9';\n\tstyle[mxConstants.STYLE_FONTCOLOR] = '#446299';\n\n\treturn style;\n};\n\n/**\n * Function: putDefaultVertexStyle\n *\n * Sets the default style for vertices using defaultVertex as the\n * stylename.\n *\n * Parameters:\n * style - Key, value pairs that define the style.\n */\nmxStylesheet.prototype.putDefaultVertexStyle = function(style)\n{\n\tthis.putCellStyle('defaultVertex', style);\n};\n\n/**\n * Function: putDefaultEdgeStyle\n *\n * Sets the default style for edges using defaultEdge as the stylename.\n */\nmxStylesheet.prototype.putDefaultEdgeStyle = function(style)\n{\n\tthis.putCellStyle('defaultEdge', style);\n};\n\n/**\n * Function: getDefaultVertexStyle\n *\n * Returns the default style for vertices.\n */\nmxStylesheet.prototype.getDefaultVertexStyle = function()\n{\n\treturn this.styles['defaultVertex'];\n};\n\n/**\n * Function: getDefaultEdgeStyle\n *\n * Sets the default style for edges.\n */\nmxStylesheet.prototype.getDefaultEdgeStyle = function()\n{\n\treturn this.styles['defaultEdge'];\n};\n\n/**\n * Function: putCellStyle\n *\n * Stores the given map of key, value pairs under the given name in\n * <styles>.\n *\n * Example:\n *\n * The following example adds a new style called 'rounded' into an\n * existing stylesheet:\n *\n * (code)\n * var style = new Object();\n * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\n * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\n * style[mxConstants.STYLE_ROUNDED] = true;\n * graph.getStylesheet().putCellStyle('rounded', style);\n * (end)\n *\n * In the above example, the new style is an object. The possible keys of\n * the object are all the constants in <mxConstants> that start with STYLE\n * and the values are either JavaScript objects, such as\n * <mxPerimeter.RightAngleRectanglePerimeter> (which is in fact a function)\n * or expressions, such as true. Note that not all keys will be\n * interpreted by all shapes (eg. the line shape ignores the fill color).\n * The final call to this method associates the style with a name in the\n * stylesheet. The style is used in a cell with the following code:\n *\n * (code)\n * model.setStyle(cell, 'rounded');\n * (end)\n *\n * Parameters:\n *\n * name - Name for the style to be stored.\n * style - Key, value pairs that define the style.\n */\nmxStylesheet.prototype.putCellStyle = function(name, style)\n{\n\tthis.styles[name] = style;\n};\n\n/**\n * Function: getCellStyle\n *\n * Returns the cell style for the specified stylename or the given\n * defaultStyle if no style can be found for the given stylename.\n *\n * Parameters:\n *\n * name - String of the form [(stylename|key=value);] that represents the\n * style.\n * defaultStyle - Default style to be returned if no style can be found.\n */\nmxStylesheet.prototype.getCellStyle = function(name, defaultStyle)\n{\n\tvar style = defaultStyle;\n\n\tif (name != null && name.length > 0)\n\t{\n\t\tvar pairs = name.split(';');\n\n\t\tif (style != null &&\n\t\t\tname.charAt(0) != ';')\n\t\t{\n\t\t\tstyle = mxUtils.clone(style);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstyle = new Object();\n\t\t}\n\n\t\t// Parses each key, value pair into the existing style\n\t \tfor (var i = 0; i < pairs.length; i++)\n\t \t{\n\t \t\tvar tmp = pairs[i];\n\t \t\tvar pos = tmp.indexOf('=');\n\n\t \t\tif (pos >= 0)\n\t \t\t{\n\t\t \t\tvar key = tmp.substring(0, pos);\n\t\t \t\tvar value = tmp.substring(pos + 1);\n\n\t\t \t\tif (value == mxConstants.NONE)\n\t\t \t\t{\n\t\t \t\t\tdelete style[key];\n\t\t \t\t}\n\t\t \t\telse if (mxUtils.isNumeric(value))\n\t\t \t\t{\n\t\t \t\t\tstyle[key] = parseFloat(value);\n\t\t \t\t}\n\t\t \t\telse\n\t\t \t\t{\n\t\t\t \t\tstyle[key] = value;\n\t\t \t\t}\n\t\t\t}\n\t \t\telse\n\t \t\t{\n\t \t\t\t// Merges the entries from a named style\n\t\t\t\tvar tmpStyle = this.styles[tmp];\n\n\t\t\t\tif (tmpStyle != null)\n\t\t\t\t{\n\t\t\t\t\tfor (var key in tmpStyle)\n\t\t\t\t\t{\n\t\t\t\t\t\tstyle[key] = tmpStyle[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t \t\t}\n\t\t}\n\t}\n\n\treturn style;\n};\n\n__mxOutput.mxStylesheet = typeof mxStylesheet !== 'undefined' ? mxStylesheet : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellState\n *\n * Represents the current state of a cell in a given <mxGraphView>.\n *\n * For edges, the edge label position is stored in <absoluteOffset>.\n *\n * The size for oversize labels can be retrieved using the boundingBox property\n * of the <text> field as shown below.\n *\n * (code)\n * var bbox = (state.text != null) ? state.text.boundingBox : null;\n * (end)\n *\n * Constructor: mxCellState\n *\n * Constructs a new object that represents the current state of the given\n * cell in the specified view.\n *\n * Parameters:\n *\n * view - <mxGraphView> that contains the state.\n * cell - <mxCell> that this state represents.\n * style - Array of key, value pairs that constitute the style.\n */\nfunction mxCellState(view, cell, style)\n{\n\tthis.view = view;\n\tthis.cell = cell;\n\tthis.style = (style != null) ? style : {};\n\n\tthis.origin = new mxPoint();\n\tthis.absoluteOffset = new mxPoint();\n};\n\n/**\n * Extends mxRectangle.\n */\nmxCellState.prototype = new mxRectangle();\nmxCellState.prototype.constructor = mxCellState;\n\n/**\n * Variable: view\n *\n * Reference to the enclosing <mxGraphView>.\n */\nmxCellState.prototype.view = null;\n\n/**\n * Variable: cell\n *\n * Reference to the <mxCell> that is represented by this state.\n */\nmxCellState.prototype.cell = null;\n\n/**\n * Variable: style\n *\n * Contains an array of key, value pairs that represent the style of the\n * cell.\n */\nmxCellState.prototype.style = null;\n\n/**\n * Variable: invalidStyle\n *\n * Specifies if the style is invalid. Default is false.\n */\nmxCellState.prototype.invalidStyle = false;\n\n/**\n * Variable: invalid\n *\n * Specifies if the state is invalid. Default is true.\n */\nmxCellState.prototype.invalid = true;\n\n/**\n * Variable: origin\n *\n * <mxPoint> that holds the origin for all child cells. Default is a new\n * empty <mxPoint>.\n */\nmxCellState.prototype.origin = null;\n\n/**\n * Variable: absolutePoints\n *\n * Holds an array of <mxPoints> that represent the absolute points of an\n * edge.\n */\nmxCellState.prototype.absolutePoints = null;\n\n/**\n * Variable: absoluteOffset\n *\n * <mxPoint> that holds the absolute offset. For edges, this is the\n * absolute coordinates of the label position. For vertices, this is the\n * offset of the label relative to the top, left corner of the vertex.\n */\nmxCellState.prototype.absoluteOffset = null;\n\n/**\n * Variable: visibleSourceState\n *\n * Caches the visible source terminal state.\n */\nmxCellState.prototype.visibleSourceState = null;\n\n/**\n * Variable: visibleTargetState\n *\n * Caches the visible target terminal state.\n */\nmxCellState.prototype.visibleTargetState = null;\n\n/**\n * Variable: terminalDistance\n *\n * Caches the distance between the end points for an edge.\n */\nmxCellState.prototype.terminalDistance = 0;\n\n/**\n * Variable: length\n *\n * Caches the length of an edge.\n */\nmxCellState.prototype.length = 0;\n\n/**\n * Variable: segments\n *\n * Array of numbers that represent the cached length of each segment of the\n * edge.\n */\nmxCellState.prototype.segments = null;\n\n/**\n * Variable: shape\n *\n * Holds the <mxShape> that represents the cell graphically.\n */\nmxCellState.prototype.shape = null;\n\n/**\n * Variable: text\n *\n * Holds the <mxText> that represents the label of the cell. Thi smay be\n * null if the cell has no label.\n */\nmxCellState.prototype.text = null;\n\n/**\n * Variable: unscaledWidth\n *\n * Holds the unscaled width of the state.\n */\nmxCellState.prototype.unscaledWidth = null;\n\n/**\n * Function: getPerimeterBounds\n *\n * Returns the <mxRectangle> that should be used as the perimeter of the\n * cell.\n *\n * Parameters:\n *\n * border - Optional border to be added around the perimeter bounds.\n * bounds - Optional <mxRectangle> to be used as the initial bounds.\n */\nmxCellState.prototype.getPerimeterBounds = function(border, bounds)\n{\n\tborder = border || 0;\n\tbounds = (bounds != null) ? bounds : new mxRectangle(this.x, this.y, this.width, this.height);\n\n\tif (this.shape != null && this.shape.stencil != null && this.shape.stencil.aspect == 'fixed')\n\t{\n\t\tvar aspect = this.shape.stencil.computeAspect(this.style, bounds.x, bounds.y, bounds.width, bounds.height);\n\n\t\tbounds.x = aspect.x;\n\t\tbounds.y = aspect.y;\n\t\tbounds.width = this.shape.stencil.w0 * aspect.width;\n\t\tbounds.height = this.shape.stencil.h0 * aspect.height;\n\t}\n\n\tif (border != 0)\n\t{\n\t\tbounds.grow(border);\n\t}\n\n\treturn bounds;\n};\n\n/**\n * Function: setAbsoluteTerminalPoint\n *\n * Sets the first or last point in <absolutePoints> depending on isSource.\n *\n * Parameters:\n *\n * point - <mxPoint> that represents the terminal point.\n * isSource - Boolean that specifies if the first or last point should\n * be assigned.\n */\nmxCellState.prototype.setAbsoluteTerminalPoint = function(point, isSource)\n{\n\tif (isSource)\n\t{\n\t\tif (this.absolutePoints == null)\n\t\t{\n\t\t\tthis.absolutePoints = [];\n\t\t}\n\n\t\tif (this.absolutePoints.length == 0)\n\t\t{\n\t\t\tthis.absolutePoints.push(point);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.absolutePoints[0] = point;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (this.absolutePoints == null)\n\t\t{\n\t\t\tthis.absolutePoints = [];\n\t\t\tthis.absolutePoints.push(null);\n\t\t\tthis.absolutePoints.push(point);\n\t\t}\n\t\telse if (this.absolutePoints.length == 1)\n\t\t{\n\t\t\tthis.absolutePoints.push(point);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.absolutePoints[this.absolutePoints.length - 1] = point;\n\t\t}\n\t}\n};\n\n/**\n * Function: setCursor\n *\n * Sets the given cursor on the shape and text shape.\n */\nmxCellState.prototype.setCursor = function(cursor)\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.setCursor(cursor);\n\t}\n\n\tif (this.text != null)\n\t{\n\t\tthis.text.setCursor(cursor);\n\t}\n};\n\n/**\n * Function: getVisibleTerminal\n *\n * Returns the visible source or target terminal cell.\n *\n * Parameters:\n *\n * source - Boolean that specifies if the source or target cell should be\n * returned.\n */\nmxCellState.prototype.getVisibleTerminal = function(source)\n{\n\tvar tmp = this.getVisibleTerminalState(source);\n\n\treturn (tmp != null) ? tmp.cell : null;\n};\n\n/**\n * Function: getVisibleTerminalState\n *\n * Returns the visible source or target terminal state.\n *\n * Parameters:\n *\n * source - Boolean that specifies if the source or target state should be\n * returned.\n */\nmxCellState.prototype.getVisibleTerminalState = function(source)\n{\n\treturn (source) ? this.visibleSourceState : this.visibleTargetState;\n};\n\n/**\n * Function: setVisibleTerminalState\n *\n * Sets the visible source or target terminal state.\n *\n * Parameters:\n *\n * terminalState - <mxCellState> that represents the terminal.\n * source - Boolean that specifies if the source or target state should be set.\n */\nmxCellState.prototype.setVisibleTerminalState = function(terminalState, source)\n{\n\tif (source)\n\t{\n\t\tthis.visibleSourceState = terminalState;\n\t}\n\telse\n\t{\n\t\tthis.visibleTargetState = terminalState;\n\t}\n};\n\n/**\n * Function: getCellBounds\n *\n * Returns the unscaled, untranslated bounds.\n */\nmxCellState.prototype.getCellBounds = function()\n{\n\treturn this.cellBounds;\n};\n\n/**\n * Function: getPaintBounds\n *\n * Returns the unscaled, untranslated paint bounds. This is the same as\n * <getCellBounds> but with a 90 degree rotation if the shape's\n * isPaintBoundsInverted returns true.\n */\nmxCellState.prototype.getPaintBounds = function()\n{\n\treturn this.paintBounds;\n};\n\n/**\n * Function: updateCachedBounds\n *\n * Updates the cellBounds and paintBounds.\n */\nmxCellState.prototype.updateCachedBounds = function()\n{\n\tvar tr = this.view.translate;\n\tvar s = this.view.scale;\n\tthis.cellBounds = new mxRectangle(this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);\n\tthis.paintBounds = mxRectangle.fromRectangle(this.cellBounds);\n\n\tif (this.shape != null && this.shape.isPaintBoundsInverted())\n\t{\n\t\tthis.paintBounds.rotate90();\n\t}\n};\n\n/**\n * Destructor: setState\n *\n * Copies all fields from the given state to this state.\n */\nmxCellState.prototype.setState = function(state)\n{\n\tthis.view = state.view;\n\tthis.cell = state.cell;\n\tthis.style = state.style;\n\tthis.absolutePoints = state.absolutePoints;\n\tthis.origin = state.origin;\n\tthis.absoluteOffset = state.absoluteOffset;\n\tthis.boundingBox = state.boundingBox;\n\tthis.terminalDistance = state.terminalDistance;\n\tthis.segments = state.segments;\n\tthis.length = state.length;\n\tthis.x = state.x;\n\tthis.y = state.y;\n\tthis.width = state.width;\n\tthis.height = state.height;\n\tthis.unscaledWidth = state.unscaledWidth;\n};\n\n/**\n * Function: clone\n *\n * Returns a clone of this <mxPoint>.\n */\nmxCellState.prototype.clone = function()\n{\n \tvar clone = new mxCellState(this.view, this.cell, this.style);\n\n\t// Clones the absolute points\n\tif (this.absolutePoints != null)\n\t{\n\t\tclone.absolutePoints = [];\n\n\t\tfor (var i = 0; i < this.absolutePoints.length; i++)\n\t\t{\n\t\t\tclone.absolutePoints[i] = this.absolutePoints[i].clone();\n\t\t}\n\t}\n\n\tif (this.origin != null)\n\t{\n\t\tclone.origin = this.origin.clone();\n\t}\n\n\tif (this.absoluteOffset != null)\n\t{\n\t\tclone.absoluteOffset = this.absoluteOffset.clone();\n\t}\n\n\tif (this.boundingBox != null)\n\t{\n\t\tclone.boundingBox = this.boundingBox.clone();\n\t}\n\n\tclone.terminalDistance = this.terminalDistance;\n\tclone.segments = this.segments;\n\tclone.length = this.length;\n\tclone.x = this.x;\n\tclone.y = this.y;\n\tclone.width = this.width;\n\tclone.height = this.height;\n\tclone.unscaledWidth = this.unscaledWidth;\n\n\treturn clone;\n};\n\n/**\n * Destructor: destroy\n *\n * Destroys the state and all associated resources.\n */\nmxCellState.prototype.destroy = function()\n{\n\tthis.view.graph.cellRenderer.destroy(this);\n};\n\n__mxOutput.mxCellState = typeof mxCellState !== 'undefined' ? mxCellState : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphSelectionModel\n *\n * Implements the selection model for a graph. Here is a listener that handles\n * all removed selection cells.\n *\n * (code)\n * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)\n * {\n *   var cells = evt.getProperty('added');\n *\n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     // Handle cells[i]...\n *   }\n * });\n * (end)\n *\n * Event: mxEvent.UNDO\n *\n * Fires after the selection was changed in <changeSelection>. The\n * <code>edit</code> property contains the <mxUndoableEdit> which contains the\n * <mxSelectionChange>.\n *\n * Event: mxEvent.CHANGE\n *\n * Fires after the selection changes by executing an <mxSelectionChange>. The\n * <code>added</code> and <code>removed</code> properties contain arrays of\n * cells that have been added to or removed from the selection, respectively.\n * The names are inverted due to historic reasons. This cannot be changed.\n *\n * Constructor: mxGraphSelectionModel\n *\n * Constructs a new graph selection model for the given <mxGraph>.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxGraphSelectionModel(graph)\n{\n\tthis.graph = graph;\n\tthis.cells = [];\n};\n\n/**\n * Extends mxEventSource.\n */\nmxGraphSelectionModel.prototype = new mxEventSource();\nmxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;\n\n/**\n * Variable: doneResource\n *\n * Specifies the resource key for the status message after a long operation.\n * If the resource for this key does not exist then the value is used as\n * the status message. Default is 'done'.\n */\nmxGraphSelectionModel.prototype.doneResource = (mxClient.language != 'none') ? 'done' : '';\n\n/**\n * Variable: updatingSelectionResource\n *\n * Specifies the resource key for the status message while the selection is\n * being updated. If the resource for this key does not exist then the\n * value is used as the status message. Default is 'updatingSelection'.\n */\nmxGraphSelectionModel.prototype.updatingSelectionResource = (mxClient.language != 'none') ? 'updatingSelection' : '';\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxGraphSelectionModel.prototype.graph = null;\n\n/**\n * Variable: singleSelection\n *\n * Specifies if only one selected item at a time is allowed.\n * Default is false.\n */\nmxGraphSelectionModel.prototype.singleSelection = false;\n\n/**\n * Function: isSingleSelection\n *\n * Returns <singleSelection> as a boolean.\n */\nmxGraphSelectionModel.prototype.isSingleSelection = function()\n{\n\treturn this.singleSelection;\n};\n\n/**\n * Function: setSingleSelection\n *\n * Sets the <singleSelection> flag.\n *\n * Parameters:\n *\n * singleSelection - Boolean that specifies the new value for\n * <singleSelection>.\n */\nmxGraphSelectionModel.prototype.setSingleSelection = function(singleSelection)\n{\n\tthis.singleSelection = singleSelection;\n};\n\n/**\n * Function: isSelected\n *\n * Returns true if the given <mxCell> is selected.\n */\nmxGraphSelectionModel.prototype.isSelected = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\treturn mxUtils.indexOf(this.cells, cell) >= 0;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: isEmpty\n *\n * Returns true if no cells are currently selected.\n */\nmxGraphSelectionModel.prototype.isEmpty = function()\n{\n\treturn this.cells.length == 0;\n};\n\n/**\n * Function: clear\n *\n * Clears the selection and fires a <change> event if the selection was not\n * empty.\n */\nmxGraphSelectionModel.prototype.clear = function()\n{\n\tthis.changeSelection(null, this.cells);\n};\n\n/**\n * Function: setCell\n *\n * Selects the specified <mxCell> using <setCells>.\n *\n * Parameters:\n *\n * cell - <mxCell> to be selected.\n */\nmxGraphSelectionModel.prototype.setCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tthis.setCells([cell]);\n\t}\n};\n\n/**\n * Function: setCells\n *\n * Selects the given array of <mxCells> and fires a <change> event.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be selected.\n */\nmxGraphSelectionModel.prototype.setCells = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tif (this.singleSelection)\n\t\t{\n\t\t\tcells = [this.getFirstSelectableCell(cells)];\n\t\t}\n\n\t\tvar tmp = [];\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.graph.isCellSelectable(cells[i]))\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.changeSelection(tmp, this.cells);\n\t}\n};\n\n/**\n * Function: getFirstSelectableCell\n *\n * Returns the first selectable cell in the given array of cells.\n */\nmxGraphSelectionModel.prototype.getFirstSelectableCell = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.graph.isCellSelectable(cells[i]))\n\t\t\t{\n\t\t\t\treturn cells[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: addCell\n *\n * Adds the given <mxCell> to the selection and fires a <select> event.\n *\n * Parameters:\n *\n * cell - <mxCell> to add to the selection.\n */\nmxGraphSelectionModel.prototype.addCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tthis.addCells([cell]);\n\t}\n};\n\n/**\n * Function: addCells\n *\n * Adds the given array of <mxCells> to the selection and fires a <select>\n * event.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to add to the selection.\n */\nmxGraphSelectionModel.prototype.addCells = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar remove = null;\n\n\t\tif (this.singleSelection)\n\t\t{\n\t\t\tremove = this.cells;\n\t\t\tcells = [this.getFirstSelectableCell(cells)];\n\t\t}\n\n\t\tvar tmp = [];\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (!this.isSelected(cells[i]) &&\n\t\t\t\tthis.graph.isCellSelectable(cells[i]))\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.changeSelection(tmp, remove);\n\t}\n};\n\n/**\n * Function: removeCell\n *\n * Removes the specified <mxCell> from the selection and fires a <select>\n * event for the remaining cells.\n *\n * Parameters:\n *\n * cell - <mxCell> to remove from the selection.\n */\nmxGraphSelectionModel.prototype.removeCell = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tthis.removeCells([cell]);\n\t}\n};\n\n/**\n * Function: removeCells\n */\nmxGraphSelectionModel.prototype.removeCells = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar tmp = [];\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.isSelected(cells[i]))\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.changeSelection(null, tmp);\n\t}\n};\n\n/**\n * Function: changeSelection\n *\n * Inner callback to add the specified <mxCell> to the selection. No event\n * is fired in this implementation.\n *\n * Paramters:\n *\n * cell - <mxCell> to add to the selection.\n */\nmxGraphSelectionModel.prototype.changeSelection = function(added, removed)\n{\n\tif ((added != null &&\n\t\tadded.length > 0 &&\n\t\tadded[0] != null) ||\n\t\t(removed != null &&\n\t\tremoved.length > 0 &&\n\t\tremoved[0] != null))\n\t{\n\t\tvar change = new mxSelectionChange(this, added, removed);\n\t\tchange.execute();\n\t\tvar edit = new mxUndoableEdit(this, false);\n\t\tedit.add(change);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n\t}\n};\n\n/**\n * Function: cellAdded\n *\n * Inner callback to add the specified <mxCell> to the selection. No event\n * is fired in this implementation.\n *\n * Paramters:\n *\n * cell - <mxCell> to add to the selection.\n */\nmxGraphSelectionModel.prototype.cellAdded = function(cell)\n{\n\tif (cell != null &&\n\t\t!this.isSelected(cell))\n\t{\n\t\tthis.cells.push(cell);\n\t}\n};\n\n/**\n * Function: cellRemoved\n *\n * Inner callback to remove the specified <mxCell> from the selection. No\n * event is fired in this implementation.\n *\n * Parameters:\n *\n * cell - <mxCell> to remove from the selection.\n */\nmxGraphSelectionModel.prototype.cellRemoved = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tvar index = mxUtils.indexOf(this.cells, cell);\n\n\t\tif (index >= 0)\n\t\t{\n\t\t\tthis.cells.splice(index, 1);\n\t\t}\n\t}\n};\n\n/**\n * Class: mxSelectionChange\n *\n * Action to change the current root in a view.\n *\n * Constructor: mxCurrentRootChange\n *\n * Constructs a change of the current root in the given view.\n */\nfunction mxSelectionChange(selectionModel, added, removed)\n{\n\tthis.selectionModel = selectionModel;\n\tthis.added = (added != null) ? added.slice() : null;\n\tthis.removed = (removed != null) ? removed.slice() : null;\n};\n\n/**\n * Function: execute\n *\n * Changes the current root of the view.\n */\nmxSelectionChange.prototype.execute = function()\n{\n\tvar t0 = mxLog.enter('mxSelectionChange.execute');\n\twindow.status = mxResources.get(\n\t\tthis.selectionModel.updatingSelectionResource) ||\n\t\tthis.selectionModel.updatingSelectionResource;\n\n\tif (this.removed != null)\n\t{\n\t\tfor (var i = 0; i < this.removed.length; i++)\n\t\t{\n\t\t\tthis.selectionModel.cellRemoved(this.removed[i]);\n\t\t}\n\t}\n\n\tif (this.added != null)\n\t{\n\t\tfor (var i = 0; i < this.added.length; i++)\n\t\t{\n\t\t\tthis.selectionModel.cellAdded(this.added[i]);\n\t\t}\n\t}\n\n\tvar tmp = this.added;\n\tthis.added = this.removed;\n\tthis.removed = tmp;\n\n\twindow.status = mxResources.get(this.selectionModel.doneResource) ||\n\t\tthis.selectionModel.doneResource;\n\tmxLog.leave('mxSelectionChange.execute', t0);\n\n\tthis.selectionModel.fireEvent(new mxEventObject(mxEvent.CHANGE,\n\t\t\t'added', this.added, 'removed', this.removed));\n};\n\n__mxOutput.mxGraphSelectionModel = typeof mxGraphSelectionModel !== 'undefined' ? mxGraphSelectionModel : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellEditor\n *\n * In-place editor for the graph. To control this editor, use\n * <mxGraph.invokesStopCellEditing>, <mxGraph.enterStopsCellEditing> and\n * <mxGraph.escapeEnabled>. If <mxGraph.enterStopsCellEditing> is true then\n * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\n * escape keys can always be used to stop editing.\n *\n * To customize the location of the textbox in the graph, override\n * <getEditorBounds> as follows:\n *\n * (code)\n * graph.cellEditor.getEditorBounds = function(state)\n * {\n *   var result = mxCellEditor.prototype.getEditorBounds.apply(this, arguments);\n *\n *   if (this.graph.getModel().isEdge(state.cell))\n *   {\n *     result.x = state.getCenterX() - result.width / 2;\n *     result.y = state.getCenterY() - result.height / 2;\n *   }\n *\n *   return result;\n * };\n * (end)\n *\n * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\n * then <mxShape.getLabelBounds> is used to compute the current bounds of the textbox.\n *\n * The textarea uses the mxCellEditor CSS class. You can modify this class in\n * your custom CSS. Note: You should modify the CSS after loading the client\n * in the page.\n *\n * Example:\n *\n * To only allow numeric input in the in-place editor, use the following code.\n *\n * (code)\n * var text = graph.cellEditor.textarea;\n *\n * mxEvent.addListener(text, 'keydown', function (evt)\n * {\n *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\n *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\n *   {\n *     mxEvent.consume(evt);\n *   }\n * });\n * (end)\n *\n * Placeholder:\n *\n * To implement a placeholder for cells without a label, use the\n * <emptyLabelText> variable.\n *\n * Resize in Chrome:\n *\n * Resize of the textarea is disabled by default. If you want to enable\n * this feature extend <init> and set this.textarea.style.resize = ''.\n *\n * To start editing on a key press event, the container of the graph\n * should have focus or a focusable parent should be used to add the\n * key press handler as follows.\n *\n * (code)\n * mxEvent.addListener(graph.container, 'keypress', mxUtils.bind(this, function(evt)\n * {\n *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\n *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\n *   {\n *     graph.startEditing();\n *\n *     if (mxClient.IS_FF)\n *     {\n *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\n *     }\n *   }\n * }));\n * (end)\n *\n * To allow focus for a DIV, and hence to receive key press events, some browsers\n * require it to have a valid tabindex attribute. In this case the following\n * code may be used to keep the container focused.\n *\n * (code)\n * var graphFireMouseEvent = graph.fireMouseEvent;\n * graph.fireMouseEvent = function(evtName, me, sender)\n * {\n *   if (evtName == mxEvent.MOUSE_DOWN)\n *   {\n *     this.container.focus();\n *   }\n *\n *   graphFireMouseEvent.apply(this, arguments);\n * };\n * (end)\n *\n * Constructor: mxCellEditor\n *\n * Constructs a new in-place editor for the specified graph.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxCellEditor(graph)\n{\n\tthis.graph = graph;\n\n\t// Stops editing after zoom changes\n\tthis.zoomHandler = mxUtils.bind(this, function()\n\t{\n\t\tif (this.graph.isEditing())\n\t\t{\n\t\t\tthis.resize();\n\t\t}\n\t});\n\n\tthis.graph.view.addListener(mxEvent.SCALE, this.zoomHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.zoomHandler);\n\n\t// Adds handling of deleted cells while editing\n\tthis.changeHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tif (this.editingCell != null && this.graph.getView().getState(this.editingCell) == null)\n\t\t{\n\t\t\tthis.stopEditing(true);\n\t\t}\n\t});\n\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxCellEditor.prototype.graph = null;\n\n/**\n * Variable: textarea\n *\n * Holds the DIV that is used for text editing. Note that this may be null before the first\n * edit. Instantiated in <init>.\n */\nmxCellEditor.prototype.textarea = null;\n\n/**\n * Variable: editingCell\n *\n * Reference to the <mxCell> that is currently being edited.\n */\nmxCellEditor.prototype.editingCell = null;\n\n/**\n * Variable: trigger\n *\n * Reference to the event that was used to start editing.\n */\nmxCellEditor.prototype.trigger = null;\n\n/**\n * Variable: modified\n *\n * Specifies if the label has been modified.\n */\nmxCellEditor.prototype.modified = false;\n\n/**\n * Variable: autoSize\n *\n * Specifies if the textarea should be resized while the text is being edited.\n * Default is true.\n */\nmxCellEditor.prototype.autoSize = true;\n\n/**\n * Variable: selectText\n *\n * Specifies if the text should be selected when editing starts. Default is\n * true.\n */\nmxCellEditor.prototype.selectText = true;\n\n/**\n * Variable: emptyLabelText\n *\n * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as\n * a workaround for the missing cursor bug for empty content editable. This can\n * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The\n * value is only displayed before the first keystroke and is never used as the\n * actual editing value.\n */\nmxCellEditor.prototype.emptyLabelText = (mxClient.IS_FF) ? '<br>' : '';\n\n/**\n * Variable: escapeCancelsEditing\n *\n * If true, pressing the escape key will stop editing and not accept the new\n * value. Change this to false to accept the new value on escape, and cancel\n * editing on Shift+Escape instead. Default is true.\n */\nmxCellEditor.prototype.escapeCancelsEditing = true;\n\n/**\n * Variable: textNode\n *\n * Reference to the label DOM node that has been hidden.\n */\nmxCellEditor.prototype.textNode = '';\n\n/**\n * Variable: zIndex\n *\n * Specifies the zIndex for the textarea. Default is 5.\n */\nmxCellEditor.prototype.zIndex = 5;\n\n/**\n * Variable: minResize\n *\n * Defines the minimum width and height to be used in <resize>. Default is 0x20px.\n */\nmxCellEditor.prototype.minResize = new mxRectangle(0, 20);\n\n/**\n * Variable: wordWrapPadding\n *\n * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE\n * 11 and 1 in all other browsers and modes.\n */\nmxCellEditor.prototype.wordWrapPadding = (mxClient.IS_QUIRKS) ? 2 : (!mxClient.IS_IE11) ? 1 : 0;\n\n/**\n * Variable: blurEnabled\n *\n * If <focusLost> should be called if <textarea> loses the focus. Default is false.\n */\nmxCellEditor.prototype.blurEnabled = false;\n\n/**\n * Variable: initialValue\n *\n * Holds the initial editing value to check if the current value was modified.\n */\nmxCellEditor.prototype.initialValue = null;\n\n/**\n * Variable: align\n *\n * Holds the current temporary horizontal alignment for the cell style. If this\n * is modified then the current text alignment is changed and the cell style is\n * updated when the value is applied.\n */\nmxCellEditor.prototype.align = null;\n\n/**\n * Function: init\n *\n * Creates the <textarea> and installs the event listeners. The key handler\n * updates the <modified> state.\n */\nmxCellEditor.prototype.init = function ()\n{\n\tthis.textarea = document.createElement('div');\n\tthis.textarea.className = 'mxCellEditor mxPlainTextEditor';\n\tthis.textarea.contentEditable = true;\n\n\t// Workaround for selection outside of DIV if height is 0\n\tif (mxClient.IS_GC)\n\t{\n\t\tthis.textarea.style.minHeight = '1em';\n\t}\n\n\tthis.textarea.style.position = ((this.isLegacyEditor())) ? 'absolute' : 'relative';\n\tthis.installListeners(this.textarea);\n};\n\n/**\n * Function: applyValue\n *\n * Called in <stopEditing> if cancel is false to invoke <mxGraph.labelChanged>.\n */\nmxCellEditor.prototype.applyValue = function(state, value)\n{\n\tthis.graph.labelChanged(state.cell, value, this.trigger);\n};\n\n/**\n * Function: setAlign\n *\n * Sets the temporary horizontal alignment for the current editing session.\n */\nmxCellEditor.prototype.setAlign = function (align)\n{\n\tif (this.textarea != null)\n\t{\n\t\tthis.textarea.style.textAlign = align;\n\t}\n\n\tthis.align = align;\n\tthis.resize();\n};\n\n/**\n * Function: getInitialValue\n *\n * Gets the initial editing value for the given cell.\n */\nmxCellEditor.prototype.getInitialValue = function(state, trigger)\n{\n\tvar result = mxUtils.htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);\n\n    // Workaround for trailing line breaks being ignored in the editor\n\tif (!mxClient.IS_QUIRKS && document.documentMode != 8 && document.documentMode != 9 &&\n\t\tdocument.documentMode != 10)\n\t{\n\t\tresult = mxUtils.replaceTrailingNewlines(result, '<div><br></div>');\n\t}\n\n    return result.replace(/\\n/g, '<br>');\n};\n\n/**\n * Function: getCurrentValue\n *\n * Returns the current editing value.\n */\nmxCellEditor.prototype.getCurrentValue = function(state)\n{\n\treturn mxUtils.extractTextWithWhitespace(this.textarea.childNodes);\n};\n\n/**\n * Function: isCancelEditingKeyEvent\n *\n * Returns true if <escapeCancelsEditing> is true and shift, control and meta\n * are not pressed.\n */\nmxCellEditor.prototype.isCancelEditingKeyEvent = function(evt)\n{\n\treturn this.escapeCancelsEditing || mxEvent.isShiftDown(evt) || mxEvent.isControlDown(evt) || mxEvent.isMetaDown(evt);\n};\n\n/**\n * Function: installListeners\n *\n * Installs listeners for focus, change and standard key event handling.\n */\nmxCellEditor.prototype.installListeners = function(elt)\n{\n\t// Applies value if text is dragged\n\t// LATER: Gesture mouse events ignored for starting move\n\tmxEvent.addListener(elt, 'dragstart', mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.graph.stopEditing(false);\n\t\tmxEvent.consume(evt);\n\t}));\n\n\t// Applies value if focus is lost\n\tmxEvent.addListener(elt, 'blur', mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.blurEnabled)\n\t\t{\n\t\t\tthis.focusLost(evt);\n\t\t}\n\t}));\n\n\t// Updates modified state and handles placeholder text\n\tmxEvent.addListener(elt, 'keydown', mxUtils.bind(this, function(evt)\n\t{\n\t\tif (!mxEvent.isConsumed(evt))\n\t\t{\n\t\t\tif (this.isStopEditingEvent(evt))\n\t\t\t{\n\t\t\t\tthis.graph.stopEditing(false);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}\n\t\t\telse if (evt.keyCode == 27 /* Escape */)\n\t\t\t{\n\t\t\t\tthis.graph.stopEditing(this.isCancelEditingKeyEvent(evt));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}\n\t\t}\n\t}));\n\n\t// Keypress only fires if printable key was pressed and handles removing the empty placeholder\n\tvar keypressHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.editingCell != null)\n\t\t{\n\t\t\t// Clears the initial empty label on the first keystroke\n\t\t\t// and workaround for FF which fires keypress for delete and backspace\n\t\t\tif (this.clearOnChange && elt.innerHTML == this.getEmptyLabelText() &&\n\t\t\t\t(!mxClient.IS_FF || (evt.keyCode != 8 /* Backspace */ && evt.keyCode != 46 /* Delete */)))\n\t\t\t{\n\t\t\t\tthis.clearOnChange = false;\n\t\t\t\telt.innerHTML = '';\n\t\t\t}\n\t\t}\n\t});\n\n\tmxEvent.addListener(elt, 'keypress', keypressHandler);\n\tmxEvent.addListener(elt, 'paste', keypressHandler);\n\n\t// Handler for updating the empty label text value after a change\n\tvar keyupHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.editingCell != null)\n\t\t{\n\t\t\t// Uses an optional text value for sempty labels which is cleared\n\t\t\t// when the first keystroke appears. This makes it easier to see\n\t\t\t// that a label is being edited even if the label is empty.\n\t\t\t// In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size\n\t\t\tif (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == '<br>')\n\t\t\t{\n\t\t\t\tthis.textarea.innerHTML = this.getEmptyLabelText();\n\t\t\t\tthis.clearOnChange = this.textarea.innerHTML.length > 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.clearOnChange = false;\n\t\t\t}\n\t\t}\n\t});\n\n\tmxEvent.addListener(elt, (!mxClient.IS_IE11 && !mxClient.IS_IE) ? 'input' : 'keyup', keyupHandler);\n\tmxEvent.addListener(elt, 'cut', keyupHandler);\n\tmxEvent.addListener(elt, 'paste', keyupHandler);\n\n\t// Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events\n\tvar evtName = (!mxClient.IS_IE11 && !mxClient.IS_IE) ? 'input' : 'keydown';\n\n\tvar resizeHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tif (this.editingCell != null && this.autoSize && !mxEvent.isConsumed(evt))\n\t\t{\n\t\t\t// Asynchronous is needed for keydown and shows better results for input events overall\n\t\t\t// (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)\n\t\t\tif (this.resizeThread != null)\n\t\t\t{\n\t\t\t\twindow.clearTimeout(this.resizeThread);\n\t\t\t}\n\n\t\t\tthis.resizeThread = window.setTimeout(mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.resizeThread = null;\n\t\t\t\tthis.resize();\n\t\t\t}), 0);\n\t\t}\n\t});\n\n\tmxEvent.addListener(elt, evtName, resizeHandler);\n\tmxEvent.addListener(window, 'resize', resizeHandler);\n\n\tif (document.documentMode >= 9)\n\t{\n\t\tmxEvent.addListener(elt, 'DOMNodeRemoved', resizeHandler);\n\t\tmxEvent.addListener(elt, 'DOMNodeInserted', resizeHandler);\n\t}\n\telse\n\t{\n\t\tmxEvent.addListener(elt, 'cut', resizeHandler);\n\t\tmxEvent.addListener(elt, 'paste', resizeHandler);\n\t}\n};\n\n/**\n * Function: isStopEditingEvent\n *\n * Returns true if the given keydown event should stop cell editing. This\n * returns true if F2 is pressed of if <mxGraph.enterStopsCellEditing> is true\n * and enter is pressed without control or shift.\n */\nmxCellEditor.prototype.isStopEditingEvent = function(evt)\n{\n\treturn evt.keyCode == 113 /* F2 */ || (this.graph.isEnterStopsCellEditing() &&\n\t\tevt.keyCode == 13 /* Enter */ && !mxEvent.isControlDown(evt) &&\n\t\t!mxEvent.isShiftDown(evt));\n};\n\n/**\n * Function: isEventSource\n *\n * Returns true if this editor is the source for the given native event.\n */\nmxCellEditor.prototype.isEventSource = function(evt)\n{\n\treturn mxEvent.getSource(evt) == this.textarea;\n};\n\n/**\n * Function: resize\n *\n * Returns <modified>.\n */\nmxCellEditor.prototype.resize = function()\n{\n\tvar state = this.graph.getView().getState(this.editingCell);\n\n\tif (state == null)\n\t{\n\t\tthis.stopEditing(true);\n\t}\n\telse if (this.textarea != null)\n\t{\n\t\tvar isEdge = this.graph.getModel().isEdge(state.cell);\n \t\tvar scale = this.graph.getView().scale;\n \t\tvar m = null;\n\n\t\tif (!this.autoSize || (state.style[mxConstants.STYLE_OVERFLOW] == 'fill'))\n\t\t{\n\t\t\t// Specifies the bounds of the editor box\n\t\t\tthis.bounds = this.getEditorBounds(state);\n\t\t\tthis.textarea.style.width = Math.round(this.bounds.width / scale) + 'px';\n\t\t\tthis.textarea.style.height = Math.round(this.bounds.height / scale) + 'px';\n\n\t\t\t// FIXME: Offset when scaled\n\t\t\tif (document.documentMode == 8 || mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\tthis.textarea.style.left = Math.round(this.bounds.x) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.round(this.bounds.y) + 'px';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + 'px';\n\t\t\t}\n\n\t\t\t// Installs native word wrapping and avoids word wrap for empty label placeholder\n\t\t\tif (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n\t\t\t\tthis.textarea.innerHTML != this.getEmptyLabelText())\n\t\t\t{\n\t\t\t\tthis.textarea.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\tthis.textarea.style.whiteSpace = 'normal';\n\n\t\t\t\tif (state.style[mxConstants.STYLE_OVERFLOW] != 'fill')\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.textarea.style.whiteSpace = 'nowrap';\n\n\t\t\t\tif (state.style[mxConstants.STYLE_OVERFLOW] != 'fill')\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.width = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t \t{\n\t \t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\t\t\tm = (state.text != null && this.align == null) ? state.text.margin : null;\n\n\t\t\tif (m == null)\n\t\t\t{\n\t\t\t\tm = mxUtils.getAlignmentAsPoint(this.align || mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER),\n\t\t\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE));\n\t\t\t}\n\n\t \t\tif (isEdge)\n\t\t\t{\n\t\t\t\tthis.bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);\n\n\t\t\t\tif (lw != null)\n\t\t\t \t{\n\t\t\t\t\tvar tmp = (parseFloat(lw) + 2) * scale;\n\t\t\t\t\tthis.bounds.width = tmp;\n\t\t\t\t\tthis.bounds.x += m.x * tmp;\n\t\t\t \t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar bds = mxRectangle.fromRectangle(state);\n\t\t\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\t\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\t\t\t\tbds = (state.shape != null && hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE) ? state.shape.getLabelBounds(bds) : bds;\n\n\t\t\t \tif (lw != null)\n\t\t\t \t{\n\t\t\t \t\tbds.width = parseFloat(lw) * scale;\n\t\t\t \t}\n\n\t\t\t \tif (!state.view.graph.cellRenderer.legacySpacing || state.style[mxConstants.STYLE_OVERFLOW] != 'width')\n\t\t\t \t{\n\t\t\t\t\tvar spacing = parseInt(state.style[mxConstants.STYLE_SPACING] || 2) * scale;\n\t\t\t\t\tvar spacingTop = (parseInt(state.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;\n\t\t\t\t\tvar spacingRight = (parseInt(state.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;\n\t\t\t\t\tvar spacingBottom = (parseInt(state.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;\n\t\t\t\t\tvar spacingLeft = (parseInt(state.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;\n\n\t\t\t\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\t\t\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\t\t\t\t\tbds = new mxRectangle(bds.x + spacingLeft, bds.y + spacingTop,\n\t\t\t\t\t\tbds.width - ((hpos == mxConstants.ALIGN_CENTER && lw == null) ? (spacingLeft + spacingRight) : 0),\n\t\t\t\t\t\tbds.height - ((vpos == mxConstants.ALIGN_MIDDLE) ? (spacingTop + spacingBottom) : 0));\n\t\t\t \t}\n\n\t\t\t\tthis.bounds = new mxRectangle(bds.x + state.absoluteOffset.x, bds.y + state.absoluteOffset.y, bds.width, bds.height);\n\t\t\t}\n\n\t\t\t// Needed for word wrap inside text blocks with oversize lines to match the final result where\n\t \t\t// the width of the longest line is used as the reference for text alignment in the cell\n\t \t\t// TODO: Fix word wrapping preview for edge labels in helloworld.html\n\t\t\tif (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) &&\n\t\t\t\tthis.textarea.innerHTML != this.getEmptyLabelText())\n\t\t\t{\n\t\t\t\tthis.textarea.style.wordWrap = mxConstants.WORD_WRAP;\n\t\t\t\tthis.textarea.style.whiteSpace = 'normal';\n\n\t\t \t\t// Forces automatic reflow if text is removed from an oversize label and normal word wrap\n\t\t\t\tvar tmp = Math.round(this.bounds.width / ((document.documentMode == 8) ? scale : scale)) + this.wordWrapPadding;\n\n\t\t\t\tif (this.textarea.style.position != 'relative')\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.width = tmp + 'px';\n\n\t\t\t\t\tif (this.textarea.scrollWidth > tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.textarea.style.width = this.textarea.scrollWidth + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.textarea.style.maxWidth = tmp + 'px';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// KNOWN: Trailing cursor in IE9 quirks mode is not visible\n\t\t\t\tthis.textarea.style.whiteSpace = 'nowrap';\n\t\t\t\tthis.textarea.style.width = '';\n\t\t\t}\n\n\t\t\t// LATER: Keep in visible area, add fine tuning for pixel precision\n\t\t\t// Workaround for wrong measuring in IE8 standards\n\t\t\tif (document.documentMode == 8)\n\t\t\t{\n\t\t\t\tthis.textarea.style.zoom = '1';\n\t\t\t\tthis.textarea.style.height = 'auto';\n\t\t\t}\n\n\t\t\tvar ow = this.textarea.scrollWidth;\n\t\t\tvar oh = this.textarea.scrollHeight;\n\n\t\t\t// TODO: Update CSS width and height if smaller than minResize or remove minResize\n\t\t\t//if (this.minResize != null)\n\t\t\t//{\n\t\t\t//\tow = Math.max(ow, this.minResize.width);\n\t\t\t//\toh = Math.max(oh, this.minResize.height);\n\t\t\t//}\n\n\t\t\t// LATER: Keep in visible area, add fine tuning for pixel precision\n\t\t\tif (document.documentMode == 8)\n\t\t\t{\n\t\t\t\t// LATER: Scaled wrapping and position is wrong in IE8\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2) / scale)) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1) / scale)) + 'px';\n\t\t\t\t// Workaround for wrong event handling width and height\n\t\t\t\tthis.textarea.style.width = Math.round(ow * scale) + 'px';\n\t\t\t\tthis.textarea.style.height = Math.round(oh * scale) + 'px';\n\t\t\t}\n\t\t\telse if (mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.ceil(this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2)) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.ceil(this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1)) + 'px';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.textarea.style.left = Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1) + 'px';\n\t\t\t\tthis.textarea.style.top = Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + ((m.y == -1) ? 3 : 0)) + 1) + 'px';\n\t\t\t}\n\t \t}\n\n\t\tif (mxClient.IS_VML)\n\t\t{\n\t\t\tthis.textarea.style.zoom = scale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxUtils.setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');\n\t\t\tmxUtils.setPrefixedStyle(this.textarea.style, 'transform',\n\t\t\t\t'scale(' + scale + ',' + scale + ')' + ((m == null) ? '' :\n\t\t\t\t' translate(' + (m.x * 100) + '%,' + (m.y * 100) + '%)'));\n\t\t}\n\t}\n};\n\n/**\n * Function: focusLost\n *\n * Called if the textarea has lost focus.\n */\nmxCellEditor.prototype.focusLost = function()\n{\n\tthis.stopEditing(!this.graph.isInvokesStopCellEditing());\n};\n\n/**\n * Function: getBackgroundColor\n *\n * Returns the background color for the in-place editor. This implementation\n * always returns null.\n */\nmxCellEditor.prototype.getBackgroundColor = function(state)\n{\n\treturn null;\n};\n\n/**\n * Function: isLegacyEditor\n *\n * Returns true if max-width is not supported or if the SVG root element in\n * in the graph does not have CSS position absolute. In these cases the text\n * editor must use CSS position absolute to avoid an offset but it will have\n * a less accurate line wrapping width during the text editing preview. This\n * implementation returns true for IE8- and quirks mode or if the CSS position\n * of the SVG element is not absolute.\n */\nmxCellEditor.prototype.isLegacyEditor = function()\n{\n\tif (mxClient.IS_VML)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tvar absoluteRoot = false;\n\n\t\tif (mxClient.IS_SVG)\n\t\t{\n\t\t\tvar root = this.graph.view.getDrawPane().ownerSVGElement;\n\n\t\t\tif (root != null)\n\t\t\t{\n\t\t\t\tabsoluteRoot = mxUtils.getCurrentStyle(root).position == 'absolute';\n\t\t\t}\n\t\t}\n\n\t\treturn !absoluteRoot;\n\t}\n};\n\n/**\n * Function: startEditing\n *\n * Starts the editor for the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> to start editing.\n * trigger - Optional mouse event that triggered the editor.\n */\nmxCellEditor.prototype.startEditing = function(cell, trigger)\n{\n\tthis.stopEditing(true);\n\tthis.align = null;\n\n\t// Creates new textarea instance\n\tif (this.textarea == null)\n\t{\n\t\tthis.init();\n\t}\n\n\tif (this.graph.tooltipHandler != null)\n\t{\n\t\tthis.graph.tooltipHandler.hideTooltip();\n\t}\n\n\tvar state = this.graph.getView().getState(cell);\n\n\tif (state != null)\n\t{\n\t\t// Configures the style of the in-place editor\n\t\tvar scale = this.graph.getView().scale;\n\t\tvar size = mxUtils.getValue(state.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);\n\t\tvar family = mxUtils.getValue(state.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY);\n\t\tvar color = mxUtils.getValue(state.style, mxConstants.STYLE_FONTCOLOR, 'black');\n\t\tvar align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);\n\t\tvar bold = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &\n\t\t\t\tmxConstants.FONT_BOLD) == mxConstants.FONT_BOLD;\n\t\tvar italic = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &\n\t\t\t\tmxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC;\n\t\tvar uline = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &\n\t\t\t\tmxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE;\n\n\t\tthis.textarea.style.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? Math.round(size * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;\n\t\tthis.textarea.style.backgroundColor = this.getBackgroundColor(state);\n\t\tthis.textarea.style.textDecoration = (uline) ? 'underline' : '';\n\t\tthis.textarea.style.fontWeight = (bold) ? 'bold' : 'normal';\n\t\tthis.textarea.style.fontStyle = (italic) ? 'italic' : '';\n\t\tthis.textarea.style.fontSize = Math.round(size) + 'px';\n\t\tthis.textarea.style.zIndex = this.zIndex;\n\t\t// Quotes are workaround for font name \"m+\"\n\t\tthis.textarea.style.fontFamily = '\"' + family + '\"';\n\t\tthis.textarea.style.textAlign = align;\n\t\tthis.textarea.style.outline = 'none';\n\t\tthis.textarea.style.color = color;\n\n\t\tvar dir = this.textDirection = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);\n\n\t\tif (dir == mxConstants.TEXT_DIRECTION_AUTO)\n\t\t{\n\t\t\tif (state != null && state.text != null && state.text.dialect != mxConstants.DIALECT_STRICTHTML &&\n\t\t\t\t!mxUtils.isNode(state.text.value))\n\t\t\t{\n\t\t\t\tdir = state.text.getAutoDirection();\n\t\t\t}\n\t\t}\n\n\t\tif (dir == mxConstants.TEXT_DIRECTION_LTR || dir == mxConstants.TEXT_DIRECTION_RTL)\n\t\t{\n\t\t\tthis.textarea.setAttribute('dir', dir);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.textarea.removeAttribute('dir');\n\t\t}\n\n\t\t// Sets the initial editing value\n\t\tthis.textarea.innerHTML = this.getInitialValue(state, trigger) || '';\n\t\tthis.initialValue = this.textarea.innerHTML;\n\n\t\t// Uses an optional text value for empty labels which is cleared\n\t\t// when the first keystroke appears. This makes it easier to see\n\t\t// that a label is being edited even if the label is empty.\n\t\tif (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == '<br>')\n\t\t{\n\t\t\tthis.textarea.innerHTML = this.getEmptyLabelText();\n\t\t\tthis.clearOnChange = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();\n\t\t}\n\n\t\tthis.graph.container.appendChild(this.textarea);\n\n\t\t// Update this after firing all potential events that could update the cleanOnChange flag\n\t\tthis.editingCell = cell;\n\t\tthis.trigger = trigger;\n\t\tthis.textNode = null;\n\n\t\tif (state.text != null && this.isHideLabel(state))\n\t\t{\n\t\t\tthis.textNode = state.text.node;\n\t\t\tthis.textNode.style.visibility = 'hidden';\n\t\t}\n\n\t\t// Workaround for initial offsetHeight not ready for heading in markup\n\t\tif (this.autoSize && (this.graph.model.isEdge(state.cell) || state.style[mxConstants.STYLE_OVERFLOW] != 'fill'))\n\t\t{\n\t\t\twindow.setTimeout(mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.resize();\n\t\t\t}), 0);\n\t\t}\n\n\t\tthis.resize();\n\n\t\t// Workaround for NS_ERROR_FAILURE in FF\n\t\ttry\n\t\t{\n\t\t\t// Prefers blinking cursor over no selected text if empty\n\t\t\tthis.textarea.focus();\n\n\t\t\tif (this.isSelectText() && this.textarea.innerHTML.length > 0 &&\n\t\t\t\t(this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange))\n\t\t\t{\n\t\t\t\tdocument.execCommand('selectAll', false, null);\n\t\t\t}\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\t}\n};\n\n/**\n * Function: isSelectText\n *\n * Returns <selectText>.\n */\nmxCellEditor.prototype.isSelectText = function()\n{\n\treturn this.selectText;\n};\n\n/**\n * Function: isSelectText\n *\n * Returns <selectText>.\n */\nmxCellEditor.prototype.clearSelection = function()\n{\n\tvar selection = null;\n\n\tif (window.getSelection)\n\t{\n\t\tselection = window.getSelection();\n\t}\n\telse if (document.selection)\n\t{\n\t\tselection = document.selection;\n\t}\n\n\tif (selection != null)\n\t{\n\t\tif (selection.empty)\n\t\t{\n\t\t\tselection.empty();\n\t\t}\n\t\telse if (selection.removeAllRanges)\n\t\t{\n\t\t\tselection.removeAllRanges();\n\t\t}\n\t}\n};\n\n/**\n * Function: stopEditing\n *\n * Stops the editor and applies the value if cancel is false.\n */\nmxCellEditor.prototype.stopEditing = function(cancel)\n{\n\tcancel = cancel || false;\n\n\tif (this.editingCell != null)\n\t{\n\t\tif (this.textNode != null)\n\t\t{\n\t\t\tthis.textNode.style.visibility = 'visible';\n\t\t\tthis.textNode = null;\n\t\t}\n\n\t\tvar state = (!cancel) ? this.graph.view.getState(this.editingCell) : null;\n\n\t\tvar initial = this.initialValue;\n\t\tthis.initialValue = null;\n\t\tthis.editingCell = null;\n\t\tthis.trigger = null;\n\t\tthis.bounds = null;\n\t\tthis.textarea.blur();\n\t\tthis.clearSelection();\n\n\t\tif (this.textarea.parentNode != null)\n\t\t{\n\t\t\tthis.textarea.parentNode.removeChild(this.textarea);\n\t\t}\n\n\t\tif (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText())\n\t\t{\n\t\t\tthis.textarea.innerHTML = '';\n\t\t\tthis.clearOnChange = false;\n\t\t}\n\n\t\tif (state != null && (this.textarea.innerHTML != initial || this.align != null))\n\t\t{\n\t\t\tthis.prepareTextarea();\n\t\t\tvar value = this.getCurrentValue(state);\n\n\t\t\tthis.graph.getModel().beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (value != null)\n\t\t\t\t{\n\t\t\t\t\tthis.applyValue(state, value);\n\t\t\t\t}\n\n\t\t\t\tif (this.align != null)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.setCellStyles(mxConstants.STYLE_ALIGN, this.align, [state.cell]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.graph.getModel().endUpdate();\n\t\t\t}\n\t\t}\n\n\t\t// Forces new instance on next edit for undo history reset\n\t\tmxEvent.release(this.textarea);\n\t\tthis.textarea = null;\n\t\tthis.align = null;\n\t}\n};\n\n/**\n * Function: prepareTextarea\n *\n * Prepares the textarea for getting its value in <stopEditing>.\n * This implementation removes the extra trailing linefeed in Firefox.\n */\nmxCellEditor.prototype.prepareTextarea = function()\n{\n\tif (this.textarea.lastChild != null &&\n\t\tthis.textarea.lastChild.nodeName == 'BR')\n\t{\n\t\tthis.textarea.removeChild(this.textarea.lastChild);\n\t}\n};\n\n/**\n * Function: isHideLabel\n *\n * Returns true if the label should be hidden while the cell is being\n * edited.\n */\nmxCellEditor.prototype.isHideLabel = function(state)\n{\n\treturn true;\n};\n\n/**\n * Function: getMinimumSize\n *\n * Returns the minimum width and height for editing the given state.\n */\nmxCellEditor.prototype.getMinimumSize = function(state)\n{\n\tvar scale = this.graph.getView().scale;\n\n\treturn new mxRectangle(0, 0, (state.text == null) ? 30 : state.text.size * scale + 20,\n\t\t\t(this.textarea.style.textAlign == 'left') ? 120 : 40);\n};\n\n/**\n * Function: getEditorBounds\n *\n * Returns the <mxRectangle> that defines the bounds of the editor.\n */\nmxCellEditor.prototype.getEditorBounds = function(state)\n{\n\tvar isEdge = this.graph.getModel().isEdge(state.cell);\n\tvar scale = this.graph.getView().scale;\n\tvar minSize = this.getMinimumSize(state);\n\tvar minWidth = minSize.width;\n \tvar minHeight = minSize.height;\n \tvar result = null;\n\n \tif (!isEdge && state.view.graph.cellRenderer.legacySpacing && state.style[mxConstants.STYLE_OVERFLOW] == 'fill')\n \t{\n \t\tresult = state.shape.getLabelBounds(mxRectangle.fromRectangle(state));\n \t}\n \telse\n \t{\n\t\tvar spacing = parseInt(state.style[mxConstants.STYLE_SPACING] || 0) * scale;\n\t\tvar spacingTop = (parseInt(state.style[mxConstants.STYLE_SPACING_TOP] || 0) + mxText.prototype.baseSpacingTop) * scale + spacing;\n\t\tvar spacingRight = (parseInt(state.style[mxConstants.STYLE_SPACING_RIGHT] || 0) + mxText.prototype.baseSpacingRight) * scale + spacing;\n\t\tvar spacingBottom = (parseInt(state.style[mxConstants.STYLE_SPACING_BOTTOM] || 0) + mxText.prototype.baseSpacingBottom) * scale + spacing;\n\t\tvar spacingLeft = (parseInt(state.style[mxConstants.STYLE_SPACING_LEFT] || 0) + mxText.prototype.baseSpacingLeft) * scale + spacing;\n\n\t \tresult = new mxRectangle(state.x, state.y,\n\t \t\t Math.max(minWidth, state.width - spacingLeft - spacingRight),\n\t \t\t Math.max(minHeight, state.height - spacingTop - spacingBottom));\n\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\t\tresult = (state.shape != null && hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE) ? state.shape.getLabelBounds(result) : result;\n\n\t\tif (isEdge)\n\t\t{\n\t\t\tresult.x = state.absoluteOffset.x;\n\t\t\tresult.y = state.absoluteOffset.y;\n\n\t\t\tif (state.text != null && state.text.boundingBox != null)\n\t\t\t{\n\t\t\t\t// Workaround for label containing just spaces in which case\n\t\t\t\t// the bounding box location contains negative numbers\n\t\t\t\tif (state.text.boundingBox.x > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.x = state.text.boundingBox.x;\n\t\t\t\t}\n\n\t\t\t\tif (state.text.boundingBox.y > 0)\n\t\t\t\t{\n\t\t\t\t\tresult.y = state.text.boundingBox.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tresult.x = Math.min(result.x, state.text.boundingBox.x);\n\t\t\tresult.y = Math.min(result.y, state.text.boundingBox.y);\n\t\t}\n\n\t\tresult.x += spacingLeft;\n\t\tresult.y += spacingTop;\n\n\t\tif (state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tif (!isEdge)\n\t\t\t{\n\t\t\t\tresult.width = Math.max(result.width, state.text.boundingBox.width);\n\t\t\t\tresult.height = Math.max(result.height, state.text.boundingBox.height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.width = Math.max(minWidth, state.text.boundingBox.width);\n\t\t\t\tresult.height = Math.max(minHeight, state.text.boundingBox.height);\n\t\t\t}\n\t\t}\n\n\t\t// Applies the horizontal and vertical label positions\n\t\tif (this.graph.getModel().isVertex(state.cell))\n\t\t{\n\t\t\tvar horizontal = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\n\t\t\tif (horizontal == mxConstants.ALIGN_LEFT)\n\t\t\t{\n\t\t\t\tresult.x -= state.width;\n\t\t\t}\n\t\t\telse if (horizontal == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tresult.x += state.width;\n\t\t\t}\n\n\t\t\tvar vertical = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\t\t\tif (vertical == mxConstants.ALIGN_TOP)\n\t\t\t{\n\t\t\t\tresult.y -= state.height;\n\t\t\t}\n\t\t\telse if (vertical == mxConstants.ALIGN_BOTTOM)\n\t\t\t{\n\t\t\t\tresult.y += state.height;\n\t\t\t}\n\t\t}\n \t}\n\n \treturn new mxRectangle(Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));\n};\n\n/**\n * Function: getEmptyLabelText\n *\n * Returns the initial label value to be used of the label of the given\n * cell is empty. This label is displayed and cleared on the first keystroke.\n * This implementation returns <emptyLabelText>.\n *\n * Parameters:\n *\n * cell - <mxCell> for which a text for an empty editing box should be\n * returned.\n */\nmxCellEditor.prototype.getEmptyLabelText = function (cell)\n{\n\treturn this.emptyLabelText;\n};\n\n/**\n * Function: getEditingCell\n *\n * Returns the cell that is currently being edited or null if no cell is\n * being edited.\n */\nmxCellEditor.prototype.getEditingCell = function ()\n{\n\treturn this.editingCell;\n};\n\n/**\n * Function: destroy\n *\n * Destroys the editor and removes all associated resources.\n */\nmxCellEditor.prototype.destroy = function ()\n{\n\tif (this.textarea != null)\n\t{\n\t\tmxEvent.release(this.textarea);\n\n\t\tif (this.textarea.parentNode != null)\n\t\t{\n\t\t\tthis.textarea.parentNode.removeChild(this.textarea);\n\t\t}\n\n\t\tthis.textarea = null;\n\n\t}\n\n\tif (this.changeHandler != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.changeHandler);\n\t\tthis.changeHandler = null;\n\t}\n\n\tif (this.zoomHandler)\n\t{\n\t\tthis.graph.view.removeListener(this.zoomHandler);\n\t\tthis.zoomHandler = null;\n\t}\n};\n\n__mxOutput.mxCellEditor = typeof mxCellEditor !== 'undefined' ? mxCellEditor : undefined;\n\n/**\n * Copyright (c) 2006-2017, JGraph Ltd\n * Copyright (c) 2006-2017, Gaudenz Alder\n */\n/**\n * Class: mxCellRenderer\n *\n * Renders cells into a document object model. The <defaultShapes> is a global\n * map of shapename, constructor pairs that is used in all instances. You can\n * get a list of all available shape names using the following code.\n *\n * In general the cell renderer is in charge of creating, redrawing and\n * destroying the shape and label associated with a cell state, as well as\n * some other graphical objects, namely controls and overlays. The shape\n * hieararchy in the display (ie. the hierarchy in which the DOM nodes\n * appear in the document) does not reflect the cell hierarchy. The shapes\n * are a (flat) sequence of shapes and labels inside the draw pane of the\n * graph view, with some exceptions, namely the HTML labels being placed\n * directly inside the graph container for certain browsers.\n *\n * (code)\n * mxLog.show();\n * for (var i in mxCellRenderer.defaultShapes)\n * {\n *   mxLog.debug(i);\n * }\n * (end)\n *\n * Constructor: mxCellRenderer\n *\n * Constructs a new cell renderer with the following built-in shapes:\n * arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,\n * swimlane, connector, actor and cloud.\n */\nfunction mxCellRenderer() { };\n\n/**\n * Variable: defaultShapes\n *\n * Static array that contains the globally registered shapes which are\n * known to all instances of this class. For adding new shapes you should\n * use the static <mxCellRenderer.registerShape> function.\n */\nmxCellRenderer.defaultShapes = new Object();\n\n/**\n * Variable: defaultEdgeShape\n *\n * Defines the default shape for edges. Default is <mxConnector>.\n */\nmxCellRenderer.prototype.defaultEdgeShape = mxConnector;\n\n/**\n * Variable: defaultVertexShape\n *\n * Defines the default shape for vertices. Default is <mxRectangleShape>.\n */\nmxCellRenderer.prototype.defaultVertexShape = mxRectangleShape;\n\n/**\n * Variable: defaultTextShape\n *\n * Defines the default shape for labels. Default is <mxText>.\n */\nmxCellRenderer.prototype.defaultTextShape = mxText;\n\n/**\n * Variable: legacyControlPosition\n *\n * Specifies if the folding icon should ignore the horizontal\n * orientation of a swimlane. Default is true.\n */\nmxCellRenderer.prototype.legacyControlPosition = true;\n\n/**\n * Variable: legacySpacing\n *\n * Specifies if spacing and label position should be ignored if overflow is\n * fill or width. Default is true for backwards compatiblity.\n */\nmxCellRenderer.prototype.legacySpacing = true;\n\n/**\n * Variable: antiAlias\n *\n * Anti-aliasing option for new shapes. Default is true.\n */\nmxCellRenderer.prototype.antiAlias = true;\n\n/**\n * Variable: minSvgStrokeWidth\n *\n * Minimum stroke width for SVG output.\n */\nmxCellRenderer.prototype.minSvgStrokeWidth = 1;\n\n/**\n * Variable: forceControlClickHandler\n *\n * Specifies if the enabled state of the graph should be ignored in the control\n * click handler (to allow folding in disabled graphs). Default is false.\n */\nmxCellRenderer.prototype.forceControlClickHandler = false;\n\n/**\n * Function: registerShape\n *\n * Registers the given constructor under the specified key in this instance\n * of the renderer.\n *\n * Example:\n *\n * (code)\n * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\n * (end)\n *\n * Parameters:\n *\n * key - String representing the shape name.\n * shape - Constructor of the <mxShape> subclass.\n */\nmxCellRenderer.registerShape = function(key, shape)\n{\n\tmxCellRenderer.defaultShapes[key] = shape;\n};\n\n// Adds default shapes into the default shapes array\nmxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ELLIPSE, mxEllipse);\nmxCellRenderer.registerShape(mxConstants.SHAPE_RHOMBUS, mxRhombus);\nmxCellRenderer.registerShape(mxConstants.SHAPE_CYLINDER, mxCylinder);\nmxCellRenderer.registerShape(mxConstants.SHAPE_CONNECTOR, mxConnector);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ACTOR, mxActor);\nmxCellRenderer.registerShape(mxConstants.SHAPE_TRIANGLE, mxTriangle);\nmxCellRenderer.registerShape(mxConstants.SHAPE_HEXAGON, mxHexagon);\nmxCellRenderer.registerShape(mxConstants.SHAPE_CLOUD, mxCloud);\nmxCellRenderer.registerShape(mxConstants.SHAPE_LINE, mxLine);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ARROW, mxArrow);\nmxCellRenderer.registerShape(mxConstants.SHAPE_ARROW_CONNECTOR, mxArrowConnector);\nmxCellRenderer.registerShape(mxConstants.SHAPE_DOUBLE_ELLIPSE, mxDoubleEllipse);\nmxCellRenderer.registerShape(mxConstants.SHAPE_SWIMLANE, mxSwimlane);\nmxCellRenderer.registerShape(mxConstants.SHAPE_IMAGE, mxImageShape);\nmxCellRenderer.registerShape(mxConstants.SHAPE_LABEL, mxLabel);\n\n/**\n * Function: initializeShape\n *\n * Initializes the shape in the given state by calling its init method with\n * the correct container after configuring it using <configureShape>.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the shape should be initialized.\n */\nmxCellRenderer.prototype.initializeShape = function(state)\n{\n\tstate.shape.dialect = state.view.graph.dialect;\n\tthis.configureShape(state);\n\tstate.shape.init(state.view.getDrawPane());\n};\n\n/**\n * Function: createShape\n *\n * Creates and returns the shape for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the shape should be created.\n */\nmxCellRenderer.prototype.createShape = function(state)\n{\n\tvar shape = null;\n\n\tif (state.style != null)\n\t{\n\t\t// Checks if there is a stencil for the name and creates\n\t\t// a shape instance for the stencil if one exists\n\t\tvar stencil = mxStencilRegistry.getStencil(state.style[mxConstants.STYLE_SHAPE]);\n\n\t\tif (stencil != null)\n\t\t{\n\t\t\tshape = new mxShape(stencil);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar ctor = this.getShapeConstructor(state);\n\t\t\tshape = new ctor();\n\t\t}\n\t}\n\n\treturn shape;\n};\n\n/**\n * Function: createIndicatorShape\n *\n * Creates the indicator shape for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the indicator shape should be created.\n */\nmxCellRenderer.prototype.createIndicatorShape = function(state)\n{\n\tstate.shape.indicatorShape = this.getShape(state.view.graph.getIndicatorShape(state));\n};\n\n/**\n * Function: getShape\n *\n * Returns the shape for the given name from <defaultShapes>.\n */\nmxCellRenderer.prototype.getShape = function(name)\n{\n\treturn (name != null) ? mxCellRenderer.defaultShapes[name] : null;\n};\n\n/**\n * Function: getShapeConstructor\n *\n * Returns the constructor to be used for creating the shape.\n */\nmxCellRenderer.prototype.getShapeConstructor = function(state)\n{\n\tvar ctor = this.getShape(state.style[mxConstants.STYLE_SHAPE]);\n\n\tif (ctor == null)\n\t{\n\t\tctor = (state.view.graph.getModel().isEdge(state.cell)) ?\n\t\t\tthis.defaultEdgeShape : this.defaultVertexShape;\n\t}\n\n\treturn ctor;\n};\n\n/**\n * Function: configureShape\n *\n * Configures the shape for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the shape should be configured.\n */\nmxCellRenderer.prototype.configureShape = function(state)\n{\n\tstate.shape.apply(state);\n\tstate.shape.image = state.view.graph.getImage(state);\n\tstate.shape.indicatorColor = state.view.graph.getIndicatorColor(state);\n\tstate.shape.indicatorStrokeColor = state.style[mxConstants.STYLE_INDICATOR_STROKECOLOR];\n\tstate.shape.indicatorGradientColor = state.view.graph.getIndicatorGradientColor(state);\n\tstate.shape.indicatorDirection = state.style[mxConstants.STYLE_INDICATOR_DIRECTION];\n\tstate.shape.indicatorImage = state.view.graph.getIndicatorImage(state);\n\n\tthis.postConfigureShape(state);\n};\n\n/**\n * Function: postConfigureShape\n *\n * Replaces any reserved words used for attributes, eg. inherit,\n * indicated or swimlane for colors in the shape for the given state.\n * This implementation resolves these keywords on the fill, stroke\n * and gradient color keys.\n */\nmxCellRenderer.prototype.postConfigureShape = function(state)\n{\n\tif (state.shape != null)\n\t{\n\t\tthis.resolveColor(state, 'indicatorColor', mxConstants.STYLE_FILLCOLOR);\n\t\tthis.resolveColor(state, 'indicatorGradientColor', mxConstants.STYLE_GRADIENTCOLOR);\n\t\tthis.resolveColor(state, 'fill', mxConstants.STYLE_FILLCOLOR);\n\t\tthis.resolveColor(state, 'stroke', mxConstants.STYLE_STROKECOLOR);\n\t\tthis.resolveColor(state, 'gradient', mxConstants.STYLE_GRADIENTCOLOR);\n\t}\n};\n\n/**\n * Function: checkPlaceholderStyles\n *\n * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n * the respective color on the shape.\n */\nmxCellRenderer.prototype.checkPlaceholderStyles = function(state)\n{\n\t// LATER: Check if the color has actually changed\n\tif (state.style != null)\n\t{\n\t\tvar values = ['inherit', 'swimlane', 'indicated'];\n\t\tvar styles = [mxConstants.STYLE_FILLCOLOR, mxConstants.STYLE_STROKECOLOR, mxConstants.STYLE_GRADIENTCOLOR];\n\n\t\tfor (var i = 0; i < styles.length; i++)\n\t\t{\n\t\t\tif (mxUtils.indexOf(values, state.style[styles[i]]) >= 0)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: resolveColor\n *\n * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\n * the respective color on the shape.\n */\nmxCellRenderer.prototype.resolveColor = function(state, field, key)\n{\n\tvar value = state.shape[field];\n\tvar graph = state.view.graph;\n\tvar referenced = null;\n\n\tif (value == 'inherit')\n\t{\n\t\treferenced = graph.model.getParent(state.cell);\n\t}\n\telse if (value == 'swimlane')\n\t{\n\t\tstate.shape[field] = (key == mxConstants.STYLE_STROKECOLOR) ? '#000000' : '#ffffff';\n\n\t\tif (graph.model.getTerminal(state.cell, false) != null)\n\t\t{\n\t\t\treferenced = graph.model.getTerminal(state.cell, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treferenced = state.cell;\n\t\t}\n\n\t\treferenced = graph.getSwimlane(referenced);\n\t\tkey = graph.swimlaneIndicatorColorAttribute;\n\t}\n\telse if (value == 'indicated')\n\t{\n\t\tstate.shape[field] = state.shape.indicatorColor;\n\t}\n\n\tif (referenced != null)\n\t{\n\t\tvar rstate = graph.getView().getState(referenced);\n\t\tstate.shape[field] = null;\n\n\t\tif (rstate != null)\n\t\t{\n\t\t\tif (rstate.shape != null && field != 'indicatorColor')\n\t\t\t{\n\t\t\t\tstate.shape[field] = rstate.shape[field];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.shape[field] = rstate.style[key];\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getLabelValue\n *\n * Returns the value to be used for the label.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the label should be created.\n */\nmxCellRenderer.prototype.getLabelValue = function(state)\n{\n\treturn state.view.graph.getLabel(state.cell);\n};\n\n/**\n * Function: createLabel\n *\n * Creates the label for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the label should be created.\n */\nmxCellRenderer.prototype.createLabel = function(state, value)\n{\n\tvar graph = state.view.graph;\n\tvar isEdge = graph.getModel().isEdge(state.cell);\n\n\tif (state.style[mxConstants.STYLE_FONTSIZE] > 0 || state.style[mxConstants.STYLE_FONTSIZE] == null)\n\t{\n\t\t// Avoids using DOM node for empty labels\n\t\tvar isForceHtml = (graph.isHtmlLabel(state.cell) || (value != null && mxUtils.isNode(value)));\n\n\t\tstate.text = new this.defaultTextShape(value, new mxRectangle(),\n\t\t\t\t(state.style[mxConstants.STYLE_ALIGN] || mxConstants.ALIGN_CENTER),\n\t\t\t\tgraph.getVerticalAlign(state),\n\t\t\t\tstate.style[mxConstants.STYLE_FONTCOLOR],\n\t\t\t\tstate.style[mxConstants.STYLE_FONTFAMILY],\n\t\t\t\tstate.style[mxConstants.STYLE_FONTSIZE],\n\t\t\t\tstate.style[mxConstants.STYLE_FONTSTYLE],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_TOP],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_RIGHT],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_BOTTOM],\n\t\t\t\tstate.style[mxConstants.STYLE_SPACING_LEFT],\n\t\t\t\tstate.style[mxConstants.STYLE_HORIZONTAL],\n\t\t\t\tstate.style[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR],\n\t\t\t\tstate.style[mxConstants.STYLE_LABEL_BORDERCOLOR],\n\t\t\t\tgraph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell),\n\t\t\t\tgraph.isLabelClipped(state.cell),\n\t\t\t\tstate.style[mxConstants.STYLE_OVERFLOW],\n\t\t\t\tstate.style[mxConstants.STYLE_LABEL_PADDING],\n\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION));\n\t\tstate.text.opacity = mxUtils.getValue(state.style, mxConstants.STYLE_TEXT_OPACITY, 100);\n\t\tstate.text.dialect = (isForceHtml) ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;\n\t\tstate.text.style = state.style;\n\t\tstate.text.state = state;\n\t\tthis.initializeLabel(state, state.text);\n\n\t\t// Workaround for touch devices routing all events for a mouse gesture\n\t\t// (down, move, up) via the initial DOM node. IE additionally redirects\n\t\t// the event via the initial DOM node but the event source is the node\n\t\t// under the mouse, so we need to check if this is the case and force\n\t\t// getCellAt for the subsequent mouseMoves and the final mouseUp.\n\t\tvar forceGetCell = false;\n\n\t\tvar getState = function(evt)\n\t\t{\n\t\t\tvar result = state;\n\n\t\t\tif (mxClient.IS_TOUCH || forceGetCell)\n\t\t\t{\n\t\t\t\tvar x = mxEvent.getClientX(evt);\n\t\t\t\tvar y = mxEvent.getClientY(evt);\n\n\t\t\t\t// Dispatches the drop event to the graph which\n\t\t\t\t// consumes and executes the source function\n\t\t\t\tvar pt = mxUtils.convertPoint(graph.container, x, y);\n\t\t\t\tresult = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\t// TODO: Add handling for special touch device gestures\n\t\tmxEvent.addGestureListeners(state.text.node,\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));\n\t\t\t\t\tforceGetCell = graph.dialect != mxConstants.DIALECT_SVG &&\n\t\t\t\t\t\tmxEvent.getSource(evt).nodeName == 'IMG';\n\t\t\t\t}\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t\t}\n\t\t\t}),\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));\n\t\t\t\t\tforceGetCell = false;\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\t// Uses double click timeout in mxGraph for quirks mode\n\t\tif (graph.nativeDblClickEnabled)\n\t\t{\n\t\t\tmxEvent.addListener(state.text.node, 'dblclick',\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tif (this.isLabelEvent(state, evt))\n\t\t\t\t\t{\n\t\t\t\t\t\tgraph.dblClick(evt, state.cell);\n\t\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Function: initializeLabel\n *\n * Initiailzes the label with a suitable container.\n *\n * Parameters:\n *\n * state - <mxCellState> whose label should be initialized.\n */\nmxCellRenderer.prototype.initializeLabel = function(state, shape)\n{\n\tif (mxClient.IS_SVG && mxClient.NO_FO && shape.dialect != mxConstants.DIALECT_SVG)\n\t{\n\t\tshape.init(state.view.graph.container);\n\t}\n\telse\n\t{\n\t\tshape.init(state.view.getDrawPane());\n\t}\n};\n\n/**\n * Function: createCellOverlays\n *\n * Creates the actual shape for showing the overlay for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the overlay should be created.\n */\nmxCellRenderer.prototype.createCellOverlays = function(state)\n{\n\tvar graph = state.view.graph;\n\tvar overlays = graph.getCellOverlays(state.cell);\n\tvar dict = null;\n\n\tif (overlays != null)\n\t{\n\t\tdict = new mxDictionary();\n\n\t\tfor (var i = 0; i < overlays.length; i++)\n\t\t{\n\t\t\tvar shape = (state.overlays != null) ? state.overlays.remove(overlays[i]) : null;\n\n\t\t\tif (shape == null)\n\t\t\t{\n\t\t\t\tvar tmp = new mxImageShape(new mxRectangle(), overlays[i].image.src);\n\t\t\t\ttmp.dialect = state.view.graph.dialect;\n\t\t\t\ttmp.preserveImageAspect = false;\n\t\t\t\ttmp.overlay = overlays[i];\n\t\t\t\tthis.initializeOverlay(state, tmp);\n\t\t\t\tthis.installCellOverlayListeners(state, overlays[i], tmp);\n\n\t\t\t\tif (overlays[i].cursor != null)\n\t\t\t\t{\n\t\t\t\t\ttmp.node.style.cursor = overlays[i].cursor;\n\t\t\t\t}\n\n\t\t\t\tdict.put(overlays[i], tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdict.put(overlays[i], shape);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Removes unused\n\tif (state.overlays != null)\n\t{\n\t\tstate.overlays.visit(function(id, shape)\n\t\t{\n\t\t\tshape.destroy();\n\t\t});\n\t}\n\n\tstate.overlays = dict;\n};\n\n/**\n * Function: initializeOverlay\n *\n * Initializes the given overlay.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the overlay should be created.\n * overlay - <mxImageShape> that represents the overlay.\n */\nmxCellRenderer.prototype.initializeOverlay = function(state, overlay)\n{\n\toverlay.init(state.view.getOverlayPane());\n};\n\n/**\n * Function: installOverlayListeners\n *\n * Installs the listeners for the given <mxCellState>, <mxCellOverlay> and\n * <mxShape> that represents the overlay.\n */\nmxCellRenderer.prototype.installCellOverlayListeners = function(state, overlay, shape)\n{\n\tvar graph  = state.view.graph;\n\n\tmxEvent.addListener(shape.node, 'click', function (evt)\n\t{\n\t\tif (graph.isEditing())\n\t\t{\n\t\t\tgraph.stopEditing(!graph.isInvokesStopCellEditing());\n\t\t}\n\n\t\toverlay.fireEvent(new mxEventObject(mxEvent.CLICK,\n\t\t\t\t'event', evt, 'cell', state.cell));\n\t});\n\n\tmxEvent.addGestureListeners(shape.node,\n\t\tfunction (evt)\n\t\t{\n\t\t\tmxEvent.consume(evt);\n\t\t},\n\t\tfunction (evt)\n\t\t{\n\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE,\n\t\t\t\tnew mxMouseEvent(evt, state));\n\t\t});\n\n\tif (mxClient.IS_TOUCH)\n\t{\n\t\tmxEvent.addListener(shape.node, 'touchend', function (evt)\n\t\t{\n\t\t\toverlay.fireEvent(new mxEventObject(mxEvent.CLICK,\n\t\t\t\t\t'event', evt, 'cell', state.cell));\n\t\t});\n\t}\n};\n\n/**\n * Function: createControl\n *\n * Creates the control for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the control should be created.\n */\nmxCellRenderer.prototype.createControl = function(state)\n{\n\tvar graph = state.view.graph;\n\tvar image = graph.getFoldingImage(state);\n\n\tif (graph.foldingEnabled && image != null)\n\t{\n\t\tif (state.control == null)\n\t\t{\n\t\t\tvar b = new mxRectangle(0, 0, image.width, image.height);\n\t\t\tstate.control = new mxImageShape(b, image.src);\n\t\t\tstate.control.preserveImageAspect = false;\n\t\t\tstate.control.dialect = graph.dialect;\n\n\t\t\tthis.initControl(state, state.control, true, this.createControlClickHandler(state));\n\t\t}\n\t}\n\telse if (state.control != null)\n\t{\n\t\tstate.control.destroy();\n\t\tstate.control = null;\n\t}\n};\n\n/**\n * Function: createControlClickHandler\n *\n * Hook for creating the click handler for the folding icon.\n *\n * Parameters:\n *\n * state - <mxCellState> whose control click handler should be returned.\n */\nmxCellRenderer.prototype.createControlClickHandler = function(state)\n{\n\tvar graph = state.view.graph;\n\n\treturn mxUtils.bind(this, function (evt)\n\t{\n\t\tif (this.forceControlClickHandler || graph.isEnabled())\n\t\t{\n\t\t\tvar collapse = !graph.isCellCollapsed(state.cell);\n\t\t\tgraph.foldCells(collapse, false, [state.cell], null, evt);\n\t\t\tmxEvent.consume(evt);\n\t\t}\n\t});\n};\n\n/**\n * Function: initControl\n *\n * Initializes the given control and returns the corresponding DOM node.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the control should be initialized.\n * control - <mxShape> to be initialized.\n * handleEvents - Boolean indicating if mousedown and mousemove should fire events via the graph.\n * clickHandler - Optional function to implement clicks on the control.\n */\nmxCellRenderer.prototype.initControl = function(state, control, handleEvents, clickHandler)\n{\n\tvar graph = state.view.graph;\n\n\t// In the special case where the label is in HTML and the display is SVG the image\n\t// should go into the graph container directly in order to be clickable. Otherwise\n\t// it is obscured by the HTML label that overlaps the cell.\n\tvar isForceHtml = graph.isHtmlLabel(state.cell) && mxClient.NO_FO &&\n\t\tgraph.dialect == mxConstants.DIALECT_SVG;\n\n\tif (isForceHtml)\n\t{\n\t\tcontrol.dialect = mxConstants.DIALECT_PREFERHTML;\n\t\tcontrol.init(graph.container);\n\t\tcontrol.node.style.zIndex = 1;\n\t}\n\telse\n\t{\n\t\tcontrol.init(state.view.getOverlayPane());\n\t}\n\n\tvar node = control.innerNode || control.node;\n\n\t// Workaround for missing click event on iOS is to check tolerance below\n\tif (clickHandler != null && !mxClient.IS_IOS)\n\t{\n\t\tif (graph.isEnabled())\n\t\t{\n\t\t\tnode.style.cursor = 'pointer';\n\t\t}\n\n\t\tmxEvent.addListener(node, 'click', clickHandler);\n\t}\n\n\tif (handleEvents)\n\t{\n\t\tvar first = null;\n\n\t\tmxEvent.addGestureListeners(node,\n\t\t\tfunction (evt)\n\t\t\t{\n\t\t\t\tfirst = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t},\n\t\t\tfunction (evt)\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, state));\n\t\t\t},\n\t\t\tfunction (evt)\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, state));\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t});\n\n\t\t// Uses capture phase for event interception to stop bubble phase\n\t\tif (clickHandler != null && mxClient.IS_IOS)\n\t\t{\n\t\t\tnode.addEventListener('touchend', function(evt)\n\t\t\t{\n\t\t\t\tif (first != null)\n\t\t\t\t{\n\t\t\t\t\tvar tol = graph.tolerance;\n\n\t\t\t\t\tif (Math.abs(first.x - mxEvent.getClientX(evt)) < tol &&\n\t\t\t\t\t\tMath.abs(first.y - mxEvent.getClientY(evt)) < tol)\n\t\t\t\t\t{\n\t\t\t\t\t\tclickHandler.call(clickHandler, evt);\n\t\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, true);\n\t\t}\n\t}\n\n\treturn node;\n};\n\n/**\n * Function: isShapeEvent\n *\n * Returns true if the event is for the shape of the given state. This\n * implementation always returns true.\n *\n * Parameters:\n *\n * state - <mxCellState> whose shape fired the event.\n * evt - Mouse event which was fired.\n */\nmxCellRenderer.prototype.isShapeEvent = function(state, evt)\n{\n\treturn true;\n};\n\n/**\n * Function: isLabelEvent\n *\n * Returns true if the event is for the label of the given state. This\n * implementation always returns true.\n *\n * Parameters:\n *\n * state - <mxCellState> whose label fired the event.\n * evt - Mouse event which was fired.\n */\nmxCellRenderer.prototype.isLabelEvent = function(state, evt)\n{\n\treturn true;\n};\n\n/**\n * Function: installListeners\n *\n * Installs the event listeners for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the event listeners should be isntalled.\n */\nmxCellRenderer.prototype.installListeners = function(state)\n{\n\tvar graph = state.view.graph;\n\n\t// Workaround for touch devices routing all events for a mouse\n\t// gesture (down, move, up) via the initial DOM node. Same for\n\t// HTML images in all IE versions (VML images are working).\n\tvar getState = function(evt)\n\t{\n\t\tvar result = state;\n\n\t\tif ((graph.dialect != mxConstants.DIALECT_SVG && mxEvent.getSource(evt).nodeName == 'IMG') || mxClient.IS_TOUCH)\n\t\t{\n\t\t\tvar x = mxEvent.getClientX(evt);\n\t\t\tvar y = mxEvent.getClientY(evt);\n\n\t\t\t// Dispatches the drop event to the graph which\n\t\t\t// consumes and executes the source function\n\t\t\tvar pt = mxUtils.convertPoint(graph.container, x, y);\n\t\t\tresult = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n\t\t}\n\n\t\treturn result;\n\t};\n\n\tmxEvent.addGestureListeners(state.shape.node,\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt, state));\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t})\n\t);\n\n\t// Uses double click timeout in mxGraph for quirks mode\n\tif (graph.nativeDblClickEnabled)\n\t{\n\t\tmxEvent.addListener(state.shape.node, 'dblclick',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tif (this.isShapeEvent(state, evt))\n\t\t\t\t{\n\t\t\t\t\tgraph.dblClick(evt, state.cell);\n\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n};\n\n/**\n * Function: redrawLabel\n *\n * Redraws the label for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> whose label should be redrawn.\n */\nmxCellRenderer.prototype.redrawLabel = function(state, forced)\n{\n\tvar graph = state.view.graph;\n\tvar value = this.getLabelValue(state);\n\tvar wrapping = graph.isWrapping(state.cell);\n\tvar clipping = graph.isLabelClipped(state.cell);\n\tvar isForceHtml = (state.view.graph.isHtmlLabel(state.cell) || (value != null && mxUtils.isNode(value)));\n\tvar dialect = (isForceHtml) ? mxConstants.DIALECT_STRICTHTML : state.view.graph.dialect;\n\tvar overflow = state.style[mxConstants.STYLE_OVERFLOW] || 'visible';\n\n\tif (state.text != null && (state.text.wrap != wrapping || state.text.clipped != clipping ||\n\t\tstate.text.overflow != overflow || state.text.dialect != dialect))\n\t{\n\t\tstate.text.destroy();\n\t\tstate.text = null;\n\t}\n\n\tif (state.text == null && value != null && (mxUtils.isNode(value) || value.length > 0))\n\t{\n\t\tthis.createLabel(state, value);\n\t}\n\telse if (state.text != null && (value == null || value.length == 0))\n\t{\n\t\tstate.text.destroy();\n\t\tstate.text = null;\n\t}\n\n\tif (state.text != null)\n\t{\n\t\t// Forced is true if the style has changed, so to get the updated\n\t\t// result in getLabelBounds we apply the new style to the shape\n\t\tif (forced)\n\t\t{\n\t\t\t// Checks if a full repaint is needed\n\t\t\tif (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text))\n\t\t\t{\n\t\t\t\t// Forces a full repaint\n\t\t\t\tstate.text.lastValue = null;\n\t\t\t}\n\n\t\t\tstate.text.resetStyles();\n\t\t\tstate.text.apply(state);\n\n\t\t\t// Special case where value is obtained via hook in graph\n\t\t\tstate.text.valign = graph.getVerticalAlign(state);\n\t\t}\n\n\t\tvar bounds = this.getLabelBounds(state);\n\t\tvar nextScale = this.getTextScale(state);\n\n\t\tif (forced || state.text.value != value || state.text.isWrapping != wrapping ||\n\t\t\tstate.text.overflow != overflow || state.text.isClipping != clipping ||\n\t\t\tstate.text.scale != nextScale || state.text.dialect != dialect ||\n\t\t\t!state.text.bounds.equals(bounds))\n\t\t{\n\t\t\t// Forces an update of the text bounding box\n\t\t\tif (state.text.bounds.width != 0 && state.unscaledWidth != null &&\n\t\t\t\tMath.round((state.text.bounds.width /\n\t\t\t\tstate.text.scale * nextScale) - bounds.width) != 0)\n\t\t\t{\n\t\t\t\tstate.unscaledWidth = null;\n\t\t\t}\n\n\t\t\tstate.text.dialect = dialect;\n\t\t\tstate.text.value = value;\n\t\t\tstate.text.bounds = bounds;\n\t\t\tstate.text.scale = nextScale;\n\t\t\tstate.text.wrap = wrapping;\n\t\t\tstate.text.clipped = clipping;\n\t\t\tstate.text.overflow = overflow;\n\n\t\t\t// Preserves visible state\n\t\t\tvar vis = state.text.node.style.visibility;\n\t\t\tthis.redrawLabelShape(state.text);\n\t\t\tstate.text.node.style.visibility = vis;\n\t\t}\n\t}\n};\n\n/**\n * Function: isTextShapeInvalid\n *\n * Returns true if the style for the text shape has changed.\n *\n * Parameters:\n *\n * state - <mxCellState> whose label should be checked.\n * shape - <mxText> shape to be checked.\n */\nmxCellRenderer.prototype.isTextShapeInvalid = function(state, shape)\n{\n\tfunction check(property, stylename, defaultValue)\n\t{\n\t\tvar result = false;\n\n\t\t// Workaround for spacing added to directional spacing\n\t\tif (stylename == 'spacingTop' || stylename == 'spacingRight' ||\n\t\t\tstylename == 'spacingBottom' || stylename == 'spacingLeft')\n\t\t{\n\t\t\tresult = parseFloat(shape[property]) - parseFloat(shape.spacing) !=\n\t\t\t\t(state.style[stylename] || defaultValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = shape[property] != (state.style[stylename] || defaultValue);\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn check('fontStyle', mxConstants.STYLE_FONTSTYLE, mxConstants.DEFAULT_FONTSTYLE) ||\n\t\tcheck('family', mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY) ||\n\t\tcheck('size', mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE) ||\n\t\tcheck('color', mxConstants.STYLE_FONTCOLOR, 'black') ||\n\t\tcheck('align', mxConstants.STYLE_ALIGN, '') ||\n\t\tcheck('valign', mxConstants.STYLE_VERTICAL_ALIGN, '') ||\n\t\tcheck('spacing', mxConstants.STYLE_SPACING, 2) ||\n\t\tcheck('spacingTop', mxConstants.STYLE_SPACING_TOP, 0) ||\n\t\tcheck('spacingRight', mxConstants.STYLE_SPACING_RIGHT, 0) ||\n\t\tcheck('spacingBottom', mxConstants.STYLE_SPACING_BOTTOM, 0) ||\n\t\tcheck('spacingLeft', mxConstants.STYLE_SPACING_LEFT, 0) ||\n\t\tcheck('horizontal', mxConstants.STYLE_HORIZONTAL, true) ||\n\t\tcheck('background', mxConstants.STYLE_LABEL_BACKGROUNDCOLOR) ||\n\t\tcheck('border', mxConstants.STYLE_LABEL_BORDERCOLOR) ||\n\t\tcheck('opacity', mxConstants.STYLE_TEXT_OPACITY, 100) ||\n\t\tcheck('textDirection', mxConstants.STYLE_TEXT_DIRECTION, mxConstants.DEFAULT_TEXT_DIRECTION);\n};\n\n/**\n * Function: redrawLabelShape\n *\n * Called to invoked redraw on the given text shape.\n *\n * Parameters:\n *\n * shape - <mxText> shape to be redrawn.\n */\nmxCellRenderer.prototype.redrawLabelShape = function(shape)\n{\n\tshape.redraw();\n};\n\n/**\n * Function: getTextScale\n *\n * Returns the scaling used for the label of the given state\n *\n * Parameters:\n *\n * state - <mxCellState> whose label scale should be returned.\n */\nmxCellRenderer.prototype.getTextScale = function(state)\n{\n\treturn state.view.scale;\n};\n\n/**\n * Function: getLabelBounds\n *\n * Returns the bounds to be used to draw the label of the given state.\n *\n * Parameters:\n *\n * state - <mxCellState> whose label bounds should be returned.\n */\nmxCellRenderer.prototype.getLabelBounds = function(state)\n{\n\tvar graph = state.view.graph;\n\tvar scale = state.view.scale;\n\tvar isEdge = graph.getModel().isEdge(state.cell);\n\tvar bounds = new mxRectangle(state.absoluteOffset.x, state.absoluteOffset.y);\n\n\tif (isEdge)\n\t{\n\t\tvar spacing = state.text.getSpacing();\n\t\tbounds.x += spacing.x * scale;\n\t\tbounds.y += spacing.y * scale;\n\n\t\tvar geo = graph.getCellGeometry(state.cell);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tbounds.width = Math.max(0, geo.width * scale);\n\t\t\tbounds.height = Math.max(0, geo.height * scale);\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Inverts label position\n\t\tif (state.text.isPaintBoundsInverted())\n\t\t{\n\t\t\tvar tmp = bounds.x;\n\t\t\tbounds.x = bounds.y;\n\t\t\tbounds.y = tmp;\n\t\t}\n\n\t\tbounds.x += state.x;\n\t\tbounds.y += state.y;\n\n\t\t// Minimum of 1 fixes alignment bug in HTML labels\n\t\tbounds.width = Math.max(1, state.width);\n\t\tbounds.height = Math.max(1, state.height);\n\n\t\tvar sc = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);\n\n\t\tif (sc != mxConstants.NONE && sc != '')\n\t\t{\n\t\t\tvar s = parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_STROKEWIDTH, 1)) * scale;\n\t\t\tvar dx = 1 + Math.floor((s - 1) / 2);\n\t\t\tvar dh = Math.floor(s + 1);\n\n\t\t\tbounds.x += dx;\n\t\t\tbounds.y += dx;\n\t\t\tbounds.width -= dh;\n\t\t\tbounds.height -= dh;\n\t\t}\n\t}\n\n\tif (state.text.isPaintBoundsInverted())\n\t{\n\t\t// Rotates around center of state\n\t\tvar t = (state.width - state.height) / 2;\n\t\tbounds.x += t;\n\t\tbounds.y -= t;\n\t\tvar tmp = bounds.width;\n\t\tbounds.width = bounds.height;\n\t\tbounds.height = tmp;\n\t}\n\n\t// Shape can modify its label bounds\n\tif (state.shape != null)\n\t{\n\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\t\tif (hpos == mxConstants.ALIGN_CENTER && vpos == mxConstants.ALIGN_MIDDLE)\n\t\t{\n\t\t\tbounds = state.shape.getLabelBounds(bounds);\n\t\t}\n\t}\n\n\t// Label width style overrides actual label width\n\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\n\tif (lw != null)\n\t{\n\t\tbounds.width = parseFloat(lw) * scale;\n\t}\n\n\tif (!isEdge)\n\t{\n\t\tthis.rotateLabelBounds(state, bounds);\n\t}\n\n\treturn bounds;\n};\n\n/**\n * Function: rotateLabelBounds\n *\n * Adds the shape rotation to the given label bounds and\n * applies the alignment and offsets.\n *\n * Parameters:\n *\n * state - <mxCellState> whose label bounds should be rotated.\n * bounds - <mxRectangle> the rectangle to be rotated.\n */\nmxCellRenderer.prototype.rotateLabelBounds = function(state, bounds)\n{\n\tbounds.y -= state.text.margin.y * bounds.height;\n\tbounds.x -= state.text.margin.x * bounds.width;\n\n\tif (!this.legacySpacing || (state.style[mxConstants.STYLE_OVERFLOW] != 'fill' && state.style[mxConstants.STYLE_OVERFLOW] != 'width'))\n\t{\n\t\tvar s = state.view.scale;\n\t\tvar spacing = state.text.getSpacing();\n\t\tbounds.x += spacing.x * s;\n\t\tbounds.y += spacing.y * s;\n\n\t\tvar hpos = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\t\tvar vpos = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\n\t\tbounds.width = Math.max(0, bounds.width - ((hpos == mxConstants.ALIGN_CENTER && lw == null) ? (state.text.spacingLeft * s + state.text.spacingRight * s) : 0));\n\t\tbounds.height = Math.max(0, bounds.height - ((vpos == mxConstants.ALIGN_MIDDLE) ? (state.text.spacingTop * s + state.text.spacingBottom * s) : 0));\n\t}\n\n\tvar theta = state.text.getTextRotation();\n\n\t// Only needed if rotated around another center\n\tif (theta != 0 && state != null && state.view.graph.model.isVertex(state.cell))\n\t{\n\t\tvar cx = state.getCenterX();\n\t\tvar cy = state.getCenterY();\n\n\t\tif (bounds.x != cx || bounds.y != cy)\n\t\t{\n\t\t\tvar rad = theta * (Math.PI / 180);\n\t\t\tpt = mxUtils.getRotatedPoint(new mxPoint(bounds.x, bounds.y),\n\t\t\t\t\tMath.cos(rad), Math.sin(rad), new mxPoint(cx, cy));\n\n\t\t\tbounds.x = pt.x;\n\t\t\tbounds.y = pt.y;\n\t\t}\n\t}\n};\n\n/**\n * Function: redrawCellOverlays\n *\n * Redraws the overlays for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> whose overlays should be redrawn.\n */\nmxCellRenderer.prototype.redrawCellOverlays = function(state, forced)\n{\n\tthis.createCellOverlays(state);\n\n\tif (state.overlays != null)\n\t{\n\t\tvar rot = mxUtils.mod(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0), 90);\n        var rad = mxUtils.toRadians(rot);\n        var cos = Math.cos(rad);\n        var sin = Math.sin(rad);\n\n\t\tstate.overlays.visit(function(id, shape)\n\t\t{\n\t\t\tvar bounds = shape.overlay.getBounds(state);\n\n\t\t\tif (!state.view.graph.getModel().isEdge(state.cell))\n\t\t\t{\n\t\t\t\tif (state.shape != null && rot != 0)\n\t\t\t\t{\n\t\t\t\t\tvar cx = bounds.getCenterX();\n\t\t\t\t\tvar cy = bounds.getCenterY();\n\n\t\t\t\t\tvar point = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin,\n\t\t\t        \t\tnew mxPoint(state.getCenterX(), state.getCenterY()));\n\n\t\t\t        cx = point.x;\n\t\t\t        cy = point.y;\n\t\t\t        bounds.x = Math.round(cx - bounds.width / 2);\n\t\t\t        bounds.y = Math.round(cy - bounds.height / 2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (forced || shape.bounds == null || shape.scale != state.view.scale ||\n\t\t\t\t!shape.bounds.equals(bounds))\n\t\t\t{\n\t\t\t\tshape.bounds = bounds;\n\t\t\t\tshape.scale = state.view.scale;\n\t\t\t\tshape.redraw();\n\t\t\t}\n\t\t});\n\t}\n};\n\n/**\n * Function: redrawControl\n *\n * Redraws the control for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> whose control should be redrawn.\n */\nmxCellRenderer.prototype.redrawControl = function(state, forced)\n{\n\tvar image = state.view.graph.getFoldingImage(state);\n\n\tif (state.control != null && image != null)\n\t{\n\t\tvar bounds = this.getControlBounds(state, image.width, image.height);\n\t\tvar r = (this.legacyControlPosition) ?\n\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0) :\n\t\t\t\tstate.shape.getTextRotation();\n\t\tvar s = state.view.scale;\n\n\t\tif (forced || state.control.scale != s || !state.control.bounds.equals(bounds) ||\n\t\t\tstate.control.rotation != r)\n\t\t{\n\t\t\tstate.control.rotation = r;\n\t\t\tstate.control.bounds = bounds;\n\t\t\tstate.control.scale = s;\n\n\t\t\tstate.control.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: getControlBounds\n *\n * Returns the bounds to be used to draw the control (folding icon) of the\n * given state.\n */\nmxCellRenderer.prototype.getControlBounds = function(state, w, h)\n{\n\tif (state.control != null)\n\t{\n\t\tvar s = state.view.scale;\n\t\tvar cx = state.getCenterX();\n\t\tvar cy = state.getCenterY();\n\n\t\tif (!state.view.graph.getModel().isEdge(state.cell))\n\t\t{\n\t\t\tcx = state.x + w * s;\n\t\t\tcy = state.y + h * s;\n\n\t\t\tif (state.shape != null)\n\t\t\t{\n\t\t\t\t// TODO: Factor out common code\n\t\t\t\tvar rot = state.shape.getShapeRotation();\n\n\t\t\t\tif (this.legacyControlPosition)\n\t\t\t\t{\n\t\t\t\t\trot = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (state.shape.isPaintBoundsInverted())\n\t\t\t\t\t{\n\t\t\t\t\t\tvar t = (state.width - state.height) / 2;\n\t\t\t\t\t\tcx += t;\n\t\t\t\t\t\tcy -= t;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (rot != 0)\n\t\t\t\t{\n\t\t\t        var rad = mxUtils.toRadians(rot);\n\t\t\t        var cos = Math.cos(rad);\n\t\t\t        var sin = Math.sin(rad);\n\n\t\t\t        var point = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin,\n\t\t\t        \t\tnew mxPoint(state.getCenterX(), state.getCenterY()));\n\t\t\t        cx = point.x;\n\t\t\t        cy = point.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (state.view.graph.getModel().isEdge(state.cell)) ?\n\t\t\tnew mxRectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s))\n\t\t\t: new mxRectangle(Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: insertStateAfter\n *\n * Inserts the given array of <mxShapes> after the given nodes in the DOM.\n *\n * Parameters:\n *\n * shapes - Array of <mxShapes> to be inserted.\n * node - Node in <drawPane> after which the shapes should be inserted.\n * htmlNode - Node in the graph container after which the shapes should be inserted that\n * will not go into the <drawPane> (eg. HTML labels without foreignObjects).\n */\nmxCellRenderer.prototype.insertStateAfter = function(state, node, htmlNode)\n{\n\tvar shapes = this.getShapesForState(state);\n\n\tfor (var i = 0; i < shapes.length; i++)\n\t{\n\t\tif (shapes[i] != null && shapes[i].node != null)\n\t\t{\n\t\t\tvar html = shapes[i].node.parentNode != state.view.getDrawPane() &&\n\t\t\t\tshapes[i].node.parentNode != state.view.getOverlayPane();\n\t\t\tvar temp = (html) ? htmlNode : node;\n\n\t\t\tif (temp != null && temp.nextSibling != shapes[i].node)\n\t\t\t{\n\t\t\t\tif (temp.nextSibling == null)\n\t\t\t\t{\n\t\t\t\t\ttemp.parentNode.appendChild(shapes[i].node);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttemp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (temp == null)\n\t\t\t{\n\t\t\t\t// Special case: First HTML node should be first sibling after canvas\n\t\t\t\tif (shapes[i].node.parentNode == state.view.graph.container)\n\t\t\t\t{\n\t\t\t\t\tvar canvas = state.view.canvas;\n\n\t\t\t\t\twhile (canvas != null && canvas.parentNode != state.view.graph.container)\n\t\t\t\t\t{\n\t\t\t\t\t\tcanvas = canvas.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (canvas != null && canvas.nextSibling != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (canvas.nextSibling != shapes[i].node)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tshapes[i].node.parentNode.insertBefore(shapes[i].node, canvas.nextSibling);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tshapes[i].node.parentNode.appendChild(shapes[i].node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (shapes[i].node.parentNode.firstChild != null && shapes[i].node.parentNode.firstChild != shapes[i].node)\n\t\t\t\t{\n\t\t\t\t\t// Inserts the node as the first child of the parent to implement the order\n\t\t\t\t\tshapes[i].node.parentNode.insertBefore(shapes[i].node, shapes[i].node.parentNode.firstChild);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (html)\n\t\t\t{\n\t\t\t\thtmlNode = shapes[i].node;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnode = shapes[i].node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [node, htmlNode];\n};\n\n/**\n * Function: getShapesForState\n *\n * Returns the <mxShapes> for the given cell state in the order in which they should\n * appear in the DOM.\n *\n * Parameters:\n *\n * state - <mxCellState> whose shapes should be returned.\n */\nmxCellRenderer.prototype.getShapesForState = function(state)\n{\n\treturn [state.shape, state.text, state.control];\n};\n\n/**\n * Function: redraw\n *\n * Updates the bounds or points and scale of the shapes for the given cell\n * state. This is called in mxGraphView.validatePoints as the last step of\n * updating all cells.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the shapes should be updated.\n * force - Optional boolean that specifies if the cell should be reconfiured\n * and redrawn without any additional checks.\n * rendering - Optional boolean that specifies if the cell should actually\n * be drawn into the DOM. If this is false then redraw and/or reconfigure\n * will not be called on the shape.\n */\nmxCellRenderer.prototype.redraw = function(state, force, rendering)\n{\n\tvar shapeChanged = this.redrawShape(state, force, rendering);\n\n\tif (state.shape != null && (rendering == null || rendering))\n\t{\n\t\tthis.redrawLabel(state, shapeChanged);\n\t\tthis.redrawCellOverlays(state, shapeChanged);\n\t\tthis.redrawControl(state, shapeChanged);\n\t}\n};\n\n/**\n * Function: redrawShape\n *\n * Redraws the shape for the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> whose label should be redrawn.\n */\nmxCellRenderer.prototype.redrawShape = function(state, force, rendering)\n{\n\tvar model = state.view.graph.model;\n\tvar shapeChanged = false;\n\n\t// Forces creation of new shape if shape style has changed\n\tif (state.shape != null && state.shape.style != null && state.style != null &&\n\t\tstate.shape.style[mxConstants.STYLE_SHAPE] != state.style[mxConstants.STYLE_SHAPE])\n\t{\n\t\tstate.shape.destroy();\n\t\tstate.shape = null;\n\t}\n\n\tif (state.shape == null && state.view.graph.container != null &&\n\t\tstate.cell != state.view.currentRoot &&\n\t\t(model.isVertex(state.cell) || model.isEdge(state.cell)))\n\t{\n\t\tstate.shape = this.createShape(state);\n\n\t\tif (state.shape != null)\n\t\t{\n\t\t\tstate.shape.minSvgStrokeWidth = this.minSvgStrokeWidth;\n\t\t\tstate.shape.antiAlias = this.antiAlias;\n\n\t\t\tthis.createIndicatorShape(state);\n\t\t\tthis.initializeShape(state);\n\t\t\tthis.createCellOverlays(state);\n\t\t\tthis.installListeners(state);\n\n\t\t\t// Forces a refresh of the handler if one exists\n\t\t\tstate.view.graph.selectionCellsHandler.updateHandler(state);\n\t\t}\n\t}\n\telse if (!force && state.shape != null && (!mxUtils.equalEntries(state.shape.style,\n\t\tstate.style) || this.checkPlaceholderStyles(state)))\n\t{\n\t\tstate.shape.resetStyles();\n\t\tthis.configureShape(state);\n\t\t// LATER: Ignore update for realtime to fix reset of current gesture\n\t\tstate.view.graph.selectionCellsHandler.updateHandler(state);\n\t\tforce = true;\n\t}\n\n\tif (state.shape != null)\n\t{\n\t\t// Handles changes of the collapse icon\n\t\tthis.createControl(state);\n\n\t\t// Redraws the cell if required, ignores changes to bounds if points are\n\t\t// defined as the bounds are updated for the given points inside the shape\n\t\tif (force || this.isShapeInvalid(state, state.shape))\n\t\t{\n\t\t\tif (state.absolutePoints != null)\n\t\t\t{\n\t\t\t\tstate.shape.points = state.absolutePoints.slice();\n\t\t\t\tstate.shape.bounds = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.shape.points = null;\n\t\t\t\tstate.shape.bounds = new mxRectangle(state.x, state.y, state.width, state.height);\n\t\t\t}\n\n\t\t\tstate.shape.scale = state.view.scale;\n\n\t\t\tif (rendering == null || rendering)\n\t\t\t{\n\t\t\t\tthis.doRedrawShape(state);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.shape.updateBoundingBox();\n\t\t\t}\n\n\t\t\tshapeChanged = true;\n\t\t}\n\t}\n\n\treturn shapeChanged;\n};\n\n/**\n * Function: doRedrawShape\n *\n * Invokes redraw on the shape of the given state.\n */\nmxCellRenderer.prototype.doRedrawShape = function(state)\n{\n\tstate.shape.redraw();\n};\n\n/**\n * Function: isShapeInvalid\n *\n * Returns true if the given shape must be repainted.\n */\nmxCellRenderer.prototype.isShapeInvalid = function(state, shape)\n{\n\treturn shape.bounds == null || shape.scale != state.view.scale ||\n\t\t(state.absolutePoints == null && !shape.bounds.equals(state)) ||\n\t\t(state.absolutePoints != null && !mxUtils.equalPoints(shape.points, state.absolutePoints))\n};\n\n/**\n * Function: destroy\n *\n * Destroys the shapes associated with the given cell state.\n *\n * Parameters:\n *\n * state - <mxCellState> for which the shapes should be destroyed.\n */\nmxCellRenderer.prototype.destroy = function(state)\n{\n\tif (state.shape != null)\n\t{\n\t\tif (state.text != null)\n\t\t{\n\t\t\tstate.text.destroy();\n\t\t\tstate.text = null;\n\t\t}\n\n\t\tif (state.overlays != null)\n\t\t{\n\t\t\tstate.overlays.visit(function(id, shape)\n\t\t\t{\n\t\t\t\tshape.destroy();\n\t\t\t});\n\n\t\t\tstate.overlays = null;\n\t\t}\n\n\t\tif (state.control != null)\n\t\t{\n\t\t\tstate.control.destroy();\n\t\t\tstate.control = null;\n\t\t}\n\n\t\tstate.shape.destroy();\n\t\tstate.shape = null;\n\t}\n};\n\n__mxOutput.mxCellRenderer = typeof mxCellRenderer !== 'undefined' ? mxCellRenderer : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxEdgeStyle =\n{\n\t/**\n\t * Class: mxEdgeStyle\n\t *\n\t * Provides various edge styles to be used as the values for\n\t * <mxConstants.STYLE_EDGE> in a cell style.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * var style = stylesheet.getDefaultEdgeStyle();\n\t * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;\n\t * (end)\n\t *\n\t * Sets the default edge style to <ElbowConnector>.\n\t *\n\t * Custom edge style:\n\t *\n\t * To write a custom edge style, a function must be added to the mxEdgeStyle\n\t * object as follows:\n\t *\n\t * (code)\n\t * mxEdgeStyle.MyStyle = function(state, source, target, points, result)\n\t * {\n\t *   if (source != null && target != null)\n\t *   {\n\t *     var pt = new mxPoint(target.getCenterX(), source.getCenterY());\n\t *\n\t *     if (mxUtils.contains(source, pt.x, pt.y))\n\t *     {\n\t *       pt.y = source.y + source.height;\n\t *     }\n\t *\n\t *     result.push(pt);\n\t *   }\n\t * };\n\t * (end)\n\t *\n\t * In the above example, a right angle is created using a point on the\n\t * horizontal center of the target vertex and the vertical center of the source\n\t * vertex. The code checks if that point intersects the source vertex and makes\n\t * the edge straight if it does. The point is then added into the result array,\n\t * which acts as the return value of the function.\n\t *\n\t * The new edge style should then be registered in the <mxStyleRegistry> as follows:\n\t * (code)\n\t * mxStyleRegistry.putValue('myEdgeStyle', mxEdgeStyle.MyStyle);\n\t * (end)\n\t *\n\t * The custom edge style above can now be used in a specific edge as follows:\n\t *\n\t * (code)\n\t * model.setStyle(edge, 'edgeStyle=myEdgeStyle');\n\t * (end)\n\t *\n\t * Note that the key of the <mxStyleRegistry> entry for the function should\n\t * be used in string values, unless <mxGraphView.allowEval> is true, in\n\t * which case you can also use mxEdgeStyle.MyStyle for the value in the\n\t * cell style above.\n\t *\n\t * Or it can be used for all edges in the graph as follows:\n\t *\n\t * (code)\n\t * var style = graph.getStylesheet().getDefaultEdgeStyle();\n\t * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.MyStyle;\n\t * (end)\n\t *\n\t * Note that the object can be used directly when programmatically setting\n\t * the value, but the key in the <mxStyleRegistry> should be used when\n\t * setting the value via a key, value pair in a cell style.\n\t *\n\t * Function: EntityRelation\n\t *\n\t * Implements an entity relation style for edges (as used in database\n\t * schema diagrams). At the time the function is called, the result\n\t * array contains a placeholder (null) for the first absolute point,\n\t * that is, the point where the edge and source terminal are connected.\n\t * The implementation of the style then adds all intermediate waypoints\n\t * except for the last point, that is, the connection point between the\n\t * edge and the target terminal. The first ant the last point in the\n\t * result array are then replaced with mxPoints that take into account\n\t * the terminal's perimeter and next point on the edge.\n\t *\n\t * Parameters:\n\t *\n\t * state - <mxCellState> that represents the edge to be updated.\n\t * source - <mxCellState> that represents the source terminal.\n\t * target - <mxCellState> that represents the target terminal.\n\t * points - List of relative control points.\n\t * result - Array of <mxPoints> that represent the actual points of the\n\t * edge.\n\t */\n\t EntityRelation: function (state, source, target, points, result)\n\t {\n\t\tvar view = state.view;\n\t \tvar graph = view.graph;\n\t \tvar segment = mxUtils.getValue(state.style,\n\t \t\t\tmxConstants.STYLE_SEGMENT,\n\t \t\t\tmxConstants.ENTITY_SEGMENT) * view.scale;\n\n\t\tvar pts = state.absolutePoints;\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\n\t \tvar isSourceLeft = false;\n\n\t\tif (p0 != null)\n\t\t{\n\t\t\tsource = new mxCellState();\n\t\t\tsource.x = p0.x;\n\t\t\tsource.y = p0.y;\n\t\t}\n\t\telse if (source != null)\n\t\t{\n\t\t\tvar constraint = mxUtils.getPortConstraints(source, state, true, mxConstants.DIRECTION_MASK_NONE);\n\n\t\t\tif (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST +\n\t\t\t\tmxConstants.DIRECTION_MASK_EAST)\n\t\t\t{\n\t\t\t\tisSourceLeft = constraint == mxConstants.DIRECTION_MASK_WEST;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t \tvar sourceGeometry = graph.getCellGeometry(source.cell);\n\n\t\t\t \tif (sourceGeometry.relative)\n\t\t\t \t{\n\t\t\t \t\tisSourceLeft = sourceGeometry.x <= 0.5;\n\t\t\t \t}\n\t\t\t \telse if (target != null)\n\t\t\t \t{\n\t\t\t \t\tisSourceLeft = target.x + target.width < source.x;\n\t\t\t \t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t \tvar isTargetLeft = true;\n\n\t\tif (pe != null)\n\t\t{\n\t\t\ttarget = new mxCellState();\n\t\t\ttarget.x = pe.x;\n\t\t\ttarget.y = pe.y;\n\t\t}\n\t\telse if (target != null)\n\t \t{\n\t\t\tvar constraint = mxUtils.getPortConstraints(target, state, false, mxConstants.DIRECTION_MASK_NONE);\n\n\t\t\tif (constraint != mxConstants.DIRECTION_MASK_NONE && constraint != mxConstants.DIRECTION_MASK_WEST +\n\t\t\t\tmxConstants.DIRECTION_MASK_EAST)\n\t\t\t{\n\t\t\t\tisTargetLeft = constraint == mxConstants.DIRECTION_MASK_WEST;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t \tvar targetGeometry = graph.getCellGeometry(target.cell);\n\n\t\t\t \tif (targetGeometry.relative)\n\t\t\t \t{\n\t\t\t \t\tisTargetLeft = targetGeometry.x <= 0.5;\n\t\t\t \t}\n\t\t\t \telse if (source != null)\n\t\t\t \t{\n\t\t\t \t\tisTargetLeft = source.x + source.width < target.x;\n\t\t\t \t}\n\t\t\t}\n\t \t}\n\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tvar x0 = (isSourceLeft) ? source.x : source.x + source.width;\n\t\t\tvar y0 = view.getRoutingCenterY(source);\n\n\t\t\tvar xe = (isTargetLeft) ? target.x : target.x + target.width;\n\t\t\tvar ye = view.getRoutingCenterY(target);\n\n\t\t\tvar seg = segment;\n\n\t\t\tvar dx = (isSourceLeft) ? -seg : seg;\n\t\t\tvar dep = new mxPoint(x0 + dx, y0);\n\n\t\t\tdx = (isTargetLeft) ? -seg : seg;\n\t\t\tvar arr = new mxPoint(xe + dx, ye);\n\n\t\t\t// Adds intermediate points if both go out on same side\n\t\t\tif (isSourceLeft == isTargetLeft)\n\t\t\t{\n\t\t\t\tvar x = (isSourceLeft) ?\n\t\t\t\t\tMath.min(x0, xe)-segment :\n\t\t\t\t\tMath.max(x0, xe)+segment;\n\n\t\t\t\tresult.push(new mxPoint(x, y0));\n\t\t\t\tresult.push(new mxPoint(x, ye));\n\t\t\t}\n\t\t\telse if ((dep.x < arr.x) == isSourceLeft)\n\t\t\t{\n\t\t\t\tvar midY = y0 + (ye - y0) / 2;\n\n\t\t\t\tresult.push(dep);\n\t\t\t\tresult.push(new mxPoint(dep.x, midY));\n\t\t\t\tresult.push(new mxPoint(arr.x, midY));\n\t\t\t\tresult.push(arr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.push(dep);\n\t\t\t\tresult.push(arr);\n\t\t\t}\n\t\t}\n\t },\n\n\t /**\n\t * Function: Loop\n\t *\n\t * Implements a self-reference, aka. loop.\n\t */\n\tLoop: function (state, source, target, points, result)\n\t{\n\t\tvar pts = state.absolutePoints;\n\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\n\t\tif (p0 != null && pe != null)\n\t\t{\n\t\t\tif (points != null && points.length > 0)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar pt = points[i];\n\t\t\t\t\tpt = state.view.transformControlPoint(state, pt);\n\t\t\t\t\tresult.push(new mxPoint(pt.x, pt.y));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (source != null)\n\t\t{\n\t\t\tvar view = state.view;\n\t\t\tvar graph = view.graph;\n\t\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tpt = view.transformControlPoint(state, pt);\n\n\t\t\t\tif (mxUtils.contains(source, pt.x, pt.y))\n\t\t\t\t{\n\t\t\t\t\tpt = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar x = 0;\n\t\t\tvar dx = 0;\n\t\t\tvar y = 0;\n\t\t\tvar dy = 0;\n\n\t\t \tvar seg = mxUtils.getValue(state.style, mxConstants.STYLE_SEGMENT,\n\t\t \t\tgraph.gridSize) * view.scale;\n\t\t\tvar dir = mxUtils.getValue(state.style, mxConstants.STYLE_DIRECTION,\n\t\t\t\tmxConstants.DIRECTION_WEST);\n\n\t\t\tif (dir == mxConstants.DIRECTION_NORTH ||\n\t\t\t\tdir == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tx = view.getRoutingCenterX(source);\n\t\t\t\tdx = seg;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty = view.getRoutingCenterY(source);\n\t\t\t\tdy = seg;\n\t\t\t}\n\n\t\t\tif (pt == null ||\n\t\t\t\tpt.x < source.x ||\n\t\t\t\tpt.x > source.x + source.width)\n\t\t\t{\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tx = pt.x;\n\t\t\t\t\tdy = Math.max(Math.abs(y - pt.y), dy);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (dir == mxConstants.DIRECTION_NORTH)\n\t\t\t\t\t{\n\t\t\t\t\t\ty = source.y - 2 * dx;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == mxConstants.DIRECTION_SOUTH)\n\t\t\t\t\t{\n\t\t\t\t\t\ty = source.y + source.height + 2 * dx;\n\t\t\t\t\t}\n\t\t\t\t\telse if (dir == mxConstants.DIRECTION_EAST)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = source.x - 2 * dy;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = source.x + source.width + 2 * dy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pt != null)\n\t\t\t{\n\t\t\t\tx = view.getRoutingCenterX(source);\n\t\t\t\tdx = Math.max(Math.abs(x - pt.x), dy);\n\t\t\t\ty = pt.y;\n\t\t\t\tdy = 0;\n\t\t\t}\n\n\t\t\tresult.push(new mxPoint(x - dx, y - dy));\n\t\t\tresult.push(new mxPoint(x + dx, y + dy));\n\t\t}\n\t},\n\n\t/**\n\t * Function: ElbowConnector\n\t *\n\t * Uses either <SideToSide> or <TopToBottom> depending on the horizontal\n\t * flag in the cell style. <SideToSide> is used if horizontal is true or\n\t * unspecified. See <EntityRelation> for a description of the\n\t * parameters.\n\t */\n\tElbowConnector: function (state, source, target, points, result)\n\t{\n\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\n\t\tvar vertical = false;\n\t\tvar horizontal = false;\n\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tvar left = Math.min(source.x, target.x);\n\t\t\t\tvar right = Math.max(source.x + source.width,\n\t\t\t\t\ttarget.x + target.width);\n\n\t\t\t\tvar top = Math.min(source.y, target.y);\n\t\t\t\tvar bottom = Math.max(source.y + source.height,\n\t\t\t\t\ttarget.y + target.height);\n\n\t\t\t\tpt = state.view.transformControlPoint(state, pt);\n\n\t\t\t\tvertical = pt.y < top || pt.y > bottom;\n\t\t\t\thorizontal = pt.x < left || pt.x > right;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar left = Math.max(source.x, target.x);\n\t\t\t\tvar right = Math.min(source.x + source.width,\n\t\t\t\t\ttarget.x + target.width);\n\n\t\t\t\tvertical = left == right;\n\n\t\t\t\tif (!vertical)\n\t\t\t\t{\n\t\t\t\t\tvar top = Math.max(source.y, target.y);\n\t\t\t\t\tvar bottom = Math.min(source.y + source.height,\n\t\t\t\t\t\ttarget.y + target.height);\n\n\t\t\t\t\thorizontal = top == bottom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!horizontal && (vertical ||\n\t\t\tstate.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL))\n\t\t{\n\t\t\tmxEdgeStyle.TopToBottom(state, source, target, points, result);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxEdgeStyle.SideToSide(state, source, target, points, result);\n\t\t}\n\t},\n\n\t/**\n\t * Function: SideToSide\n\t *\n\t * Implements a vertical elbow edge. See <EntityRelation> for a description\n\t * of the parameters.\n\t */\n\tSideToSide: function (state, source, target, points, result)\n\t{\n\t\tvar view = state.view;\n\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\t\tvar pts = state.absolutePoints;\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\n\t\tif (pt != null)\n\t\t{\n\t\t\tpt = view.transformControlPoint(state, pt);\n\t\t}\n\n\t\tif (p0 != null)\n\t\t{\n\t\t\tsource = new mxCellState();\n\t\t\tsource.x = p0.x;\n\t\t\tsource.y = p0.y;\n\t\t}\n\n\t\tif (pe != null)\n\t\t{\n\t\t\ttarget = new mxCellState();\n\t\t\ttarget.x = pe.x;\n\t\t\ttarget.y = pe.y;\n\t\t}\n\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tvar l = Math.max(source.x, target.x);\n\t\t\tvar r = Math.min(source.x + source.width,\n\t\t\t\t\t\t\t target.x + target.width);\n\n\t\t\tvar x = (pt != null) ? pt.x : Math.round(r + (l - r) / 2);\n\n\t\t\tvar y1 = view.getRoutingCenterY(source);\n\t\t\tvar y2 = view.getRoutingCenterY(target);\n\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tif (pt.y >= source.y && pt.y <= source.y + source.height)\n\t\t\t\t{\n\t\t\t\t\ty1 = pt.y;\n\t\t\t\t}\n\n\t\t\t\tif (pt.y >= target.y && pt.y <= target.y + target.height)\n\t\t\t\t{\n\t\t\t\t\ty2 = pt.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!mxUtils.contains(target, x, y1) &&\n\t\t\t\t!mxUtils.contains(source, x, y1))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x,  y1));\n\t\t\t}\n\n\t\t\tif (!mxUtils.contains(target, x, y2) &&\n\t\t\t\t!mxUtils.contains(source, x, y2))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x, y2));\n\t\t\t}\n\n\t\t\tif (result.length == 1)\n\t\t\t{\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tif (!mxUtils.contains(target, x, pt.y) &&\n\t\t\t\t\t\t!mxUtils.contains(source, x, pt.y))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(new mxPoint(x, pt.y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar t = Math.max(source.y, target.y);\n\t\t\t\t\tvar b = Math.min(source.y + source.height,\n\t\t\t\t\t\t\t target.y + target.height);\n\n\t\t\t\t\tresult.push(new mxPoint(x, t + (b - t) / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: TopToBottom\n\t *\n\t * Implements a horizontal elbow edge. See <EntityRelation> for a\n\t * description of the parameters.\n\t */\n\tTopToBottom: function(state, source, target, points, result)\n\t{\n\t\tvar view = state.view;\n\t\tvar pt = (points != null && points.length > 0) ? points[0] : null;\n\t\tvar pts = state.absolutePoints;\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\n\t\tif (pt != null)\n\t\t{\n\t\t\tpt = view.transformControlPoint(state, pt);\n\t\t}\n\n\t\tif (p0 != null)\n\t\t{\n\t\t\tsource = new mxCellState();\n\t\t\tsource.x = p0.x;\n\t\t\tsource.y = p0.y;\n\t\t}\n\n\t\tif (pe != null)\n\t\t{\n\t\t\ttarget = new mxCellState();\n\t\t\ttarget.x = pe.x;\n\t\t\ttarget.y = pe.y;\n\t\t}\n\n\t\tif (source != null && target != null)\n\t\t{\n\t\t\tvar t = Math.max(source.y, target.y);\n\t\t\tvar b = Math.min(source.y + source.height,\n\t\t\t\t\t\t\t target.y + target.height);\n\n\t\t\tvar x = view.getRoutingCenterX(source);\n\n\t\t\tif (pt != null &&\n\t\t\t\tpt.x >= source.x &&\n\t\t\t\tpt.x <= source.x + source.width)\n\t\t\t{\n\t\t\t\tx = pt.x;\n\t\t\t}\n\n\t\t\tvar y = (pt != null) ? pt.y : Math.round(b + (t - b) / 2);\n\n\t\t\tif (!mxUtils.contains(target, x, y) &&\n\t\t\t\t!mxUtils.contains(source, x, y))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x, y));\n\t\t\t}\n\n\t\t\tif (pt != null &&\n\t\t\t\tpt.x >= target.x &&\n\t\t\t\tpt.x <= target.x + target.width)\n\t\t\t{\n\t\t\t\tx = pt.x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx = view.getRoutingCenterX(target);\n\t\t\t}\n\n\t\t\tif (!mxUtils.contains(target, x, y) &&\n\t\t\t\t!mxUtils.contains(source, x, y))\n\t\t\t{\n\t\t\t\tresult.push(new mxPoint(x, y));\n\t\t\t}\n\n\t\t\tif (result.length == 1)\n\t\t\t{\n\t\t\t\tif (pt != null && result.length == 1)\n\t\t\t\t{\n\t\t\t\t\tif (!mxUtils.contains(target, pt.x, y) &&\n\t\t\t\t\t\t!mxUtils.contains(source, pt.x, y))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(new mxPoint(pt.x, y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar l = Math.max(source.x, target.x);\n\t\t\t\t\tvar r = Math.min(source.x + source.width,\n\t\t\t\t\t\t\t target.x + target.width);\n\n\t\t\t\t\tresult.push(new mxPoint(l + (r - l) / 2, y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Function: SegmentConnector\n\t *\n\t * Implements an orthogonal edge style. Use <mxEdgeSegmentHandler>\n\t * as an interactive handler for this style.\n\t */\n\tSegmentConnector: function(state, source, target, hints, result)\n\t{\n\t\t// Creates array of all way- and terminalpoints\n\t\tvar pts = state.absolutePoints;\n\t\tvar tol = Math.max(1, state.view.scale);\n\n\t\t// Whether the first segment outgoing from the source end is horizontal\n\t\tvar lastPushed = (result.length > 0) ? result[0] : null;\n\t\tvar horizontal = true;\n\t\tvar hint = null;\n\n\t\t// Adds waypoints only if outside of tolerance\n\t\tfunction pushPoint(pt)\n\t\t{\n\t\t\tif (lastPushed == null || Math.abs(lastPushed.x - pt.x) >= tol || Math.abs(lastPushed.y - pt.y) >= tol)\n\t\t\t{\n\t\t\t\tresult.push(pt);\n\t\t\t\tlastPushed = pt;\n\t\t\t}\n\n\t\t\treturn lastPushed;\n\t\t};\n\n\t\t// Adds the first point\n\t\tvar pt = pts[0];\n\n\t\tif (pt == null && source != null)\n\t\t{\n\t\t\tpt = new mxPoint(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));\n\t\t}\n\t\telse if (pt != null)\n\t\t{\n\t\t\tpt = pt.clone();\n\t\t}\n\n\t\tpt.x = Math.round(pt.x);\n\t\tpt.y = Math.round(pt.y);\n\n\t\tvar lastInx = pts.length - 1;\n\n\t\t// Adds the waypoints\n\t\tif (hints != null && hints.length > 0)\n\t\t{\n\t\t\t// Converts all hints and removes nulls\n\t\t\tvar newHints = [];\n\n\t\t\tfor (var i = 0; i < hints.length; i++)\n\t\t\t{\n\t\t\t\tvar tmp = state.view.transformControlPoint(state, hints[i]);\n\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\ttmp.x = Math.round(tmp.x);\n\t\t\t\t\ttmp.y = Math.round(tmp.y);\n\t\t\t\t\tnewHints.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHints.length == 0)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\thints = newHints;\n\n\t\t\t// Aligns source and target hint to fixed points\n\t\t\tif (pt != null && hints[0] != null)\n\t\t\t{\n\t\t\t\tif (Math.abs(hints[0].x - pt.x) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[0].x = pt.x;\n\t\t\t\t}\n\n\t\t\t\tif (Math.abs(hints[0].y - pt.y) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[0].y = pt.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar pe = pts[lastInx];\n\n\t\t\tif (pe != null && hints[hints.length - 1] != null)\n\t\t\t{\n\t\t\t\tif (Math.abs(hints[hints.length - 1].x - pe.x) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[hints.length - 1].x = pe.x;\n\t\t\t\t}\n\n\t\t\t\tif (Math.abs(hints[hints.length - 1].y - pe.y) < tol)\n\t\t\t\t{\n\t\t\t\t\thints[hints.length - 1].y = pe.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thint = hints[0];\n\n\t\t\tvar currentTerm = source;\n\t\t\tvar currentPt = pts[0];\n\t\t\tvar hozChan = false;\n\t\t\tvar vertChan = false;\n\t\t\tvar currentHint = hint;\n\n\t\t\tif (currentPt != null)\n\t\t\t{\n\t\t\t\tcurrentPt.x = Math.round(currentPt.x);\n\t\t\t\tcurrentPt.y = Math.round(currentPt.y);\n\t\t\t\tcurrentTerm = null;\n\t\t\t}\n\n\t\t\t// Check for alignment with fixed points and with channels\n\t\t\t// at source and target segments only\n\t\t\tfor (var i = 0; i < 2; i++)\n\t\t\t{\n\t\t\t\tvar fixedVertAlign = currentPt != null && currentPt.x == currentHint.x;\n\t\t\t\tvar fixedHozAlign = currentPt != null && currentPt.y == currentHint.y;\n\n\t\t\t\tvar inHozChan = currentTerm != null && (currentHint.y >= currentTerm.y &&\n\t\t\t\t\t\tcurrentHint.y <= currentTerm.y + currentTerm.height);\n\t\t\t\tvar inVertChan = currentTerm != null && (currentHint.x >= currentTerm.x &&\n\t\t\t\t\t\tcurrentHint.x <= currentTerm.x + currentTerm.width);\n\n\t\t\t\thozChan = fixedHozAlign || (currentPt == null && inHozChan);\n\t\t\t\tvertChan = fixedVertAlign || (currentPt == null && inVertChan);\n\n\t\t\t\t// If the current hint falls in both the hor and vert channels in the case\n\t\t\t\t// of a floating port, or if the hint is exactly co-incident with a\n\t\t\t\t// fixed point, ignore the source and try to work out the orientation\n\t\t\t\t// from the target end\n\t\t\t\tif (i==0 && ((hozChan && vertChan) || (fixedVertAlign && fixedHozAlign)))\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (currentPt != null && (!fixedHozAlign && !fixedVertAlign) && (inHozChan || inVertChan))\n\t\t\t\t\t{\n\t\t\t\t\t\thorizontal = inHozChan ? false : true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (vertChan || hozChan)\n\t\t\t\t\t{\n\t\t\t\t\t\thorizontal = hozChan;\n\n\t\t\t\t\t\tif (i == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Work back from target end\n\t\t\t\t\t\t\thorizontal = hints.length % 2 == 0 ? hozChan : vertChan;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcurrentTerm = target;\n\t\t\t\tcurrentPt = pts[lastInx];\n\n\t\t\t\tif (currentPt != null)\n\t\t\t\t{\n\t\t\t\t\tcurrentPt.x = Math.round(currentPt.x);\n\t\t\t\t\tcurrentPt.y = Math.round(currentPt.y);\n\t\t\t\t\tcurrentTerm = null;\n\t\t\t\t}\n\n\t\t\t\tcurrentHint = hints[hints.length - 1];\n\n\t\t\t\tif (fixedVertAlign && fixedHozAlign)\n\t\t\t\t{\n\t\t\t\t\thints = hints.slice(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (horizontal && ((pts[0] != null && pts[0].y != hint.y) ||\n\t\t\t\t(pts[0] == null && source != null &&\n\t\t\t\t(hint.y < source.y || hint.y > source.y + source.height))))\n\t\t\t{\n\t\t\t\tpushPoint(new mxPoint(pt.x, hint.y));\n\t\t\t}\n\t\t\telse if (!horizontal && ((pts[0] != null && pts[0].x != hint.x) ||\n\t\t\t\t\t(pts[0] == null && source != null &&\n\t\t\t\t\t(hint.x < source.x || hint.x > source.x + source.width))))\n\t\t\t{\n\t\t\t\tpushPoint(new mxPoint(hint.x, pt.y));\n\t\t\t}\n\n\t\t\tif (horizontal)\n\t\t\t{\n\t\t\t\tpt.y = hint.y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpt.x = hint.x;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < hints.length; i++)\n\t\t\t{\n\t\t\t\thorizontal = !horizontal;\n\t\t\t\thint = hints[i];\n\n//\t\t\t\tmxLog.show();\n//\t\t\t\tmxLog.debug('hint', i, hint.x, hint.y);\n\n\t\t\t\tif (horizontal)\n\t\t\t\t{\n\t\t\t\t\tpt.y = hint.y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpt.x = hint.x;\n\t\t\t\t}\n\n\t\t\t\tpushPoint(pt.clone());\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\thint = pt;\n\t\t\t// FIXME: First click in connect preview toggles orientation\n\t\t\thorizontal = true;\n\t\t}\n\n\t\t// Adds the last point\n\t\tpt = pts[lastInx];\n\n\t\tif (pt == null && target != null)\n\t\t{\n\t\t\tpt = new mxPoint(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));\n\t\t}\n\n\t\tif (pt != null)\n\t\t{\n\t\t\tpt.x = Math.round(pt.x);\n\t\t\tpt.y = Math.round(pt.y);\n\n\t\t\tif (hint != null)\n\t\t\t{\n\t\t\t\tif (horizontal && ((pts[lastInx] != null && pts[lastInx].y != hint.y) ||\n\t\t\t\t\t(pts[lastInx] == null && target != null &&\n\t\t\t\t\t(hint.y < target.y || hint.y > target.y + target.height))))\n\t\t\t\t{\n\t\t\t\t\tpushPoint(new mxPoint(pt.x, hint.y));\n\t\t\t\t}\n\t\t\t\telse if (!horizontal && ((pts[lastInx] != null && pts[lastInx].x != hint.x) ||\n\t\t\t\t\t\t(pts[lastInx] == null && target != null &&\n\t\t\t\t\t\t(hint.x < target.x || hint.x > target.x + target.width))))\n\t\t\t\t{\n\t\t\t\t\tpushPoint(new mxPoint(hint.x, pt.y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Removes bends inside the source terminal for floating ports\n\t\tif (pts[0] == null && source != null)\n\t\t{\n\t\t\twhile (result.length > 1 && result[1] != null &&\n\t\t\t\tmxUtils.contains(source, result[1].x, result[1].y))\n\t\t\t{\n\t\t\t\tresult.splice(1, 1);\n\t\t\t}\n\t\t}\n\n\t\t// Removes bends inside the target terminal\n\t\tif (pts[lastInx] == null && target != null)\n\t\t{\n\t\t\twhile (result.length > 1 && result[result.length - 1] != null &&\n\t\t\t\tmxUtils.contains(target, result[result.length - 1].x, result[result.length - 1].y))\n\t\t\t{\n\t\t\t\tresult.splice(result.length - 1, 1);\n\t\t\t}\n\t\t}\n\n\t\t// Removes last point if inside tolerance with end point\n\t\tif (pe != null && result[result.length - 1] != null &&\n\t\t\tMath.abs(pe.x - result[result.length - 1].x) < tol &&\n\t\t\tMath.abs(pe.y - result[result.length - 1].y) < tol)\n\t\t{\n\t\t\tresult.splice(result.length - 1, 1);\n\n\t\t\t// Lines up second last point in result with end point\n\t\t\tif (result[result.length - 1] != null)\n\t\t\t{\n\t\t\t\tif (Math.abs(result[result.length - 1].x - pe.x) < tol)\n\t\t\t\t{\n\t\t\t\t\tresult[result.length - 1].x = pe.x;\n\t\t\t\t}\n\n\t\t\t\tif (Math.abs(result[result.length - 1].y - pe.y) < tol)\n\t\t\t\t{\n\t\t\t\t\tresult[result.length - 1].y = pe.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\torthBuffer: 10,\n\n\torthPointsFallback: true,\n\n\tdirVectors: [ [ -1, 0 ],\n\t\t\t[ 0, -1 ], [ 1, 0 ], [ 0, 1 ], [ -1, 0 ], [ 0, -1 ], [ 1, 0 ] ],\n\n\twayPoints1: [ [ 0, 0], [ 0, 0],  [ 0, 0], [ 0, 0], [ 0, 0],  [ 0, 0],\n\t              [ 0, 0],  [ 0, 0], [ 0, 0],  [ 0, 0], [ 0, 0],  [ 0, 0] ],\n\n\troutePatterns: [\n\t\t[ [ 513, 2308, 2081, 2562 ], [ 513, 1090, 514, 2184, 2114, 2561 ],\n\t\t\t[ 513, 1090, 514, 2564, 2184, 2562 ],\n\t\t\t[ 513, 2308, 2561, 1090, 514, 2568, 2308 ] ],\n\t[ [ 514, 1057, 513, 2308, 2081, 2562 ], [ 514, 2184, 2114, 2561 ],\n\t\t\t[ 514, 2184, 2562, 1057, 513, 2564, 2184 ],\n\t\t\t[ 514, 1057, 513, 2568, 2308, 2561 ] ],\n\t[ [ 1090, 514, 1057, 513, 2308, 2081, 2562 ], [ 2114, 2561 ],\n\t\t\t[ 1090, 2562, 1057, 513, 2564, 2184 ],\n\t\t\t[ 1090, 514, 1057, 513, 2308, 2561, 2568 ] ],\n\t[ [ 2081, 2562 ], [ 1057, 513, 1090, 514, 2184, 2114, 2561 ],\n\t\t\t[ 1057, 513, 1090, 514, 2184, 2562, 2564 ],\n\t\t\t[ 1057, 2561, 1090, 514, 2568, 2308 ] ] ],\n\n\tinlineRoutePatterns: [\n\t\t\t[ null, [ 2114, 2568 ], null, null ],\n\t\t\t[ null, [ 514, 2081, 2114, 2568 ] , null, null ],\n\t\t\t[ null, [ 2114, 2561 ], null, null ],\n\t\t\t[ [ 2081, 2562 ], [ 1057, 2114, 2568 ],\n\t\t\t\t\t[ 2184, 2562 ],\n\t\t\t\t\tnull ] ],\n\tvertexSeperations: [],\n\n\tlimits: [\n\t       [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ],\n\t       [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ],\n\n\tLEFT_MASK: 32,\n\n\tTOP_MASK: 64,\n\n\tRIGHT_MASK: 128,\n\n\tBOTTOM_MASK: 256,\n\n\tLEFT: 1,\n\n\tTOP: 2,\n\n\tRIGHT: 4,\n\n\tBOTTOM: 8,\n\n\t// TODO remove magic numbers\n\tSIDE_MASK: 480,\n\t//mxEdgeStyle.LEFT_MASK | mxEdgeStyle.TOP_MASK | mxEdgeStyle.RIGHT_MASK\n\t//| mxEdgeStyle.BOTTOM_MASK,\n\n\tCENTER_MASK: 512,\n\n\tSOURCE_MASK: 1024,\n\n\tTARGET_MASK: 2048,\n\n\tVERTEX_MASK: 3072,\n\t// mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,\n\n\tgetJettySize: function(state, source, target, points, isSource)\n\t{\n\t\tvar value = mxUtils.getValue(state.style, (isSource) ? mxConstants.STYLE_SOURCE_JETTY_SIZE :\n\t\t\tmxConstants.STYLE_TARGET_JETTY_SIZE, mxUtils.getValue(state.style,\n\t\t\t\t\tmxConstants.STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer));\n\n\t\tif (value == 'auto')\n\t\t{\n\t\t\t// Computes the automatic jetty size\n\t\t\tvar type = mxUtils.getValue(state.style, (isSource) ? mxConstants.STYLE_STARTARROW : mxConstants.STYLE_ENDARROW, mxConstants.NONE);\n\n\t\t\tif (type != mxConstants.NONE)\n\t\t\t{\n\t\t\t\tvar size = mxUtils.getNumber(state.style, (isSource) ? mxConstants.STYLE_STARTSIZE : mxConstants.STYLE_ENDSIZE, mxConstants.DEFAULT_MARKERSIZE);\n\t\t\t\tvalue = Math.max(2, Math.ceil((size + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalue = 2 * mxEdgeStyle.orthBuffer;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\n\t/**\n\t * Function: OrthConnector\n\t *\n\t * Implements a local orthogonal router between the given\n\t * cells.\n\t *\n\t * Parameters:\n\t *\n\t * state - <mxCellState> that represents the edge to be updated.\n\t * source - <mxCellState> that represents the source terminal.\n\t * target - <mxCellState> that represents the target terminal.\n\t * points - List of relative control points.\n\t * result - Array of <mxPoints> that represent the actual points of the\n\t * edge.\n\t *\n\t */\n\tOrthConnector: function(state, source, target, points, result)\n\t{\n\t\tvar graph = state.view.graph;\n\t\tvar sourceEdge = source == null ? false : graph.getModel().isEdge(source.cell);\n\t\tvar targetEdge = target == null ? false : graph.getModel().isEdge(target.cell);\n\n\t\tvar pts = state.absolutePoints;\n\t\tvar p0 = pts[0];\n\t\tvar pe = pts[pts.length-1];\n\n\t\tvar sourceX = source != null ? source.x : p0.x;\n\t\tvar sourceY = source != null ? source.y : p0.y;\n\t\tvar sourceWidth = source != null ? source.width : 0;\n\t\tvar sourceHeight = source != null ? source.height : 0;\n\n\t\tvar targetX = target != null ? target.x : pe.x;\n\t\tvar targetY = target != null ? target.y : pe.y;\n\t\tvar targetWidth = target != null ? target.width : 0;\n\t\tvar targetHeight = target != null ? target.height : 0;\n\n\t\tvar scaledSourceBuffer = state.view.scale * mxEdgeStyle.getJettySize(state, source, target, points, true);\n\t\tvar scaledTargetBuffer = state.view.scale * mxEdgeStyle.getJettySize(state, source, target, points, false);\n\n\t\t// Workaround for loop routing within buffer zone\n\t\tif (source != null && target == source)\n\t\t{\n\t\t\tscaledTargetBuffer = Math.max(scaledSourceBuffer, scaledTargetBuffer);\n\t\t\tscaledSourceBuffer = scaledTargetBuffer;\n\t\t}\n\n\t\tvar totalBuffer = scaledTargetBuffer + scaledSourceBuffer;\n\t\tvar tooShort = false;\n\n\t\t// Checks minimum distance for fixed points and falls back to segment connector\n\t\tif (p0 != null && pe != null)\n\t\t{\n\t\t\tvar dx = pe.x - p0.x;\n\t\t\tvar dy = pe.y - p0.y;\n\n\t\t\ttooShort = dx * dx + dy * dy < totalBuffer * totalBuffer;\n\t\t}\n\n\t\tif (tooShort || (mxEdgeStyle.orthPointsFallback && (points != null &&\n\t\t\tpoints.length > 0)) || sourceEdge || targetEdge)\n\t\t{\n\t\t\tmxEdgeStyle.SegmentConnector(state, source, target, points, result);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine the side(s) of the source and target vertices\n\t\t// that the edge may connect to\n\t\t// portConstraint [source, target]\n\t\tvar portConstraint = [mxConstants.DIRECTION_MASK_ALL, mxConstants.DIRECTION_MASK_ALL];\n\t\tvar rotation = 0;\n\n\t\tif (source != null)\n\t\t{\n\t\t\tportConstraint[0] = mxUtils.getPortConstraints(source, state, true,\n\t\t\t\t\tmxConstants.DIRECTION_MASK_ALL);\n\t\t\trotation = mxUtils.getValue(source.style, mxConstants.STYLE_ROTATION, 0);\n\n\t\t\tif (rotation != 0)\n\t\t\t{\n\t\t\t\tvar newRect = mxUtils.getBoundingBox(new mxRectangle(sourceX, sourceY, sourceWidth, sourceHeight), rotation);\n\t\t\t\tsourceX = newRect.x;\n\t\t\t\tsourceY = newRect.y;\n\t\t\t\tsourceWidth = newRect.width;\n\t\t\t\tsourceHeight = newRect.height;\n\t\t\t}\n\t\t}\n\n\t\tif (target != null)\n\t\t{\n\t\t\tportConstraint[1] = mxUtils.getPortConstraints(target, state, false,\n\t\t\t\tmxConstants.DIRECTION_MASK_ALL);\n\t\t\trotation = mxUtils.getValue(target.style, mxConstants.STYLE_ROTATION, 0);\n\n\t\t\tif (rotation != 0)\n\t\t\t{\n\t\t\t\tvar newRect = mxUtils.getBoundingBox(new mxRectangle(targetX, targetY, targetWidth, targetHeight), rotation);\n\t\t\t\ttargetX = newRect.x;\n\t\t\t\ttargetY = newRect.y;\n\t\t\t\ttargetWidth = newRect.width;\n\t\t\t\ttargetHeight = newRect.height;\n\t\t\t}\n\t\t}\n\n\t\t// Avoids floating point number errors\n\t\tsourceX = Math.round(sourceX * 10) / 10;\n\t\tsourceY = Math.round(sourceY * 10) / 10;\n\t\tsourceWidth = Math.round(sourceWidth * 10) / 10;\n\t\tsourceHeight = Math.round(sourceHeight * 10) / 10;\n\n\t\ttargetX = Math.round(targetX * 10) / 10;\n\t\ttargetY = Math.round(targetY * 10) / 10;\n\t\ttargetWidth = Math.round(targetWidth * 10) / 10;\n\t\ttargetHeight = Math.round(targetHeight * 10) / 10;\n\n\t\tvar dir = [0, 0];\n\n\t\t// Work out which faces of the vertices present against each other\n\t\t// in a way that would allow a 3-segment connection if port constraints\n\t\t// permitted.\n\t\t// geo -> [source, target] [x, y, width, height]\n\t\tvar geo = [ [sourceX, sourceY, sourceWidth, sourceHeight] ,\n\t\t            [targetX, targetY, targetWidth, targetHeight] ];\n\t\tvar buffer = [scaledSourceBuffer, scaledTargetBuffer];\n\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tmxEdgeStyle.limits[i][1] = geo[i][0] - buffer[i];\n\t\t\tmxEdgeStyle.limits[i][2] = geo[i][1] - buffer[i];\n\t\t\tmxEdgeStyle.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];\n\t\t\tmxEdgeStyle.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];\n\t\t}\n\n\t\t// Work out which quad the target is in\n\t\tvar sourceCenX = geo[0][0] + geo[0][2] / 2.0;\n\t\tvar sourceCenY = geo[0][1] + geo[0][3] / 2.0;\n\t\tvar targetCenX = geo[1][0] + geo[1][2] / 2.0;\n\t\tvar targetCenY = geo[1][1] + geo[1][3] / 2.0;\n\n\t\tvar dx = sourceCenX - targetCenX;\n\t\tvar dy = sourceCenY - targetCenY;\n\n\t\tvar quad = 0;\n\n\t\tif (dx < 0)\n\t\t{\n\t\t\tif (dy < 0)\n\t\t\t{\n\t\t\t\tquad = 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tquad = 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (dy <= 0)\n\t\t\t{\n\t\t\t\tquad = 3;\n\n\t\t\t\t// Special case on x = 0 and negative y\n\t\t\t\tif (dx == 0)\n\t\t\t\t{\n\t\t\t\t\tquad = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check for connection constraints\n\t\tvar currentTerm = null;\n\n\t\tif (source != null)\n\t\t{\n\t\t\tcurrentTerm = p0;\n\t\t}\n\n\t\tvar constraint = [ [0.5, 0.5] , [0.5, 0.5] ];\n\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (currentTerm != null)\n\t\t\t{\n\t\t\t\tconstraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];\n\n\t\t\t\tif (Math.abs(currentTerm.x - geo[i][0]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_WEST;\n\t\t\t\t}\n\t\t\t\telse if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_EAST;\n\t\t\t\t}\n\n\t\t\t\tconstraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];\n\n\t\t\t\tif (Math.abs(currentTerm.y - geo[i][1]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_NORTH;\n\t\t\t\t}\n\t\t\t\telse if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1)\n\t\t\t\t{\n\t\t\t\t\tdir[i] = mxConstants.DIRECTION_MASK_SOUTH;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentTerm = null;\n\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tcurrentTerm = pe;\n\t\t\t}\n\t\t}\n\n\t\tvar sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);\n\t\tvar sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);\n\t\tvar sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);\n\t\tvar sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);\n\n\t\tmxEdgeStyle.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);\n\t\tmxEdgeStyle.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);\n\t\tmxEdgeStyle.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);\n\t\tmxEdgeStyle.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);\n\n\t\t//==============================================================\n\t\t// Start of source and target direction determination\n\n\t\t// Work through the preferred orientations by relative positioning\n\t\t// of the vertices and list them in preferred and available order\n\n\t\tvar dirPref = [];\n\t\tvar horPref = [];\n\t\tvar vertPref = [];\n\n\t\thorPref[0] = (sourceLeftDist >= sourceRightDist) ? mxConstants.DIRECTION_MASK_WEST\n\t\t\t\t: mxConstants.DIRECTION_MASK_EAST;\n\t\tvertPref[0] = (sourceTopDist >= sourceBottomDist) ? mxConstants.DIRECTION_MASK_NORTH\n\t\t\t\t: mxConstants.DIRECTION_MASK_SOUTH;\n\n\t\thorPref[1] = mxUtils.reversePortConstraints(horPref[0]);\n\t\tvertPref[1] = mxUtils.reversePortConstraints(vertPref[0]);\n\n\t\tvar preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist\n\t\t\t\t: sourceRightDist;\n\t\tvar preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist\n\t\t\t\t: sourceBottomDist;\n\n\t\tvar prefOrdering = [ [0, 0] , [0, 0] ];\n\t\tvar preferredOrderSet = false;\n\n\t\t// If the preferred port isn't available, switch it\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (dir[i] != 0x0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((horPref[i] & portConstraint[i]) == 0)\n\t\t\t{\n\t\t\t\thorPref[i] = mxUtils.reversePortConstraints(horPref[i]);\n\t\t\t}\n\n\t\t\tif ((vertPref[i] & portConstraint[i]) == 0)\n\t\t\t{\n\t\t\t\tvertPref[i] = mxUtils\n\t\t\t\t\t\t.reversePortConstraints(vertPref[i]);\n\t\t\t}\n\n\t\t\tprefOrdering[i][0] = vertPref[i];\n\t\t\tprefOrdering[i][1] = horPref[i];\n\t\t}\n\n\t\tif (preferredVertDist > 0\n\t\t\t\t&& preferredHorizDist > 0)\n\t\t{\n\t\t\t// Possibility of two segment edge connection\n\t\t\tif (((horPref[0] & portConstraint[0]) > 0)\n\t\t\t\t\t&& ((vertPref[1] & portConstraint[1]) > 0))\n\t\t\t{\n\t\t\t\tprefOrdering[0][0] = horPref[0];\n\t\t\t\tprefOrdering[0][1] = vertPref[0];\n\t\t\t\tprefOrdering[1][0] = vertPref[1];\n\t\t\t\tprefOrdering[1][1] = horPref[1];\n\t\t\t\tpreferredOrderSet = true;\n\t\t\t}\n\t\t\telse if (((vertPref[0] & portConstraint[0]) > 0)\n\t\t\t\t\t&& ((horPref[1] & portConstraint[1]) > 0))\n\t\t\t{\n\t\t\t\tprefOrdering[0][0] = vertPref[0];\n\t\t\t\tprefOrdering[0][1] = horPref[0];\n\t\t\t\tprefOrdering[1][0] = horPref[1];\n\t\t\t\tprefOrdering[1][1] = vertPref[1];\n\t\t\t\tpreferredOrderSet = true;\n\t\t\t}\n\t\t}\n\n\t\tif (preferredVertDist > 0 && !preferredOrderSet)\n\t\t{\n\t\t\tprefOrdering[0][0] = vertPref[0];\n\t\t\tprefOrdering[0][1] = horPref[0];\n\t\t\tprefOrdering[1][0] = vertPref[1];\n\t\t\tprefOrdering[1][1] = horPref[1];\n\t\t\tpreferredOrderSet = true;\n\n\t\t}\n\n\t\tif (preferredHorizDist > 0 && !preferredOrderSet)\n\t\t{\n\t\t\tprefOrdering[0][0] = horPref[0];\n\t\t\tprefOrdering[0][1] = vertPref[0];\n\t\t\tprefOrdering[1][0] = horPref[1];\n\t\t\tprefOrdering[1][1] = vertPref[1];\n\t\t\tpreferredOrderSet = true;\n\t\t}\n\n\t\t// The source and target prefs are now an ordered list of\n\t\t// the preferred port selections\n\t\t// It the list can contain gaps, compact it\n\n\t\tfor (var i = 0; i < 2; i++)\n\t\t{\n\t\t\tif (dir[i] != 0x0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((prefOrdering[i][0] & portConstraint[i]) == 0)\n\t\t\t{\n\t\t\t\tprefOrdering[i][0] = prefOrdering[i][1];\n\t\t\t}\n\n\t\t\tdirPref[i] = prefOrdering[i][0] & portConstraint[i];\n\t\t\tdirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;\n\t\t\tdirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;\n\t\t\tdirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;\n\n\t\t\tif ((dirPref[i] & 0xF) == 0)\n\t\t\t{\n\t\t\t\tdirPref[i] = dirPref[i] << 8;\n\t\t\t}\n\n\t\t\tif ((dirPref[i] & 0xF00) == 0)\n\t\t\t{\n\t\t\t\tdirPref[i] = (dirPref[i] & 0xF) | dirPref[i] >> 8;\n\t\t\t}\n\n\t\t\tif ((dirPref[i] & 0xF0000) == 0)\n\t\t\t{\n\t\t\t\tdirPref[i] = (dirPref[i] & 0xFFFF)\n\t\t\t\t\t\t| ((dirPref[i] & 0xF000000) >> 8);\n\t\t\t}\n\n\t\t\tdir[i] = dirPref[i] & 0xF;\n\n\t\t\tif (portConstraint[i] == mxConstants.DIRECTION_MASK_WEST\n\t\t\t\t\t|| portConstraint[i] == mxConstants.DIRECTION_MASK_NORTH\n\t\t\t\t\t|| portConstraint[i] == mxConstants.DIRECTION_MASK_EAST\n\t\t\t\t\t|| portConstraint[i] == mxConstants.DIRECTION_MASK_SOUTH)\n\t\t\t{\n\t\t\t\tdir[i] = portConstraint[i];\n\t\t\t}\n\t\t}\n\n\t\t//==============================================================\n\t\t// End of source and target direction determination\n\n\t\tvar sourceIndex = dir[0] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[0];\n\t\tvar targetIndex = dir[1] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[1];\n\n\t\tsourceIndex -= quad;\n\t\ttargetIndex -= quad;\n\n\t\tif (sourceIndex < 1)\n\t\t{\n\t\t\tsourceIndex += 4;\n\t\t}\n\n\t\tif (targetIndex < 1)\n\t\t{\n\t\t\ttargetIndex += 4;\n\t\t}\n\n\t\tvar routePattern = mxEdgeStyle.routePatterns[sourceIndex - 1][targetIndex - 1];\n\n\t\tmxEdgeStyle.wayPoints1[0][0] = geo[0][0];\n\t\tmxEdgeStyle.wayPoints1[0][1] = geo[0][1];\n\n\t\tswitch (dir[0])\n\t\t{\n\t\t\tcase mxConstants.DIRECTION_MASK_WEST:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] -= scaledSourceBuffer;\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n\t\t\t\tbreak;\n\t\t\tcase mxConstants.DIRECTION_MASK_SOUTH:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] += geo[0][3] + scaledSourceBuffer;\n\t\t\t\tbreak;\n\t\t\tcase mxConstants.DIRECTION_MASK_EAST:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] += geo[0][2] + scaledSourceBuffer;\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n\t\t\t\tbreak;\n\t\t\tcase mxConstants.DIRECTION_MASK_NORTH:\n\t\t\t\tmxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n\t\t\t\tmxEdgeStyle.wayPoints1[0][1] -= scaledSourceBuffer;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tvar currentIndex = 0;\n\n\t\t// Orientation, 0 horizontal, 1 vertical\n\t\tvar lastOrientation = (dir[0] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) > 0 ? 0\n\t\t\t\t: 1;\n\t\tvar initialOrientation = lastOrientation;\n\t\tvar currentOrientation = 0;\n\n\t\tfor (var i = 0; i < routePattern.length; i++)\n\t\t{\n\t\t\tvar nextDirection = routePattern[i] & 0xF;\n\n\t\t\t// Rotate the index of this direction by the quad\n\t\t\t// to get the real direction\n\t\t\tvar directionIndex = nextDirection == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t\t: nextDirection;\n\n\t\t\tdirectionIndex += quad;\n\n\t\t\tif (directionIndex > 4)\n\t\t\t{\n\t\t\t\tdirectionIndex -= 4;\n\t\t\t}\n\n\t\t\tvar direction = mxEdgeStyle.dirVectors[directionIndex - 1];\n\n\t\t\tcurrentOrientation = (directionIndex % 2 > 0) ? 0 : 1;\n\t\t\t// Only update the current index if the point moved\n\t\t\t// in the direction of the current segment move,\n\t\t\t// otherwise the same point is moved until there is\n\t\t\t// a segment direction change\n\t\t\tif (currentOrientation != lastOrientation)\n\t\t\t{\n\t\t\t\tcurrentIndex++;\n\t\t\t\t// Copy the previous way point into the new one\n\t\t\t\t// We can't base the new position on index - 1\n\t\t\t\t// because sometime elbows turn out not to exist,\n\t\t\t\t// then we'd have to rewind.\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][0] = mxEdgeStyle.wayPoints1[currentIndex - 1][0];\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][1] = mxEdgeStyle.wayPoints1[currentIndex - 1][1];\n\t\t\t}\n\n\t\t\tvar tar = (routePattern[i] & mxEdgeStyle.TARGET_MASK) > 0;\n\t\t\tvar sou = (routePattern[i] & mxEdgeStyle.SOURCE_MASK) > 0;\n\t\t\tvar side = (routePattern[i] & mxEdgeStyle.SIDE_MASK) >> 5;\n\t\t\tside = side << quad;\n\n\t\t\tif (side > 0xF)\n\t\t\t{\n\t\t\t\tside = side >> 4;\n\t\t\t}\n\n\t\t\tvar center = (routePattern[i] & mxEdgeStyle.CENTER_MASK) > 0;\n\n\t\t\tif ((sou || tar) && side < 9)\n\t\t\t{\n\t\t\t\tvar limit = 0;\n\t\t\t\tvar souTar = sou ? 0 : 1;\n\n\t\t\t\tif (center && currentOrientation == 0)\n\t\t\t\t{\n\t\t\t\t\tlimit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];\n\t\t\t\t}\n\t\t\t\telse if (center)\n\t\t\t\t{\n\t\t\t\t\tlimit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlimit = mxEdgeStyle.limits[souTar][side];\n\t\t\t\t}\n\n\t\t\t\tif (currentOrientation == 0)\n\t\t\t\t{\n\t\t\t\t\tvar lastX = mxEdgeStyle.wayPoints1[currentIndex][0];\n\t\t\t\t\tvar deltaX = (limit - lastX) * direction[0];\n\n\t\t\t\t\tif (deltaX > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][0] += direction[0]\n\t\t\t\t\t\t\t\t* deltaX;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar lastY = mxEdgeStyle.wayPoints1[currentIndex][1];\n\t\t\t\t\tvar deltaY = (limit - lastY) * direction[1];\n\n\t\t\t\t\tif (deltaY > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][1] += direction[1]\n\t\t\t\t\t\t\t\t* deltaY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (center)\n\t\t\t{\n\t\t\t\t// Which center we're travelling to depend on the current direction\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][0] += direction[0]\n\t\t\t\t\t\t* Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);\n\t\t\t\tmxEdgeStyle.wayPoints1[currentIndex][1] += direction[1]\n\t\t\t\t\t\t* Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);\n\t\t\t}\n\n\t\t\tif (currentIndex > 0\n\t\t\t\t\t&& mxEdgeStyle.wayPoints1[currentIndex][currentOrientation] == mxEdgeStyle.wayPoints1[currentIndex - 1][currentOrientation])\n\t\t\t{\n\t\t\t\tcurrentIndex--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlastOrientation = currentOrientation;\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i <= currentIndex; i++)\n\t\t{\n\t\t\tif (i == currentIndex)\n\t\t\t{\n\t\t\t\t// Last point can cause last segment to be in\n\t\t\t\t// same direction as jetty/approach. If so,\n\t\t\t\t// check the number of points is consistent\n\t\t\t\t// with the relative orientation of source and target\n\t\t\t\t// jx. Same orientation requires an even\n\t\t\t\t// number of turns (points), different requires\n\t\t\t\t// odd.\n\t\t\t\tvar targetOrientation = (dir[1] & (mxConstants.DIRECTION_MASK_EAST | mxConstants.DIRECTION_MASK_WEST)) > 0 ? 0\n\t\t\t\t\t\t: 1;\n\t\t\t\tvar sameOrient = targetOrientation == initialOrientation ? 0 : 1;\n\n\t\t\t\t// (currentIndex + 1) % 2 is 0 for even number of points,\n\t\t\t\t// 1 for odd\n\t\t\t\tif (sameOrient != (currentIndex + 1) % 2)\n\t\t\t\t{\n\t\t\t\t\t// The last point isn't required\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult.push(new mxPoint(Math.round(mxEdgeStyle.wayPoints1[i][0]), Math.round(mxEdgeStyle.wayPoints1[i][1])));\n\t\t}\n\n\t\t// Removes duplicates\n\t\tvar index = 1;\n\n\t\twhile (index < result.length)\n\t\t{\n\t\t\tif (result[index - 1] == null || result[index] == null ||\n\t\t\t\tresult[index - 1].x != result[index].x ||\n\t\t\t\tresult[index - 1].y != result[index].y)\n\t\t\t{\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.splice(index, 1);\n\t\t\t}\n\t\t}\n\t},\n\n\tgetRoutePattern: function(dir, quad, dx, dy)\n\t{\n\t\tvar sourceIndex = dir[0] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[0];\n\t\tvar targetIndex = dir[1] == mxConstants.DIRECTION_MASK_EAST ? 3\n\t\t\t\t: dir[1];\n\n\t\tsourceIndex -= quad;\n\t\ttargetIndex -= quad;\n\n\t\tif (sourceIndex < 1)\n\t\t{\n\t\t\tsourceIndex += 4;\n\t\t}\n\t\tif (targetIndex < 1)\n\t\t{\n\t\t\ttargetIndex += 4;\n\t\t}\n\n\t\tvar result = routePatterns[sourceIndex - 1][targetIndex - 1];\n\n\t\tif (dx == 0 || dy == 0)\n\t\t{\n\t\t\tif (inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null)\n\t\t\t{\n\t\t\t\tresult = inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\n__mxOutput.mxEdgeStyle = typeof mxEdgeStyle !== 'undefined' ? mxEdgeStyle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxStyleRegistry =\n{\n\t/**\n\t * Class: mxStyleRegistry\n\t *\n\t * Singleton class that acts as a global converter from string to object values\n\t * in a style. This is currently only used to perimeters and edge styles.\n\t *\n\t * Variable: values\n\t *\n\t * Maps from strings to objects.\n\t */\n\tvalues: [],\n\n\t/**\n\t * Function: putValue\n\t *\n\t * Puts the given object into the registry under the given name.\n\t */\n\tputValue: function(name, obj)\n\t{\n\t\tmxStyleRegistry.values[name] = obj;\n\t},\n\n\t/**\n\t * Function: getValue\n\t *\n\t * Returns the value associated with the given name.\n\t */\n\tgetValue: function(name)\n\t{\n\t\treturn mxStyleRegistry.values[name];\n\t},\n\n\t/**\n\t * Function: getName\n\t *\n\t * Returns the name for the given value.\n\t */\n\tgetName: function(value)\n\t{\n\t\tfor (var key in mxStyleRegistry.values)\n\t\t{\n\t\t\tif (mxStyleRegistry.values[key] == value)\n\t\t\t{\n\t\t\t\treturn key;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n};\n\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_ELBOW, mxEdgeStyle.ElbowConnector);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_ENTITY_RELATION, mxEdgeStyle.EntityRelation);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_LOOP, mxEdgeStyle.Loop);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_SIDETOSIDE, mxEdgeStyle.SideToSide);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_TOPTOBOTTOM, mxEdgeStyle.TopToBottom);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_ORTHOGONAL, mxEdgeStyle.OrthConnector);\nmxStyleRegistry.putValue(mxConstants.EDGESTYLE_SEGMENT, mxEdgeStyle.SegmentConnector);\n\nmxStyleRegistry.putValue(mxConstants.PERIMETER_ELLIPSE, mxPerimeter.EllipsePerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_RECTANGLE, mxPerimeter.RectanglePerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_RHOMBUS, mxPerimeter.RhombusPerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_TRIANGLE, mxPerimeter.TrianglePerimeter);\nmxStyleRegistry.putValue(mxConstants.PERIMETER_HEXAGON, mxPerimeter.HexagonPerimeter);\n\n__mxOutput.mxStyleRegistry = typeof mxStyleRegistry !== 'undefined' ? mxStyleRegistry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphView\n *\n * Extends <mxEventSource> to implement a view for a graph. This class is in\n * charge of computing the absolute coordinates for the relative child\n * geometries, the points for perimeters and edge styles and keeping them\n * cached in <mxCellStates> for faster retrieval. The states are updated\n * whenever the model or the view state (translate, scale) changes. The scale\n * and translate are honoured in the bounds.\n *\n * Event: mxEvent.UNDO\n *\n * Fires after the root was changed in <setCurrentRoot>. The <code>edit</code>\n * property contains the <mxUndoableEdit> which contains the\n * <mxCurrentRootChange>.\n *\n * Event: mxEvent.SCALE_AND_TRANSLATE\n *\n * Fires after the scale and translate have been changed in <scaleAndTranslate>.\n * The <code>scale</code>, <code>previousScale</code>, <code>translate</code>\n * and <code>previousTranslate</code> properties contain the new and previous\n * scale and translate, respectively.\n *\n * Event: mxEvent.SCALE\n *\n * Fires after the scale was changed in <setScale>. The <code>scale</code> and\n * <code>previousScale</code> properties contain the new and previous scale.\n *\n * Event: mxEvent.TRANSLATE\n *\n * Fires after the translate was changed in <setTranslate>. The\n * <code>translate</code> and <code>previousTranslate</code> properties contain\n * the new and previous value for translate.\n *\n * Event: mxEvent.DOWN and mxEvent.UP\n *\n * Fire if the current root is changed by executing an <mxCurrentRootChange>.\n * The event name depends on the location of the root in the cell hierarchy\n * with respect to the current root. The <code>root</code> and\n * <code>previous</code> properties contain the new and previous root,\n * respectively.\n *\n * Constructor: mxGraphView\n *\n * Constructs a new view for the given <mxGraph>.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxGraphView(graph)\n{\n\tthis.graph = graph;\n\tthis.translate = new mxPoint();\n\tthis.graphBounds = new mxRectangle();\n\tthis.states = new mxDictionary();\n};\n\n/**\n * Extends mxEventSource.\n */\nmxGraphView.prototype = new mxEventSource();\nmxGraphView.prototype.constructor = mxGraphView;\n\n/**\n *\n */\nmxGraphView.prototype.EMPTY_POINT = new mxPoint();\n\n/**\n * Variable: doneResource\n *\n * Specifies the resource key for the status message after a long operation.\n * If the resource for this key does not exist then the value is used as\n * the status message. Default is 'done'.\n */\nmxGraphView.prototype.doneResource = (mxClient.language != 'none') ? 'done' : '';\n\n/**\n * Function: updatingDocumentResource\n *\n * Specifies the resource key for the status message while the document is\n * being updated. If the resource for this key does not exist then the\n * value is used as the status message. Default is 'updatingDocument'.\n */\nmxGraphView.prototype.updatingDocumentResource = (mxClient.language != 'none') ? 'updatingDocument' : '';\n\n/**\n * Variable: allowEval\n *\n * Specifies if string values in cell styles should be evaluated using\n * <mxUtils.eval>. This will only be used if the string values can't be mapped\n * to objects using <mxStyleRegistry>. Default is false. NOTE: Enabling this\n * switch carries a possible security risk.\n */\nmxGraphView.prototype.allowEval = false;\n\n/**\n * Variable: captureDocumentGesture\n *\n * Specifies if a gesture should be captured when it goes outside of the\n * graph container. Default is true.\n */\nmxGraphView.prototype.captureDocumentGesture = true;\n\n/**\n * Variable: optimizeVmlReflows\n *\n * Specifies if the <canvas> should be hidden while rendering in IE8 standards\n * mode and quirks mode. This will significantly improve rendering performance.\n * Default is true.\n */\nmxGraphView.prototype.optimizeVmlReflows = true;\n\n/**\n * Variable: rendering\n *\n * Specifies if shapes should be created, updated and destroyed using the\n * methods of <mxCellRenderer> in <graph>. Default is true.\n */\nmxGraphView.prototype.rendering = true;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxGraphView.prototype.graph = null;\n\n/**\n * Variable: currentRoot\n *\n * <mxCell> that acts as the root of the displayed cell hierarchy.\n */\nmxGraphView.prototype.currentRoot = null;\n\n/**\n * Variable: graphBounds\n *\n * <mxRectangle> that caches the scales, translated bounds of the current view.\n */\nmxGraphView.prototype.graphBounds = null;\n\n/**\n * Variable: scale\n *\n * Specifies the scale. Default is 1 (100%).\n */\nmxGraphView.prototype.scale = 1;\n\n/**\n * Variable: translate\n *\n * <mxPoint> that specifies the current translation. Default is a new\n * empty <mxPoint>.\n */\nmxGraphView.prototype.translate = null;\n\n/**\n * Variable: states\n *\n * <mxDictionary> that maps from cell IDs to <mxCellStates>.\n */\nmxGraphView.prototype.states = null;\n\n/**\n * Variable: updateStyle\n *\n * Specifies if the style should be updated in each validation step. If this\n * is false then the style is only updated if the state is created or if the\n * style of the cell was changed. Default is false.\n */\nmxGraphView.prototype.updateStyle = false;\n\n/**\n * Variable: lastNode\n *\n * During validation, this contains the last DOM node that was processed.\n */\nmxGraphView.prototype.lastNode = null;\n\n/**\n * Variable: lastHtmlNode\n *\n * During validation, this contains the last HTML DOM node that was processed.\n */\nmxGraphView.prototype.lastHtmlNode = null;\n\n/**\n * Variable: lastForegroundNode\n *\n * During validation, this contains the last edge's DOM node that was processed.\n */\nmxGraphView.prototype.lastForegroundNode = null;\n\n/**\n * Variable: lastForegroundHtmlNode\n *\n * During validation, this contains the last edge HTML DOM node that was processed.\n */\nmxGraphView.prototype.lastForegroundHtmlNode = null;\n\n/**\n * Function: getGraphBounds\n *\n * Returns <graphBounds>.\n */\nmxGraphView.prototype.getGraphBounds = function()\n{\n\treturn this.graphBounds;\n};\n\n/**\n * Function: setGraphBounds\n *\n * Sets <graphBounds>.\n */\nmxGraphView.prototype.setGraphBounds = function(value)\n{\n\tthis.graphBounds = value;\n};\n\n/**\n * Function: getBounds\n *\n * Returns the union of all <mxCellStates> for the given array of <mxCells>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounds should be returned.\n */\nmxGraphView.prototype.getBounds = function(cells)\n{\n\tvar result = null;\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (model.isVertex(cells[i]) || model.isEdge(cells[i]))\n\t\t\t{\n\t\t\t\tvar state = this.getState(cells[i]);\n\n\t\t\t\tif (state != null)\n\t\t\t\t{\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = mxRectangle.fromRectangle(state);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.add(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: setCurrentRoot\n *\n * Sets and returns the current root and fires an <undo> event before\n * calling <mxGraph.sizeDidChange>.\n *\n * Parameters:\n *\n * root - <mxCell> that specifies the root of the displayed cell hierarchy.\n */\nmxGraphView.prototype.setCurrentRoot = function(root)\n{\n\tif (this.currentRoot != root)\n\t{\n\t\tvar change = new mxCurrentRootChange(this, root);\n\t\tchange.execute();\n\t\tvar edit = new mxUndoableEdit(this, true);\n\t\tedit.add(change);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.UNDO, 'edit', edit));\n\t\tthis.graph.sizeDidChange();\n\t}\n\n\treturn root;\n};\n\n/**\n * Function: scaleAndTranslate\n *\n * Sets the scale and translation and fires a <scale> and <translate> event\n * before calling <revalidate> followed by <mxGraph.sizeDidChange>.\n *\n * Parameters:\n *\n * scale - Decimal value that specifies the new scale (1 is 100%).\n * dx - X-coordinate of the translation.\n * dy - Y-coordinate of the translation.\n */\nmxGraphView.prototype.scaleAndTranslate = function(scale, dx, dy)\n{\n\tvar previousScale = this.scale;\n\tvar previousTranslate = new mxPoint(this.translate.x, this.translate.y);\n\n\tif (this.scale != scale || this.translate.x != dx || this.translate.y != dy)\n\t{\n\t\tthis.scale = scale;\n\n\t\tthis.translate.x = dx;\n\t\tthis.translate.y = dy;\n\n\t\tif (this.isEventsEnabled())\n\t\t{\n\t\t\tthis.viewStateChanged();\n\t\t}\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.SCALE_AND_TRANSLATE,\n\t\t'scale', scale, 'previousScale', previousScale,\n\t\t'translate', this.translate, 'previousTranslate', previousTranslate));\n};\n\n/**\n * Function: getScale\n *\n * Returns the <scale>.\n */\nmxGraphView.prototype.getScale = function()\n{\n\treturn this.scale;\n};\n\n/**\n * Function: setScale\n *\n * Sets the scale and fires a <scale> event before calling <revalidate> followed\n * by <mxGraph.sizeDidChange>.\n *\n * Parameters:\n *\n * value - Decimal value that specifies the new scale (1 is 100%).\n */\nmxGraphView.prototype.setScale = function(value)\n{\n\tvar previousScale = this.scale;\n\n\tif (this.scale != value)\n\t{\n\t\tthis.scale = value;\n\n\t\tif (this.isEventsEnabled())\n\t\t{\n\t\t\tthis.viewStateChanged();\n\t\t}\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.SCALE,\n\t\t'scale', value, 'previousScale', previousScale));\n};\n\n/**\n * Function: getTranslate\n *\n * Returns the <translate>.\n */\nmxGraphView.prototype.getTranslate = function()\n{\n\treturn this.translate;\n};\n\n/**\n * Function: setTranslate\n *\n * Sets the translation and fires a <translate> event before calling\n * <revalidate> followed by <mxGraph.sizeDidChange>. The translation is the\n * negative of the origin.\n *\n * Parameters:\n *\n * dx - X-coordinate of the translation.\n * dy - Y-coordinate of the translation.\n */\nmxGraphView.prototype.setTranslate = function(dx, dy)\n{\n\tvar previousTranslate = new mxPoint(this.translate.x, this.translate.y);\n\n\tif (this.translate.x != dx || this.translate.y != dy)\n\t{\n\t\tthis.translate.x = dx;\n\t\tthis.translate.y = dy;\n\n\t\tif (this.isEventsEnabled())\n\t\t{\n\t\t\tthis.viewStateChanged();\n\t\t}\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.TRANSLATE,\n\t\t'translate', this.translate, 'previousTranslate', previousTranslate));\n};\n\n/**\n * Function: viewStateChanged\n *\n * Invoked after <scale> and/or <translate> has changed.\n */\nmxGraphView.prototype.viewStateChanged = function()\n{\n\tthis.revalidate();\n\tthis.graph.sizeDidChange();\n};\n\n/**\n * Function: refresh\n *\n * Clears the view if <currentRoot> is not null and revalidates.\n */\nmxGraphView.prototype.refresh = function()\n{\n\tif (this.currentRoot != null)\n\t{\n\t\tthis.clear();\n\t}\n\n\tthis.revalidate();\n};\n\n/**\n * Function: revalidate\n *\n * Revalidates the complete view with all cell states.\n */\nmxGraphView.prototype.revalidate = function()\n{\n\tthis.invalidate();\n\tthis.validate();\n};\n\n/**\n * Function: clear\n *\n * Removes the state of the given cell and all descendants if the given\n * cell is not the current root.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> for which the state should be removed. Default\n * is the root of the model.\n * force - Boolean indicating if the current root should be ignored for\n * recursion.\n */\nmxGraphView.prototype.clear = function(cell, force, recurse)\n{\n\tvar model = this.graph.getModel();\n\tcell = cell || model.getRoot();\n\tforce = (force != null) ? force : false;\n\trecurse = (recurse != null) ? recurse : true;\n\n\tthis.removeState(cell);\n\n\tif (recurse && (force || cell != this.currentRoot))\n\t{\n\t\tvar childCount = model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.clear(model.getChildAt(cell, i), force);\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.invalidate(cell);\n\t}\n};\n\n/**\n * Function: invalidate\n *\n * Invalidates the state of the given cell, all its descendants and\n * connected edges.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> to be invalidated. Default is the root of the\n * model.\n */\nmxGraphView.prototype.invalidate = function(cell, recurse, includeEdges)\n{\n\tvar model = this.graph.getModel();\n\tcell = cell || model.getRoot();\n\trecurse = (recurse != null) ? recurse : true;\n\tincludeEdges = (includeEdges != null) ? includeEdges : true;\n\n\tvar state = this.getState(cell);\n\n\tif (state != null)\n\t{\n\t\tstate.invalid = true;\n\t}\n\n\t// Avoids infinite loops for invalid graphs\n\tif (!cell.invalidating)\n\t{\n\t\tcell.invalidating = true;\n\n\t\t// Recursively invalidates all descendants\n\t\tif (recurse)\n\t\t{\n\t\t\tvar childCount = model.getChildCount(cell);\n\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar child = model.getChildAt(cell, i);\n\t\t\t\tthis.invalidate(child, recurse, includeEdges);\n\t\t\t}\n\t\t}\n\n\t\t// Propagates invalidation to all connected edges\n\t\tif (includeEdges)\n\t\t{\n\t\t\tvar edgeCount = model.getEdgeCount(cell);\n\n\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t{\n\t\t\t\tthis.invalidate(model.getEdgeAt(cell, i), recurse, includeEdges);\n\t\t\t}\n\t\t}\n\n\t\tdelete cell.invalidating;\n\t}\n};\n\n/**\n * Function: validate\n *\n * Calls <validateCell> and <validateCellState> and updates the <graphBounds>\n * using <getBoundingBox>. Finally the background is validated using\n * <validateBackground>.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> to be used as the root of the validation.\n * Default is <currentRoot> or the root of the model.\n */\nmxGraphView.prototype.validate = function(cell)\n{\n\tvar t0 = mxLog.enter('mxGraphView.validate');\n\twindow.status = mxResources.get(this.updatingDocumentResource) ||\n\t\tthis.updatingDocumentResource;\n\n\tthis.resetValidationState();\n\n\t// Improves IE rendering speed by minimizing reflows\n\tvar prevDisplay = null;\n\n\tif (this.optimizeVmlReflows && this.canvas != null && this.textDiv == null &&\n\t\t((document.documentMode == 8 && !mxClient.IS_EM) || mxClient.IS_QUIRKS))\n\t{\n\t\t// Placeholder keeps scrollbar positions when canvas is hidden\n\t\tthis.placeholder = document.createElement('div');\n\t\tthis.placeholder.style.position = 'absolute';\n\t\tthis.placeholder.style.width = this.canvas.clientWidth + 'px';\n\t\tthis.placeholder.style.height = this.canvas.clientHeight + 'px';\n\t\tthis.canvas.parentNode.appendChild(this.placeholder);\n\n\t\tprevDisplay = this.drawPane.style.display;\n\t\tthis.canvas.style.display = 'none';\n\n\t\t// Creates temporary DIV used for text measuring in mxText.updateBoundingBox\n\t\tthis.textDiv = document.createElement('div');\n\t\tthis.textDiv.style.position = 'absolute';\n\t\tthis.textDiv.style.whiteSpace = 'nowrap';\n\t\tthis.textDiv.style.visibility = 'hidden';\n\t\tthis.textDiv.style.display = (mxClient.IS_QUIRKS) ? 'inline' : 'inline-block';\n\t\tthis.textDiv.style.zoom = '1';\n\n\t\tdocument.body.appendChild(this.textDiv);\n\t}\n\n\tvar graphBounds = this.getBoundingBox(this.validateCellState(\n\t\tthis.validateCell(cell || ((this.currentRoot != null) ?\n\t\t\tthis.currentRoot : this.graph.getModel().getRoot()))));\n\tthis.setGraphBounds((graphBounds != null) ? graphBounds : this.getEmptyBounds());\n\tthis.validateBackground();\n\n\tif (prevDisplay != null)\n\t{\n\t\tthis.canvas.style.display = prevDisplay;\n\t\tthis.textDiv.parentNode.removeChild(this.textDiv);\n\n\t\tif (this.placeholder != null)\n\t\t{\n\t\t\tthis.placeholder.parentNode.removeChild(this.placeholder);\n\t\t}\n\n\t\t// Textdiv cannot be reused\n\t\tthis.textDiv = null;\n\t}\n\n\tthis.resetValidationState();\n\n\twindow.status = mxResources.get(this.doneResource) ||\n\t\tthis.doneResource;\n\tmxLog.leave('mxGraphView.validate', t0);\n};\n\n/**\n * Function: getEmptyBounds\n *\n * Returns the bounds for an empty graph. This returns a rectangle at\n * <translate> with the size of 0 x 0.\n */\nmxGraphView.prototype.getEmptyBounds = function()\n{\n\treturn new mxRectangle(this.translate.x * this.scale, this.translate.y * this.scale);\n};\n\n/**\n * Function: getBoundingBox\n *\n * Returns the bounding box of the shape and the label for the given\n * <mxCellState> and its children if recurse is true.\n *\n * Parameters:\n *\n * state - <mxCellState> whose bounding box should be returned.\n * recurse - Optional boolean indicating if the children should be included.\n * Default is true.\n */\nmxGraphView.prototype.getBoundingBox = function(state, recurse)\n{\n\trecurse = (recurse != null) ? recurse : true;\n\tvar bbox = null;\n\n\tif (state != null)\n\t{\n\t\tif (state.shape != null && state.shape.boundingBox != null)\n\t\t{\n\t\t\tbbox = state.shape.boundingBox.clone();\n\t\t}\n\n\t\t// Adds label bounding box to graph bounds\n\t\tif (state.text != null && state.text.boundingBox != null)\n\t\t{\n\t\t\tif (bbox != null)\n\t\t\t{\n\t\t\t\tbbox.add(state.text.boundingBox);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbbox = state.text.boundingBox.clone();\n\t\t\t}\n\t\t}\n\n\t\tif (recurse)\n\t\t{\n\t\t\tvar model = this.graph.getModel();\n\t\t\tvar childCount = model.getChildCount(state.cell);\n\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar bounds = this.getBoundingBox(this.getState(model.getChildAt(state.cell, i)));\n\n\t\t\t\tif (bounds != null)\n\t\t\t\t{\n\t\t\t\t\tif (bbox == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbbox = bounds;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbbox.add(bounds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bbox;\n};\n\n/**\n * Function: createBackgroundPageShape\n *\n * Creates and returns the shape used as the background page.\n *\n * Parameters:\n *\n * bounds - <mxRectangle> that represents the bounds of the shape.\n */\nmxGraphView.prototype.createBackgroundPageShape = function(bounds)\n{\n\treturn new mxRectangleShape(bounds, 'white', 'black');\n};\n\n/**\n * Function: validateBackground\n *\n * Calls <validateBackgroundImage> and <validateBackgroundPage>.\n */\nmxGraphView.prototype.validateBackground = function()\n{\n\tthis.validateBackgroundImage();\n\tthis.validateBackgroundPage();\n};\n\n/**\n * Function: validateBackgroundImage\n *\n * Validates the background image.\n */\nmxGraphView.prototype.validateBackgroundImage = function()\n{\n\tvar bg = this.graph.getBackgroundImage();\n\n\tif (bg != null)\n\t{\n\t\tif (this.backgroundImage == null || this.backgroundImage.image != bg.src)\n\t\t{\n\t\t\tif (this.backgroundImage != null)\n\t\t\t{\n\t\t\t\tthis.backgroundImage.destroy();\n\t\t\t}\n\n\t\t\tvar bounds = new mxRectangle(0, 0, 1, 1);\n\n\t\t\tthis.backgroundImage = new mxImageShape(bounds, bg.src);\n\t\t\tthis.backgroundImage.dialect = this.graph.dialect;\n\t\t\tthis.backgroundImage.init(this.backgroundPane);\n\t\t\tthis.backgroundImage.redraw();\n\n\t\t\t// Workaround for ignored event on background in IE8 standards mode\n\t\t\tif (document.documentMode == 8 && !mxClient.IS_EM)\n\t\t\t{\n\t\t\t\tmxEvent.addGestureListeners(this.backgroundImage.node,\n\t\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t\t\t\t\t}),\n\t\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t\t\t\t}),\n\t\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthis.redrawBackgroundImage(this.backgroundImage, bg);\n\t}\n\telse if (this.backgroundImage != null)\n\t{\n\t\tthis.backgroundImage.destroy();\n\t\tthis.backgroundImage = null;\n\t}\n};\n\n/**\n * Function: validateBackgroundPage\n *\n * Validates the background page.\n */\nmxGraphView.prototype.validateBackgroundPage = function()\n{\n\tif (this.graph.pageVisible)\n\t{\n\t\tvar bounds = this.getBackgroundPageBounds();\n\n\t\tif (this.backgroundPageShape == null)\n\t\t{\n\t\t\tthis.backgroundPageShape = this.createBackgroundPageShape(bounds);\n\t\t\tthis.backgroundPageShape.scale = this.scale;\n\t\t\tthis.backgroundPageShape.isShadow = true;\n\t\t\tthis.backgroundPageShape.dialect = this.graph.dialect;\n\t\t\tthis.backgroundPageShape.init(this.backgroundPane);\n\t\t\tthis.backgroundPageShape.redraw();\n\n\t\t\t// Adds listener for double click handling on background\n\t\t\tif (this.graph.nativeDblClickEnabled)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(this.backgroundPageShape.node, 'dblclick', mxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.dblClick(evt);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Adds basic listeners for graph event dispatching outside of the\n\t\t\t// container and finishing the handling of a single gesture\n\t\t\tmxEvent.addGestureListeners(this.backgroundPageShape.node,\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t\t\t\t}),\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\t// Hides the tooltip if mouse is outside container\n\t\t\t\t\tif (this.graph.tooltipHandler != null && this.graph.tooltipHandler.isHideOnHover())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.tooltipHandler.hide();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.graph.isMouseDown && !mxEvent.isConsumed(evt))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.backgroundPageShape.scale = this.scale;\n\t\t\tthis.backgroundPageShape.bounds = bounds;\n\t\t\tthis.backgroundPageShape.redraw();\n\t\t}\n\t}\n\telse if (this.backgroundPageShape != null)\n\t{\n\t\tthis.backgroundPageShape.destroy();\n\t\tthis.backgroundPageShape = null;\n\t}\n};\n\n/**\n * Function: getBackgroundPageBounds\n *\n * Returns the bounds for the background page.\n */\nmxGraphView.prototype.getBackgroundPageBounds = function()\n{\n\tvar fmt = this.graph.pageFormat;\n\tvar ps = this.scale * this.graph.pageScale;\n\tvar bounds = new mxRectangle(this.scale * this.translate.x, this.scale * this.translate.y,\n\t\t\tfmt.width * ps, fmt.height * ps);\n\n\treturn bounds;\n};\n\n/**\n * Function: redrawBackgroundImage\n *\n * Updates the bounds and redraws the background image.\n *\n * Example:\n *\n * If the background image should not be scaled, this can be replaced with\n * the following.\n *\n * (code)\n * mxGraphView.prototype.redrawBackground = function(backgroundImage, bg)\n * {\n *   backgroundImage.bounds.x = this.translate.x;\n *   backgroundImage.bounds.y = this.translate.y;\n *   backgroundImage.bounds.width = bg.width;\n *   backgroundImage.bounds.height = bg.height;\n *\n *   backgroundImage.redraw();\n * };\n * (end)\n *\n * Parameters:\n *\n * backgroundImage - <mxImageShape> that represents the background image.\n * bg - <mxImage> that specifies the image and its dimensions.\n */\nmxGraphView.prototype.redrawBackgroundImage = function(backgroundImage, bg)\n{\n\tbackgroundImage.scale = this.scale;\n\tbackgroundImage.bounds.x = this.scale * this.translate.x;\n\tbackgroundImage.bounds.y = this.scale * this.translate.y;\n\tbackgroundImage.bounds.width = this.scale * bg.width;\n\tbackgroundImage.bounds.height = this.scale * bg.height;\n\n\tbackgroundImage.redraw();\n};\n\n/**\n * Function: validateCell\n *\n * Recursively creates the cell state for the given cell if visible is true and\n * the given cell is visible. If the cell is not visible but the state exists\n * then it is removed using <removeState>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose <mxCellState> should be created.\n * visible - Optional boolean indicating if the cell should be visible. Default\n * is true.\n */\nmxGraphView.prototype.validateCell = function(cell, visible)\n{\n\tvisible = (visible != null) ? visible : true;\n\n\tif (cell != null)\n\t{\n\t\tvisible = visible && this.graph.isCellVisible(cell);\n\t\tvar state = this.getState(cell, visible);\n\n\t\tif (state != null && !visible)\n\t\t{\n\t\t\tthis.removeState(cell);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar model = this.graph.getModel();\n\t\t\tvar childCount = model.getChildCount(cell);\n\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tthis.validateCell(model.getChildAt(cell, i), visible &&\n\t\t\t\t\t(!this.isCellCollapsed(cell) || cell == this.currentRoot));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cell;\n};\n\n/**\n * Function: validateCellState\n *\n * Validates and repaints the <mxCellState> for the given <mxCell>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose <mxCellState> should be validated.\n * recurse - Optional boolean indicating if the children of the cell should be\n * validated. Default is true.\n */\nmxGraphView.prototype.validateCellState = function(cell, recurse)\n{\n\trecurse = (recurse != null) ? recurse : true;\n\tvar state = null;\n\n\tif (cell != null)\n\t{\n\t\tstate = this.getState(cell);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tvar model = this.graph.getModel();\n\n\t\t\tif (state.invalid)\n\t\t\t{\n\t\t\t\tstate.invalid = false;\n\n\t\t\t\tif (state.style == null || state.invalidStyle)\n\t\t\t\t{\n\t\t\t\t\tstate.style = this.graph.getCellStyle(state.cell);\n\t\t\t\t\tstate.invalidStyle = false;\n\t\t\t\t}\n\n\t\t\t\tif (cell != this.currentRoot)\n\t\t\t\t{\n\t\t\t\t\tthis.validateCellState(model.getParent(cell), false);\n\t\t\t\t}\n\n\t\t\t\tstate.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);\n\t\t\t\tstate.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);\n\n\t\t\t\tthis.updateCellState(state);\n\n\t\t\t\t// Repaint happens immediately after the cell is validated\n\t\t\t\tif (cell != this.currentRoot && !state.invalid)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.cellRenderer.redraw(state, false, this.isRendering());\n\n\t\t\t\t\t// Handles changes to invertex paintbounds after update of rendering shape\n\t\t\t\t\tstate.updateCachedBounds();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (recurse && !state.invalid)\n\t\t\t{\n\t\t\t\t// Updates order in DOM if recursively traversing\n\t\t\t\tif (state.shape != null)\n\t\t\t\t{\n\t\t\t\t\tthis.stateValidated(state);\n\t\t\t\t}\n\n\t\t\t\tvar childCount = model.getChildCount(cell);\n\n\t\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.validateCellState(model.getChildAt(cell, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn state;\n};\n\n/**\n * Function: updateCellState\n *\n * Updates the given <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> to be updated.\n */\nmxGraphView.prototype.updateCellState = function(state)\n{\n\tstate.absoluteOffset.x = 0;\n\tstate.absoluteOffset.y = 0;\n\tstate.origin.x = 0;\n\tstate.origin.y = 0;\n\tstate.length = 0;\n\n\tif (state.cell != this.currentRoot)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\tvar pState = this.getState(model.getParent(state.cell));\n\n\t\tif (pState != null && pState.cell != this.currentRoot)\n\t\t{\n\t\t\tstate.origin.x += pState.origin.x;\n\t\t\tstate.origin.y += pState.origin.y;\n\t\t}\n\n\t\tvar offset = this.graph.getChildOffsetForCell(state.cell);\n\n\t\tif (offset != null)\n\t\t{\n\t\t\tstate.origin.x += offset.x;\n\t\t\tstate.origin.y += offset.y;\n\t\t}\n\n\t\tvar geo = this.graph.getCellGeometry(state.cell);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tif (!model.isEdge(state.cell))\n\t\t\t{\n\t\t\t\toffset = geo.offset || this.EMPTY_POINT;\n\n\t\t\t\tif (geo.relative && pState != null)\n\t\t\t\t{\n\t\t\t\t\tif (model.isEdge(pState.cell))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar origin = this.getPoint(pState, geo);\n\n\t\t\t\t\t\tif (origin != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate.origin.x += (origin.x / this.scale) - pState.origin.x - this.translate.x;\n\t\t\t\t\t\t\tstate.origin.y += (origin.y / this.scale) - pState.origin.y - this.translate.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tstate.origin.x += geo.x * pState.width / this.scale + offset.x;\n\t\t\t\t\t\tstate.origin.y += geo.y * pState.height / this.scale + offset.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstate.absoluteOffset.x = this.scale * offset.x;\n\t\t\t\t\tstate.absoluteOffset.y = this.scale * offset.y;\n\t\t\t\t\tstate.origin.x += geo.x;\n\t\t\t\t\tstate.origin.y += geo.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.x = this.scale * (this.translate.x + state.origin.x);\n\t\t\tstate.y = this.scale * (this.translate.y + state.origin.y);\n\t\t\tstate.width = this.scale * geo.width;\n\t\t\tstate.unscaledWidth = geo.width;\n\t\t\tstate.height = this.scale * geo.height;\n\n\t\t\tif (model.isVertex(state.cell))\n\t\t\t{\n\t\t\t\tthis.updateVertexState(state, geo);\n\t\t\t}\n\n\t\t\tif (model.isEdge(state.cell))\n\t\t\t{\n\t\t\t\tthis.updateEdgeState(state, geo);\n\t\t\t}\n\t\t}\n\t}\n\n\tstate.updateCachedBounds();\n};\n\n/**\n * Function: isCellCollapsed\n *\n * Returns true if the children of the given cell should not be visible in the\n * view. This implementation uses <mxGraph.isCellVisible> but it can be\n * overidden to use a separate condition.\n */\nmxGraphView.prototype.isCellCollapsed = function(cell)\n{\n\treturn this.graph.isCellCollapsed(cell);\n};\n\n/**\n * Function: updateVertexState\n *\n * Validates the given cell state.\n */\nmxGraphView.prototype.updateVertexState = function(state, geo)\n{\n\tvar model = this.graph.getModel();\n\tvar pState = this.getState(model.getParent(state.cell));\n\n\tif (geo.relative && pState != null && !model.isEdge(pState.cell))\n\t{\n\t\tvar alpha = mxUtils.toRadians(pState.style[mxConstants.STYLE_ROTATION] || '0');\n\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(alpha);\n\t\t\tvar sin = Math.sin(alpha);\n\n\t\t\tvar ct = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\tvar cx = new mxPoint(pState.getCenterX(), pState.getCenterY());\n\t\t\tvar pt = mxUtils.getRotatedPoint(ct, cos, sin, cx);\n\t\t\tstate.x = pt.x - state.width / 2;\n\t\t\tstate.y = pt.y - state.height / 2;\n\t\t}\n\t}\n\n\tthis.updateVertexLabelOffset(state);\n};\n\n/**\n * Function: updateEdgeState\n *\n * Validates the given cell state.\n */\nmxGraphView.prototype.updateEdgeState = function(state, geo)\n{\n\tvar source = state.getVisibleTerminalState(true);\n\tvar target = state.getVisibleTerminalState(false);\n\n\t// This will remove edges with no terminals and no terminal points\n\t// as such edges are invalid and produce NPEs in the edge styles.\n\t// Also removes connected edges that have no visible terminals.\n\tif ((this.graph.model.getTerminal(state.cell, true) != null && source == null) ||\n\t\t(source == null && geo.getTerminalPoint(true) == null) ||\n\t\t(this.graph.model.getTerminal(state.cell, false) != null && target == null) ||\n\t\t(target == null && geo.getTerminalPoint(false) == null))\n\t{\n\t\tthis.clear(state.cell, true);\n\t}\n\telse\n\t{\n\t\tthis.updateFixedTerminalPoints(state, source, target);\n\t\tthis.updatePoints(state, geo.points, source, target);\n\t\tthis.updateFloatingTerminalPoints(state, source, target);\n\n\t\tvar pts = state.absolutePoints;\n\n\t\tif (state.cell != this.currentRoot && (pts == null || pts.length < 2 ||\n\t\t\tpts[0] == null || pts[pts.length - 1] == null))\n\t\t{\n\t\t\t// This will remove edges with invalid points from the list of states in the view.\n\t\t\t// Happens if the one of the terminals and the corresponding terminal point is null.\n\t\t\tthis.clear(state.cell, true);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.updateEdgeBounds(state);\n\t\t\tthis.updateEdgeLabelOffset(state);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateVertexLabelOffset\n *\n * Updates the absoluteOffset of the given vertex cell state. This takes\n * into account the label position styles.\n *\n * Parameters:\n *\n * state - <mxCellState> whose absolute offset should be updated.\n */\nmxGraphView.prototype.updateVertexLabelOffset = function(state)\n{\n\tvar h = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_POSITION, mxConstants.ALIGN_CENTER);\n\n\tif (h == mxConstants.ALIGN_LEFT)\n\t{\n\t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\n\t\tif (lw != null)\n\t\t{\n\t\t\tlw *= this.scale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlw = state.width;\n\t\t}\n\n\t\tstate.absoluteOffset.x -= lw;\n\t}\n\telse if (h == mxConstants.ALIGN_RIGHT)\n\t{\n\t\tstate.absoluteOffset.x += state.width;\n\t}\n\telse if (h == mxConstants.ALIGN_CENTER)\n\t{\n\t\tvar lw = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_WIDTH, null);\n\n\t\tif (lw != null)\n\t\t{\n\t\t\t// Aligns text block with given width inside the vertex width\n\t\t\tvar align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER);\n\t\t\tvar dx = 0;\n\n\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t{\n\t\t\t\tdx = 0.5;\n\t\t\t}\n\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t{\n\t\t\t\tdx = 1;\n\t\t\t}\n\n\t\t\tif (dx != 0)\n\t\t\t{\n\t\t\t\tstate.absoluteOffset.x -= (lw * this.scale - state.width) * dx;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar v = mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_LABEL_POSITION, mxConstants.ALIGN_MIDDLE);\n\n\tif (v == mxConstants.ALIGN_TOP)\n\t{\n\t\tstate.absoluteOffset.y -= state.height;\n\t}\n\telse if (v == mxConstants.ALIGN_BOTTOM)\n\t{\n\t\tstate.absoluteOffset.y += state.height;\n\t}\n};\n\n/**\n * Function: resetValidationState\n *\n * Resets the current validation state.\n */\nmxGraphView.prototype.resetValidationState = function()\n{\n\tthis.lastNode = null;\n\tthis.lastHtmlNode = null;\n\tthis.lastForegroundNode = null;\n\tthis.lastForegroundHtmlNode = null;\n};\n\n/**\n * Function: stateValidated\n *\n * Invoked when a state has been processed in <validatePoints>. This is used\n * to update the order of the DOM nodes of the shape.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the cell state.\n */\nmxGraphView.prototype.stateValidated = function(state)\n{\n\tvar fg = (this.graph.getModel().isEdge(state.cell) && this.graph.keepEdgesInForeground) ||\n\t\t(this.graph.getModel().isVertex(state.cell) && this.graph.keepEdgesInBackground);\n\tvar htmlNode = (fg) ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;\n\tvar node = (fg) ? this.lastForegroundNode || this.lastNode : this.lastNode;\n\tvar result = this.graph.cellRenderer.insertStateAfter(state, node, htmlNode);\n\n\tif (fg)\n\t{\n\t\tthis.lastForegroundHtmlNode = result[1];\n\t\tthis.lastForegroundNode = result[0];\n\t}\n\telse\n\t{\n\t\tthis.lastHtmlNode = result[1];\n\t\tthis.lastNode = result[0];\n\t}\n};\n\n/**\n * Function: updateFixedTerminalPoints\n *\n * Sets the initial absolute terminal points in the given state before the edge\n * style is computed.\n *\n * Parameters:\n *\n * edge - <mxCellState> whose initial terminal points should be updated.\n * source - <mxCellState> which represents the source terminal.\n * target - <mxCellState> which represents the target terminal.\n */\nmxGraphView.prototype.updateFixedTerminalPoints = function(edge, source, target)\n{\n\tthis.updateFixedTerminalPoint(edge, source, true,\n\t\tthis.graph.getConnectionConstraint(edge, source, true));\n\tthis.updateFixedTerminalPoint(edge, target, false,\n\t\tthis.graph.getConnectionConstraint(edge, target, false));\n};\n\n/**\n * Function: updateFixedTerminalPoint\n *\n * Sets the fixed source or target terminal point on the given edge.\n *\n * Parameters:\n *\n * edge - <mxCellState> whose terminal point should be updated.\n * terminal - <mxCellState> which represents the actual terminal.\n * source - Boolean that specifies if the terminal is the source.\n * constraint - <mxConnectionConstraint> that specifies the connection.\n */\nmxGraphView.prototype.updateFixedTerminalPoint = function(edge, terminal, source, constraint)\n{\n\tedge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);\n};\n\n/**\n * Function: getFixedTerminalPoint\n *\n * Returns the fixed source or target terminal point for the given edge.\n *\n * Parameters:\n *\n * edge - <mxCellState> whose terminal point should be returned.\n * terminal - <mxCellState> which represents the actual terminal.\n * source - Boolean that specifies if the terminal is the source.\n * constraint - <mxConnectionConstraint> that specifies the connection.\n */\nmxGraphView.prototype.getFixedTerminalPoint = function(edge, terminal, source, constraint)\n{\n\tvar pt = null;\n\n\tif (constraint != null)\n\t{\n\t\tpt = this.graph.getConnectionPoint(terminal, constraint);\n\t}\n\n\tif (pt == null && terminal == null)\n\t{\n\t\tvar s = this.scale;\n\t\tvar tr = this.translate;\n\t\tvar orig = edge.origin;\n\t\tvar geo = this.graph.getCellGeometry(edge.cell);\n\t\tpt = geo.getTerminalPoint(source);\n\n\t\tif (pt != null)\n\t\t{\n\t\t\tpt = new mxPoint(s * (tr.x + pt.x + orig.x),\n\t\t\t\t\t\t\t s * (tr.y + pt.y + orig.y));\n\t\t}\n\t}\n\n\treturn pt;\n};\n\n/**\n * Function: updateBoundsFromStencil\n *\n * Updates the bounds of the given cell state to reflect the bounds of the stencil\n * if it has a fixed aspect and returns the previous bounds as an <mxRectangle> if\n * the bounds have been modified or null otherwise.\n *\n * Parameters:\n *\n * edge - <mxCellState> whose bounds should be updated.\n */\nmxGraphView.prototype.updateBoundsFromStencil = function(state)\n{\n\tvar previous = null;\n\n\tif (state != null && state.shape != null && state.shape.stencil != null && state.shape.stencil.aspect == 'fixed')\n\t{\n\t\tprevious = mxRectangle.fromRectangle(state);\n\t\tvar asp = state.shape.stencil.computeAspect(state.style, state.x, state.y, state.width, state.height);\n\t\tstate.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);\n\t}\n\n\treturn previous;\n};\n\n/**\n * Function: updatePoints\n *\n * Updates the absolute points in the given state using the specified array\n * of <mxPoints> as the relative points.\n *\n * Parameters:\n *\n * edge - <mxCellState> whose absolute points should be updated.\n * points - Array of <mxPoints> that constitute the relative points.\n * source - <mxCellState> that represents the source terminal.\n * target - <mxCellState> that represents the target terminal.\n */\nmxGraphView.prototype.updatePoints = function(edge, points, source, target)\n{\n\tif (edge != null)\n\t{\n\t\tvar pts = [];\n\t\tpts.push(edge.absolutePoints[0]);\n\t\tvar edgeStyle = this.getEdgeStyle(edge, points, source, target);\n\n\t\tif (edgeStyle != null)\n\t\t{\n\t\t\tvar src = this.getTerminalPort(edge, source, true);\n\t\t\tvar trg = this.getTerminalPort(edge, target, false);\n\n\t\t\t// Uses the stencil bounds for routing and restores after routing\n\t\t\tvar srcBounds = this.updateBoundsFromStencil(src);\n\t\t\tvar trgBounds = this.updateBoundsFromStencil(trg);\n\n\t\t\tedgeStyle(edge, src, trg, points, pts);\n\n\t\t\t// Restores previous bounds\n\t\t\tif (srcBounds != null)\n\t\t\t{\n\t\t\t\tsrc.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);\n\t\t\t}\n\n\t\t\tif (trgBounds != null)\n\t\t\t{\n\t\t\t\ttrg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);\n\t\t\t}\n\t\t}\n\t\telse if (points != null)\n\t\t{\n\t\t\tfor (var i = 0; i < points.length; i++)\n\t\t\t{\n\t\t\t\tif (points[i] != null)\n\t\t\t\t{\n\t\t\t\t\tvar pt = mxUtils.clone(points[i]);\n\t\t\t\t\tpts.push(this.transformControlPoint(edge, pt));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar tmp = edge.absolutePoints;\n\t\tpts.push(tmp[tmp.length-1]);\n\n\t\tedge.absolutePoints = pts;\n\t}\n};\n\n/**\n * Function: transformControlPoint\n *\n * Transforms the given control point to an absolute point.\n */\nmxGraphView.prototype.transformControlPoint = function(state, pt)\n{\n\tif (state != null && pt != null)\n\t{\n\t\tvar orig = state.origin;\n\n\t    return new mxPoint(this.scale * (pt.x + this.translate.x + orig.x),\n\t    \tthis.scale * (pt.y + this.translate.y + orig.y));\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: isLoopStyleEnabled\n *\n * Returns true if the given edge should be routed with <mxGraph.defaultLoopStyle>\n * or the <mxConstants.STYLE_LOOP> defined for the given edge. This implementation\n * returns true if the given edge is a loop and does not have connections constraints\n * associated.\n */\nmxGraphView.prototype.isLoopStyleEnabled = function(edge, points, source, target)\n{\n\tvar sc = this.graph.getConnectionConstraint(edge, source, true);\n\tvar tc = this.graph.getConnectionConstraint(edge, target, false);\n\n\tif ((points == null || points.length < 2) &&\n\t\t(!mxUtils.getValue(edge.style, mxConstants.STYLE_ORTHOGONAL_LOOP, false) ||\n\t\t((sc == null || sc.point == null) && (tc == null || tc.point == null))))\n\t{\n\t\treturn source != null && source == target;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getEdgeStyle\n *\n * Returns the edge style function to be used to render the given edge state.\n */\nmxGraphView.prototype.getEdgeStyle = function(edge, points, source, target)\n{\n\tvar edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ?\n\t\tmxUtils.getValue(edge.style, mxConstants.STYLE_LOOP, this.graph.defaultLoopStyle) :\n\t\t(!mxUtils.getValue(edge.style, mxConstants.STYLE_NOEDGESTYLE, false) ?\n\t\tedge.style[mxConstants.STYLE_EDGE] : null);\n\n\t// Converts string values to objects\n\tif (typeof(edgeStyle) == \"string\")\n\t{\n\t\tvar tmp = mxStyleRegistry.getValue(edgeStyle);\n\n\t\tif (tmp == null && this.isAllowEval())\n\t\t{\n \t\t\ttmp = mxUtils.eval(edgeStyle);\n\t\t}\n\n\t\tedgeStyle = tmp;\n\t}\n\n\tif (typeof(edgeStyle) == \"function\")\n\t{\n\t\treturn edgeStyle;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: updateFloatingTerminalPoints\n *\n * Updates the terminal points in the given state after the edge style was\n * computed for the edge.\n *\n * Parameters:\n *\n * state - <mxCellState> whose terminal points should be updated.\n * source - <mxCellState> that represents the source terminal.\n * target - <mxCellState> that represents the target terminal.\n */\nmxGraphView.prototype.updateFloatingTerminalPoints = function(state, source, target)\n{\n\tvar pts = state.absolutePoints;\n\tvar p0 = pts[0];\n\tvar pe = pts[pts.length - 1];\n\n\tif (pe == null && target != null)\n\t{\n\t\tthis.updateFloatingTerminalPoint(state, target, source, false);\n\t}\n\n\tif (p0 == null && source != null)\n\t{\n\t\tthis.updateFloatingTerminalPoint(state, source, target, true);\n\t}\n};\n\n/**\n * Function: updateFloatingTerminalPoint\n *\n * Updates the absolute terminal point in the given state for the given\n * start and end state, where start is the source if source is true.\n *\n * Parameters:\n *\n * edge - <mxCellState> whose terminal point should be updated.\n * start - <mxCellState> for the terminal on \"this\" side of the edge.\n * end - <mxCellState> for the terminal on the other side of the edge.\n * source - Boolean indicating if start is the source terminal state.\n */\nmxGraphView.prototype.updateFloatingTerminalPoint = function(edge, start, end, source)\n{\n\tedge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);\n};\n\n/**\n * Function: getFloatingTerminalPoint\n *\n * Returns the floating terminal point for the given edge, start and end\n * state, where start is the source if source is true.\n *\n * Parameters:\n *\n * edge - <mxCellState> whose terminal point should be returned.\n * start - <mxCellState> for the terminal on \"this\" side of the edge.\n * end - <mxCellState> for the terminal on the other side of the edge.\n * source - Boolean indicating if start is the source terminal state.\n */\nmxGraphView.prototype.getFloatingTerminalPoint = function(edge, start, end, source)\n{\n\tstart = this.getTerminalPort(edge, start, source);\n\tvar next = this.getNextPoint(edge, end, source);\n\n\tvar orth = this.graph.isOrthogonal(edge);\n\tvar alpha = mxUtils.toRadians(Number(start.style[mxConstants.STYLE_ROTATION] || '0'));\n\tvar center = new mxPoint(start.getCenterX(), start.getCenterY());\n\n\tif (alpha != 0)\n\t{\n\t\tvar cos = Math.cos(-alpha);\n\t\tvar sin = Math.sin(-alpha);\n\t\tnext = mxUtils.getRotatedPoint(next, cos, sin, center);\n\t}\n\n\tvar border = parseFloat(edge.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);\n\tborder += parseFloat(edge.style[(source) ?\n\t\tmxConstants.STYLE_SOURCE_PERIMETER_SPACING :\n\t\tmxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0);\n\tvar pt = this.getPerimeterPoint(start, next, alpha == 0 && orth, border);\n\n\tif (alpha != 0)\n\t{\n\t\tvar cos = Math.cos(alpha);\n\t\tvar sin = Math.sin(alpha);\n\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, center);\n\t}\n\n\treturn pt;\n};\n\n/**\n * Function: getTerminalPort\n *\n * Returns an <mxCellState> that represents the source or target terminal or\n * port for the given edge.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the state of the edge.\n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean indicating if the given terminal is the source terminal.\n */\nmxGraphView.prototype.getTerminalPort = function(state, terminal, source)\n{\n\tvar key = (source) ? mxConstants.STYLE_SOURCE_PORT :\n\t\tmxConstants.STYLE_TARGET_PORT;\n\tvar id = mxUtils.getValue(state.style, key);\n\n\tif (id != null)\n\t{\n\t\tvar tmp = this.getState(this.graph.getModel().getCell(id));\n\n\t\t// Only uses ports where a cell state exists\n\t\tif (tmp != null)\n\t\t{\n\t\t\tterminal = tmp;\n\t\t}\n\t}\n\n\treturn terminal;\n};\n\n/**\n * Function: getPerimeterPoint\n *\n * Returns an <mxPoint> that defines the location of the intersection point between\n * the perimeter and the line between the center of the shape and the given point.\n *\n * Parameters:\n *\n * terminal - <mxCellState> for the source or target terminal.\n * next - <mxPoint> that lies outside of the given terminal.\n * orthogonal - Boolean that specifies if the orthogonal projection onto\n * the perimeter should be returned. If this is false then the intersection\n * of the perimeter and the line between the next and the center point is\n * returned.\n * border - Optional border between the perimeter and the shape.\n */\nmxGraphView.prototype.getPerimeterPoint = function(terminal, next, orthogonal, border)\n{\n\tvar point = null;\n\n\tif (terminal != null)\n\t{\n\t\tvar perimeter = this.getPerimeterFunction(terminal);\n\n\t\tif (perimeter != null && next != null)\n\t\t{\n\t\t\tvar bounds = this.getPerimeterBounds(terminal, border);\n\n\t\t\tif (bounds.width > 0 || bounds.height > 0)\n\t\t\t{\n\t\t\t\tpoint = new mxPoint(next.x, next.y);\n\t\t\t\tvar flipH = false;\n\t\t\t\tvar flipV = false;\n\n\t\t\t\tif (this.graph.model.isVertex(terminal.cell))\n\t\t\t\t{\n\t\t\t\t\tflipH = mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\t\t\t\tflipV = mxUtils.getValue(terminal.style, mxConstants.STYLE_FLIPV, 0) == 1;\n\n\t\t\t\t\t// Legacy support for stencilFlipH/V\n\t\t\t\t\tif (terminal.shape != null && terminal.shape.stencil != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tflipH = (mxUtils.getValue(terminal.style, 'stencilFlipH', 0) == 1) || flipH;\n\t\t\t\t\t\tflipV = (mxUtils.getValue(terminal.style, 'stencilFlipV', 0) == 1) || flipV;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flipH)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.x = 2 * bounds.getCenterX() - point.x;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.y = 2 * bounds.getCenterY() - point.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpoint = perimeter(bounds, terminal, point, orthogonal);\n\n\t\t\t\tif (point != null)\n\t\t\t\t{\n\t\t\t\t\tif (flipH)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.x = 2 * bounds.getCenterX() - point.x;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flipV)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.y = 2 * bounds.getCenterY() - point.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (point == null)\n\t\t{\n\t\t\tpoint = this.getPoint(terminal);\n\t\t}\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: getRoutingCenterX\n *\n * Returns the x-coordinate of the center point for automatic routing.\n */\nmxGraphView.prototype.getRoutingCenterX = function (state)\n{\n\tvar f = (state.style != null) ? parseFloat(state.style\n\t\t[mxConstants.STYLE_ROUTING_CENTER_X]) || 0 : 0;\n\n\treturn state.getCenterX() + f * state.width;\n};\n\n/**\n * Function: getRoutingCenterY\n *\n * Returns the y-coordinate of the center point for automatic routing.\n */\nmxGraphView.prototype.getRoutingCenterY = function (state)\n{\n\tvar f = (state.style != null) ? parseFloat(state.style\n\t\t[mxConstants.STYLE_ROUTING_CENTER_Y]) || 0 : 0;\n\n\treturn state.getCenterY() + f * state.height;\n};\n\n/**\n * Function: getPerimeterBounds\n *\n * Returns the perimeter bounds for the given terminal, edge pair as an\n * <mxRectangle>.\n *\n * If you have a model where each terminal has a relative child that should\n * act as the graphical endpoint for a connection from/to the terminal, then\n * this method can be replaced as follows:\n *\n * (code)\n * var oldGetPerimeterBounds = mxGraphView.prototype.getPerimeterBounds;\n * mxGraphView.prototype.getPerimeterBounds = function(terminal, edge, isSource)\n * {\n *   var model = this.graph.getModel();\n *   var childCount = model.getChildCount(terminal.cell);\n *\n *   if (childCount > 0)\n *   {\n *     var child = model.getChildAt(terminal.cell, 0);\n *     var geo = model.getGeometry(child);\n *\n *     if (geo != null &&\n *         geo.relative)\n *     {\n *       var state = this.getState(child);\n *\n *       if (state != null)\n *       {\n *         terminal = state;\n *       }\n *     }\n *   }\n *\n *   return oldGetPerimeterBounds.apply(this, arguments);\n * };\n * (end)\n *\n * Parameters:\n *\n * terminal - <mxCellState> that represents the terminal.\n * border - Number that adds a border between the shape and the perimeter.\n */\nmxGraphView.prototype.getPerimeterBounds = function(terminal, border)\n{\n\tborder = (border != null) ? border : 0;\n\n\tif (terminal != null)\n\t{\n\t\tborder += parseFloat(terminal.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);\n\t}\n\n\treturn terminal.getPerimeterBounds(border * this.scale);\n};\n\n/**\n * Function: getPerimeterFunction\n *\n * Returns the perimeter function for the given state.\n */\nmxGraphView.prototype.getPerimeterFunction = function(state)\n{\n\tvar perimeter = state.style[mxConstants.STYLE_PERIMETER];\n\n\t// Converts string values to objects\n\tif (typeof(perimeter) == \"string\")\n\t{\n\t\tvar tmp = mxStyleRegistry.getValue(perimeter);\n\n\t\tif (tmp == null && this.isAllowEval())\n\t\t{\n \t\t\ttmp = mxUtils.eval(perimeter);\n\t\t}\n\n\t\tperimeter = tmp;\n\t}\n\n\tif (typeof(perimeter) == \"function\")\n\t{\n\t\treturn perimeter;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getNextPoint\n *\n * Returns the nearest point in the list of absolute points or the center\n * of the opposite terminal.\n *\n * Parameters:\n *\n * edge - <mxCellState> that represents the edge.\n * opposite - <mxCellState> that represents the opposite terminal.\n * source - Boolean indicating if the next point for the source or target\n * should be returned.\n */\nmxGraphView.prototype.getNextPoint = function(edge, opposite, source)\n{\n\tvar pts = edge.absolutePoints;\n\tvar point = null;\n\n\tif (pts != null && pts.length >= 2)\n\t{\n\t\tvar count = pts.length;\n\t\tpoint = pts[(source) ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n\t}\n\n\tif (point == null && opposite != null)\n\t{\n\t\tpoint = new mxPoint(opposite.getCenterX(), opposite.getCenterY());\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: getVisibleTerminal\n *\n * Returns the nearest ancestor terminal that is visible. The edge appears\n * to be connected to this terminal on the display. The result of this method\n * is cached in <mxCellState.getVisibleTerminalState>.\n *\n * Parameters:\n *\n * edge - <mxCell> whose visible terminal should be returned.\n * source - Boolean that specifies if the source or target terminal\n * should be returned.\n */\nmxGraphView.prototype.getVisibleTerminal = function(edge, source)\n{\n\tvar model = this.graph.getModel();\n\tvar result = model.getTerminal(edge, source);\n\tvar best = result;\n\n\twhile (result != null && result != this.currentRoot)\n\t{\n\t\tif (!this.graph.isCellVisible(best) || this.isCellCollapsed(result))\n\t\t{\n\t\t\tbest = result;\n\t\t}\n\n\t\tresult = model.getParent(result);\n\t}\n\n\t// Checks if the result is valid for the current view state\n\tif (best != null && (!model.contains(best) ||\n\t\tmodel.getParent(best) == model.getRoot() ||\n\t\tbest == this.currentRoot))\n\t{\n\t\tbest = null;\n\t}\n\n\treturn best;\n};\n\n/**\n * Function: updateEdgeBounds\n *\n * Updates the given state using the bounding box of t\n * he absolute points.\n * Also updates <mxCellState.terminalDistance>, <mxCellState.length> and\n * <mxCellState.segments>.\n *\n * Parameters:\n *\n * state - <mxCellState> whose bounds should be updated.\n */\nmxGraphView.prototype.updateEdgeBounds = function(state)\n{\n\tvar points = state.absolutePoints;\n\tvar p0 = points[0];\n\tvar pe = points[points.length - 1];\n\n\tif (p0.x != pe.x || p0.y != pe.y)\n\t{\n\t\tvar dx = pe.x - p0.x;\n\t\tvar dy = pe.y - p0.y;\n\t\tstate.terminalDistance = Math.sqrt(dx * dx + dy * dy);\n\t}\n\telse\n\t{\n\t\tstate.terminalDistance = 0;\n\t}\n\n\tvar length = 0;\n\tvar segments = [];\n\tvar pt = p0;\n\n\tif (pt != null)\n\t{\n\t\tvar minX = pt.x;\n\t\tvar minY = pt.y;\n\t\tvar maxX = minX;\n\t\tvar maxY = minY;\n\n\t\tfor (var i = 1; i < points.length; i++)\n\t\t{\n\t\t\tvar tmp = points[i];\n\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tvar dx = pt.x - tmp.x;\n\t\t\t\tvar dy = pt.y - tmp.y;\n\n\t\t\t\tvar segment = Math.sqrt(dx * dx + dy * dy);\n\t\t\t\tsegments.push(segment);\n\t\t\t\tlength += segment;\n\n\t\t\t\tpt = tmp;\n\n\t\t\t\tminX = Math.min(pt.x, minX);\n\t\t\t\tminY = Math.min(pt.y, minY);\n\t\t\t\tmaxX = Math.max(pt.x, maxX);\n\t\t\t\tmaxY = Math.max(pt.y, maxY);\n\t\t\t}\n\t\t}\n\n\t\tstate.length = length;\n\t\tstate.segments = segments;\n\n\t\tvar markerSize = 1; // TODO: include marker size\n\n\t\tstate.x = minX;\n\t\tstate.y = minY;\n\t\tstate.width = Math.max(markerSize, maxX - minX);\n\t\tstate.height = Math.max(markerSize, maxY - minY);\n\t}\n};\n\n/**\n * Function: getPoint\n *\n * Returns the absolute point on the edge for the given relative\n * <mxGeometry> as an <mxPoint>. The edge is represented by the given\n * <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the state of the parent edge.\n * geometry - <mxGeometry> that represents the relative location.\n */\nmxGraphView.prototype.getPoint = function(state, geometry)\n{\n\tvar x = state.getCenterX();\n\tvar y = state.getCenterY();\n\n\tif (state.segments != null && (geometry == null || geometry.relative))\n\t{\n\t\tvar gx = (geometry != null) ? geometry.x / 2 : 0;\n\t\tvar pointCount = state.absolutePoints.length;\n\t\tvar dist = Math.round((gx + 0.5) * state.length);\n\t\tvar segment = state.segments[0];\n\t\tvar length = 0;\n\t\tvar index = 1;\n\n\t\twhile (dist >= Math.round(length + segment) && index < pointCount - 1)\n\t\t{\n\t\t\tlength += segment;\n\t\t\tsegment = state.segments[index++];\n\t\t}\n\n\t\tvar factor = (segment == 0) ? 0 : (dist - length) / segment;\n\t\tvar p0 = state.absolutePoints[index-1];\n\t\tvar pe = state.absolutePoints[index];\n\n\t\tif (p0 != null && pe != null)\n\t\t{\n\t\t\tvar gy = 0;\n\t\t\tvar offsetX = 0;\n\t\t\tvar offsetY = 0;\n\n\t\t\tif (geometry != null)\n\t\t\t{\n\t\t\t\tgy = geometry.y;\n\t\t\t\tvar offset = geometry.offset;\n\n\t\t\t\tif (offset != null)\n\t\t\t\t{\n\t\t\t\t\toffsetX = offset.x;\n\t\t\t\t\toffsetY = offset.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dx = pe.x - p0.x;\n\t\t\tvar dy = pe.y - p0.y;\n\t\t\tvar nx = (segment == 0) ? 0 : dy / segment;\n\t\t\tvar ny = (segment == 0) ? 0 : dx / segment;\n\n\t\t\tx = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;\n\t\t\ty = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;\n\t\t}\n\t}\n\telse if (geometry != null)\n\t{\n\t\tvar offset = geometry.offset;\n\n\t\tif (offset != null)\n\t\t{\n\t\t\tx += offset.x;\n\t\t\ty += offset.y;\n\t\t}\n\t}\n\n\treturn new mxPoint(x, y);\n};\n\n/**\n * Function: getRelativePoint\n *\n * Gets the relative point that describes the given, absolute label\n * position for the given edge state.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the state of the parent edge.\n * x - Specifies the x-coordinate of the absolute label location.\n * y - Specifies the y-coordinate of the absolute label location.\n */\nmxGraphView.prototype.getRelativePoint = function(edgeState, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar geometry = model.getGeometry(edgeState.cell);\n\n\tif (geometry != null)\n\t{\n\t\tvar pointCount = edgeState.absolutePoints.length;\n\n\t\tif (geometry.relative && pointCount > 1)\n\t\t{\n\t\t\tvar totalLength = edgeState.length;\n\t\t\tvar segments = edgeState.segments;\n\n\t\t\t// Works which line segment the point of the label is closest to\n\t\t\tvar p0 = edgeState.absolutePoints[0];\n\t\t\tvar pe = edgeState.absolutePoints[1];\n\t\t\tvar minDist = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n\n\t\t\tvar index = 0;\n\t\t\tvar tmp = 0;\n\t\t\tvar length = 0;\n\n\t\t\tfor (var i = 2; i < pointCount; i++)\n\t\t\t{\n\t\t\t\ttmp += segments[i - 2];\n\t\t\t\tpe = edgeState.absolutePoints[i];\n\t\t\t\tvar dist = mxUtils.ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n\n\t\t\t\tif (dist <= minDist)\n\t\t\t\t{\n\t\t\t\t\tminDist = dist;\n\t\t\t\t\tindex = i - 1;\n\t\t\t\t\tlength = tmp;\n\t\t\t\t}\n\n\t\t\t\tp0 = pe;\n\t\t\t}\n\n\t\t\tvar seg = segments[index];\n\t\t\tp0 = edgeState.absolutePoints[index];\n\t\t\tpe = edgeState.absolutePoints[index + 1];\n\n\t\t\tvar x2 = p0.x;\n\t\t\tvar y2 = p0.y;\n\n\t\t\tvar x1 = pe.x;\n\t\t\tvar y1 = pe.y;\n\n\t\t\tvar px = x;\n\t\t\tvar py = y;\n\n\t\t\tvar xSegment = x2 - x1;\n\t\t\tvar ySegment = y2 - y1;\n\n\t\t\tpx -= x1;\n\t\t\tpy -= y1;\n\t\t\tvar projlenSq = 0;\n\n\t\t\tpx = xSegment - px;\n\t\t\tpy = ySegment - py;\n\t\t\tvar dotprod = px * xSegment + py * ySegment;\n\n\t\t\tif (dotprod <= 0.0)\n\t\t\t{\n\t\t\t\tprojlenSq = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprojlenSq = dotprod * dotprod\n\t\t\t\t\t\t/ (xSegment * xSegment + ySegment * ySegment);\n\t\t\t}\n\n\t\t\tvar projlen = Math.sqrt(projlenSq);\n\n\t\t\tif (projlen > seg)\n\t\t\t{\n\t\t\t\tprojlen = seg;\n\t\t\t}\n\n\t\t\tvar yDistance = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, pe\n\t\t\t\t\t.x, pe.y, x, y));\n\t\t\tvar direction = mxUtils.relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);\n\n\t\t\tif (direction == -1)\n\t\t\t{\n\t\t\t\tyDistance = -yDistance;\n\t\t\t}\n\n\t\t\t// Constructs the relative point for the label\n\t\t\treturn new mxPoint(((totalLength / 2 - length - projlen) / totalLength) * -2,\n\t\t\t\t\t\tyDistance / this.scale);\n\t\t}\n\t}\n\n\treturn new mxPoint();\n};\n\n/**\n * Function: updateEdgeLabelOffset\n *\n * Updates <mxCellState.absoluteOffset> for the given state. The absolute\n * offset is normally used for the position of the edge label. Is is\n * calculated from the geometry as an absolute offset from the center\n * between the two endpoints if the geometry is absolute, or as the\n * relative distance between the center along the line and the absolute\n * orthogonal distance if the geometry is relative.\n *\n * Parameters:\n *\n * state - <mxCellState> whose absolute offset should be updated.\n */\nmxGraphView.prototype.updateEdgeLabelOffset = function(state)\n{\n\tvar points = state.absolutePoints;\n\n\tstate.absoluteOffset.x = state.getCenterX();\n\tstate.absoluteOffset.y = state.getCenterY();\n\n\tif (points != null && points.length > 0 && state.segments != null)\n\t{\n\t\tvar geometry = this.graph.getCellGeometry(state.cell);\n\n\t\tif (geometry.relative)\n\t\t{\n\t\t\tvar offset = this.getPoint(state, geometry);\n\n\t\t\tif (offset != null)\n\t\t\t{\n\t\t\t\tstate.absoluteOffset = offset;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar p0 = points[0];\n\t\t\tvar pe = points[points.length - 1];\n\n\t\t\tif (p0 != null && pe != null)\n\t\t\t{\n\t\t\t\tvar dx = pe.x - p0.x;\n\t\t\t\tvar dy = pe.y - p0.y;\n\t\t\t\tvar x0 = 0;\n\t\t\t\tvar y0 = 0;\n\n\t\t\t\tvar off = geometry.offset;\n\n\t\t\t\tif (off != null)\n\t\t\t\t{\n\t\t\t\t\tx0 = off.x;\n\t\t\t\t\ty0 = off.y;\n\t\t\t\t}\n\n\t\t\t\tvar x = p0.x + dx / 2 + x0 * this.scale;\n\t\t\t\tvar y = p0.y + dy / 2 + y0 * this.scale;\n\n\t\t\t\tstate.absoluteOffset.x = x;\n\t\t\t\tstate.absoluteOffset.y = y;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getState\n *\n * Returns the <mxCellState> for the given cell. If create is true, then\n * the state is created if it does not yet exist.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the <mxCellState> should be returned.\n * create - Optional boolean indicating if a new state should be created\n * if it does not yet exist. Default is false.\n */\nmxGraphView.prototype.getState = function(cell, create)\n{\n\tcreate = create || false;\n\tvar state = null;\n\n\tif (cell != null)\n\t{\n\t\tstate = this.states.get(cell);\n\n\t\tif (create && (state == null || this.updateStyle) && this.graph.isCellVisible(cell))\n\t\t{\n\t\t\tif (state == null)\n\t\t\t{\n\t\t\t\tstate = this.createState(cell);\n\t\t\t\tthis.states.put(cell, state);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstate.style = this.graph.getCellStyle(cell);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn state;\n};\n\n/**\n * Function: isRendering\n *\n * Returns <rendering>.\n */\nmxGraphView.prototype.isRendering = function()\n{\n\treturn this.rendering;\n};\n\n/**\n * Function: setRendering\n *\n * Sets <rendering>.\n */\nmxGraphView.prototype.setRendering = function(value)\n{\n\tthis.rendering = value;\n};\n\n/**\n * Function: isAllowEval\n *\n * Returns <allowEval>.\n */\nmxGraphView.prototype.isAllowEval = function()\n{\n\treturn this.allowEval;\n};\n\n/**\n * Function: setAllowEval\n *\n * Sets <allowEval>.\n */\nmxGraphView.prototype.setAllowEval = function(value)\n{\n\tthis.allowEval = value;\n};\n\n/**\n * Function: getStates\n *\n * Returns <states>.\n */\nmxGraphView.prototype.getStates = function()\n{\n\treturn this.states;\n};\n\n/**\n * Function: setStates\n *\n * Sets <states>.\n */\nmxGraphView.prototype.setStates = function(value)\n{\n\tthis.states = value;\n};\n\n/**\n * Function: getCellStates\n *\n * Returns the <mxCellStates> for the given array of <mxCells>. The array\n * contains all states that are not null, that is, the returned array may\n * have less elements than the given array. If no argument is given, then\n * this returns <states>.\n */\nmxGraphView.prototype.getCellStates = function(cells)\n{\n\tif (cells == null)\n\t{\n\t\treturn this.states;\n\t}\n\telse\n\t{\n\t\tvar result = [];\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar state = this.getState(cells[i]);\n\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\tresult.push(state);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\n/**\n * Function: removeState\n *\n * Removes and returns the <mxCellState> for the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the <mxCellState> should be removed.\n */\nmxGraphView.prototype.removeState = function(cell)\n{\n\tvar state = null;\n\n\tif (cell != null)\n\t{\n\t\tstate = this.states.remove(cell);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.graph.cellRenderer.destroy(state);\n\t\t\tstate.invalid = true;\n\t\t\tstate.destroy();\n\t\t}\n\t}\n\n\treturn state;\n};\n\n/**\n * Function: createState\n *\n * Creates and returns an <mxCellState> for the given cell and initializes\n * it using <mxCellRenderer.initialize>.\n *\n * Parameters:\n *\n * cell - <mxCell> for which a new <mxCellState> should be created.\n */\nmxGraphView.prototype.createState = function(cell)\n{\n\treturn new mxCellState(this, cell, this.graph.getCellStyle(cell));\n};\n\n/**\n * Function: getCanvas\n *\n * Returns the DOM node that contains the background-, draw- and\n * overlay- and decoratorpanes.\n */\nmxGraphView.prototype.getCanvas = function()\n{\n\treturn this.canvas;\n};\n\n/**\n * Function: getBackgroundPane\n *\n * Returns the DOM node that represents the background layer.\n */\nmxGraphView.prototype.getBackgroundPane = function()\n{\n\treturn this.backgroundPane;\n};\n\n/**\n * Function: getDrawPane\n *\n * Returns the DOM node that represents the main drawing layer.\n */\nmxGraphView.prototype.getDrawPane = function()\n{\n\treturn this.drawPane;\n};\n\n/**\n * Function: getOverlayPane\n *\n * Returns the DOM node that represents the layer above the drawing layer.\n */\nmxGraphView.prototype.getOverlayPane = function()\n{\n\treturn this.overlayPane;\n};\n\n/**\n * Function: getDecoratorPane\n *\n * Returns the DOM node that represents the topmost drawing layer.\n */\nmxGraphView.prototype.getDecoratorPane = function()\n{\n\treturn this.decoratorPane;\n};\n\n/**\n * Function: isContainerEvent\n *\n * Returns true if the event origin is one of the drawing panes or\n * containers of the view.\n */\nmxGraphView.prototype.isContainerEvent = function(evt)\n{\n\tvar source = mxEvent.getSource(evt);\n\n\treturn (source == this.graph.container ||\n\t\tsource.parentNode == this.backgroundPane ||\n\t\t(source.parentNode != null &&\n\t\tsource.parentNode.parentNode == this.backgroundPane) ||\n\t\tsource == this.canvas.parentNode ||\n\t\tsource == this.canvas ||\n\t\tsource == this.backgroundPane ||\n\t\tsource == this.drawPane ||\n\t\tsource == this.overlayPane ||\n\t\tsource == this.decoratorPane);\n};\n\n/**\n * Function: isScrollEvent\n *\n * Returns true if the event origin is one of the scrollbars of the\n * container in IE. Such events are ignored.\n */\n mxGraphView.prototype.isScrollEvent = function(evt)\n{\n\tvar offset = mxUtils.getOffset(this.graph.container);\n\tvar pt = new mxPoint(evt.clientX - offset.x, evt.clientY - offset.y);\n\n\tvar outWidth = this.graph.container.offsetWidth;\n\tvar inWidth = this.graph.container.clientWidth;\n\n\tif (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth)\n\t{\n\t\treturn true;\n\t}\n\n\tvar outHeight = this.graph.container.offsetHeight;\n\tvar inHeight = this.graph.container.clientHeight;\n\n\tif (outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight)\n\t{\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: init\n *\n * Initializes the graph event dispatch loop for the specified container\n * and invokes <create> to create the required DOM nodes for the display.\n */\nmxGraphView.prototype.init = function()\n{\n\tthis.installListeners();\n\n\t// Creates the DOM nodes for the respective display dialect\n\tvar graph = this.graph;\n\n\tif (graph.dialect == mxConstants.DIALECT_SVG)\n\t{\n\t\tthis.createSvg();\n\t}\n\telse if (graph.dialect == mxConstants.DIALECT_VML)\n\t{\n\t\tthis.createVml();\n\t}\n\telse\n\t{\n\t\tthis.createHtml();\n\t}\n};\n\n/**\n * Function: installListeners\n *\n * Installs the required listeners in the container.\n */\nmxGraphView.prototype.installListeners = function()\n{\n\tvar graph = this.graph;\n\tvar container = graph.container;\n\n\tif (container != null)\n\t{\n\t\t// Support for touch device gestures (eg. pinch to zoom)\n\t\t// Double-tap handling is implemented in mxGraph.fireMouseEvent\n\t\tif (mxClient.IS_TOUCH)\n\t\t{\n\t\t\tmxEvent.addListener(container, 'gesturestart', mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tgraph.fireGestureEvent(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}));\n\n\t\t\tmxEvent.addListener(container, 'gesturechange', mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tgraph.fireGestureEvent(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}));\n\n\t\t\tmxEvent.addListener(container, 'gestureend', mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tgraph.fireGestureEvent(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}));\n\t\t}\n\n\t\t// Adds basic listeners for graph event dispatching\n\t\tmxEvent.addGestureListeners(container, mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\t// Condition to avoid scrollbar events starting a rubberband selection\n\t\t\tif (this.isContainerEvent(evt) && ((!mxClient.IS_IE && !mxClient.IS_IE11 && !mxClient.IS_GC &&\n\t\t\t\t!mxClient.IS_OP && !mxClient.IS_SF) || !this.isScrollEvent(evt)))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isContainerEvent(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t\t}\n\t\t}),\n\t\tmxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isContainerEvent(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t}\n\t\t}));\n\n\t\t// Adds listener for double click handling on background, this does always\n\t\t// use native event handler, we assume that the DOM of the background\n\t\t// does not change during the double click\n\t\tmxEvent.addListener(container, 'dblclick', mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.isContainerEvent(evt))\n\t\t\t{\n\t\t\t\tgraph.dblClick(evt);\n\t\t\t}\n\t\t}));\n\n\t\t// Workaround for touch events which started on some DOM node\n\t\t// on top of the container, in which case the cells under the\n\t\t// mouse for the move and up events are not detected.\n\t\tvar getState = function(evt)\n\t\t{\n\t\t\tvar state = null;\n\n\t\t\t// Workaround for touch events which started on some DOM node\n\t\t\t// on top of the container, in which case the cells under the\n\t\t\t// mouse for the move and up events are not detected.\n\t\t\tif (mxClient.IS_TOUCH)\n\t\t\t{\n\t\t\t\tvar x = mxEvent.getClientX(evt);\n\t\t\t\tvar y = mxEvent.getClientY(evt);\n\n\t\t\t\t// Dispatches the drop event to the graph which\n\t\t\t\t// consumes and executes the source function\n\t\t\t\tvar pt = mxUtils.convertPoint(container, x, y);\n\t\t\t\tstate = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n\t\t\t}\n\n\t\t\treturn state;\n\t\t};\n\n\t\t// Adds basic listeners for graph event dispatching outside of the\n\t\t// container and finishing the handling of a single gesture\n\t\t// Implemented via graph event dispatch loop to avoid duplicate events\n\t\t// in Firefox and Chrome\n\t\tgraph.addMouseListener(\n\t\t{\n\t\t\tmouseDown: function(sender, me)\n\t\t\t{\n\t\t\t\tgraph.popupMenuHandler.hideMenu();\n\t\t\t},\n\t\t\tmouseMove: function() { },\n\t\t\tmouseUp: function() { }\n\t\t});\n\n\t\tthis.moveHandler = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\t// Hides the tooltip if mouse is outside container\n\t\t\tif (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover())\n\t\t\t{\n\t\t\t\tgraph.tooltipHandler.hide();\n\t\t\t}\n\n\t\t\tif (this.captureDocumentGesture && graph.isMouseDown && graph.container != null &&\n\t\t\t\t!this.isContainerEvent(evt) && graph.container.style.display != 'none' &&\n\t\t\t\tgraph.container.style.visibility != 'hidden' && !mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, getState(evt)));\n\t\t\t}\n\t\t});\n\n\t\tthis.endHandler = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (this.captureDocumentGesture && graph.isMouseDown && graph.container != null &&\n\t\t\t\t!this.isContainerEvent(evt) && graph.container.style.display != 'none' &&\n\t\t\t\tgraph.container.style.visibility != 'hidden')\n\t\t\t{\n\t\t\t\tgraph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t\t}\n\t\t});\n\n\t\tmxEvent.addGestureListeners(document, null, this.moveHandler, this.endHandler);\n\t}\n};\n\n/**\n * Function: create\n *\n * Creates the DOM nodes for the HTML display.\n */\nmxGraphView.prototype.createHtml = function()\n{\n\tvar container = this.graph.container;\n\n\tif (container != null)\n\t{\n\t\tthis.canvas = this.createHtmlPane('100%', '100%');\n\t\tthis.canvas.style.overflow = 'hidden';\n\n\t\t// Uses minimal size for inner DIVs on Canvas. This is required\n\t\t// for correct event processing in IE. If we have an overlapping\n\t\t// DIV then the events on the cells are only fired for labels.\n\t\tthis.backgroundPane = this.createHtmlPane('1px', '1px');\n\t\tthis.drawPane = this.createHtmlPane('1px', '1px');\n\t\tthis.overlayPane = this.createHtmlPane('1px', '1px');\n\t\tthis.decoratorPane = this.createHtmlPane('1px', '1px');\n\n\t\tthis.canvas.appendChild(this.backgroundPane);\n\t\tthis.canvas.appendChild(this.drawPane);\n\t\tthis.canvas.appendChild(this.overlayPane);\n\t\tthis.canvas.appendChild(this.decoratorPane);\n\n\t\tcontainer.appendChild(this.canvas);\n\t\tthis.updateContainerStyle(container);\n\n\t\t// Implements minWidth/minHeight in quirks mode\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tvar onResize = mxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\tvar bounds = this.getGraphBounds();\n\t\t\t\tvar width = bounds.x + bounds.width + this.graph.border;\n\t\t\t\tvar height = bounds.y + bounds.height + this.graph.border;\n\n\t\t\t\tthis.updateHtmlCanvasSize(width, height);\n\t\t\t});\n\n\t\t\tmxEvent.addListener(window, 'resize', onResize);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateHtmlCanvasSize\n *\n * Updates the size of the HTML canvas.\n */\nmxGraphView.prototype.updateHtmlCanvasSize = function(width, height)\n{\n\tif (this.graph.container != null)\n\t{\n\t\tvar ow = this.graph.container.offsetWidth;\n\t\tvar oh = this.graph.container.offsetHeight;\n\n\t\tif (ow < width)\n\t\t{\n\t\t\tthis.canvas.style.width = width + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.canvas.style.width = '100%';\n\t\t}\n\n\t\tif (oh < height)\n\t\t{\n\t\t\tthis.canvas.style.height = height + 'px';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.canvas.style.height = '100%';\n\t\t}\n\t}\n};\n\n/**\n * Function: createHtmlPane\n *\n * Creates and returns a drawing pane in HTML (DIV).\n */\nmxGraphView.prototype.createHtmlPane = function(width, height)\n{\n\tvar pane = document.createElement('DIV');\n\n\tif (width != null && height != null)\n\t{\n\t\tpane.style.position = 'absolute';\n\t\tpane.style.left = '0px';\n\t\tpane.style.top = '0px';\n\n\t\tpane.style.width = width;\n\t\tpane.style.height = height;\n\t}\n\telse\n\t{\n\t\tpane.style.position = 'relative';\n\t}\n\n\treturn pane;\n};\n\n/**\n * Function: create\n *\n * Creates the DOM nodes for the VML display.\n */\nmxGraphView.prototype.createVml = function()\n{\n\tvar container = this.graph.container;\n\n\tif (container != null)\n\t{\n\t\tvar width = container.offsetWidth;\n\t\tvar height = container.offsetHeight;\n\t\tthis.canvas = this.createVmlPane(width, height);\n\t\tthis.canvas.style.overflow = 'hidden';\n\n\t\tthis.backgroundPane = this.createVmlPane(width, height);\n\t\tthis.drawPane = this.createVmlPane(width, height);\n\t\tthis.overlayPane = this.createVmlPane(width, height);\n\t\tthis.decoratorPane = this.createVmlPane(width, height);\n\n\t\tthis.canvas.appendChild(this.backgroundPane);\n\t\tthis.canvas.appendChild(this.drawPane);\n\t\tthis.canvas.appendChild(this.overlayPane);\n\t\tthis.canvas.appendChild(this.decoratorPane);\n\n\t\tcontainer.appendChild(this.canvas);\n\t}\n};\n\n/**\n * Function: createVmlPane\n *\n * Creates a drawing pane in VML (group).\n */\nmxGraphView.prototype.createVmlPane = function(width, height)\n{\n\tvar pane = document.createElement(mxClient.VML_PREFIX + ':group');\n\n\t// At this point the width and height are potentially\n\t// uninitialized. That's OK.\n\tpane.style.position = 'absolute';\n\tpane.style.left = '0px';\n\tpane.style.top = '0px';\n\n\tpane.style.width = width + 'px';\n\tpane.style.height = height + 'px';\n\n\tpane.setAttribute('coordsize', width + ',' + height);\n\tpane.setAttribute('coordorigin', '0,0');\n\n\treturn pane;\n};\n\n/**\n * Function: create\n *\n * Creates and returns the DOM nodes for the SVG display.\n */\nmxGraphView.prototype.createSvg = function()\n{\n\tvar container = this.graph.container;\n\tthis.canvas = document.createElementNS(mxConstants.NS_SVG, 'g');\n\n\t// For background image\n\tthis.backgroundPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.backgroundPane);\n\n\t// Adds two layers (background is early feature)\n\tthis.drawPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.drawPane);\n\n\tthis.overlayPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.overlayPane);\n\n\tthis.decoratorPane = document.createElementNS(mxConstants.NS_SVG, 'g');\n\tthis.canvas.appendChild(this.decoratorPane);\n\n\tvar root = document.createElementNS(mxConstants.NS_SVG, 'svg');\n\troot.style.left = '0px';\n\troot.style.top = '0px';\n\troot.style.width = '100%';\n\troot.style.height = '100%';\n\n\t// NOTE: In standards mode, the SVG must have block layout\n\t// in order for the container DIV to not show scrollbars.\n\troot.style.display = 'block';\n\troot.appendChild(this.canvas);\n\n\t// Workaround for scrollbars in IE11 and below\n\tif (mxClient.IS_IE || mxClient.IS_IE11)\n\t{\n\t\troot.style.overflow = 'hidden';\n\t}\n\n\tif (container != null)\n\t{\n\t\tcontainer.appendChild(root);\n\t\tthis.updateContainerStyle(container);\n\t}\n};\n\n/**\n * Function: updateContainerStyle\n *\n * Updates the style of the container after installing the SVG DOM elements.\n */\nmxGraphView.prototype.updateContainerStyle = function(container)\n{\n\t// Workaround for offset of container\n\tvar style = mxUtils.getCurrentStyle(container);\n\n\tif (style != null && style.position == 'static')\n\t{\n\t\tcontainer.style.position = 'relative';\n\t}\n\n\t// Disables built-in pan and zoom in IE10 and later\n\tif (mxClient.IS_POINTER)\n\t{\n\t\tcontainer.style.touchAction = 'none';\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the view and all its resources.\n */\nmxGraphView.prototype.destroy = function()\n{\n\tvar root = (this.canvas != null) ? this.canvas.ownerSVGElement : null;\n\n\tif (root == null)\n\t{\n\t\troot = this.canvas;\n\t}\n\n\tif (root != null && root.parentNode != null)\n\t{\n\t\tthis.clear(this.currentRoot, true);\n\t\tmxEvent.removeGestureListeners(document, null, this.moveHandler, this.endHandler);\n\t\tmxEvent.release(this.graph.container);\n\t\troot.parentNode.removeChild(root);\n\n\t\tthis.moveHandler = null;\n\t\tthis.endHandler = null;\n\t\tthis.canvas = null;\n\t\tthis.backgroundPane = null;\n\t\tthis.drawPane = null;\n\t\tthis.overlayPane = null;\n\t\tthis.decoratorPane = null;\n\t}\n};\n\n/**\n * Class: mxCurrentRootChange\n *\n * Action to change the current root in a view.\n *\n * Constructor: mxCurrentRootChange\n *\n * Constructs a change of the current root in the given view.\n */\nfunction mxCurrentRootChange(view, root)\n{\n\tthis.view = view;\n\tthis.root = root;\n\tthis.previous = root;\n\tthis.isUp = root == null;\n\n\tif (!this.isUp)\n\t{\n\t\tvar tmp = this.view.currentRoot;\n\t\tvar model = this.view.graph.getModel();\n\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp == root)\n\t\t\t{\n\t\t\t\tthis.isUp = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttmp = model.getParent(tmp);\n\t\t}\n\t}\n};\n\n/**\n * Function: execute\n *\n * Changes the current root of the view.\n */\nmxCurrentRootChange.prototype.execute = function()\n{\n\tvar tmp = this.view.currentRoot;\n\tthis.view.currentRoot = this.previous;\n\tthis.previous = tmp;\n\n\tvar translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);\n\n\tif (translate != null)\n\t{\n\t\tthis.view.translate = new mxPoint(-translate.x, -translate.y);\n\t}\n\n\tif (this.isUp)\n\t{\n\t\tthis.view.clear(this.view.currentRoot, true);\n\t\tthis.view.validate();\n\t}\n\telse\n\t{\n\t\tthis.view.refresh();\n\t}\n\n\tvar name = (this.isUp) ? mxEvent.UP : mxEvent.DOWN;\n\tthis.view.fireEvent(new mxEventObject(name,\n\t\t'root', this.view.currentRoot, 'previous', this.previous));\n\tthis.isUp = !this.isUp;\n};\n\n__mxOutput.mxGraphView = typeof mxGraphView !== 'undefined' ? mxGraphView : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraph\n *\n * Extends <mxEventSource> to implement a graph component for\n * the browser. This is the main class of the package. To activate\n * panning and connections use <setPanning> and <setConnectable>.\n * For rubberband selection you must create a new instance of\n * <mxRubberband>. The following listeners are added to\n * <mouseListeners> by default:\n *\n * - <tooltipHandler>: <mxTooltipHandler> that displays tooltips\n * - <panningHandler>: <mxPanningHandler> for panning and popup menus\n * - <connectionHandler>: <mxConnectionHandler> for creating connections\n * - <graphHandler>: <mxGraphHandler> for moving and cloning cells\n *\n * These listeners will be called in the above order if they are enabled.\n *\n * Background Images:\n *\n * To display a background image, set the image, image width and\n * image height using <setBackgroundImage>. If one of the\n * above values has changed then the <view>'s <mxGraphView.validate>\n * should be invoked.\n *\n * Cell Images:\n *\n * To use images in cells, a shape must be specified in the default\n * vertex style (or any named style). Possible shapes are\n * <mxConstants.SHAPE_IMAGE> and <mxConstants.SHAPE_LABEL>.\n * The code to change the shape used in the default vertex style,\n * the following code is used:\n *\n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;\n * (end)\n *\n * For the default vertex style, the image to be displayed can be\n * specified in a cell's style using the <mxConstants.STYLE_IMAGE>\n * key and the image URL as a value, for example:\n *\n * (code)\n * image=http://www.example.com/image.gif\n * (end)\n *\n * For a named style, the the stylename must be the first element\n * of the cell style:\n *\n * (code)\n * stylename;image=http://www.example.com/image.gif\n * (end)\n *\n * A cell style can have any number of key=value pairs added, divided\n * by a semicolon as follows:\n *\n * (code)\n * [stylename;|key=value;]\n * (end)\n *\n * Labels:\n *\n * The cell labels are defined by <getLabel> which uses <convertValueToString>\n * if <labelsVisible> is true. If a label must be rendered as HTML markup, then\n * <isHtmlLabel> should return true for the respective cell. If all labels\n * contain HTML markup, <htmlLabels> can be set to true. NOTE: Enabling HTML\n * labels carries a possible security risk (see the section on security in\n * the manual).\n *\n * If wrapping is needed for a label, then <isHtmlLabel> and <isWrapping> must\n * return true for the cell whose label should be wrapped. See <isWrapping> for\n * an example.\n *\n * If clipping is needed to keep the rendering of a HTML label inside the\n * bounds of its vertex, then <isClipping> should return true for the\n * respective cell.\n *\n * By default, edge labels are movable and vertex labels are fixed. This can be\n * changed by setting <edgeLabelsMovable> and <vertexLabelsMovable>, or by\n * overriding <isLabelMovable>.\n *\n * In-place Editing:\n *\n * In-place editing is started with a doubleclick or by typing F2.\n * Programmatically, <edit> is used to check if the cell is editable\n * (<isCellEditable>) and call <startEditingAtCell>, which invokes\n * <mxCellEditor.startEditing>. The editor uses the value returned\n * by <getEditingValue> as the editing value.\n *\n * After in-place editing, <labelChanged> is called, which invokes\n * <mxGraphModel.setValue>, which in turn calls\n * <mxGraphModel.valueForCellChanged> via <mxValueChange>.\n *\n * The event that triggers in-place editing is passed through to the\n * <cellEditor>, which may take special actions depending on the type of the\n * event or mouse location, and is also passed to <getEditingValue>. The event\n * is then passed back to the event processing functions which can perform\n * specific actions based on the trigger event.\n *\n * Tooltips:\n *\n * Tooltips are implemented by <getTooltip>, which calls <getTooltipForCell>\n * if a cell is under the mousepointer. The default implementation checks if\n * the cell has a getTooltip function and calls it if it exists. Hence, in order\n * to provide custom tooltips, the cell must provide a getTooltip function, or\n * one of the two above functions must be overridden.\n *\n * Typically, for custom cell tooltips, the latter function is overridden as\n * follows:\n *\n * (code)\n * graph.getTooltipForCell = function(cell)\n * {\n *   var label = this.convertValueToString(cell);\n *   return 'Tooltip for '+label;\n * }\n * (end)\n *\n * When using a config file, the function is overridden in the mxGraph section\n * using the following entry:\n *\n * (code)\n * <add as=\"getTooltipForCell\"><![CDATA[\n *   function(cell)\n *   {\n *     var label = this.convertValueToString(cell);\n *     return 'Tooltip for '+label;\n *   }\n * ]]></add>\n * (end)\n *\n * \"this\" refers to the graph in the implementation, so for example to check if\n * a cell is an edge, you use this.getModel().isEdge(cell)\n *\n * For replacing the default implementation of <getTooltipForCell> (rather than\n * replacing the function on a specific instance), the following code should be\n * used after loading the JavaScript files, but before creating a new mxGraph\n * instance using <mxGraph>:\n *\n * (code)\n * mxGraph.prototype.getTooltipForCell = function(cell)\n * {\n *   var label = this.convertValueToString(cell);\n *   return 'Tooltip for '+label;\n * }\n * (end)\n *\n * Shapes & Styles:\n *\n * The implementation of new shapes is demonstrated in the examples. We'll assume\n * that we have implemented a custom shape with the name BoxShape which we want\n * to use for drawing vertices. To use this shape, it must first be registered in\n * the cell renderer as follows:\n *\n * (code)\n * mxCellRenderer.registerShape('box', BoxShape);\n * (end)\n *\n * The code registers the BoxShape constructor under the name box in the cell\n * renderer of the graph. The shape can now be referenced using the shape-key in\n * a style definition. (The cell renderer contains a set of additional shapes,\n * namely one for each constant with a SHAPE-prefix in <mxConstants>.)\n *\n * Styles are a collection of key, value pairs and a stylesheet is a collection\n * of named styles. The names are referenced by the cellstyle, which is stored\n * in <mxCell.style> with the following format: [stylename;|key=value;]. The\n * string is resolved to a collection of key, value pairs, where the keys are\n * overridden with the values in the string.\n *\n * When introducing a new shape, the name under which the shape is registered\n * must be used in the stylesheet. There are three ways of doing this:\n *\n *   - By changing the default style, so that all vertices will use the new\n * \t\tshape\n *   - By defining a new style, so that only vertices with the respective\n * \t\tcellstyle will use the new shape\n *   - By using shape=box in the cellstyle's optional list of key, value pairs\n * \t\tto be overridden\n *\n * In the first case, the code to fetch and modify the default style for\n * vertices is as follows:\n *\n * (code)\n * var style = graph.getStylesheet().getDefaultVertexStyle();\n * style[mxConstants.STYLE_SHAPE] = 'box';\n * (end)\n *\n * The code takes the default vertex style, which is used for all vertices that\n * do not have a specific cellstyle, and modifies the value for the shape-key\n * in-place to use the new BoxShape for drawing vertices. This is done by\n * assigning the box value in the second line, which refers to the name of the\n * BoxShape in the cell renderer.\n *\n * In the second case, a collection of key, value pairs is created and then\n * added to the stylesheet under a new name. In order to distinguish the\n * shapename and the stylename we'll use boxstyle for the stylename:\n *\n * (code)\n * var style = new Object();\n * style[mxConstants.STYLE_SHAPE] = 'box';\n * style[mxConstants.STYLE_STROKECOLOR] = '#000000';\n * style[mxConstants.STYLE_FONTCOLOR] = '#000000';\n * graph.getStylesheet().putCellStyle('boxstyle', style);\n * (end)\n *\n * The code adds a new style with the name boxstyle to the stylesheet. To use\n * this style with a cell, it must be referenced from the cellstyle as follows:\n *\n * (code)\n * var vertex = graph.insertVertex(parent, null, 'Hello, World!', 20, 20, 80, 20,\n * \t\t\t\t'boxstyle');\n * (end)\n *\n * To summarize, each new shape must be registered in the <mxCellRenderer> with\n * a unique name. That name is then used as the value of the shape-key in a\n * default or custom style. If there are multiple custom shapes, then there\n * should be a separate style for each shape.\n *\n * Inheriting Styles:\n *\n * For fill-, stroke-, gradient- and indicatorColors special keywords can be\n * used. The inherit keyword for one of these colors will inherit the color\n * for the same key from the parent cell. The swimlane keyword does the same,\n * but inherits from the nearest swimlane in the ancestor hierarchy. Finally,\n * the indicated keyword will use the color of the indicator as the color for\n * the given key.\n *\n * Scrollbars:\n *\n * The <containers> overflow CSS property defines if scrollbars are used to\n * display the graph. For values of 'auto' or 'scroll', the scrollbars will\n * be shown. Note that the <resizeContainer> flag is normally not used\n * together with scrollbars, as it will resize the container to match the\n * size of the graph after each change.\n *\n * Multiplicities and Validation:\n *\n * To control the possible connections in mxGraph, <getEdgeValidationError> is\n * used. The default implementation of the function uses <multiplicities>,\n * which is an array of <mxMultiplicity>. Using this class allows to establish\n * simple multiplicities, which are enforced by the graph.\n *\n * The <mxMultiplicity> uses <mxCell.is> to determine for which terminals it\n * applies. The default implementation of <mxCell.is> works with DOM nodes (XML\n * nodes) and checks if the given type parameter matches the nodeName of the\n * node (case insensitive). Optionally, an attributename and value can be\n * specified which are also checked.\n *\n * <getEdgeValidationError> is called whenever the connectivity of an edge\n * changes. It returns an empty string or an error message if the edge is\n * invalid or null if the edge is valid. If the returned string is not empty\n * then it is displayed as an error message.\n *\n * <mxMultiplicity> allows to specify the multiplicity between a terminal and\n * its possible neighbors. For example, if any rectangle may only be connected\n * to, say, a maximum of two circles you can add the following rule to\n * <multiplicities>:\n *\n * (code)\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only shape targets allowed'));\n * (end)\n *\n * This will display the first error message whenever a rectangle is connected\n * to more than two circles and the second error message if a rectangle is\n * connected to anything but a circle.\n *\n * For certain multiplicities, such as a minimum of 1 connection, which cannot\n * be enforced at cell creation time (unless the cell is created together with\n * the connection), mxGraph offers <validate> which checks all multiplicities\n * for all cells and displays the respective error messages in an overlay icon\n * on the cells.\n *\n * If a cell is collapsed and contains validation errors, a respective warning\n * icon is attached to the collapsed cell.\n *\n * Auto-Layout:\n *\n * For automatic layout, the <getLayout> hook is provided in <mxLayoutManager>.\n * It can be overridden to return a layout algorithm for the children of a\n * given cell.\n *\n * Unconnected edges:\n *\n * The default values for all switches are designed to meet the requirements of\n * general diagram drawing applications. A very typical set of settings to\n * avoid edges that are not connected is the following:\n *\n * (code)\n * graph.setAllowDanglingEdges(false);\n * graph.setDisconnectOnMove(false);\n * (end)\n *\n * Setting the <cloneInvalidEdges> switch to true is optional. This switch\n * controls if edges are inserted after a copy, paste or clone-drag if they are\n * invalid. For example, edges are invalid if copied or control-dragged without\n * having selected the corresponding terminals and allowDanglingEdges is\n * false, in which case the edges will not be cloned if the switch is false.\n *\n * Output:\n *\n * To produce an XML representation for a diagram, the following code can be\n * used.\n *\n * (code)\n * var enc = new mxCodec(mxUtils.createXmlDocument());\n * var node = enc.encode(graph.getModel());\n * (end)\n *\n * This will produce an XML node than can be handled using the DOM API or\n * turned into a string representation using the following code:\n *\n * (code)\n * var xml = mxUtils.getXml(node);\n * (end)\n *\n * To obtain a formatted string, mxUtils.getPrettyXml can be used instead.\n *\n * This string can now be stored in a local persistent storage (for example\n * using Google Gears) or it can be passed to a backend using mxUtils.post as\n * follows. The url variable is the URL of the Java servlet, PHP page or HTTP\n * handler, depending on the server.\n *\n * (code)\n * var xmlString = encodeURIComponent(mxUtils.getXml(node));\n * mxUtils.post(url, 'xml='+xmlString, function(req)\n * {\n *   // Process server response using req of type mxXmlRequest\n * });\n * (end)\n *\n * Input:\n *\n * To load an XML representation of a diagram into an existing graph object\n * mxUtils.load can be used as follows. The url variable is the URL of the Java\n * servlet, PHP page or HTTP handler that produces the XML string.\n *\n * (code)\n * var xmlDoc = mxUtils.load(url).getXml();\n * var node = xmlDoc.documentElement;\n * var dec = new mxCodec(node.ownerDocument);\n * dec.decode(node, graph.getModel());\n * (end)\n *\n * For creating a page that loads the client and a diagram using a single\n * request please refer to the deployment examples in the backends.\n *\n * Functional dependencies:\n *\n * (see images/callgraph.png)\n *\n * Resources:\n *\n * resources/graph - Language resources for mxGraph\n *\n * Group: Events\n *\n * Event: mxEvent.ROOT\n *\n * Fires if the root in the model has changed. This event has no properties.\n *\n * Event: mxEvent.ALIGN_CELLS\n *\n * Fires between begin- and endUpdate in <alignCells>. The <code>cells</code>\n * and <code>align</code> properties contain the respective arguments that were\n * passed to <alignCells>.\n *\n * Event: mxEvent.FLIP_EDGE\n *\n * Fires between begin- and endUpdate in <flipEdge>. The <code>edge</code>\n * property contains the edge passed to <flipEdge>.\n *\n * Event: mxEvent.ORDER_CELLS\n *\n * Fires between begin- and endUpdate in <orderCells>. The <code>cells</code>\n * and <code>back</code> properties contain the respective arguments that were\n * passed to <orderCells>.\n *\n * Event: mxEvent.CELLS_ORDERED\n *\n * Fires between begin- and endUpdate in <cellsOrdered>. The <code>cells</code>\n * and <code>back</code> arguments contain the respective arguments that were\n * passed to <cellsOrdered>.\n *\n * Event: mxEvent.GROUP_CELLS\n *\n * Fires between begin- and endUpdate in <groupCells>. The <code>group</code>,\n * <code>cells</code> and <code>border</code> arguments contain the respective\n * arguments that were passed to <groupCells>.\n *\n * Event: mxEvent.UNGROUP_CELLS\n *\n * Fires between begin- and endUpdate in <ungroupCells>. The <code>cells</code>\n * property contains the array of cells that was passed to <ungroupCells>.\n *\n * Event: mxEvent.REMOVE_CELLS_FROM_PARENT\n *\n * Fires between begin- and endUpdate in <removeCellsFromParent>. The\n * <code>cells</code> property contains the array of cells that was passed to\n * <removeCellsFromParent>.\n *\n * Event: mxEvent.ADD_CELLS\n *\n * Fires between begin- and endUpdate in <addCells>. The <code>cells</code>,\n * <code>parent</code>, <code>index</code>, <code>source</code> and\n * <code>target</code> properties contain the respective arguments that were\n * passed to <addCells>.\n *\n * Event: mxEvent.CELLS_ADDED\n *\n * Fires between begin- and endUpdate in <cellsAdded>. The <code>cells</code>,\n * <code>parent</code>, <code>index</code>, <code>source</code>,\n * <code>target</code> and <code>absolute</code> properties contain the\n * respective arguments that were passed to <cellsAdded>.\n *\n * Event: mxEvent.REMOVE_CELLS\n *\n * Fires between begin- and endUpdate in <removeCells>. The <code>cells</code>\n * and <code>includeEdges</code> arguments contain the respective arguments\n * that were passed to <removeCells>.\n *\n * Event: mxEvent.CELLS_REMOVED\n *\n * Fires between begin- and endUpdate in <cellsRemoved>. The <code>cells</code>\n * argument contains the array of cells that was removed.\n *\n * Event: mxEvent.SPLIT_EDGE\n *\n * Fires between begin- and endUpdate in <splitEdge>. The <code>edge</code>\n * property contains the edge to be splitted, the <code>cells</code>,\n * <code>newEdge</code>, <code>dx</code> and <code>dy</code> properties contain\n * the respective arguments that were passed to <splitEdge>.\n *\n * Event: mxEvent.TOGGLE_CELLS\n *\n * Fires between begin- and endUpdate in <toggleCells>. The <code>show</code>,\n * <code>cells</code> and <code>includeEdges</code> properties contain the\n * respective arguments that were passed to <toggleCells>.\n *\n * Event: mxEvent.FOLD_CELLS\n *\n * Fires between begin- and endUpdate in <foldCells>. The\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\n * properties contain the respective arguments that were passed to <foldCells>.\n *\n * Event: mxEvent.CELLS_FOLDED\n *\n * Fires between begin- and endUpdate in cellsFolded. The\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\n * properties contain the respective arguments that were passed to\n * <cellsFolded>.\n *\n * Event: mxEvent.UPDATE_CELL_SIZE\n *\n * Fires between begin- and endUpdate in <updateCellSize>. The\n * <code>cell</code> and <code>ignoreChildren</code> properties contain the\n * respective arguments that were passed to <updateCellSize>.\n *\n * Event: mxEvent.RESIZE_CELLS\n *\n * Fires between begin- and endUpdate in <resizeCells>. The <code>cells</code>\n * and <code>bounds</code> properties contain the respective arguments that\n * were passed to <resizeCells>.\n *\n * Event: mxEvent.CELLS_RESIZED\n *\n * Fires between begin- and endUpdate in <cellsResized>. The <code>cells</code>\n * and <code>bounds</code> properties contain the respective arguments that\n * were passed to <cellsResized>.\n *\n * Event: mxEvent.MOVE_CELLS\n *\n * Fires between begin- and endUpdate in <moveCells>. The <code>cells</code>,\n * <code>dx</code>, <code>dy</code>, <code>clone</code>, <code>target</code>\n * and <code>event</code> properties contain the respective arguments that\n * were passed to <moveCells>.\n *\n * Event: mxEvent.CELLS_MOVED\n *\n * Fires between begin- and endUpdate in <cellsMoved>. The <code>cells</code>,\n * <code>dx</code>, <code>dy</code> and <code>disconnect</code> properties\n * contain the respective arguments that were passed to <cellsMoved>.\n *\n * Event: mxEvent.CONNECT_CELL\n *\n * Fires between begin- and endUpdate in <connectCell>. The <code>edge</code>,\n * <code>terminal</code> and <code>source</code> properties contain the\n * respective arguments that were passed to <connectCell>.\n *\n * Event: mxEvent.CELL_CONNECTED\n *\n * Fires between begin- and endUpdate in <cellConnected>. The\n * <code>edge</code>, <code>terminal</code> and <code>source</code> properties\n * contain the respective arguments that were passed to <cellConnected>.\n *\n * Event: mxEvent.REFRESH\n *\n * Fires after <refresh> was executed. This event has no properties.\n *\n * Event: mxEvent.CLICK\n *\n * Fires in <click> after a click event. The <code>event</code> property\n * contains the original mouse event and <code>cell</code> property contains\n * the cell under the mouse or null if the background was clicked.\n *\n * Event: mxEvent.DOUBLE_CLICK\n *\n * Fires in <dblClick> after a double click. The <code>event</code> property\n * contains the original mouse event and the <code>cell</code> property\n * contains the cell under the mouse or null if the background was clicked.\n *\n * Event: mxEvent.GESTURE\n *\n * Fires in <fireGestureEvent> after a touch gesture. The <code>event</code>\n * property contains the original gesture end event and the <code>cell</code>\n * property contains the optional cell associated with the gesture.\n *\n * Event: mxEvent.TAP_AND_HOLD\n *\n * Fires in <tapAndHold> if a tap and hold event was detected. The <code>event</code>\n * property contains the initial touch event and the <code>cell</code> property\n * contains the cell under the mouse or null if the background was clicked.\n *\n * Event: mxEvent.FIRE_MOUSE_EVENT\n *\n * Fires in <fireMouseEvent> before the mouse listeners are invoked. The\n * <code>eventName</code> property contains the event name and the\n * <code>event</code> property contains the <mxMouseEvent>.\n *\n * Event: mxEvent.SIZE\n *\n * Fires after <sizeDidChange> was executed. The <code>bounds</code> property\n * contains the new graph bounds.\n *\n * Event: mxEvent.START_EDITING\n *\n * Fires before the in-place editor starts in <startEditingAtCell>. The\n * <code>cell</code> property contains the cell that is being edited and the\n * <code>event</code> property contains the optional event argument that was\n * passed to <startEditingAtCell>.\n *\n * Event: mxEvent.EDITING_STARTED\n *\n * Fires after the in-place editor starts in <startEditingAtCell>. The\n * <code>cell</code> property contains the cell that is being edited and the\n * <code>event</code> property contains the optional event argument that was\n * passed to <startEditingAtCell>.\n *\n * Event: mxEvent.EDITING_STOPPED\n *\n * Fires after the in-place editor stops in <stopEditing>.\n *\n * Event: mxEvent.LABEL_CHANGED\n *\n * Fires between begin- and endUpdate in <cellLabelChanged>. The\n * <code>cell</code> property contains the cell, the <code>value</code>\n * property contains the new value for the cell, the <code>old</code> property\n * contains the old value and the optional <code>event</code> property contains\n * the mouse event that started the edit.\n *\n * Event: mxEvent.ADD_OVERLAY\n *\n * Fires after an overlay is added in <addCellOverlay>. The <code>cell</code>\n * property contains the cell and the <code>overlay</code> property contains\n * the <mxCellOverlay> that was added.\n *\n * Event: mxEvent.REMOVE_OVERLAY\n *\n * Fires after an overlay is removed in <removeCellOverlay> and\n * <removeCellOverlays>. The <code>cell</code> property contains the cell and\n * the <code>overlay</code> property contains the <mxCellOverlay> that was\n * removed.\n *\n * Constructor: mxGraph\n *\n * Constructs a new mxGraph in the specified container. Model is an optional\n * mxGraphModel. If no model is provided, a new mxGraphModel instance is\n * used as the model. The container must have a valid owner document prior\n * to calling this function in Internet Explorer. RenderHint is a string to\n * affect the display performance and rendering in IE, but not in SVG-based\n * browsers. The parameter is mapped to <dialect>, which may\n * be one of <mxConstants.DIALECT_SVG> for SVG-based browsers,\n * <mxConstants.DIALECT_STRICTHTML> for fastest display mode,\n * <mxConstants.DIALECT_PREFERHTML> for faster display mode,\n * <mxConstants.DIALECT_MIXEDHTML> for fast and <mxConstants.DIALECT_VML>\n * for exact display mode (slowest). The dialects are defined in mxConstants.\n * The default values are DIALECT_SVG for SVG-based browsers and\n * DIALECT_MIXED for IE.\n *\n * The possible values for the renderingHint parameter are explained below:\n *\n * fast - The parameter is based on the fact that the display performance is\n * highly improved in IE if the VML is not contained within a VML group\n * element. The lack of a group element only slightly affects the display while\n * panning, but improves the performance by almost a factor of 2, while keeping\n * the display sufficiently accurate. This also allows to render certain shapes as HTML\n * if the display accuracy is not affected, which is implemented by\n * <mxShape.isMixedModeHtml>. This is the default setting and is mapped to\n * DIALECT_MIXEDHTML.\n * faster - Same as fast, but more expensive shapes are avoided. This is\n * controlled by <mxShape.preferModeHtml>. The default implementation will\n * avoid gradients and rounded rectangles, but more significant shapes, such\n * as rhombus, ellipse, actor and cylinder will be rendered accurately. This\n * setting is mapped to DIALECT_PREFERHTML.\n * fastest - Almost anything will be rendered in Html. This allows for\n * rectangles, labels and images. This setting is mapped to\n * DIALECT_STRICTHTML.\n * exact - If accurate panning is required and if the diagram is small (up\n * to 100 cells), then this value should be used. In this mode, a group is\n * created that contains the VML. This allows for accurate panning and is\n * mapped to DIALECT_VML.\n *\n * Example:\n *\n * To create a graph inside a DOM node with an id of graph:\n * (code)\n * var container = document.getElementById('graph');\n * var graph = new mxGraph(container);\n * (end)\n *\n * Parameters:\n *\n * container - Optional DOM node that acts as a container for the graph.\n * If this is null then the container can be initialized later using\n * <init>.\n * model - Optional <mxGraphModel> that constitutes the graph data.\n * renderHint - Optional string that specifies the display accuracy and\n * performance. Default is mxConstants.DIALECT_MIXEDHTML (for IE).\n * stylesheet - Optional <mxStylesheet> to be used in the graph.\n */\nfunction mxGraph(container, model, renderHint, stylesheet)\n{\n\t// Initializes the variable in case the prototype has been\n\t// modified to hold some listeners (which is possible because\n\t// the createHandlers call is executed regardless of the\n\t// arguments passed into the ctor).\n\tthis.mouseListeners = null;\n\n\t// Converts the renderHint into a dialect\n\tthis.renderHint = renderHint;\n\n\tif (mxClient.IS_SVG)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_SVG;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_EXACT && mxClient.IS_VML)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_VML;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_FASTEST)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_STRICTHTML;\n\t}\n\telse if (renderHint == mxConstants.RENDERING_HINT_FASTER)\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_PREFERHTML;\n\t}\n\telse // default for VML\n\t{\n\t\tthis.dialect = mxConstants.DIALECT_MIXEDHTML;\n\t}\n\n\t// Initializes the main members that do not require a container\n\tthis.model = (model != null) ? model : new mxGraphModel();\n\tthis.multiplicities = [];\n\tthis.imageBundles = [];\n\tthis.cellRenderer = this.createCellRenderer();\n\tthis.setSelectionModel(this.createSelectionModel());\n\tthis.setStylesheet((stylesheet != null) ? stylesheet : this.createStylesheet());\n\tthis.view = this.createGraphView();\n\n\t// Adds a graph model listener to update the view\n\tthis.graphModelChangeListener = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tthis.graphModelChanged(evt.getProperty('edit').changes);\n\t});\n\n\tthis.model.addListener(mxEvent.CHANGE, this.graphModelChangeListener);\n\n\t// Installs basic event handlers with disabled default settings.\n\tthis.createHandlers();\n\n\t// Initializes the display if a container was specified\n\tif (container != null)\n\t{\n\t\tthis.init(container);\n\t}\n\n\tthis.view.revalidate();\n};\n\n/**\n * Installs the required language resources at class\n * loading time.\n */\nif (mxLoadResources)\n{\n\tmxResources.add(mxClient.basePath + '/resources/graph');\n}\nelse\n{\n\tmxClient.defaultBundles.push(mxClient.basePath + '/resources/graph');\n}\n\n/**\n * Extends mxEventSource.\n */\nmxGraph.prototype = new mxEventSource();\nmxGraph.prototype.constructor = mxGraph;\n\n/**\n * Group: Variables\n */\n\n/**\n * Variable: mouseListeners\n *\n * Holds the mouse event listeners. See <fireMouseEvent>.\n */\nmxGraph.prototype.mouseListeners = null;\n\n/**\n * Variable: isMouseDown\n *\n * Holds the state of the mouse button.\n */\nmxGraph.prototype.isMouseDown = false;\n\n/**\n * Variable: model\n *\n * Holds the <mxGraphModel> that contains the cells to be displayed.\n */\nmxGraph.prototype.model = null;\n\n/**\n * Variable: view\n *\n * Holds the <mxGraphView> that caches the <mxCellStates> for the cells.\n */\nmxGraph.prototype.view = null;\n\n/**\n * Variable: stylesheet\n *\n * Holds the <mxStylesheet> that defines the appearance of the cells.\n *\n *\n * Example:\n *\n * Use the following code to read a stylesheet into an existing graph.\n *\n * (code)\n * var req = mxUtils.load('stylesheet.xml');\n * var root = req.getDocumentElement();\n * var dec = new mxCodec(root.ownerDocument);\n * dec.decode(root, graph.stylesheet);\n * (end)\n */\nmxGraph.prototype.stylesheet = null;\n\n/**\n * Variable: selectionModel\n *\n * Holds the <mxGraphSelectionModel> that models the current selection.\n */\nmxGraph.prototype.selectionModel = null;\n\n/**\n * Variable: cellEditor\n *\n * Holds the <mxCellEditor> that is used as the in-place editing.\n */\nmxGraph.prototype.cellEditor = null;\n\n/**\n * Variable: cellRenderer\n *\n * Holds the <mxCellRenderer> for rendering the cells in the graph.\n */\nmxGraph.prototype.cellRenderer = null;\n\n/**\n * Variable: multiplicities\n *\n * An array of <mxMultiplicities> describing the allowed\n * connections in a graph.\n */\nmxGraph.prototype.multiplicities = null;\n\n/**\n * Variable: renderHint\n *\n * RenderHint as it was passed to the constructor.\n */\nmxGraph.prototype.renderHint = null;\n\n/**\n * Variable: dialect\n *\n * Dialect to be used for drawing the graph. Possible values are all\n * constants in <mxConstants> with a DIALECT-prefix.\n */\nmxGraph.prototype.dialect = null;\n\n/**\n * Variable: gridSize\n *\n * Specifies the grid size. Default is 10.\n */\nmxGraph.prototype.gridSize = 10;\n\n/**\n * Variable: gridEnabled\n *\n * Specifies if the grid is enabled. This is used in <snap>. Default is\n * true.\n */\nmxGraph.prototype.gridEnabled = true;\n\n/**\n * Variable: portsEnabled\n *\n * Specifies if ports are enabled. This is used in <cellConnected> to update\n * the respective style. Default is true.\n */\nmxGraph.prototype.portsEnabled = true;\n\n/**\n * Variable: nativeDoubleClickEnabled\n *\n * Specifies if native double click events should be detected. Default is true.\n */\nmxGraph.prototype.nativeDblClickEnabled = true;\n\n/**\n * Variable: doubleTapEnabled\n *\n * Specifies if double taps on touch-based devices should be handled as a\n * double click. Default is true.\n */\nmxGraph.prototype.doubleTapEnabled = true;\n\n/**\n * Variable: doubleTapTimeout\n *\n * Specifies the timeout for double taps and non-native double clicks. Default\n * is 500 ms.\n */\nmxGraph.prototype.doubleTapTimeout = 500;\n\n/**\n * Variable: doubleTapTolerance\n *\n * Specifies the tolerance for double taps and double clicks in quirks mode.\n * Default is 25 pixels.\n */\nmxGraph.prototype.doubleTapTolerance = 25;\n\n/**\n * Variable: lastTouchX\n *\n * Holds the x-coordinate of the last touch event for double tap detection.\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\n * Variable: lastTouchX\n *\n * Holds the y-coordinate of the last touch event for double tap detection.\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\n * Variable: lastTouchTime\n *\n * Holds the time of the last touch event for double click detection.\n */\nmxGraph.prototype.lastTouchTime = 0;\n\n/**\n * Variable: tapAndHoldEnabled\n *\n * Specifies if tap and hold should be used for starting connections on touch-based\n * devices. Default is true.\n */\nmxGraph.prototype.tapAndHoldEnabled = true;\n\n/**\n * Variable: tapAndHoldDelay\n *\n * Specifies the time for a tap and hold. Default is 500 ms.\n */\nmxGraph.prototype.tapAndHoldDelay = 500;\n\n/**\n * Variable: tapAndHoldInProgress\n *\n * True if the timer for tap and hold events is running.\n */\nmxGraph.prototype.tapAndHoldInProgress = false;\n\n/**\n * Variable: tapAndHoldValid\n *\n * True as long as the timer is running and the touch events\n * stay within the given <tapAndHoldTolerance>.\n */\nmxGraph.prototype.tapAndHoldValid = false;\n\n/**\n * Variable: initialTouchX\n *\n * Holds the x-coordinate of the intial touch event for tap and hold.\n */\nmxGraph.prototype.initialTouchX = 0;\n\n/**\n * Variable: initialTouchY\n *\n * Holds the y-coordinate of the intial touch event for tap and hold.\n */\nmxGraph.prototype.initialTouchY = 0;\n\n/**\n * Variable: tolerance\n *\n * Tolerance for a move to be handled as a single click.\n * Default is 4 pixels.\n */\nmxGraph.prototype.tolerance = 4;\n\n/**\n * Variable: defaultOverlap\n *\n * Value returned by <getOverlap> if <isAllowOverlapParent> returns\n * true for the given cell. <getOverlap> is used in <constrainChild> if\n * <isConstrainChild> returns true. The value specifies the\n * portion of the child which is allowed to overlap the parent.\n */\nmxGraph.prototype.defaultOverlap = 0.5;\n\n/**\n * Variable: defaultParent\n *\n * Specifies the default parent to be used to insert new cells.\n * This is used in <getDefaultParent>. Default is null.\n */\nmxGraph.prototype.defaultParent = null;\n\n/**\n * Variable: alternateEdgeStyle\n *\n * Specifies the alternate edge style to be used if the main control point\n * on an edge is being doubleclicked. Default is null.\n */\nmxGraph.prototype.alternateEdgeStyle = null;\n\n/**\n * Variable: backgroundImage\n *\n * Specifies the <mxImage> to be returned by <getBackgroundImage>. Default\n * is null.\n *\n * Example:\n *\n * (code)\n * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);\n * graph.setBackgroundImage(img);\n * graph.view.validate();\n * (end)\n */\nmxGraph.prototype.backgroundImage = null;\n\n/**\n * Variable: pageVisible\n *\n * Specifies if the background page should be visible. Default is false.\n * Not yet implemented.\n */\nmxGraph.prototype.pageVisible = false;\n\n/**\n * Variable: pageBreaksVisible\n *\n * Specifies if a dashed line should be drawn between multiple pages. Default\n * is false. If you change this value while a graph is being displayed then you\n * should call <sizeDidChange> to force an update of the display.\n */\nmxGraph.prototype.pageBreaksVisible = false;\n\n/**\n * Variable: pageBreakColor\n *\n * Specifies the color for page breaks. Default is 'gray'.\n */\nmxGraph.prototype.pageBreakColor = 'gray';\n\n/**\n * Variable: pageBreakDashed\n *\n * Specifies the page breaks should be dashed. Default is true.\n */\nmxGraph.prototype.pageBreakDashed = true;\n\n/**\n * Variable: minPageBreakDist\n *\n * Specifies the minimum distance for page breaks to be visible. Default is\n * 20 (in pixels).\n */\nmxGraph.prototype.minPageBreakDist = 20;\n\n/**\n * Variable: preferPageSize\n *\n * Specifies if the graph size should be rounded to the next page number in\n * <sizeDidChange>. This is only used if the graph container has scrollbars.\n * Default is false.\n */\nmxGraph.prototype.preferPageSize = false;\n\n/**\n * Variable: pageFormat\n *\n * Specifies the page format for the background page. Default is\n * <mxConstants.PAGE_FORMAT_A4_PORTRAIT>. This is used as the default in\n * <mxPrintPreview> and for painting the background page if <pageVisible> is\n * true and the pagebreaks if <pageBreaksVisible> is true.\n */\nmxGraph.prototype.pageFormat = mxConstants.PAGE_FORMAT_A4_PORTRAIT;\n\n/**\n * Variable: pageScale\n *\n * Specifies the scale of the background page. Default is 1.5.\n * Not yet implemented.\n */\nmxGraph.prototype.pageScale = 1.5;\n\n/**\n * Variable: enabled\n *\n * Specifies the return value for <isEnabled>. Default is true.\n */\nmxGraph.prototype.enabled = true;\n\n/**\n * Variable: escapeEnabled\n *\n * Specifies if <mxKeyHandler> should invoke <escape> when the escape key\n * is pressed. Default is true.\n */\nmxGraph.prototype.escapeEnabled = true;\n\n/**\n * Variable: invokesStopCellEditing\n *\n * If true, when editing is to be stopped by way of selection changing,\n * data in diagram changing or other means stopCellEditing is invoked, and\n * changes are saved. This is implemented in a focus handler in\n * <mxCellEditor>. Default is true.\n */\nmxGraph.prototype.invokesStopCellEditing = true;\n\n/**\n * Variable: enterStopsCellEditing\n *\n * If true, pressing the enter key without pressing control or shift will stop\n * editing and accept the new value. This is used in <mxCellEditor> to stop\n * cell editing. Note: You can always use F2 and escape to stop editing.\n * Default is false.\n */\nmxGraph.prototype.enterStopsCellEditing = false;\n\n/**\n * Variable: useScrollbarsForPanning\n *\n * Specifies if scrollbars should be used for panning in <panGraph> if\n * any scrollbars are available. If scrollbars are enabled in CSS, but no\n * scrollbars appear because the graph is smaller than the container size,\n * then no panning occurs if this is true. Default is true.\n */\nmxGraph.prototype.useScrollbarsForPanning = true;\n\n/**\n * Variable: exportEnabled\n *\n * Specifies the return value for <canExportCell>. Default is true.\n */\nmxGraph.prototype.exportEnabled = true;\n\n/**\n * Variable: importEnabled\n *\n * Specifies the return value for <canImportCell>. Default is true.\n */\nmxGraph.prototype.importEnabled = true;\n\n/**\n * Variable: cellsLocked\n *\n * Specifies the return value for <isCellLocked>. Default is false.\n */\nmxGraph.prototype.cellsLocked = false;\n\n/**\n * Variable: cellsCloneable\n *\n * Specifies the return value for <isCellCloneable>. Default is true.\n */\nmxGraph.prototype.cellsCloneable = true;\n\n/**\n * Variable: foldingEnabled\n *\n * Specifies if folding (collapse and expand via an image icon in the graph\n * should be enabled). Default is true.\n */\nmxGraph.prototype.foldingEnabled = true;\n\n/**\n * Variable: cellsEditable\n *\n * Specifies the return value for <isCellEditable>. Default is true.\n */\nmxGraph.prototype.cellsEditable = true;\n\n/**\n * Variable: cellsDeletable\n *\n * Specifies the return value for <isCellDeletable>. Default is true.\n */\nmxGraph.prototype.cellsDeletable = true;\n\n/**\n * Variable: cellsMovable\n *\n * Specifies the return value for <isCellMovable>. Default is true.\n */\nmxGraph.prototype.cellsMovable = true;\n\n/**\n * Variable: edgeLabelsMovable\n *\n * Specifies the return value for edges in <isLabelMovable>. Default is true.\n */\nmxGraph.prototype.edgeLabelsMovable = true;\n\n/**\n * Variable: vertexLabelsMovable\n *\n * Specifies the return value for vertices in <isLabelMovable>. Default is false.\n */\nmxGraph.prototype.vertexLabelsMovable = false;\n\n/**\n * Variable: dropEnabled\n *\n * Specifies the return value for <isDropEnabled>. Default is false.\n */\nmxGraph.prototype.dropEnabled = false;\n\n/**\n * Variable: splitEnabled\n *\n * Specifies if dropping onto edges should be enabled. This is ignored if\n * <dropEnabled> is false. If enabled, it will call <splitEdge> to carry\n * out the drop operation. Default is true.\n */\nmxGraph.prototype.splitEnabled = true;\n\n/**\n * Variable: cellsResizable\n *\n * Specifies the return value for <isCellResizable>. Default is true.\n */\nmxGraph.prototype.cellsResizable = true;\n\n/**\n * Variable: cellsBendable\n *\n * Specifies the return value for <isCellsBendable>. Default is true.\n */\nmxGraph.prototype.cellsBendable = true;\n\n/**\n * Variable: cellsSelectable\n *\n * Specifies the return value for <isCellSelectable>. Default is true.\n */\nmxGraph.prototype.cellsSelectable = true;\n\n/**\n * Variable: cellsDisconnectable\n *\n * Specifies the return value for <isCellDisconntable>. Default is true.\n */\nmxGraph.prototype.cellsDisconnectable = true;\n\n/**\n * Variable: autoSizeCells\n *\n * Specifies if the graph should automatically update the cell size after an\n * edit. This is used in <isAutoSizeCell>. Default is false.\n */\nmxGraph.prototype.autoSizeCells = false;\n\n/**\n * Variable: autoSizeCellsOnAdd\n *\n * Specifies if autoSize style should be applied when cells are added. Default is false.\n */\nmxGraph.prototype.autoSizeCellsOnAdd = false;\n\n/**\n * Variable: autoScroll\n *\n * Specifies if the graph should automatically scroll if the mouse goes near\n * the container edge while dragging. This is only taken into account if the\n * container has scrollbars. Default is true.\n *\n * If you need this to work without scrollbars then set <ignoreScrollbars> to\n * true. Please consult the <ignoreScrollbars> for details. In general, with\n * no scrollbars, the use of <allowAutoPanning> is recommended.\n */\nmxGraph.prototype.autoScroll = true;\n\n/**\n * Variable: ignoreScrollbars\n *\n * Specifies if the graph should automatically scroll regardless of the\n * scrollbars. This will scroll the container using positive values for\n * scroll positions (ie usually only rightwards and downwards). To avoid\n * possible conflicts with panning, set <translateToScrollPosition> to true.\n */\nmxGraph.prototype.ignoreScrollbars = false;\n\n/**\n * Variable: translateToScrollPosition\n *\n * Specifies if the graph should automatically convert the current scroll\n * position to a translate in the graph view when a mouseUp event is received.\n * This can be used to avoid conflicts when using <autoScroll> and\n * <ignoreScrollbars> with no scrollbars in the container.\n */\nmxGraph.prototype.translateToScrollPosition = false;\n\n/**\n * Variable: timerAutoScroll\n *\n * Specifies if autoscrolling should be carried out via mxPanningManager even\n * if the container has scrollbars. This disables <scrollPointToVisible> and\n * uses <mxPanningManager> instead. If this is true then <autoExtend> is\n * disabled. It should only be used with a scroll buffer or when scollbars\n * are visible and scrollable in all directions. Default is false.\n */\nmxGraph.prototype.timerAutoScroll = false;\n\n/**\n * Variable: allowAutoPanning\n *\n * Specifies if panning via <panGraph> should be allowed to implement autoscroll\n * if no scrollbars are available in <scrollPointToVisible>. To enable panning\n * inside the container, near the edge, set <mxPanningManager.border> to a\n * positive value. Default is false.\n */\nmxGraph.prototype.allowAutoPanning = false;\n\n/**\n * Variable: autoExtend\n *\n * Specifies if the size of the graph should be automatically extended if the\n * mouse goes near the container edge while dragging. This is only taken into\n * account if the container has scrollbars. Default is true. See <autoScroll>.\n */\nmxGraph.prototype.autoExtend = true;\n\n/**\n * Variable: maximumGraphBounds\n *\n * <mxRectangle> that specifies the area in which all cells in the diagram\n * should be placed. Uses in <getMaximumGraphBounds>. Use a width or height of\n * 0 if you only want to give a upper, left corner.\n */\nmxGraph.prototype.maximumGraphBounds = null;\n\n/**\n * Variable: minimumGraphSize\n *\n * <mxRectangle> that specifies the minimum size of the graph. This is ignored\n * if the graph container has no scrollbars. Default is null.\n */\nmxGraph.prototype.minimumGraphSize = null;\n\n/**\n * Variable: minimumContainerSize\n *\n * <mxRectangle> that specifies the minimum size of the <container> if\n * <resizeContainer> is true.\n */\nmxGraph.prototype.minimumContainerSize = null;\n\n/**\n * Variable: maximumContainerSize\n *\n * <mxRectangle> that specifies the maximum size of the container if\n * <resizeContainer> is true.\n */\nmxGraph.prototype.maximumContainerSize = null;\n\n/**\n * Variable: resizeContainer\n *\n * Specifies if the container should be resized to the graph size when\n * the graph size has changed. Default is false.\n */\nmxGraph.prototype.resizeContainer = false;\n\n/**\n * Variable: border\n *\n * Border to be added to the bottom and right side when the container is\n * being resized after the graph has been changed. Default is 0.\n */\nmxGraph.prototype.border = 0;\n\n/**\n * Variable: keepEdgesInForeground\n *\n * Specifies if edges should appear in the foreground regardless of their order\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\n * both true then the normal order is applied. Default is false.\n */\nmxGraph.prototype.keepEdgesInForeground = false;\n\n/**\n * Variable: keepEdgesInBackground\n *\n * Specifies if edges should appear in the background regardless of their order\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\n * both true then the normal order is applied. Default is false.\n */\nmxGraph.prototype.keepEdgesInBackground = false;\n\n/**\n * Variable: allowNegativeCoordinates\n *\n * Specifies if negative coordinates for vertices are allowed. Default is true.\n */\nmxGraph.prototype.allowNegativeCoordinates = true;\n\n/**\n * Variable: constrainChildren\n *\n * Specifies if a child should be constrained inside the parent bounds after a\n * move or resize of the child. Default is true.\n */\nmxGraph.prototype.constrainChildren = true;\n\n/**\n * Variable: constrainRelativeChildren\n *\n * Specifies if child cells with relative geometries should be constrained\n * inside the parent bounds, if <constrainChildren> is true, and/or the\n * <maximumGraphBounds>. Default is false.\n */\nmxGraph.prototype.constrainRelativeChildren = false;\n\n/**\n * Variable: extendParents\n *\n * Specifies if a parent should contain the child bounds after a resize of\n * the child. Default is true. This has precedence over <constrainChildren>.\n */\nmxGraph.prototype.extendParents = true;\n\n/**\n * Variable: extendParentsOnAdd\n *\n * Specifies if parents should be extended according to the <extendParents>\n * switch if cells are added. Default is true.\n */\nmxGraph.prototype.extendParentsOnAdd = true;\n\n/**\n * Variable: extendParentsOnAdd\n *\n * Specifies if parents should be extended according to the <extendParents>\n * switch if cells are added. Default is false for backwards compatiblity.\n */\nmxGraph.prototype.extendParentsOnMove = false;\n\n/**\n * Variable: recursiveResize\n *\n * Specifies the return value for <isRecursiveResize>. Default is\n * false for backwards compatiblity.\n */\nmxGraph.prototype.recursiveResize = false;\n\n/**\n * Variable: collapseToPreferredSize\n *\n * Specifies if the cell size should be changed to the preferred size when\n * a cell is first collapsed. Default is true.\n */\nmxGraph.prototype.collapseToPreferredSize = true;\n\n/**\n * Variable: zoomFactor\n *\n * Specifies the factor used for <zoomIn> and <zoomOut>. Default is 1.2\n * (120%).\n */\nmxGraph.prototype.zoomFactor = 1.2;\n\n/**\n * Variable: keepSelectionVisibleOnZoom\n *\n * Specifies if the viewport should automatically contain the selection cells\n * after a zoom operation. Default is false.\n */\nmxGraph.prototype.keepSelectionVisibleOnZoom = false;\n\n/**\n * Variable: centerZoom\n *\n * Specifies if the zoom operations should go into the center of the actual\n * diagram rather than going from top, left. Default is true.\n */\nmxGraph.prototype.centerZoom = true;\n\n/**\n * Variable: resetViewOnRootChange\n *\n * Specifies if the scale and translate should be reset if the root changes in\n * the model. Default is true.\n */\nmxGraph.prototype.resetViewOnRootChange = true;\n\n/**\n * Variable: resetEdgesOnResize\n *\n * Specifies if edge control points should be reset after the resize of a\n * connected cell. Default is false.\n */\nmxGraph.prototype.resetEdgesOnResize = false;\n\n/**\n * Variable: resetEdgesOnMove\n *\n * Specifies if edge control points should be reset after the move of a\n * connected cell. Default is false.\n */\nmxGraph.prototype.resetEdgesOnMove = false;\n\n/**\n * Variable: resetEdgesOnConnect\n *\n * Specifies if edge control points should be reset after the the edge has been\n * reconnected. Default is true.\n */\nmxGraph.prototype.resetEdgesOnConnect = true;\n\n/**\n * Variable: allowLoops\n *\n * Specifies if loops (aka self-references) are allowed. Default is false.\n */\nmxGraph.prototype.allowLoops = false;\n\n/**\n * Variable: defaultLoopStyle\n *\n * <mxEdgeStyle> to be used for loops. This is a fallback for loops if the\n * <mxConstants.STYLE_LOOP> is undefined. Default is <mxEdgeStyle.Loop>.\n */\nmxGraph.prototype.defaultLoopStyle = mxEdgeStyle.Loop;\n\n/**\n * Variable: multigraph\n *\n * Specifies if multiple edges in the same direction between the same pair of\n * vertices are allowed. Default is true.\n */\nmxGraph.prototype.multigraph = true;\n\n/**\n * Variable: connectableEdges\n *\n * Specifies if edges are connectable. Default is false. This overrides the\n * connectable field in edges.\n */\nmxGraph.prototype.connectableEdges = false;\n\n/**\n * Variable: allowDanglingEdges\n *\n * Specifies if edges with disconnected terminals are allowed in the graph.\n * Default is true.\n */\nmxGraph.prototype.allowDanglingEdges = true;\n\n/**\n * Variable: cloneInvalidEdges\n *\n * Specifies if edges that are cloned should be validated and only inserted\n * if they are valid. Default is true.\n */\nmxGraph.prototype.cloneInvalidEdges = false;\n\n/**\n * Variable: disconnectOnMove\n *\n * Specifies if edges should be disconnected from their terminals when they\n * are moved. Default is true.\n */\nmxGraph.prototype.disconnectOnMove = true;\n\n/**\n * Variable: labelsVisible\n *\n * Specifies if labels should be visible. This is used in <getLabel>. Default\n * is true.\n */\nmxGraph.prototype.labelsVisible = true;\n\n/**\n * Variable: htmlLabels\n *\n * Specifies the return value for <isHtmlLabel>. Default is false.\n */\nmxGraph.prototype.htmlLabels = false;\n\n/**\n * Variable: swimlaneSelectionEnabled\n *\n * Specifies if swimlanes should be selectable via the content if the\n * mouse is released. Default is true.\n */\nmxGraph.prototype.swimlaneSelectionEnabled = true;\n\n/**\n * Variable: swimlaneNesting\n *\n * Specifies if nesting of swimlanes is allowed. Default is true.\n */\nmxGraph.prototype.swimlaneNesting = true;\n\n/**\n * Variable: swimlaneIndicatorColorAttribute\n *\n * The attribute used to find the color for the indicator if the indicator\n * color is set to 'swimlane'. Default is <mxConstants.STYLE_FILLCOLOR>.\n */\nmxGraph.prototype.swimlaneIndicatorColorAttribute = mxConstants.STYLE_FILLCOLOR;\n\n/**\n * Variable: imageBundles\n *\n * Holds the list of image bundles.\n */\nmxGraph.prototype.imageBundles = null;\n\n/**\n * Variable: minFitScale\n *\n * Specifies the minimum scale to be applied in <fit>. Default is 0.1. Set this\n * to null to allow any value.\n */\nmxGraph.prototype.minFitScale = 0.1;\n\n/**\n * Variable: maxFitScale\n *\n * Specifies the maximum scale to be applied in <fit>. Default is 8. Set this\n * to null to allow any value.\n */\nmxGraph.prototype.maxFitScale = 8;\n\n/**\n * Variable: panDx\n *\n * Current horizontal panning value. Default is 0.\n */\nmxGraph.prototype.panDx = 0;\n\n/**\n * Variable: panDy\n *\n * Current vertical panning value. Default is 0.\n */\nmxGraph.prototype.panDy = 0;\n\n/**\n * Variable: collapsedImage\n *\n * Specifies the <mxImage> to indicate a collapsed state.\n * Default value is mxClient.imageBasePath + '/collapsed.gif'\n */\nmxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + '/collapsed.gif', 9, 9);\n\n/**\n * Variable: expandedImage\n *\n * Specifies the <mxImage> to indicate a expanded state.\n * Default value is mxClient.imageBasePath + '/expanded.gif'\n */\nmxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + '/expanded.gif', 9, 9);\n\n/**\n * Variable: warningImage\n *\n * Specifies the <mxImage> for the image to be used to display a warning\n * overlay. See <setCellWarning>. Default value is mxClient.imageBasePath +\n * '/warning'.  The extension for the image depends on the platform. It is\n * '.png' on the Mac and '.gif' on all other platforms.\n */\nmxGraph.prototype.warningImage = new mxImage(mxClient.imageBasePath + '/warning'+\n\t((mxClient.IS_MAC) ? '.png' : '.gif'), 16, 16);\n\n/**\n * Variable: alreadyConnectedResource\n *\n * Specifies the resource key for the error message to be displayed in\n * non-multigraphs when two vertices are already connected. If the resource\n * for this key does not exist then the value is used as the error message.\n * Default is 'alreadyConnected'.\n */\nmxGraph.prototype.alreadyConnectedResource = (mxClient.language != 'none') ? 'alreadyConnected' : '';\n\n/**\n * Variable: containsValidationErrorsResource\n *\n * Specifies the resource key for the warning message to be displayed when\n * a collapsed cell contains validation errors. If the resource for this\n * key does not exist then the value is used as the warning message.\n * Default is 'containsValidationErrors'.\n */\nmxGraph.prototype.containsValidationErrorsResource = (mxClient.language != 'none') ? 'containsValidationErrors' : '';\n\n/**\n * Variable: collapseExpandResource\n *\n * Specifies the resource key for the tooltip on the collapse/expand icon.\n * If the resource for this key does not exist then the value is used as\n * the tooltip. Default is 'collapse-expand'.\n */\nmxGraph.prototype.collapseExpandResource = (mxClient.language != 'none') ? 'collapse-expand' : '';\n\n/**\n * Function: init\n *\n * Initializes the <container> and creates the respective datastructures.\n *\n * Parameters:\n *\n * container - DOM node that will contain the graph display.\n */\nmxGraph.prototype.init = function(container)\n{\n\tthis.container = container;\n\n\t// Initializes the in-place editor\n\tthis.cellEditor = this.createCellEditor();\n\n\t// Initializes the container using the view\n\tthis.view.init();\n\n\t// Updates the size of the container for the current graph\n\tthis.sizeDidChange();\n\n\t// Hides tooltips and resets tooltip timer if mouse leaves container\n\tmxEvent.addListener(container, 'mouseleave', mxUtils.bind(this, function()\n\t{\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.hide();\n\t\t}\n\t}));\n\n\t// Automatic deallocation of memory\n\tif (mxClient.IS_IE)\n\t{\n\t\tmxEvent.addListener(window, 'unload', mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.destroy();\n\t\t}));\n\n\t\t// Disable shift-click for text\n\t\tmxEvent.addListener(container, 'selectstart',\n\t\t\tmxUtils.bind(this, function(evt)\n\t\t\t{\n\t\t\t\treturn this.isEditing() || (!this.isMouseDown && !mxEvent.isShiftDown(evt));\n\t\t\t})\n\t\t);\n\t}\n\n\t// Workaround for missing last shape and connect preview in IE8 standards\n\t// mode if no initial graph displayed or no label for shape defined\n\tif (document.documentMode == 8)\n\t{\n\t\tcontainer.insertAdjacentHTML('beforeend', '<' + mxClient.VML_PREFIX + ':group' +\n\t\t\t' style=\"DISPLAY: none;\"></' + mxClient.VML_PREFIX + ':group>');\n\t}\n};\n\n/**\n * Function: createHandlers\n *\n * Creates the tooltip-, panning-, connection- and graph-handler (in this\n * order). This is called in the constructor before <init> is called.\n */\nmxGraph.prototype.createHandlers = function()\n{\n\tthis.tooltipHandler = this.createTooltipHandler();\n\tthis.tooltipHandler.setEnabled(false);\n\tthis.selectionCellsHandler = this.createSelectionCellsHandler();\n\tthis.connectionHandler = this.createConnectionHandler();\n\tthis.connectionHandler.setEnabled(false);\n\tthis.graphHandler = this.createGraphHandler();\n\tthis.panningHandler = this.createPanningHandler();\n\tthis.panningHandler.panningEnabled = false;\n\tthis.popupMenuHandler = this.createPopupMenuHandler();\n};\n\n/**\n * Function: createTooltipHandler\n *\n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\n */\nmxGraph.prototype.createTooltipHandler = function()\n{\n\treturn new mxTooltipHandler(this);\n};\n\n/**\n * Function: createSelectionCellsHandler\n *\n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\n */\nmxGraph.prototype.createSelectionCellsHandler = function()\n{\n\treturn new mxSelectionCellsHandler(this);\n};\n\n/**\n * Function: createConnectionHandler\n *\n * Creates and returns a new <mxConnectionHandler> to be used in this graph.\n */\nmxGraph.prototype.createConnectionHandler = function()\n{\n\treturn new mxConnectionHandler(this);\n};\n\n/**\n * Function: createGraphHandler\n *\n * Creates and returns a new <mxGraphHandler> to be used in this graph.\n */\nmxGraph.prototype.createGraphHandler = function()\n{\n\treturn new mxGraphHandler(this);\n};\n\n/**\n * Function: createPanningHandler\n *\n * Creates and returns a new <mxPanningHandler> to be used in this graph.\n */\nmxGraph.prototype.createPanningHandler = function()\n{\n\treturn new mxPanningHandler(this);\n};\n\n/**\n * Function: createPopupMenuHandler\n *\n * Creates and returns a new <mxPopupMenuHandler> to be used in this graph.\n */\nmxGraph.prototype.createPopupMenuHandler = function()\n{\n\treturn new mxPopupMenuHandler(this);\n};\n\n/**\n * Function: createSelectionModel\n *\n * Creates a new <mxGraphSelectionModel> to be used in this graph.\n */\nmxGraph.prototype.createSelectionModel = function()\n{\n\treturn new mxGraphSelectionModel(this);\n};\n\n/**\n * Function: createStylesheet\n *\n * Creates a new <mxGraphSelectionModel> to be used in this graph.\n */\nmxGraph.prototype.createStylesheet = function()\n{\n\treturn new mxStylesheet();\n};\n\n/**\n * Function: createGraphView\n *\n * Creates a new <mxGraphView> to be used in this graph.\n */\nmxGraph.prototype.createGraphView = function()\n{\n\treturn new mxGraphView(this);\n};\n\n/**\n * Function: createCellRenderer\n *\n * Creates a new <mxCellRenderer> to be used in this graph.\n */\nmxGraph.prototype.createCellRenderer = function()\n{\n\treturn new mxCellRenderer();\n};\n\n/**\n * Function: createCellEditor\n *\n * Creates a new <mxCellEditor> to be used in this graph.\n */\nmxGraph.prototype.createCellEditor = function()\n{\n\treturn new mxCellEditor(this);\n};\n\n/**\n * Function: getModel\n *\n * Returns the <mxGraphModel> that contains the cells.\n */\nmxGraph.prototype.getModel = function()\n{\n\treturn this.model;\n};\n\n/**\n * Function: getView\n *\n * Returns the <mxGraphView> that contains the <mxCellStates>.\n */\nmxGraph.prototype.getView = function()\n{\n\treturn this.view;\n};\n\n/**\n * Function: getStylesheet\n *\n * Returns the <mxStylesheet> that defines the style.\n */\nmxGraph.prototype.getStylesheet = function()\n{\n\treturn this.stylesheet;\n};\n\n/**\n * Function: setStylesheet\n *\n * Sets the <mxStylesheet> that defines the style.\n */\nmxGraph.prototype.setStylesheet = function(stylesheet)\n{\n\tthis.stylesheet = stylesheet;\n};\n\n/**\n * Function: getSelectionModel\n *\n * Returns the <mxGraphSelectionModel> that contains the selection.\n */\nmxGraph.prototype.getSelectionModel = function()\n{\n\treturn this.selectionModel;\n};\n\n/**\n * Function: setSelectionModel\n *\n * Sets the <mxSelectionModel> that contains the selection.\n */\nmxGraph.prototype.setSelectionModel = function(selectionModel)\n{\n\tthis.selectionModel = selectionModel;\n};\n\n/**\n * Function: getSelectionCellsForChanges\n *\n * Returns the cells to be selected for the given array of changes.\n */\nmxGraph.prototype.getSelectionCellsForChanges = function(changes)\n{\n\tvar dict = new mxDictionary();\n\tvar cells = [];\n\n\tvar addCell = mxUtils.bind(this, function(cell)\n\t{\n\t\tif (!dict.get(cell) && this.model.contains(cell))\n\t\t{\n\t\t\tif (this.model.isEdge(cell) || this.model.isVertex(cell))\n\t\t\t{\n\t\t\t\tdict.put(cell, true);\n\t\t\t\tcells.push(cell);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar childCount = this.model.getChildCount(cell);\n\n\t\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t\t{\n\t\t\t\t\taddCell(this.model.getChildAt(cell, i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tvar change = changes[i];\n\n\t\tif (change.constructor != mxRootChange)\n\t\t{\n\t\t\tvar cell = null;\n\n\t\t\tif (change instanceof mxChildChange)\n\t\t\t{\n\t\t\t\tcell = change.child;\n\t\t\t}\n\t\t\telse if (change.cell != null && change.cell instanceof mxCell)\n\t\t\t{\n\t\t\t\tcell = change.cell;\n\t\t\t}\n\n\t\t\tif (cell != null)\n\t\t\t{\n\t\t\t\taddCell(cell);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: graphModelChanged\n *\n * Called when the graph model changes. Invokes <processChange> on each\n * item of the given array to update the view accordingly.\n *\n * Parameters:\n *\n * changes - Array that contains the individual changes.\n */\nmxGraph.prototype.graphModelChanged = function(changes)\n{\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tthis.processChange(changes[i]);\n\t}\n\n\tthis.updateSelection();\n\tthis.view.validate();\n\tthis.sizeDidChange();\n};\n\n/**\n * Function: updateSelection\n *\n * Removes selection cells that are not in the model from the selection.\n */\nmxGraph.prototype.updateSelection = function()\n{\n\tvar cells = this.getSelectionCells();\n\tvar removed = [];\n\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (!this.model.contains(cells[i]) || !this.isCellVisible(cells[i]))\n\t\t{\n\t\t\tremoved.push(cells[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar par = this.model.getParent(cells[i]);\n\n\t\t\twhile (par != null && par != this.view.currentRoot)\n\t\t\t{\n\t\t\t\tif (this.isCellCollapsed(par) || !this.isCellVisible(par))\n\t\t\t\t{\n\t\t\t\t\tremoved.push(cells[i]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tpar = this.model.getParent(par);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.removeSelectionCells(removed);\n};\n\n/**\n * Function: processChange\n *\n * Processes the given change and invalidates the respective cached data\n * in <view>. This fires a <root> event if the root has changed in the\n * model.\n *\n * Parameters:\n *\n * change - Object that represents the change on the model.\n */\nmxGraph.prototype.processChange = function(change)\n{\n\t// Resets the view settings, removes all cells and clears\n\t// the selection if the root changes.\n\tif (change instanceof mxRootChange)\n\t{\n\t\tthis.clearSelection();\n\t\tthis.setDefaultParent(null);\n\t\tthis.removeStateForCell(change.previous);\n\n\t\tif (this.resetViewOnRootChange)\n\t\t{\n\t\t\tthis.view.scale = 1;\n\t\t\tthis.view.translate.x = 0;\n\t\t\tthis.view.translate.y = 0;\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ROOT));\n\t}\n\n\t// Adds or removes a child to the view by online invaliding\n\t// the minimal required portions of the cache, namely, the\n\t// old and new parent and the child.\n\telse if (change instanceof mxChildChange)\n\t{\n\t\tvar newParent = this.model.getParent(change.child);\n\t\tthis.view.invalidate(change.child, true, true);\n\n\t\tif (!this.model.contains(newParent) || this.isCellCollapsed(newParent))\n\t\t{\n\t\t\tthis.view.invalidate(change.child, true, true);\n\t\t\tthis.removeStateForCell(change.child);\n\n\t\t\t// Handles special case of current root of view being removed\n\t\t\tif (this.view.currentRoot == change.child)\n\t\t\t{\n\t\t\t\tthis.home();\n\t\t\t}\n\t\t}\n\n\t\tif (newParent != change.previous)\n\t\t{\n\t\t\t// Refreshes the collapse/expand icons on the parents\n\t\t\tif (newParent != null)\n\t\t\t{\n\t\t\t\tthis.view.invalidate(newParent, false, false);\n\t\t\t}\n\n\t\t\tif (change.previous != null)\n\t\t\t{\n\t\t\t\tthis.view.invalidate(change.previous, false, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Handles two special cases where the shape does not need to be\n\t// recreated from scratch, it only needs to be invalidated.\n\telse if (change instanceof mxTerminalChange || change instanceof mxGeometryChange)\n\t{\n\t\t// Checks if the geometry has changed to avoid unnessecary revalidation\n\t\tif (change instanceof mxTerminalChange || ((change.previous == null && change.geometry != null) ||\n\t\t\t(change.previous != null && !change.previous.equals(change.geometry))))\n\t\t{\n\t\t\tthis.view.invalidate(change.cell);\n\t\t}\n\t}\n\n\t// Handles two special cases where only the shape, but no\n\t// descendants need to be recreated\n\telse if (change instanceof mxValueChange)\n\t{\n\t\tthis.view.invalidate(change.cell, false, false);\n\t}\n\n\t// Requires a new mxShape in JavaScript\n\telse if (change instanceof mxStyleChange)\n\t{\n\t\tthis.view.invalidate(change.cell, true, true);\n\t\tvar state = this.view.getState(change.cell);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tstate.invalidStyle = true;\n\t\t}\n\t}\n\n\t// Removes the state from the cache by default\n\telse if (change.cell != null && change.cell instanceof mxCell)\n\t{\n\t\tthis.removeStateForCell(change.cell);\n\t}\n};\n\n/**\n * Function: removeStateForCell\n *\n * Removes all cached information for the given cell and its descendants.\n * This is called when a cell was removed from the model.\n *\n * Paramters:\n *\n * cell - <mxCell> that was removed from the model.\n */\nmxGraph.prototype.removeStateForCell = function(cell)\n{\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.removeStateForCell(this.model.getChildAt(cell, i));\n\t}\n\n\tthis.view.invalidate(cell, false, true);\n\tthis.view.removeState(cell);\n};\n\n/**\n * Group: Overlays\n */\n\n/**\n * Function: addCellOverlay\n *\n * Adds an <mxCellOverlay> for the specified cell. This method fires an\n * <addoverlay> event and returns the new <mxCellOverlay>.\n *\n * Parameters:\n *\n * cell - <mxCell> to add the overlay for.\n * overlay - <mxCellOverlay> to be added for the cell.\n */\nmxGraph.prototype.addCellOverlay = function(cell, overlay)\n{\n\tif (cell.overlays == null)\n\t{\n\t\tcell.overlays = [];\n\t}\n\n\tcell.overlays.push(overlay);\n\n\tvar state = this.view.getState(cell);\n\n\t// Immediately updates the cell display if the state exists\n\tif (state != null)\n\t{\n\t\tthis.cellRenderer.redraw(state);\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.ADD_OVERLAY,\n\t\t\t'cell', cell, 'overlay', overlay));\n\n\treturn overlay;\n};\n\n/**\n * Function: getCellOverlays\n *\n * Returns the array of <mxCellOverlays> for the given cell or null, if\n * no overlays are defined.\n *\n * Parameters:\n *\n * cell - <mxCell> whose overlays should be returned.\n */\nmxGraph.prototype.getCellOverlays = function(cell)\n{\n\treturn cell.overlays;\n};\n\n/**\n * Function: removeCellOverlay\n *\n * Removes and returns the given <mxCellOverlay> from the given cell. This\n * method fires a <removeoverlay> event. If no overlay is given, then all\n * overlays are removed using <removeOverlays>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose overlay should be removed.\n * overlay - Optional <mxCellOverlay> to be removed.\n */\nmxGraph.prototype.removeCellOverlay = function(cell, overlay)\n{\n\tif (overlay == null)\n\t{\n\t\tthis.removeCellOverlays(cell);\n\t}\n\telse\n\t{\n\t\tvar index = mxUtils.indexOf(cell.overlays, overlay);\n\n\t\tif (index >= 0)\n\t\t{\n\t\t\tcell.overlays.splice(index, 1);\n\n\t\t\tif (cell.overlays.length == 0)\n\t\t\t{\n\t\t\t\tcell.overlays = null;\n\t\t\t}\n\n\t\t\t// Immediately updates the cell display if the state exists\n\t\t\tvar state = this.view.getState(cell);\n\n\t\t\tif (state != null)\n\t\t\t{\n\t\t\t\tthis.cellRenderer.redraw(state);\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY,\n\t\t\t\t\t'cell', cell, 'overlay', overlay));\n\t\t}\n\t\telse\n\t\t{\n\t\t\toverlay = null;\n\t\t}\n\t}\n\n\treturn overlay;\n};\n\n/**\n * Function: removeCellOverlays\n *\n * Removes all <mxCellOverlays> from the given cell. This method\n * fires a <removeoverlay> event for each <mxCellOverlay> and returns\n * the array of <mxCellOverlays> that was removed from the cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose overlays should be removed\n */\nmxGraph.prototype.removeCellOverlays = function(cell)\n{\n\tvar overlays = cell.overlays;\n\n\tif (overlays != null)\n\t{\n\t\tcell.overlays = null;\n\n\t\t// Immediately updates the cell display if the state exists\n\t\tvar state = this.view.getState(cell);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.cellRenderer.redraw(state);\n\t\t}\n\n\t\tfor (var i = 0; i < overlays.length; i++)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_OVERLAY,\n\t\t\t\t\t'cell', cell, 'overlay', overlays[i]));\n\t\t}\n\t}\n\n\treturn overlays;\n};\n\n/**\n * Function: clearCellOverlays\n *\n * Removes all <mxCellOverlays> in the graph for the given cell and all its\n * descendants. If no cell is specified then all overlays are removed from\n * the graph. This implementation uses <removeCellOverlays> to remove the\n * overlays from the individual cells.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> that represents the root of the subtree to\n * remove the overlays from. Default is the root in the model.\n */\nmxGraph.prototype.clearCellOverlays = function(cell)\n{\n\tcell = (cell != null) ? cell : this.model.getRoot();\n\tthis.removeCellOverlays(cell);\n\n\t// Recursively removes all overlays from the children\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.model.getChildAt(cell, i);\n\t\tthis.clearCellOverlays(child); // recurse\n\t}\n};\n\n/**\n * Function: setCellWarning\n *\n * Creates an overlay for the given cell using the warning and image or\n * <warningImage> and returns the new <mxCellOverlay>. The warning is\n * displayed as a tooltip in a red font and may contain HTML markup. If\n * the warning is null or a zero length string, then all overlays are\n * removed from the cell.\n *\n * Example:\n *\n * (code)\n * graph.setCellWarning(cell, '<b>Warning:</b>: Hello, World!');\n * (end)\n *\n * Parameters:\n *\n * cell - <mxCell> whose warning should be set.\n * warning - String that represents the warning to be displayed.\n * img - Optional <mxImage> to be used for the overlay. Default is\n * <warningImage>.\n * isSelect - Optional boolean indicating if a click on the overlay\n * should select the corresponding cell. Default is false.\n */\nmxGraph.prototype.setCellWarning = function(cell, warning, img, isSelect)\n{\n\tif (warning != null && warning.length > 0)\n\t{\n\t\timg = (img != null) ? img : this.warningImage;\n\n\t\t// Creates the overlay with the image and warning\n\t\tvar overlay = new mxCellOverlay(img,\n\t\t\t'<font color=red>'+warning+'</font>');\n\n\t\t// Adds a handler for single mouseclicks to select the cell\n\t\tif (isSelect)\n\t\t{\n\t\t\toverlay.addListener(mxEvent.CLICK,\n\t\t\t\tmxUtils.bind(this, function(sender, evt)\n\t\t\t\t{\n\t\t\t\t\tif (this.isEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setSelectionCell(cell);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\t// Sets and returns the overlay in the graph\n\t\treturn this.addCellOverlay(cell, overlay);\n\t}\n\telse\n\t{\n\t\tthis.removeCellOverlays(cell);\n\t}\n\n\treturn null;\n};\n\n/**\n * Group: In-place editing\n */\n\n/**\n * Function: startEditing\n *\n * Calls <startEditingAtCell> using the given cell or the first selection\n * cell.\n *\n * Parameters:\n *\n * evt - Optional mouse event that triggered the editing.\n */\nmxGraph.prototype.startEditing = function(evt)\n{\n\tthis.startEditingAtCell(null, evt);\n};\n\n/**\n * Function: startEditingAtCell\n *\n * Fires a <startEditing> event and invokes <mxCellEditor.startEditing>\n * on <editor>. After editing was started, a <editingStarted> event is\n * fired.\n *\n * Parameters:\n *\n * cell - <mxCell> to start the in-place editor for.\n * evt - Optional mouse event that triggered the editing.\n */\nmxGraph.prototype.startEditingAtCell = function(cell, evt)\n{\n\tif (evt == null || !mxEvent.isMultiTouchEvent(evt))\n\t{\n\t\tif (cell == null)\n\t\t{\n\t\t\tcell = this.getSelectionCell();\n\n\t\t\tif (cell != null && !this.isCellEditable(cell))\n\t\t\t{\n\t\t\t\tcell = null;\n\t\t\t}\n\t\t}\n\n\t\tif (cell != null)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.START_EDITING,\n\t\t\t\t\t'cell', cell, 'event', evt));\n\t\t\tthis.cellEditor.startEditing(cell, evt);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.EDITING_STARTED,\n\t\t\t\t\t'cell', cell, 'event', evt));\n\t\t}\n\t}\n};\n\n/**\n * Function: getEditingValue\n *\n * Returns the initial value for in-place editing. This implementation\n * returns <convertValueToString> for the given cell. If this function is\n * overridden, then <mxGraphModel.valueForCellChanged> should take care\n * of correctly storing the actual new value inside the user object.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the initial editing value should be returned.\n * evt - Optional mouse event that triggered the editor.\n */\nmxGraph.prototype.getEditingValue = function(cell, evt)\n{\n\treturn this.convertValueToString(cell);\n};\n\n/**\n * Function: stopEditing\n *\n * Stops the current editing  and fires a <editingStopped> event.\n *\n * Parameters:\n *\n * cancel - Boolean that specifies if the current editing value\n * should be stored.\n */\nmxGraph.prototype.stopEditing = function(cancel)\n{\n\tthis.cellEditor.stopEditing(cancel);\n\tthis.fireEvent(new mxEventObject(mxEvent.EDITING_STOPPED, 'cancel', cancel));\n};\n\n/**\n * Function: labelChanged\n *\n * Sets the label of the specified cell to the given value using\n * <cellLabelChanged> and fires <mxEvent.LABEL_CHANGED> while the\n * transaction is in progress. Returns the cell whose label was changed.\n *\n * Parameters:\n *\n * cell - <mxCell> whose label should be changed.\n * value - New label to be assigned.\n * evt - Optional event that triggered the change.\n */\nmxGraph.prototype.labelChanged = function(cell, value, evt)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar old = cell.value;\n\t\tthis.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n\t\tthis.fireEvent(new mxEventObject(mxEvent.LABEL_CHANGED,\n\t\t\t'cell', cell, 'value', value, 'old', old, 'event', evt));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cell;\n};\n\n/**\n * Function: cellLabelChanged\n *\n * Sets the new label for a cell. If autoSize is true then\n * <cellSizeUpdated> will be called.\n *\n * In the following example, the function is extended to map changes to\n * attributes in an XML node, as shown in <convertValueToString>.\n * Alternatively, the handling of this can be implemented as shown in\n * <mxGraphModel.valueForCellChanged> without the need to clone the\n * user object.\n *\n * (code)\n * var graphCellLabelChanged = graph.cellLabelChanged;\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\n * {\n * \t// Cloned for correct undo/redo\n * \tvar elt = cell.value.cloneNode(true);\n *  elt.setAttribute('label', newValue);\n *\n *  newValue = elt;\n *  graphCellLabelChanged.apply(this, arguments);\n * };\n * (end)\n *\n * Parameters:\n *\n * cell - <mxCell> whose label should be changed.\n * value - New label to be assigned.\n * autoSize - Boolean that specifies if <cellSizeUpdated> should be called.\n */\nmxGraph.prototype.cellLabelChanged = function(cell, value, autoSize)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.model.setValue(cell, value);\n\n\t\tif (autoSize)\n\t\t{\n\t\t\tthis.cellSizeUpdated(cell, false);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n};\n\n/**\n * Group: Event processing\n */\n\n/**\n * Function: escape\n *\n * Processes an escape keystroke.\n *\n * Parameters:\n *\n * evt - Mouseevent that represents the keystroke.\n */\nmxGraph.prototype.escape = function(evt)\n{\n\tthis.fireEvent(new mxEventObject(mxEvent.ESCAPE, 'event', evt));\n};\n\n/**\n * Function: click\n *\n * Processes a singleclick on an optional cell and fires a <click> event.\n * The click event is fired initially. If the graph is enabled and the\n * event has not been consumed, then the cell is selected using\n * <selectCellForEvent> or the selection is cleared using\n * <clearSelection>. The events consumed state is set to true if the\n * corresponding <mxMouseEvent> has been consumed.\n *\n * To handle a click event, use the following code.\n *\n * (code)\n * graph.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var e = evt.getProperty('event'); // mouse event\n *   var cell = evt.getProperty('cell'); // cell may be null\n *\n *   if (cell != null)\n *   {\n *     // Do something useful with cell and consume the event\n *     evt.consume();\n *   }\n * });\n * (end)\n *\n * Parameters:\n *\n * me - <mxMouseEvent> that represents the single click.\n */\nmxGraph.prototype.click = function(me)\n{\n\tvar evt = me.getEvent();\n\tvar cell = me.getCell();\n\tvar mxe = new mxEventObject(mxEvent.CLICK, 'event', evt, 'cell', cell);\n\n\tif (me.isConsumed())\n\t{\n\t\tmxe.consume();\n\t}\n\n\tthis.fireEvent(mxe);\n\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n\t{\n\t\tif (cell != null)\n\t\t{\n\t\t\tif (this.isTransparentClickEvent(evt))\n\t\t\t{\n\t\t\t\tvar active = false;\n\n\t\t\t\tvar tmp = this.getCellAt(me.graphX, me.graphY, null, null, null, mxUtils.bind(this, function(state)\n\t\t\t\t{\n\t\t\t\t\tvar selected = this.isCellSelected(state.cell);\n\t\t\t\t\tactive = active || selected;\n\n\t\t\t\t\treturn !active || selected;\n\t\t\t\t}));\n\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tcell = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.selectCellForEvent(cell, evt);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar swimlane = null;\n\n\t\t\tif (this.isSwimlaneSelectionEnabled())\n\t\t\t{\n\t\t\t\t// Gets the swimlane at the location (includes\n\t\t\t\t// content area of swimlanes)\n\t\t\t\tswimlane = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n\t\t\t}\n\n\t\t\t// Selects the swimlane and consumes the event\n\t\t\tif (swimlane != null)\n\t\t\t{\n\t\t\t\tthis.selectCellForEvent(swimlane, evt);\n\t\t\t}\n\n\t\t\t// Ignores the event if the control key is pressed\n\t\t\telse if (!this.isToggleEvent(evt))\n\t\t\t{\n\t\t\t\tthis.clearSelection();\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: dblClick\n *\n * Processes a doubleclick on an optional cell and fires a <dblclick>\n * event. The event is fired initially. If the graph is enabled and the\n * event has not been consumed, then <edit> is called with the given\n * cell. The event is ignored if no cell was specified.\n *\n * Example for overriding this method.\n *\n * (code)\n * graph.dblClick = function(evt, cell)\n * {\n *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n *   this.fireEvent(mxe);\n *\n *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\n *   {\n * \t   mxUtils.alert('Hello, World!');\n *     mxe.consume();\n *   }\n * }\n * (end)\n *\n * Example listener for this event.\n *\n * (code)\n * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)\n * {\n *   var cell = evt.getProperty('cell');\n *   // do something with the cell and consume the\n *   // event to prevent in-place editing from start\n * });\n * (end)\n *\n * Parameters:\n *\n * evt - Mouseevent that represents the doubleclick.\n * cell - Optional <mxCell> under the mousepointer.\n */\nmxGraph.prototype.dblClick = function(evt, cell)\n{\n\tvar mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\n\tthis.fireEvent(mxe);\n\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() &&\n\t\tcell != null && this.isCellEditable(cell) && !this.isEditing(cell))\n\t{\n\t\tthis.startEditingAtCell(cell, evt);\n\t\tmxEvent.consume(evt);\n\t}\n};\n\n/**\n * Function: tapAndHold\n *\n * Handles the <mxMouseEvent> by highlighting the <mxCellState>.\n *\n * Parameters:\n *\n * me - <mxMouseEvent> that represents the touch event.\n * state - Optional <mxCellState> that is associated with the event.\n */\nmxGraph.prototype.tapAndHold = function(me)\n{\n\tvar evt = me.getEvent();\n\tvar mxe = new mxEventObject(mxEvent.TAP_AND_HOLD, 'event', evt, 'cell', me.getCell());\n\n\t// LATER: Check if event should be consumed if me is consumed\n\tthis.fireEvent(mxe);\n\n\tif (mxe.isConsumed())\n\t{\n\t\t// Resets the state of the panning handler\n\t\tthis.panningHandler.panningTrigger = false;\n\t}\n\n\t// Handles the event if it has not been consumed\n\tif (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed() && this.connectionHandler.isEnabled())\n\t{\n\t\tvar state = this.view.getState(this.connectionHandler.marker.getCell(me));\n\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;\n\t\t\tthis.connectionHandler.marker.markedState = state;\n\t\t\tthis.connectionHandler.marker.mark();\n\n\t\t\tthis.connectionHandler.first = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\tthis.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);\n\t\t\tthis.connectionHandler.previous = state;\n\t\t\tthis.connectionHandler.fireEvent(new mxEventObject(mxEvent.START, 'state', this.connectionHandler.previous));\n\t\t}\n\t}\n};\n\n/**\n * Function: scrollPointToVisible\n *\n * Scrolls the graph to the given point, extending the graph container if\n * specified.\n */\nmxGraph.prototype.scrollPointToVisible = function(x, y, extend, border)\n{\n\tif (!this.timerAutoScroll && (this.ignoreScrollbars || mxUtils.hasScrollbars(this.container)))\n\t{\n\t\tvar c = this.container;\n\t\tborder = (border != null) ? border : 20;\n\n\t\tif (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth &&\n\t\t\ty <= c.scrollTop + c.clientHeight)\n\t\t{\n\t\t\tvar dx = c.scrollLeft + c.clientWidth - x;\n\n\t\t\tif (dx < border)\n\t\t\t{\n\t\t\t\tvar old = c.scrollLeft;\n\t\t\t\tc.scrollLeft += border - dx;\n\n\t\t\t\t// Automatically extends the canvas size to the bottom, right\n\t\t\t\t// if the event is outside of the canvas and the edge of the\n\t\t\t\t// canvas has been reached. Notes: Needs fix for IE.\n\t\t\t\tif (extend && old == c.scrollLeft)\n\t\t\t\t{\n\t\t\t\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\t\t\tvar width = this.container.scrollWidth + border - dx;\n\n\t\t\t\t\t\t// Updates the clipping region. This is an expensive\n\t\t\t\t\t\t// operation that should not be executed too often.\n\t\t\t\t\t\troot.style.width = width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar width = Math.max(c.clientWidth, c.scrollWidth) + border - dx;\n\t\t\t\t\t\tvar canvas = this.view.getCanvas();\n\t\t\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\t\t}\n\n\t\t\t\t\tc.scrollLeft += border - dx;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdx = x - c.scrollLeft;\n\n\t\t\t\tif (dx < border)\n\t\t\t\t{\n\t\t\t\t\tc.scrollLeft -= border - dx;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dy = c.scrollTop + c.clientHeight - y;\n\n\t\t\tif (dy < border)\n\t\t\t{\n\t\t\t\tvar old = c.scrollTop;\n\t\t\t\tc.scrollTop += border - dy;\n\n\t\t\t\tif (old == c.scrollTop && extend)\n\t\t\t\t{\n\t\t\t\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\t\t\t\t\t\tvar height = this.container.scrollHeight + border - dy;\n\n\t\t\t\t\t\t// Updates the clipping region. This is an expensive\n\t\t\t\t\t\t// operation that should not be executed too often.\n\t\t\t\t\t\troot.style.height = height + 'px';\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar height = Math.max(c.clientHeight, c.scrollHeight) + border - dy;\n\t\t\t\t\t\tvar canvas = this.view.getCanvas();\n\t\t\t\t\t\tcanvas.style.height = height + 'px';\n\t\t\t\t\t}\n\n\t\t\t\t\tc.scrollTop += border - dy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdy = y - c.scrollTop;\n\n\t\t\t\tif (dy < border)\n\t\t\t\t{\n\t\t\t\t\tc.scrollTop -= border - dy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse if (this.allowAutoPanning && !this.panningHandler.isActive())\n\t{\n\t\tif (this.panningManager == null)\n\t\t{\n\t\t\tthis.panningManager = this.createPanningManager();\n\t\t}\n\n\t\tthis.panningManager.panTo(x + this.panDx, y + this.panDy);\n\t}\n};\n\n\n/**\n * Function: createPanningManager\n *\n * Creates and returns an <mxPanningManager>.\n */\nmxGraph.prototype.createPanningManager = function()\n{\n\treturn new mxPanningManager(this);\n};\n\n/**\n * Function: getBorderSizes\n *\n * Returns the size of the border and padding on all four sides of the\n * container. The left, top, right and bottom borders are stored in the x, y,\n * width and height of the returned <mxRectangle>, respectively.\n */\nmxGraph.prototype.getBorderSizes = function()\n{\n\tvar css = mxUtils.getCurrentStyle(this.container);\n\n\treturn new mxRectangle(mxUtils.parseCssNumber(css.paddingLeft) +\n\t\t\t((css.borderLeftStyle != 'none') ? mxUtils.parseCssNumber(css.borderLeftWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingTop) +\n\t\t\t((css.borderTopStyle != 'none') ? mxUtils.parseCssNumber(css.borderTopWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingRight) +\n\t\t\t((css.borderRightStyle != 'none') ? mxUtils.parseCssNumber(css.borderRightWidth) : 0),\n\t\tmxUtils.parseCssNumber(css.paddingBottom) +\n\t\t\t((css.borderBottomStyle != 'none') ? mxUtils.parseCssNumber(css.borderBottomWidth) : 0));\n};\n\n/**\n * Function: getPreferredPageSize\n *\n * Returns the preferred size of the background page if <preferPageSize> is true.\n */\nmxGraph.prototype.getPreferredPageSize = function(bounds, width, height)\n{\n\tvar scale = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar fmt = this.pageFormat;\n\tvar ps = this.pageScale;\n\tvar page = new mxRectangle(0, 0, Math.ceil(fmt.width * ps), Math.ceil(fmt.height * ps));\n\n\tvar hCount = (this.pageBreaksVisible) ? Math.ceil(width / page.width) : 1;\n\tvar vCount = (this.pageBreaksVisible) ? Math.ceil(height / page.height) : 1;\n\n\treturn new mxRectangle(0, 0, hCount * page.width + 2 + tr.x, vCount * page.height + 2 + tr.y);\n};\n\n/**\n * Function: fit\n *\n * Scales the graph such that the complete diagram fits into <container> and\n * returns the current scale in the view. To fit an initial graph prior to\n * rendering, set <mxGraphView.rendering> to false prior to changing the model\n * and execute the following after changing the model.\n *\n * (code)\n * graph.fit();\n * graph.view.rendering = true;\n * graph.refresh();\n * (end)\n *\n * To fit and center the graph, the following code can be used.\n *\n * (code)\n * var margin = 2;\n * var max = 3;\n *\n * var bounds = graph.getGraphBounds();\n * var cw = graph.container.clientWidth - margin;\n * var ch = graph.container.clientHeight - margin;\n * var w = bounds.width / graph.view.scale;\n * var h = bounds.height / graph.view.scale;\n * var s = Math.min(max, Math.min(cw / w, ch / h));\n *\n * graph.view.scaleAndTranslate(s,\n *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,\n *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);\n * (end)\n *\n * Parameters:\n *\n * border - Optional number that specifies the border. Default is <border>.\n * keepOrigin - Optional boolean that specifies if the translate should be\n * changed. Default is false.\n * margin - Optional margin in pixels. Default is 0.\n * enabled - Optional boolean that specifies if the scale should be set or\n * just returned. Default is true.\n * ignoreWidth - Optional boolean that specifies if the width should be\n * ignored. Default is false.\n * ignoreHeight - Optional boolean that specifies if the height should be\n * ignored. Default is false.\n * maxHeight - Optional maximum height.\n */\nmxGraph.prototype.fit = function(border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight, maxHeight)\n{\n\tif (this.container != null)\n\t{\n\t\tborder = (border != null) ? border : this.getBorder();\n\t\tkeepOrigin = (keepOrigin != null) ? keepOrigin : false;\n\t\tmargin = (margin != null) ? margin : 0;\n\t\tenabled = (enabled != null) ? enabled : true;\n\t\tignoreWidth = (ignoreWidth != null) ? ignoreWidth : false;\n\t\tignoreHeight = (ignoreHeight != null) ? ignoreHeight : false;\n\n\t\t// Adds spacing and border from css\n\t\tvar cssBorder = this.getBorderSizes();\n\t\tvar w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;\n\t\tvar h1 = (maxHeight != null) ? maxHeight : this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;\n\t\tvar bounds = this.view.getGraphBounds();\n\n\t\tif (bounds.width > 0 && bounds.height > 0)\n\t\t{\n\t\t\tif (keepOrigin && bounds.x != null && bounds.y != null)\n\t\t\t{\n\t\t\t\tbounds = bounds.clone();\n\t\t\t\tbounds.width += bounds.x;\n\t\t\t\tbounds.height += bounds.y;\n\t\t\t\tbounds.x = 0;\n\t\t\t\tbounds.y = 0;\n\t\t\t}\n\n\t\t\t// LATER: Use unscaled bounding boxes to fix rounding errors\n\t\t\tvar s = this.view.scale;\n\t\t\tvar w2 = bounds.width / s;\n\t\t\tvar h2 = bounds.height / s;\n\n\t\t\t// Fits to the size of the background image if required\n\t\t\tif (this.backgroundImage != null)\n\t\t\t{\n\t\t\t\tw2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);\n\t\t\t\th2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);\n\t\t\t}\n\n\t\t\tvar b = ((keepOrigin) ? border : 2 * border) + margin + 1;\n\n\t\t\tw1 -= b;\n\t\t\th1 -= b;\n\n\t\t\tvar s2 = (((ignoreWidth) ? h1 / h2 : (ignoreHeight) ? w1 / w2 :\n\t\t\t\tMath.min(w1 / w2, h1 / h2)));\n\n\t\t\tif (this.minFitScale != null)\n\t\t\t{\n\t\t\t\ts2 = Math.max(s2, this.minFitScale);\n\t\t\t}\n\n\t\t\tif (this.maxFitScale != null)\n\t\t\t{\n\t\t\t\ts2 = Math.min(s2, this.maxFitScale);\n\t\t\t}\n\n\t\t\tif (enabled)\n\t\t\t{\n\t\t\t\tif (!keepOrigin)\n\t\t\t\t{\n\t\t\t\t\tif (!mxUtils.hasScrollbars(this.container))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar x0 = (bounds.x != null) ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;\n\t\t\t\t\t\tvar y0 = (bounds.y != null) ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;\n\n\t\t\t\t\t\tthis.view.scaleAndTranslate(s2, x0, y0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.view.setScale(s2);\n\t\t\t\t\t\tvar b2 = this.getGraphBounds();\n\n\t\t\t\t\t\tif (b2.x != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.container.scrollLeft = b2.x;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (b2.y != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.container.scrollTop = b2.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (this.view.scale != s2)\n\t\t\t\t{\n\t\t\t\t\tthis.view.setScale(s2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn s2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn this.view.scale;\n};\n\n/**\n * Function: sizeDidChange\n *\n * Called when the size of the graph has changed. This implementation fires\n * a <size> event after updating the clipping region of the SVG element in\n * SVG-bases browsers.\n */\nmxGraph.prototype.sizeDidChange = function()\n{\n\tvar bounds = this.getGraphBounds();\n\n\tif (this.container != null)\n\t{\n\t\tvar border = this.getBorder();\n\n\t\tvar width = Math.max(0, bounds.x + bounds.width + 2 * border * this.view.scale);\n\t\tvar height = Math.max(0, bounds.y + bounds.height + 2 * border * this.view.scale);\n\n\t\tif (this.minimumContainerSize != null)\n\t\t{\n\t\t\twidth = Math.max(width, this.minimumContainerSize.width);\n\t\t\theight = Math.max(height, this.minimumContainerSize.height);\n\t\t}\n\n\t\tif (this.resizeContainer)\n\t\t{\n\t\t\tthis.doResizeContainer(width, height);\n\t\t}\n\n\t\tif (this.preferPageSize || (!mxClient.IS_IE && this.pageVisible))\n\t\t{\n\t\t\tvar size = this.getPreferredPageSize(bounds, Math.max(1, width), Math.max(1, height));\n\n\t\t\tif (size != null)\n\t\t\t{\n\t\t\t\twidth = size.width * this.view.scale;\n\t\t\t\theight = size.height * this.view.scale;\n\t\t\t}\n\t\t}\n\n\t\tif (this.minimumGraphSize != null)\n\t\t{\n\t\t\twidth = Math.max(width, this.minimumGraphSize.width * this.view.scale);\n\t\t\theight = Math.max(height, this.minimumGraphSize.height * this.view.scale);\n\t\t}\n\n\t\twidth = Math.ceil(width);\n\t\theight = Math.ceil(height);\n\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\tvar root = this.view.getDrawPane().ownerSVGElement;\n\n\t\t\tif (root != null)\n\t\t\t{\n\t\t\t\troot.style.minWidth = Math.max(1, width) + 'px';\n\t\t\t\troot.style.minHeight = Math.max(1, height) + 'px';\n\t\t\t\troot.style.width = '100%';\n\t\t\t\troot.style.height = '100%';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxClient.IS_QUIRKS)\n\t\t\t{\n\t\t\t\t// Quirks mode does not support minWidth/-Height\n\t\t\t\tthis.view.updateHtmlCanvasSize(Math.max(1, width), Math.max(1, height));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.view.canvas.style.minWidth = Math.max(1, width) + 'px';\n\t\t\t\tthis.view.canvas.style.minHeight = Math.max(1, height) + 'px';\n\t\t\t}\n\t\t}\n\n\t\tthis.updatePageBreaks(this.pageBreaksVisible, width, height);\n\t}\n\n\tthis.fireEvent(new mxEventObject(mxEvent.SIZE, 'bounds', bounds));\n};\n\n/**\n * Function: doResizeContainer\n *\n * Resizes the container for the given graph width and height.\n */\nmxGraph.prototype.doResizeContainer = function(width, height)\n{\n\tif (this.maximumContainerSize != null)\n\t{\n\t\twidth = Math.min(this.maximumContainerSize.width, width);\n\t\theight = Math.min(this.maximumContainerSize.height, height);\n\t}\n\n\tthis.container.style.width = Math.ceil(width) + 'px';\n\tthis.container.style.height = Math.ceil(height) + 'px';\n};\n\n/**\n * Function: updatePageBreaks\n *\n * Invokes from <sizeDidChange> to redraw the page breaks.\n *\n * Parameters:\n *\n * visible - Boolean that specifies if page breaks should be shown.\n * width - Specifies the width of the container in pixels.\n * height - Specifies the height of the container in pixels.\n */\nmxGraph.prototype.updatePageBreaks = function(visible, width, height)\n{\n\tvar scale = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar fmt = this.pageFormat;\n\tvar ps = scale * this.pageScale;\n\tvar bounds = new mxRectangle(0, 0, fmt.width * ps, fmt.height * ps);\n\n\tvar gb = mxRectangle.fromRectangle(this.getGraphBounds());\n\tgb.width = Math.max(1, gb.width);\n\tgb.height = Math.max(1, gb.height);\n\n\tbounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;\n\tbounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;\n\n\tgb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;\n\tgb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;\n\n\t// Does not show page breaks if the scale is too small\n\tvisible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;\n\n\tvar horizontalCount = (visible) ? Math.ceil(gb.height / bounds.height) + 1 : 0;\n\tvar verticalCount = (visible) ? Math.ceil(gb.width / bounds.width) + 1 : 0;\n\tvar right = (verticalCount - 1) * bounds.width;\n\tvar bottom = (horizontalCount - 1) * bounds.height;\n\n\tif (this.horizontalPageBreaks == null && horizontalCount > 0)\n\t{\n\t\tthis.horizontalPageBreaks = [];\n\t}\n\n\tif (this.verticalPageBreaks == null && verticalCount > 0)\n\t{\n\t\tthis.verticalPageBreaks = [];\n\t}\n\n\tvar drawPageBreaks = mxUtils.bind(this, function(breaks)\n\t{\n\t\tif (breaks != null)\n\t\t{\n\t\t\tvar count = (breaks == this.horizontalPageBreaks) ? horizontalCount : verticalCount;\n\n\t\t\tfor (var i = 0; i <= count; i++)\n\t\t\t{\n\t\t\t\tvar pts = (breaks == this.horizontalPageBreaks) ?\n\t\t\t\t\t[new mxPoint(Math.round(bounds.x), Math.round(bounds.y + i * bounds.height)),\n\t\t\t         new mxPoint(Math.round(bounds.x + right), Math.round(bounds.y + i * bounds.height))] :\n\t\t\t        [new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y)),\n\t\t\t         new mxPoint(Math.round(bounds.x + i * bounds.width), Math.round(bounds.y + bottom))];\n\n\t\t\t\tif (breaks[i] != null)\n\t\t\t\t{\n\t\t\t\t\tbreaks[i].points = pts;\n\t\t\t\t\tbreaks[i].redraw();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar pageBreak = new mxPolyline(pts, this.pageBreakColor);\n\t\t\t\t\tpageBreak.dialect = this.dialect;\n\t\t\t\t\tpageBreak.pointerEvents = false;\n\t\t\t\t\tpageBreak.isDashed = this.pageBreakDashed;\n\t\t\t\t\tpageBreak.init(this.view.backgroundPane);\n\t\t\t\t\tpageBreak.redraw();\n\n\t\t\t\t\tbreaks[i] = pageBreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = count; i < breaks.length; i++)\n\t\t\t{\n\t\t\t\tbreaks[i].destroy();\n\t\t\t}\n\n\t\t\tbreaks.splice(count, breaks.length - count);\n\t\t}\n\t});\n\n\tdrawPageBreaks(this.horizontalPageBreaks);\n\tdrawPageBreaks(this.verticalPageBreaks);\n};\n\n/**\n * Group: Cell styles\n */\n\n/**\n * Function: getCellStyle\n *\n * Returns an array of key, value pairs representing the cell style for the\n * given cell. If no string is defined in the model that specifies the\n * style, then the default style for the cell is returned or an empty object,\n * if no style can be found. Note: You should try and get the cell state\n * for the given cell and use the cached style in the state before using\n * this method.\n *\n * Parameters:\n *\n * cell - <mxCell> whose style should be returned as an array.\n */\nmxGraph.prototype.getCellStyle = function(cell)\n{\n\tvar stylename = this.model.getStyle(cell);\n\tvar style = null;\n\n\t// Gets the default style for the cell\n\tif (this.model.isEdge(cell))\n\t{\n\t\tstyle = this.stylesheet.getDefaultEdgeStyle();\n\t}\n\telse\n\t{\n\t\tstyle = this.stylesheet.getDefaultVertexStyle();\n\t}\n\n\t// Resolves the stylename using the above as the default\n\tif (stylename != null)\n\t{\n\t\tstyle = this.postProcessCellStyle(this.stylesheet.getCellStyle(stylename, style));\n\t}\n\n\t// Returns a non-null value if no style can be found\n\tif (style == null)\n\t{\n\t\tstyle = new Object();\n\t}\n\n\treturn style;\n};\n\n/**\n * Function: postProcessCellStyle\n *\n * Tries to resolve the value for the image style in the image bundles and\n * turns short data URIs as defined in mxImageBundle to data URIs as\n * defined in RFC 2397 of the IETF.\n */\nmxGraph.prototype.postProcessCellStyle = function(style)\n{\n\tif (style != null)\n\t{\n\t\tvar key = style[mxConstants.STYLE_IMAGE];\n\t\tvar image = this.getImageFromBundles(key);\n\n\t\tif (image != null)\n\t\t{\n\t\t\tstyle[mxConstants.STYLE_IMAGE] = image;\n\t\t}\n\t\telse\n\t\t{\n\t\t\timage = key;\n\t\t}\n\n\t\t// Converts short data uris to normal data uris\n\t\tif (image != null && image.substring(0, 11) == 'data:image/')\n\t\t{\n\t\t\tif (image.substring(0, 20) == 'data:image/svg+xml,<')\n\t\t\t{\n\t\t\t\t// Required for FF and IE11\n\t\t\t\timage = image.substring(0, 19) + encodeURIComponent(image.substring(19));\n\t\t\t}\n\t\t\telse if (image.substring(0, 22) != 'data:image/svg+xml,%3C')\n\t\t\t{\n\t\t\t\tvar comma = image.indexOf(',');\n\n\t\t\t\t// Adds base64 encoding prefix if needed\n\t\t\t\tif (comma > 0 && image.substring(comma - 7, comma + 1) != ';base64,')\n\t\t\t\t{\n\t\t\t\t\timage = image.substring(0, comma) + ';base64,'\n\t\t\t\t\t\t+ image.substring(comma + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstyle[mxConstants.STYLE_IMAGE] = image;\n\t\t}\n\t}\n\n\treturn style;\n};\n\n/**\n * Function: setCellStyle\n *\n * Sets the style of the specified cells. If no cells are given, then the\n * selection cells are changed.\n *\n * Parameters:\n *\n * style - String representing the new style of the cells.\n * cells - Optional array of <mxCells> to set the style for. Default is the\n * selection cells.\n */\nmxGraph.prototype.setCellStyle = function(style, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.model.setStyle(cells[i], style);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: toggleCellStyle\n *\n * Toggles the boolean value for the given key in the style of the given cell\n * and returns the new value as 0 or 1. If no cell is specified then the\n * selection cell is used.\n *\n * Parameter:\n *\n * key - String representing the key for the boolean value to be toggled.\n * defaultValue - Optional boolean default value if no value is defined.\n * Default is false.\n * cell - Optional <mxCell> whose style should be modified. Default is\n * the selection cell.\n */\nmxGraph.prototype.toggleCellStyle = function(key, defaultValue, cell)\n{\n\tcell = cell || this.getSelectionCell();\n\n\treturn this.toggleCellStyles(key, defaultValue, [cell]);\n};\n\n/**\n * Function: toggleCellStyles\n *\n * Toggles the boolean value for the given key in the style of the given cells\n * and returns the new value as 0 or 1. If no cells are specified, then the\n * selection cells are used. For example, this can be used to toggle\n * <mxConstants.STYLE_ROUNDED> or any other style with a boolean value.\n *\n * Parameter:\n *\n * key - String representing the key for the boolean value to be toggled.\n * defaultValue - Optional boolean default value if no value is defined.\n * Default is false.\n * cells - Optional array of <mxCells> whose styles should be modified.\n * Default is the selection cells.\n */\nmxGraph.prototype.toggleCellStyles = function(key, defaultValue, cells)\n{\n\tdefaultValue = (defaultValue != null) ? defaultValue : false;\n\tcells = cells || this.getSelectionCells();\n\tvar value = null;\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar state = this.view.getState(cells[0]);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cells[0]);\n\n\t\tif (style != null)\n\t\t{\n\t\t\tvalue = (mxUtils.getValue(style, key, defaultValue)) ? 0 : 1;\n\t\t\tthis.setCellStyles(key, value, cells);\n\t\t}\n\t}\n\n\treturn value;\n};\n\n/**\n * Function: setCellStyles\n *\n * Sets the key to value in the styles of the given cells. This will modify\n * the existing cell styles in-place and override any existing assignment\n * for the given key. If no cells are specified, then the selection cells\n * are changed. If no value is specified, then the respective key is\n * removed from the styles.\n *\n * Parameters:\n *\n * key - String representing the key to be assigned.\n * value - String representing the new value for the key.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.setCellStyles = function(key, value, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\tmxUtils.setCellStyles(this.model, cells, key, value);\n};\n\n/**\n * Function: toggleCellStyleFlags\n *\n * Toggles the given bit for the given key in the styles of the specified\n * cells.\n *\n * Parameters:\n *\n * key - String representing the key to toggle the flag in.\n * flag - Integer that represents the bit to be toggled.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.toggleCellStyleFlags = function(key, flag, cells)\n{\n\tthis.setCellStyleFlags(key, flag, null, cells);\n};\n\n/**\n * Function: setCellStyleFlags\n *\n * Sets or toggles the given bit for the given key in the styles of the\n * specified cells.\n *\n * Parameters:\n *\n * key - String representing the key to toggle the flag in.\n * flag - Integer that represents the bit to be toggled.\n * value - Boolean value to be used or null if the value should be toggled.\n * cells - Optional array of <mxCells> to change the style for. Default is\n * the selection cells.\n */\nmxGraph.prototype.setCellStyleFlags = function(key, flag, value, cells)\n{\n\tcells = cells || this.getSelectionCells();\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tif (value == null)\n\t\t{\n\t\t\tvar state = this.view.getState(cells[0]);\n\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(cells[0]);\n\n\t\t\tif (style != null)\n\t\t\t{\n\t\t\t\tvar current = parseInt(style[key] || 0);\n\t\t\t\tvalue = !((current & flag) == flag);\n\t\t\t}\n\t\t}\n\n\t\tmxUtils.setCellStyleFlags(this.model, cells, key, flag, value);\n\t}\n};\n\n/**\n * Group: Cell alignment and orientation\n */\n\n/**\n * Function: alignCells\n *\n * Aligns the given cells vertically or horizontally according to the given\n * alignment using the optional parameter as the coordinate.\n *\n * Parameters:\n *\n * align - Specifies the alignment. Possible values are all constants in\n * mxConstants with an ALIGN prefix.\n * cells - Array of <mxCells> to be aligned.\n * param - Optional coordinate for the alignment.\n */\nmxGraph.prototype.alignCells = function(align, cells, param)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\n\tif (cells != null && cells.length > 1)\n\t{\n\t\t// Finds the required coordinate for the alignment\n\t\tif (param == null)\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(cells[i]);\n\n\t\t\t\tif (state != null && !this.model.isEdge(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tif (param == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x + state.width / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x + state.width;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y + state.height / 2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.y + state.height;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = state.x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.max(param, state.x + state.width);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.min(param, state.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.max(param, state.y + state.height);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tparam = Math.min(param, state.x);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Aligns the cells to the coordinate\n\t\tif (param != null)\n\t\t{\n\t\t\tvar s = this.view.scale;\n\n\t\t\tthis.model.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\n\t\t\t\t\t\tif (geo != null && !this.model.isEdge(cells[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\t\t\tif (align == mxConstants.ALIGN_CENTER)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x - state.width / 2) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_RIGHT)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x - state.width) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_TOP)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y - state.height / 2) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (align == mxConstants.ALIGN_BOTTOM)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.y += (param - state.y - state.height) / s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x += (param - state.x) / s;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.resizeCell(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ALIGN_CELLS,\n\t\t\t\t\t\t'align', align, 'cells', cells));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tthis.model.endUpdate();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: flipEdge\n *\n * Toggles the style of the given edge between null (or empty) and\n * <alternateEdgeStyle>. This method fires <mxEvent.FLIP_EDGE> while the\n * transaction is in progress. Returns the edge that was flipped.\n *\n * Here is an example that overrides this implementation to invert the\n * value of <mxConstants.STYLE_ELBOW> without removing any existing styles.\n *\n * (code)\n * graph.flipEdge = function(edge)\n * {\n *   if (edge != null)\n *   {\n *     var state = this.view.getState(edge);\n *     var style = (state != null) ? state.style : this.getCellStyle(edge);\n *\n *     if (style != null)\n *     {\n *       var elbow = mxUtils.getValue(style, mxConstants.STYLE_ELBOW,\n *           mxConstants.ELBOW_HORIZONTAL);\n *       var value = (elbow == mxConstants.ELBOW_HORIZONTAL) ?\n *           mxConstants.ELBOW_VERTICAL : mxConstants.ELBOW_HORIZONTAL;\n *       this.setCellStyles(mxConstants.STYLE_ELBOW, value, [edge]);\n *     }\n *   }\n * };\n * (end)\n *\n * Parameters:\n *\n * edge - <mxCell> whose style should be changed.\n */\nmxGraph.prototype.flipEdge = function(edge)\n{\n\tif (edge != null &&\n\t\tthis.alternateEdgeStyle != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar style = this.model.getStyle(edge);\n\n\t\t\tif (style == null || style.length == 0)\n\t\t\t{\n\t\t\t\tthis.model.setStyle(edge, this.alternateEdgeStyle);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.model.setStyle(edge, null);\n\t\t\t}\n\n\t\t\t// Removes all existing control points\n\t\t\tthis.resetEdge(edge);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.FLIP_EDGE, 'edge', edge));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: addImageBundle\n *\n * Adds the specified <mxImageBundle>.\n */\nmxGraph.prototype.addImageBundle = function(bundle)\n{\n\tthis.imageBundles.push(bundle);\n};\n\n/**\n * Function: removeImageBundle\n *\n * Removes the specified <mxImageBundle>.\n */\nmxGraph.prototype.removeImageBundle = function(bundle)\n{\n\tvar tmp = [];\n\n\tfor (var i = 0; i < this.imageBundles.length; i++)\n\t{\n\t\tif (this.imageBundles[i] != bundle)\n\t\t{\n\t\t\ttmp.push(this.imageBundles[i]);\n\t\t}\n\t}\n\n\tthis.imageBundles = tmp;\n};\n\n/**\n * Function: getImageFromBundles\n *\n * Searches all <imageBundles> for the specified key and returns the value\n * for the first match or null if the key is not found.\n */\nmxGraph.prototype.getImageFromBundles = function(key)\n{\n\tif (key != null)\n\t{\n\t\tfor (var i = 0; i < this.imageBundles.length; i++)\n\t\t{\n\t\t\tvar image = this.imageBundles[i].getImage(key);\n\n\t\t\tif (image != null)\n\t\t\t{\n\t\t\t\treturn image;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Group: Order\n */\n\n/**\n * Function: orderCells\n *\n * Moves the given cells to the front or back. The change is carried out\n * using <cellsOrdered>. This method fires <mxEvent.ORDER_CELLS> while the\n * transaction is in progress.\n *\n * Parameters:\n *\n * back - Boolean that specifies if the cells should be moved to back.\n * cells - Array of <mxCells> to move to the background. If null is\n * specified then the selection cells are used.\n */\nmxGraph.prototype.orderCells = function(back, cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = mxUtils.sortCells(this.getSelectionCells(), true);\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsOrdered(cells, back);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ORDER_CELLS,\n\t\t\t\t'back', back, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsOrdered\n *\n * Moves the given cells to the front or back. This method fires\n * <mxEvent.CELLS_ORDERED> while the transaction is in progress.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose order should be changed.\n * back - Boolean that specifies if the cells should be moved to back.\n */\nmxGraph.prototype.cellsOrdered = function(cells, back)\n{\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\n\t\t\t\tif (back)\n\t\t\t\t{\n\t\t\t\t\tthis.model.add(parent, cells[i], i);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.model.add(parent, cells[i],\n\t\t\t\t\t\t\tthis.model.getChildCount(parent) - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_ORDERED,\n\t\t\t\t\t'back', back, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Grouping\n */\n\n/**\n * Function: groupCells\n *\n * Adds the cells into the given group. The change is carried out using\n * <cellsAdded>, <cellsMoved> and <cellsResized>. This method fires\n * <mxEvent.GROUP_CELLS> while the transaction is in progress. Returns the\n * new group. A group is only created if there is at least one entry in the\n * given array of cells.\n *\n * Parameters:\n *\n * group - <mxCell> that represents the target group. If null is specified\n * then a new group is created using <createGroupCell>.\n * border - Optional integer that specifies the border between the child\n * area and the group bounds. Default is 0.\n * cells - Optional array of <mxCells> to be grouped. If null is specified\n * then the selection cells are used.\n */\nmxGraph.prototype.groupCells = function(group, border, cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = mxUtils.sortCells(this.getSelectionCells(), true);\n\t}\n\n\tcells = this.getCellsForGroup(cells);\n\n\tif (group == null)\n\t{\n\t\tgroup = this.createGroupCell(cells);\n\t}\n\n\tvar bounds = this.getBoundsForGroup(group, cells, border);\n\n\tif (cells.length > 0 && bounds != null)\n\t{\n\t\t// Uses parent of group or previous parent of first child\n\t\tvar parent = this.model.getParent(group);\n\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.model.getParent(cells[0]);\n\t\t}\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Checks if the group has a geometry and\n\t\t\t// creates one if one does not exist\n\t\t\tif (this.getCellGeometry(group) == null)\n\t\t\t{\n\t\t\t\tthis.model.setGeometry(group, new mxGeometry());\n\t\t\t}\n\n\t\t\t// Adds the group into the parent\n\t\t\tvar index = this.model.getChildCount(parent);\n\t\t\tthis.cellsAdded([group], parent, index, null, null, false, false, false);\n\n\t\t\t// Adds the children into the group and moves\n\t\t\tindex = this.model.getChildCount(group);\n\t\t\tthis.cellsAdded(cells, group, index, null, null, false, false, false);\n\t\t\tthis.cellsMoved(cells, -bounds.x, -bounds.y, false, false, false);\n\n\t\t\t// Resizes the group\n\t\t\tthis.cellsResized([group], [bounds], false);\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.GROUP_CELLS,\n\t\t\t\t\t'group', group, 'border', border, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn group;\n};\n\n/**\n * Function: getCellsForGroup\n *\n * Returns the cells with the same parent as the first cell\n * in the given array.\n */\nmxGraph.prototype.getCellsForGroup = function(cells)\n{\n\tvar result = [];\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar parent = this.model.getParent(cells[0]);\n\t\tresult.push(cells[0]);\n\n\t\t// Filters selection cells with the same parent\n\t\tfor (var i = 1; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.getParent(cells[i]) == parent)\n\t\t\t{\n\t\t\t\tresult.push(cells[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getBoundsForGroup\n *\n * Returns the bounds to be used for the given group and children.\n */\nmxGraph.prototype.getBoundsForGroup = function(group, children, border)\n{\n\tvar result = this.getBoundingBoxFromGeometry(children, true);\n\n\tif (result != null)\n\t{\n\t\tif (this.isSwimlane(group))\n\t\t{\n\t\t\tvar size = this.getStartSize(group);\n\n\t\t\tresult.x -= size.width;\n\t\t\tresult.y -= size.height;\n\t\t\tresult.width += size.width;\n\t\t\tresult.height += size.height;\n\t\t}\n\n\t\t// Adds the border\n\t\tif (border != null)\n\t\t{\n\t\t\tresult.x -= border;\n\t\t\tresult.y -= border;\n\t\t\tresult.width += 2 * border;\n\t\t\tresult.height += 2 * border;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: createGroupCell\n *\n * Hook for creating the group cell to hold the given array of <mxCells> if\n * no group cell was given to the <group> function.\n *\n * The following code can be used to set the style of new group cells.\n *\n * (code)\n * var graphCreateGroupCell = graph.createGroupCell;\n * graph.createGroupCell = function(cells)\n * {\n *   var group = graphCreateGroupCell.apply(this, arguments);\n *   group.setStyle('group');\n *\n *   return group;\n * };\n */\nmxGraph.prototype.createGroupCell = function(cells)\n{\n\tvar group = new mxCell('');\n\tgroup.setVertex(true);\n\tgroup.setConnectable(false);\n\n\treturn group;\n};\n\n/**\n * Function: ungroupCells\n *\n * Ungroups the given cells by moving the children the children to their\n * parents parent and removing the empty groups. Returns the children that\n * have been removed from the groups.\n *\n * Parameters:\n *\n * cells - Array of cells to be ungrouped. If null is specified then the\n * selection cells are used.\n */\nmxGraph.prototype.ungroupCells = function(cells)\n{\n\tvar result = [];\n\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\n\t\t// Finds the cells with children\n\t\tvar tmp = [];\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.getChildCount(cells[i]) > 0)\n\t\t\t{\n\t\t\t\ttmp.push(cells[i]);\n\t\t\t}\n\t\t}\n\n\t\tcells = tmp;\n\t}\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar children = this.model.getChildren(cells[i]);\n\n\t\t\t\tif (children != null && children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tchildren = children.slice();\n\t\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\t\t\t\t\tvar index = this.model.getChildCount(parent);\n\n\t\t\t\t\tthis.cellsAdded(children, parent, index, null, null, true);\n\t\t\t\t\tresult = result.concat(children);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.removeCellsAfterUngroup(cells);\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.UNGROUP_CELLS, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: removeCellsAfterUngroup\n *\n * Hook to remove the groups after <ungroupCells>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> that were ungrouped.\n */\nmxGraph.prototype.removeCellsAfterUngroup = function(cells)\n{\n\tthis.cellsRemoved(this.addAllEdges(cells));\n};\n\n/**\n * Function: removeCellsFromParent\n *\n * Removes the specified cells from their parents and adds them to the\n * default parent. Returns the cells that were removed from their parents.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be removed from their parents.\n */\nmxGraph.prototype.removeCellsFromParent = function(cells)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar parent = this.getDefaultParent();\n\t\tvar index = this.model.getChildCount(parent);\n\n\t\tthis.cellsAdded(cells, parent, index, null, null, true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS_FROM_PARENT, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: updateGroupBounds\n *\n * Updates the bounds of the given groups to include all children and returns\n * the passed-in cells. Call this with the groups in parent to child order,\n * top-most group first, the cells are processed in reverse order and cells\n * with no children are ignored.\n *\n * Parameters:\n *\n * cells - The groups whose bounds should be updated. If this is null, then\n * the selection cells are used.\n * border - Optional border to be added in the group. Default is 0.\n * moveGroup - Optional boolean that allows the group to be moved. Default\n * is false.\n * topBorder - Optional top border to be added in the group. Default is 0.\n * rightBorder - Optional top border to be added in the group. Default is 0.\n * bottomBorder - Optional top border to be added in the group. Default is 0.\n * leftBorder - Optional top border to be added in the group. Default is 0.\n */\nmxGraph.prototype.updateGroupBounds = function(cells, border, moveGroup, topBorder, rightBorder, bottomBorder, leftBorder)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\n\tborder = (border != null) ? border : 0;\n\tmoveGroup = (moveGroup != null) ? moveGroup : false;\n\ttopBorder = (topBorder != null) ? topBorder : 0;\n\trightBorder = (rightBorder != null) ? rightBorder : 0;\n\tbottomBorder = (bottomBorder != null) ? bottomBorder : 0;\n\tleftBorder = (leftBorder != null) ? leftBorder : 0;\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tfor (var i = cells.length - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar children = this.getChildCells(cells[i]);\n\n\t\t\t\tif (children != null && children.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = this.getBoundingBoxFromGeometry(children, true);\n\n\t\t\t\t\tif (bounds != null && bounds.width > 0 && bounds.height > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar left = 0;\n\t\t\t\t\t\tvar top = 0;\n\n\t\t\t\t\t\t// Adds the size of the title area for swimlanes\n\t\t\t\t\t\tif (this.isSwimlane(cells[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar size = this.getStartSize(cells[i]);\n\t\t\t\t\t\t\tleft = size.width;\n\t\t\t\t\t\t\ttop = size.height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\t\tif (moveGroup)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x = Math.round(geo.x + bounds.x - border - left - leftBorder);\n\t\t\t\t\t\t\tgeo.y = Math.round(geo.y + bounds.y - border - top - topBorder);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo.width = Math.round(bounds.width + 2 * border + left + leftBorder + rightBorder);\n\t\t\t\t\t\tgeo.height = Math.round(bounds.height + 2 * border + top + topBorder + bottomBorder);\n\n\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\tthis.moveCells(children, border + left - bounds.x + leftBorder,\n\t\t\t\t\t\t\t\tborder + top - bounds.y + topBorder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: getBoundingBox\n *\n * Returns the bounding box for the given array of <mxCells>. The bounding box for\n * each cell and its descendants is computed using <mxGraphView.getBoundingBox>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounding box should be returned.\n */\nmxGraph.prototype.getBoundingBox = function(cells)\n{\n\tvar result = null;\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i]))\n\t\t\t{\n\t\t\t\tvar bbox = this.view.getBoundingBox(this.view.getState(cells[i]), true);\n\n\t\t\t\tif (bbox != null)\n\t\t\t\t{\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Group: Cell cloning, insertion and removal\n */\n\n/**\n * Function: cloneCell\n *\n * Returns the clone for the given cell. Uses <cloneCells>.\n *\n * Parameters:\n *\n * cell - <mxCell> to be cloned.\n * allowInvalidEdges - Optional boolean that specifies if invalid edges\n * should be cloned. Default is true.\n * mapping - Optional mapping for existing clones.\n * keepPosition - Optional boolean indicating if the position of the cells should\n * be updated to reflect the lost parent cell. Default is false.\n */\nmxGraph.prototype.cloneCell = function(cell, allowInvalidEdges, mapping, keepPosition)\n{\n\treturn this.cloneCells([cell], allowInvalidEdges, mapping, keepPosition)[0];\n};\n\n/**\n * Function: cloneCells\n *\n * Returns the clones for the given cells. The clones are created recursively\n * using <mxGraphModel.cloneCells>. If the terminal of an edge is not in the\n * given array, then the respective end is assigned a terminal point and the\n * terminal is removed.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be cloned.\n * allowInvalidEdges - Optional boolean that specifies if invalid edges\n * should be cloned. Default is true.\n * mapping - Optional mapping for existing clones.\n * keepPosition - Optional boolean indicating if the position of the cells should\n * be updated to reflect the lost parent cell. Default is false.\n */\nmxGraph.prototype.cloneCells = function(cells, allowInvalidEdges, mapping, keepPosition)\n{\n\tallowInvalidEdges = (allowInvalidEdges != null) ? allowInvalidEdges : true;\n\tvar clones = null;\n\n\tif (cells != null)\n\t{\n\t\t// Creates a dictionary for fast lookups\n\t\tvar dict = new mxDictionary();\n\t\tvar tmp = [];\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t\ttmp.push(cells[i]);\n\t\t}\n\n\t\tif (tmp.length > 0)\n\t\t{\n\t\t\tvar scale = this.view.scale;\n\t\t\tvar trans = this.view.translate;\n\t\t\tclones = this.model.cloneCells(cells, true, mapping);\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (!allowInvalidEdges && this.model.isEdge(clones[i]) &&\n\t\t\t\t\tthis.getEdgeValidationError(clones[i],\n\t\t\t\t\t\tthis.model.getTerminal(clones[i], true),\n\t\t\t\t\t\tthis.model.getTerminal(clones[i], false)) != null)\n\t\t\t\t{\n\t\t\t\t\tclones[i] = null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar g = this.model.getGeometry(clones[i]);\n\n\t\t\t\t\tif (g != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\tvar pstate = this.view.getState(this.model.getParent(cells[i]));\n\n\t\t\t\t\t\tif (state != null && pstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar dx = (keepPosition) ? 0 : pstate.origin.x;\n\t\t\t\t\t\t\tvar dy = (keepPosition) ? 0 : pstate.origin.y;\n\n\t\t\t\t\t\t\tif (this.model.isEdge(clones[i]))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\n\t\t\t\t\t\t\t\tif (pts != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Checks if the source is cloned or sets the terminal point\n\t\t\t\t\t\t\t\t\tvar src = this.model.getTerminal(cells[i], true);\n\n\t\t\t\t\t\t\t\t\twhile (src != null && !dict.get(src))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tsrc = this.model.getParent(src);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (src == null && pts[0] != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tg.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[0].x / scale - trans.x,\n\t\t\t\t\t\t\t\t\t\t\t\tpts[0].y / scale - trans.y), true);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Checks if the target is cloned or sets the terminal point\n\t\t\t\t\t\t\t\t\tvar trg = this.model.getTerminal(cells[i], false);\n\n\t\t\t\t\t\t\t\t\twhile (trg != null && !dict.get(trg))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttrg = this.model.getParent(trg);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar n = pts.length - 1;\n\n\t\t\t\t\t\t\t\t\tif (trg == null && pts[n] != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tg.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[n].x / scale - trans.x,\n\t\t\t\t\t\t\t\t\t\t\t\tpts[n].y / scale - trans.y), false);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Translates the control points\n\t\t\t\t\t\t\t\t\tvar points = g.points;\n\n\t\t\t\t\t\t\t\t\tif (points != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfor (var j = 0; j < points.length; j++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tpoints[j].x += dx;\n\t\t\t\t\t\t\t\t\t\t\tpoints[j].y += dy;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tg.translate(dx, dy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclones = [];\n\t\t}\n\t}\n\n\treturn clones;\n};\n\n/**\n * Function: insertVertex\n *\n * Adds a new vertex into the given parent <mxCell> using value as the user\n * object and the given coordinates as the <mxGeometry> of the new vertex.\n * The id and style are used for the respective properties of the new\n * <mxCell>, which is returned.\n *\n * When adding new vertices from a mouse event, one should take into\n * account the offset of the graph container and the scale and translation\n * of the view in order to find the correct unscaled, untranslated\n * coordinates using <mxGraph.getPointForEvent> as follows:\n *\n * (code)\n * var pt = graph.getPointForEvent(evt);\n * var parent = graph.getDefaultParent();\n * graph.insertVertex(parent, null,\n * \t\t\t'Hello, World!', x, y, 220, 30);\n * (end)\n *\n * For adding image cells, the style parameter can be assigned as\n *\n * (code)\n * stylename;image=imageUrl\n * (end)\n *\n * See <mxGraph> for more information on using images.\n *\n * Parameters:\n *\n * parent - <mxCell> that specifies the parent of the new vertex.\n * id - Optional string that defines the Id of the new vertex.\n * value - Object to be used as the user object.\n * x - Integer that defines the x coordinate of the vertex.\n * y - Integer that defines the y coordinate of the vertex.\n * width - Integer that defines the width of the vertex.\n * height - Integer that defines the height of the vertex.\n * style - Optional string that defines the cell style.\n * relative - Optional boolean that specifies if the geometry is relative.\n * Default is false.\n */\nmxGraph.prototype.insertVertex = function(parent, id, value,\n\tx, y, width, height, style, relative)\n{\n\tvar vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative);\n\n\treturn this.addCell(vertex, parent);\n};\n\n/**\n * Function: createVertex\n *\n * Hook method that creates the new vertex for <insertVertex>.\n */\nmxGraph.prototype.createVertex = function(parent, id, value,\n\t\tx, y, width, height, style, relative)\n{\n\t// Creates the geometry for the vertex\n\tvar geometry = new mxGeometry(x, y, width, height);\n\tgeometry.relative = (relative != null) ? relative : false;\n\n\t// Creates the vertex\n\tvar vertex = new mxCell(value, geometry, style);\n\tvertex.setId(id);\n\tvertex.setVertex(true);\n\tvertex.setConnectable(true);\n\n\treturn vertex;\n};\n\n/**\n * Function: insertEdge\n *\n * Adds a new edge into the given parent <mxCell> using value as the user\n * object and the given source and target as the terminals of the new edge.\n * The id and style are used for the respective properties of the new\n * <mxCell>, which is returned.\n *\n * Parameters:\n *\n * parent - <mxCell> that specifies the parent of the new edge.\n * id - Optional string that defines the Id of the new edge.\n * value - JavaScript object to be used as the user object.\n * source - <mxCell> that defines the source of the edge.\n * target - <mxCell> that defines the target of the edge.\n * style - Optional string that defines the cell style.\n */\nmxGraph.prototype.insertEdge = function(parent, id, value, source, target, style)\n{\n\tvar edge = this.createEdge(parent, id, value, source, target, style);\n\n\treturn this.addEdge(edge, parent, source, target);\n};\n\n/**\n * Function: createEdge\n *\n * Hook method that creates the new edge for <insertEdge>. This\n * implementation does not set the source and target of the edge, these\n * are set when the edge is added to the model.\n *\n */\nmxGraph.prototype.createEdge = function(parent, id, value, source, target, style)\n{\n\t// Creates the edge\n\tvar edge = new mxCell(value, new mxGeometry(), style);\n\tedge.setId(id);\n\tedge.setEdge(true);\n\tedge.geometry.relative = true;\n\n\treturn edge;\n};\n\n/**\n * Function: addEdge\n *\n * Adds the edge to the parent and connects it to the given source and\n * target terminals. This is a shortcut method. Returns the edge that was\n * added.\n *\n * Parameters:\n *\n * edge - <mxCell> to be inserted into the given parent.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * source - Optional <mxCell> that represents the source terminal.\n * target - Optional <mxCell> that represents the target terminal.\n * index - Optional index to insert the cells at. Default is to append.\n */\nmxGraph.prototype.addEdge = function(edge, parent, source, target, index)\n{\n\treturn this.addCell(edge, parent, index, source, target);\n};\n\n/**\n * Function: addCell\n *\n * Adds the cell to the parent and connects it to the given source and\n * target terminals. This is a shortcut method. Returns the cell that was\n * added.\n *\n * Parameters:\n *\n * cell - <mxCell> to be inserted into the given parent.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * index - Optional index to insert the cells at. Default is to append.\n * source - Optional <mxCell> that represents the source terminal.\n * target - Optional <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.addCell = function(cell, parent, index, source, target)\n{\n\treturn this.addCells([cell], parent, index, source, target)[0];\n};\n\n/**\n * Function: addCells\n *\n * Adds the cells to the parent at the given index, connecting each cell to\n * the optional source and target terminal. The change is carried out using\n * <cellsAdded>. This method fires <mxEvent.ADD_CELLS> while the\n * transaction is in progress. Returns the cells that were added.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be inserted.\n * parent - <mxCell> that represents the new parent. If no parent is\n * given then the default parent is used.\n * index - Optional index to insert the cells at. Default is to append.\n * source - Optional source <mxCell> for all inserted cells.\n * target - Optional target <mxCell> for all inserted cells.\n */\nmxGraph.prototype.addCells = function(cells, parent, index, source, target)\n{\n\tif (parent == null)\n\t{\n\t\tparent = this.getDefaultParent();\n\t}\n\n\tif (index == null)\n\t{\n\t\tindex = this.model.getChildCount(parent);\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsAdded(cells, parent, index, source, target, false, true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ADD_CELLS, 'cells', cells,\n\t\t\t\t'parent', parent, 'index', index, 'source', source, 'target', target));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsAdded\n *\n * Adds the specified cells to the given parent. This method fires\n * <mxEvent.CELLS_ADDED> while the transaction is in progress.\n */\nmxGraph.prototype.cellsAdded = function(cells, parent, index, source, target, absolute, constrain, extend)\n{\n\tif (cells != null && parent != null && index != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar parentState = (absolute) ? this.view.getState(parent) : null;\n\t\t\tvar o1 = (parentState != null) ? parentState.origin : null;\n\t\t\tvar zero = new mxPoint(0, 0);\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (cells[i] == null)\n\t\t\t\t{\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar previous = this.model.getParent(cells[i]);\n\n\t\t\t\t\t// Keeps the cell at its absolute location\n\t\t\t\t\tif (o1 != null && cells[i] != parent && parent != previous)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar oldState = this.view.getState(previous);\n\t\t\t\t\t\tvar o2 = (oldState != null) ? oldState.origin : zero;\n\t\t\t\t\t\tvar geo = this.model.getGeometry(cells[i]);\n\n\t\t\t\t\t\tif (geo != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar dx = o2.x - o1.x;\n\t\t\t\t\t\t\tvar dy = o2.y - o1.y;\n\n\t\t\t\t\t\t\t// FIXME: Cells should always be inserted first before any other edit\n\t\t\t\t\t\t\t// to avoid forward references in sessions.\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tgeo.translate(dx, dy);\n\n\t\t\t\t\t\t\tif (!geo.relative && this.model.isVertex(cells[i]) &&\n\t\t\t\t\t\t\t\t!this.isAllowNegativeCoordinates())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.x = Math.max(0, geo.x);\n\t\t\t\t\t\t\t\tgeo.y = Math.max(0, geo.y);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Decrements all following indices\n\t\t\t\t\t// if cell is already in parent\n\t\t\t\t\tif (parent == previous && index + i > this.model.getChildCount(parent))\n\t\t\t\t\t{\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.model.add(parent, cells[i], index + i);\n\n\t\t\t\t\tif (this.autoSizeCellsOnAdd)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.autoSizeCell(cells[i], true);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Extends the parent or constrains the child\n\t\t\t\t\tif ((extend == null || extend) &&\n\t\t\t\t\t\tthis.isExtendParentsOnAdd(cells[i]) && this.isExtendParent(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Additionally constrains the child after extending the parent\n\t\t\t\t\tif (constrain == null || constrain)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sets the source terminal\n\t\t\t\t\tif (source != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.cellConnected(cells[i], source, true);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Sets the target terminal\n\t\t\t\t\tif (target != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.cellConnected(cells[i], target, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_ADDED, 'cells', cells,\n\t\t\t\t'parent', parent, 'index', index, 'source', source, 'target', target,\n\t\t\t\t'absolute', absolute));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: autoSizeCell\n *\n * Resizes the specified cell to just fit around the its label and/or children\n *\n * Parameters:\n *\n * cell - <mxCells> to be resized.\n * recurse - Optional boolean which specifies if all descendants should be\n * autosized. Default is true.\n */\nmxGraph.prototype.autoSizeCell = function(cell, recurse)\n{\n\trecurse = (recurse != null) ? recurse : true;\n\n\tif (recurse)\n\t{\n\t\tvar childCount = this.model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.autoSizeCell(this.model.getChildAt(cell, i));\n\t\t}\n\t}\n\n\tif (this.getModel().isVertex(cell) && this.isAutoSizeCell(cell))\n\t{\n\t\tthis.updateCellSize(cell);\n\t}\n};\n\n/**\n * Function: removeCells\n *\n * Removes the given cells from the graph including all connected edges if\n * includeEdges is true. The change is carried out using <cellsRemoved>.\n * This method fires <mxEvent.REMOVE_CELLS> while the transaction is in\n * progress. The removed cells are returned as an array.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to remove. If null is specified then the\n * selection cells which are deletable are used.\n * includeEdges - Optional boolean which specifies if all connected edges\n * should be removed as well. Default is true.\n */\nmxGraph.prototype.removeCells = function(cells, includeEdges)\n{\n\tincludeEdges = (includeEdges != null) ? includeEdges : true;\n\n\tif (cells == null)\n\t{\n\t\tcells = this.getDeletableCells(this.getSelectionCells());\n\t}\n\n\t// Adds all edges to the cells\n\tif (includeEdges)\n\t{\n\t\t// FIXME: Remove duplicate cells in result or do not add if\n\t\t// in cells or descendant of cells\n\t\tcells = this.getDeletableCells(this.addAllEdges(cells));\n\t}\n\telse\n\t{\n\t\tcells = cells.slice();\n\n\t\t// Removes edges that are currently not\n\t\t// visible as those cannot be updated\n\t\tvar edges = this.getDeletableCells(this.getAllEdges(cells));\n\t\tvar dict = new mxDictionary();\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t}\n\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tif (this.view.getState(edges[i]) == null &&\n\t\t\t\t!dict.get(edges[i]))\n\t\t\t{\n\t\t\t\tdict.put(edges[i], true);\n\t\t\t\tcells.push(edges[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsRemoved(cells);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE_CELLS,\n\t\t\t\t'cells', cells, 'includeEdges', includeEdges));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsRemoved\n *\n * Removes the given cells from the model. This method fires\n * <mxEvent.CELLS_REMOVED> while the transaction is in progress.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to remove.\n */\nmxGraph.prototype.cellsRemoved = function(cells)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar scale = this.view.scale;\n\t\tvar tr = this.view.translate;\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Creates hashtable for faster lookup\n\t\t\tvar dict = new mxDictionary();\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\t// Disconnects edges which are not being removed\n\t\t\t\tvar edges = this.getAllEdges([cells[i]]);\n\n\t\t\t\tvar disconnectTerminal = mxUtils.bind(this, function(edge, source)\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.model.getGeometry(edge);\n\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Checks if terminal is being removed\n\t\t\t\t\t\tvar terminal = this.model.getTerminal(edge, source);\n\t\t\t\t\t\tvar connected = false;\n\t\t\t\t\t\tvar tmp = terminal;\n\n\t\t\t\t\t\twhile (tmp != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (cells[i] == tmp)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconnected = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttmp = this.model.getParent(tmp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (connected)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\tvar state = this.view.getState(edge);\n\n\t\t\t\t\t\t\tif (state != null && state.absolutePoints != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\t\t\t\t\t\t\t\tvar n = (source) ? 0 : pts.length - 1;\n\n\t\t\t\t\t\t\t\tgeo.setTerminalPoint(new mxPoint(\n\t\t\t\t\t\t\t\t\tpts[n].x / scale - tr.x - state.origin.x,\n\t\t\t\t\t\t\t\t\tpts[n].y / scale - tr.y - state.origin.y), source);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Fallback to center of terminal if routing\n\t\t\t\t\t\t\t\t// points are not available to add new point\n\t\t\t\t\t\t\t\t// KNOWN: Should recurse to find parent offset\n\t\t\t\t\t\t\t\t// of edge for nested groups but invisible edges\n\t\t\t\t\t\t\t\t// should be removed in removeCells step\n\t\t\t\t\t\t\t\tvar tstate = this.view.getState(terminal);\n\n\t\t\t\t\t\t\t\tif (tstate != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(new mxPoint(\n\t\t\t\t\t\t\t\t\t\ttstate.getCenterX() / scale - tr.x,\n\t\t\t\t\t\t\t\t\t\ttstate.getCenterY() / scale - tr.y), source);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.model.setGeometry(edge, geo);\n\t\t\t\t\t\t\tthis.model.setTerminal(edge, null, source);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!dict.get(edges[j]))\n\t\t\t\t\t{\n\t\t\t\t\t\tdict.put(edges[j], true);\n\t\t\t\t\t\tdisconnectTerminal(edges[j], true);\n\t\t\t\t\t\tdisconnectTerminal(edges[j], false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.model.remove(cells[i]);\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_REMOVED, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: splitEdge\n *\n * Splits the given edge by adding the newEdge between the previous source\n * and the given cell and reconnecting the source of the given edge to the\n * given cell. This method fires <mxEvent.SPLIT_EDGE> while the transaction\n * is in progress. Returns the new edge that was inserted.\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge to be splitted.\n * cells - <mxCells> that represents the cells to insert into the edge.\n * newEdge - <mxCell> that represents the edge to be inserted.\n * dx - Optional integer that specifies the vector to move the cells.\n * dy - Optional integer that specifies the vector to move the cells.\n */\nmxGraph.prototype.splitEdge = function(edge, cells, newEdge, dx, dy)\n{\n\tdx = dx || 0;\n\tdy = dy || 0;\n\n\tvar parent = this.model.getParent(edge);\n\tvar source = this.model.getTerminal(edge, true);\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tif (newEdge == null)\n\t\t{\n\t\t\tnewEdge = this.cloneCell(edge);\n\n\t\t\t// Removes waypoints before/after new cell\n\t\t\tvar state = this.view.getState(edge);\n\t\t\tvar geo = this.getCellGeometry(newEdge);\n\n\t\t\tif (geo != null && geo.points != null && state != null)\n\t\t\t{\n\t\t\t\tvar t = this.view.translate;\n\t\t\t\tvar s = this.view.scale;\n\t\t\t\tvar idx = mxUtils.findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n\t\t\t\tgeo.points = geo.points.slice(0, idx);\n\n\t\t\t\tgeo = this.getCellGeometry(edge);\n\n\t\t\t\tif (geo != null && geo.points != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\tgeo.points = geo.points.slice(idx);\n\t\t\t\t\tthis.model.setGeometry(edge, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.cellsMoved(cells, dx, dy, false, false);\n\t\tthis.cellsAdded(cells, parent, this.model.getChildCount(parent), null, null,\n\t\t\t\ttrue);\n\t\tthis.cellsAdded([newEdge], parent, this.model.getChildCount(parent),\n\t\t\t\tsource, cells[0], false);\n\t\tthis.cellConnected(edge, cells[0], true);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.SPLIT_EDGE, 'edge', edge,\n\t\t\t\t'cells', cells, 'newEdge', newEdge, 'dx', dx, 'dy', dy));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn newEdge;\n};\n\n/**\n * Group: Cell visibility\n */\n\n/**\n * Function: toggleCells\n *\n * Sets the visible state of the specified cells and all connected edges\n * if includeEdges is true. The change is carried out using <cellsToggled>.\n * This method fires <mxEvent.TOGGLE_CELLS> while the transaction is in\n * progress. Returns the cells whose visible state was changed.\n *\n * Parameters:\n *\n * show - Boolean that specifies the visible state to be assigned.\n * cells - Array of <mxCells> whose visible state should be changed. If\n * null is specified then the selection cells are used.\n * includeEdges - Optional boolean indicating if the visible state of all\n * connected edges should be changed as well. Default is true.\n */\nmxGraph.prototype.toggleCells = function(show, cells, includeEdges)\n{\n\tif (cells == null)\n\t{\n\t\tcells = this.getSelectionCells();\n\t}\n\n\t// Adds all connected edges recursively\n\tif (includeEdges)\n\t{\n\t\tcells = this.addAllEdges(cells);\n\t}\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsToggled(cells, show);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.TOGGLE_CELLS,\n\t\t\t'show', show, 'cells', cells, 'includeEdges', includeEdges));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsToggled\n *\n * Sets the visible state of the specified cells.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose visible state should be changed.\n * show - Boolean that specifies the visible state to be assigned.\n */\nmxGraph.prototype.cellsToggled = function(cells, show)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.model.setVisible(cells[i], show);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Folding\n */\n\n/**\n * Function: foldCells\n *\n * Sets the collapsed state of the specified cells and all descendants\n * if recurse is true. The change is carried out using <cellsFolded>.\n * This method fires <mxEvent.FOLD_CELLS> while the transaction is in\n * progress. Returns the cells whose collapsed state was changed.\n *\n * Parameters:\n *\n * collapsed - Boolean indicating the collapsed state to be assigned.\n * recurse - Optional boolean indicating if the collapsed state of all\n * descendants should be set. Default is false.\n * cells - Array of <mxCells> whose collapsed state should be set. If\n * null is specified then the foldable selection cells are used.\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\n * checked. Default is false.\n * evt - Optional native event that triggered the invocation.\n */\nmxGraph.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt)\n{\n\trecurse = (recurse != null) ? recurse : false;\n\n\tif (cells == null)\n\t{\n\t\tcells = this.getFoldableCells(this.getSelectionCells(), collapse);\n\t}\n\n\tthis.stopEditing(false);\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsFolded(cells, collapse, recurse, checkFoldable);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.FOLD_CELLS,\n\t\t\t'collapse', collapse, 'recurse', recurse, 'cells', cells));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsFolded\n *\n * Sets the collapsed state of the specified cells. This method fires\n * <mxEvent.CELLS_FOLDED> while the transaction is in progress. Returns the\n * cells whose collapsed state was changed.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose collapsed state should be set.\n * collapsed - Boolean indicating the collapsed state to be assigned.\n * recurse - Boolean indicating if the collapsed state of all descendants\n * should be set.\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\n * checked. Default is false.\n */\nmxGraph.prototype.cellsFolded = function(cells, collapse, recurse, checkFoldable)\n{\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) &&\n\t\t\t\t\tcollapse != this.isCellCollapsed(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.model.setCollapsed(cells[i], collapse);\n\t\t\t\t\tthis.swapBounds(cells[i], collapse);\n\n\t\t\t\t\tif (this.isExtendParent(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (recurse)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\t\t\t\tthis.cellsFolded(children, collapse, recurse);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_FOLDED,\n\t\t\t\t'cells', cells, 'collapse', collapse, 'recurse', recurse));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: swapBounds\n *\n * Swaps the alternate and the actual bounds in the geometry of the given\n * cell invoking <updateAlternateBounds> before carrying out the swap.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the bounds should be swapped.\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\n */\nmxGraph.prototype.swapBounds = function(cell, willCollapse)\n{\n\tif (cell != null)\n\t{\n\t\tvar geo = this.model.getGeometry(cell);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\n\t\t\tthis.updateAlternateBounds(cell, geo, willCollapse);\n\t\t\tgeo.swap();\n\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t}\n\t}\n};\n\n/**\n * Function: updateAlternateBounds\n *\n * Updates or sets the alternate bounds in the given geometry for the given\n * cell depending on whether the cell is going to be collapsed. If no\n * alternate bounds are defined in the geometry and\n * <collapseToPreferredSize> is true, then the preferred size is used for\n * the alternate bounds. The top, left corner is always kept at the same\n * location.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the geometry is being udpated.\n * g - <mxGeometry> for which the alternate bounds should be updated.\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\n */\nmxGraph.prototype.updateAlternateBounds = function(cell, geo, willCollapse)\n{\n\tif (cell != null && geo != null)\n\t{\n\t\tvar state = this.view.getState(cell);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\t\tif (geo.alternateBounds == null)\n\t\t{\n\t\t\tvar bounds = geo;\n\n\t\t\tif (this.collapseToPreferredSize)\n\t\t\t{\n\t\t\t\tvar tmp = this.getPreferredSizeForCell(cell);\n\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tbounds = tmp;\n\n\t\t\t\t\tvar startSize = mxUtils.getValue(style, mxConstants.STYLE_STARTSIZE);\n\n\t\t\t\t\tif (startSize > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbounds.height = Math.max(bounds.height, startSize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeo.alternateBounds = new mxRectangle(0, 0, bounds.width, bounds.height);\n\t\t}\n\n\t\tif (geo.alternateBounds != null)\n\t\t{\n\t\t\tgeo.alternateBounds.x = geo.x;\n\t\t\tgeo.alternateBounds.y = geo.y;\n\n\t\t\tvar alpha = mxUtils.toRadians(style[mxConstants.STYLE_ROTATION] || 0);\n\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n\t\t\t\tvar dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n\n\t\t\t\tvar cos = Math.cos(alpha);\n\t\t\t\tvar sin = Math.sin(alpha);\n\n\t\t\t\tvar dx2 = cos * dx - sin * dy;\n\t\t\t\tvar dy2 = sin * dx + cos * dy;\n\n\t\t\t\tgeo.alternateBounds.x += dx2 - dx;\n\t\t\t\tgeo.alternateBounds.y += dy2 - dy;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: addAllEdges\n *\n * Returns an array with the given cells and all edges that are connected\n * to a cell or one of its descendants.\n */\nmxGraph.prototype.addAllEdges = function(cells)\n{\n\tvar allCells = cells.slice();\n\n\treturn mxUtils.removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n};\n\n/**\n * Function: getAllEdges\n *\n * Returns all edges connected to the given cells or its descendants.\n */\nmxGraph.prototype.getAllEdges = function(cells)\n{\n\tvar edges = [];\n\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar edgeCount = this.model.getEdgeCount(cells[i]);\n\n\t\t\tfor (var j = 0; j < edgeCount; j++)\n\t\t\t{\n\t\t\t\tedges.push(this.model.getEdgeAt(cells[i], j));\n\t\t\t}\n\n\t\t\t// Recurses\n\t\t\tvar children = this.model.getChildren(cells[i]);\n\t\t\tedges = edges.concat(this.getAllEdges(children));\n\t\t}\n\t}\n\n\treturn edges;\n};\n\n/**\n * Group: Cell sizing\n */\n\n/**\n * Function: updateCellSize\n *\n * Updates the size of the given cell in the model using <cellSizeUpdated>.\n * This method fires <mxEvent.UPDATE_CELL_SIZE> while the transaction is in\n * progress. Returns the cell whose size was updated.\n *\n * Parameters:\n *\n * cell - <mxCell> whose size should be updated.\n */\nmxGraph.prototype.updateCellSize = function(cell, ignoreChildren)\n{\n\tignoreChildren = (ignoreChildren != null) ? ignoreChildren : false;\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellSizeUpdated(cell, ignoreChildren);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE,\n\t\t\t\t'cell', cell, 'ignoreChildren', ignoreChildren));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cell;\n};\n\n/**\n * Function: cellSizeUpdated\n *\n * Updates the size of the given cell in the model using\n * <getPreferredSizeForCell> to get the new size.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the size should be changed.\n */\nmxGraph.prototype.cellSizeUpdated = function(cell, ignoreChildren)\n{\n\tif (cell != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar size = this.getPreferredSizeForCell(cell);\n\t\t\tvar geo = this.model.getGeometry(cell);\n\n\t\t\tif (size != null && geo != null)\n\t\t\t{\n\t\t\t\tvar collapsed = this.isCellCollapsed(cell);\n\t\t\t\tgeo = geo.clone();\n\n\t\t\t\tif (this.isSwimlane(cell))\n\t\t\t\t{\n\t\t\t\t\tvar state = this.view.getState(cell);\n\t\t\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\t\t\t\t\tvar cellStyle = this.model.getStyle(cell);\n\n\t\t\t\t\tif (cellStyle == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = '';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = mxUtils.setStyle(cellStyle,\n\t\t\t\t\t\t\t\tmxConstants.STYLE_STARTSIZE, size.height + 8);\n\n\t\t\t\t\t\tif (collapsed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.height = size.height + 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo.width = size.width;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcellStyle = mxUtils.setStyle(cellStyle,\n\t\t\t\t\t\t\t\tmxConstants.STYLE_STARTSIZE, size.width + 8);\n\n\t\t\t\t\t\tif (collapsed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.width = size.width + 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeo.height = size.height;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.model.setStyle(cell, cellStyle);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tgeo.width = size.width;\n\t\t\t\t\tgeo.height = size.height;\n\t\t\t\t}\n\n\t\t\t\tif (!ignoreChildren && !collapsed)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = this.view.getBounds(this.model.getChildren(cell));\n\n\t\t\t\t\tif (bounds != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tr = this.view.translate;\n\t\t\t\t\t\tvar scale = this.view.scale;\n\n\t\t\t\t\t\tvar width = (bounds.x + bounds.width) / scale - geo.x - tr.x;\n\t\t\t\t\t\tvar height = (bounds.y + bounds.height) / scale - geo.y - tr.y;\n\n\t\t\t\t\t\tgeo.width = Math.max(geo.width, width);\n\t\t\t\t\t\tgeo.height = Math.max(geo.height, height);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.cellsResized([cell], [geo], false);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: getPreferredSizeForCell\n *\n * Returns the preferred width and height of the given <mxCell> as an\n * <mxRectangle>. To implement a minimum width, add a new style eg.\n * minWidth in the vertex and override this method as follows.\n *\n * (code)\n * var graphGetPreferredSizeForCell = graph.getPreferredSizeForCell;\n * graph.getPreferredSizeForCell = function(cell)\n * {\n *   var result = graphGetPreferredSizeForCell.apply(this, arguments);\n *   var style = this.getCellStyle(cell);\n *\n *   if (style['minWidth'] > 0)\n *   {\n *     result.width = Math.max(style['minWidth'], result.width);\n *   }\n *\n *   return result;\n * };\n * (end)\n *\n * Parameters:\n *\n * cell - <mxCell> for which the preferred size should be returned.\n */\nmxGraph.prototype.getPreferredSizeForCell = function(cell)\n{\n\tvar result = null;\n\n\tif (cell != null)\n\t{\n\t\tvar state = this.view.getState(cell) || this.view.createState(cell);\n\t\tvar style = state.style;\n\n\t\tif (!this.model.isEdge(cell))\n\t\t{\n\t\t\tvar fontSize = style[mxConstants.STYLE_FONTSIZE] || mxConstants.DEFAULT_FONTSIZE;\n\t\t\tvar dx = 0;\n\t\t\tvar dy = 0;\n\n\t\t\t// Adds dimension of image if shape is a label\n\t\t\tif (this.getImage(state) != null || style[mxConstants.STYLE_IMAGE] != null)\n\t\t\t{\n\t\t\t\tif (style[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_LABEL)\n\t\t\t\t{\n\t\t\t\t\tif (style[mxConstants.STYLE_VERTICAL_ALIGN] == mxConstants.ALIGN_MIDDLE)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx += parseFloat(style[mxConstants.STYLE_IMAGE_WIDTH]) || mxLabel.prototype.imageSize;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (style[mxConstants.STYLE_ALIGN] != mxConstants.ALIGN_CENTER)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy += parseFloat(style[mxConstants.STYLE_IMAGE_HEIGHT]) || mxLabel.prototype.imageSize;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adds spacings\n\t\t\tdx += 2 * (style[mxConstants.STYLE_SPACING] || 0);\n\t\t\tdx += style[mxConstants.STYLE_SPACING_LEFT] || 0;\n\t\t\tdx += style[mxConstants.STYLE_SPACING_RIGHT] || 0;\n\n\t\t\tdy += 2 * (style[mxConstants.STYLE_SPACING] || 0);\n\t\t\tdy += style[mxConstants.STYLE_SPACING_TOP] || 0;\n\t\t\tdy += style[mxConstants.STYLE_SPACING_BOTTOM] || 0;\n\n\t\t\t// Add spacing for collapse/expand icon\n\t\t\t// LATER: Check alignment and use constants\n\t\t\t// for image spacing\n\t\t\tvar image = this.getFoldingImage(state);\n\n\t\t\tif (image != null)\n\t\t\t{\n\t\t\t\tdx += image.width + 8;\n\t\t\t}\n\n\t\t\t// Adds space for label\n\t\t\tvar value = this.cellRenderer.getLabelValue(state);\n\n\t\t\tif (value != null && value.length > 0)\n\t\t\t{\n\t\t\t\tif (!this.isHtmlLabel(state.cell))\n\t\t\t\t{\n\t\t\t\t\tvalue = mxUtils.htmlEntities(value);\n\t\t\t\t}\n\n\t\t\t\tvalue = value.replace(/\\n/g, '<br>');\n\n\t\t\t\tvar size = mxUtils.getSizeForString(value, fontSize, style[mxConstants.STYLE_FONTFAMILY]);\n\t\t\t\tvar width = size.width + dx;\n\t\t\t\tvar height = size.height + dy;\n\n\t\t\t\tif (!mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t\t\t{\n\t\t\t\t\tvar tmp = height;\n\n\t\t\t\t\theight = width;\n\t\t\t\t\twidth = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (this.gridEnabled)\n\t\t\t\t{\n\t\t\t\t\twidth = this.snap(width + this.gridSize / 2);\n\t\t\t\t\theight = this.snap(height + this.gridSize / 2);\n\t\t\t\t}\n\n\t\t\t\tresult = new mxRectangle(0, 0, width, height);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar gs2 = 4 * this.gridSize;\n\t\t\t\tresult = new mxRectangle(0, 0, gs2, gs2);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: resizeCell\n *\n * Sets the bounds of the given cell using <resizeCells>. Returns the\n * cell which was passed to the function.\n *\n * Parameters:\n *\n * cell - <mxCell> whose bounds should be changed.\n * bounds - <mxRectangle> that represents the new bounds.\n */\nmxGraph.prototype.resizeCell = function(cell, bounds, recurse)\n{\n\treturn this.resizeCells([cell], [bounds], recurse)[0];\n};\n\n/**\n * Function: resizeCells\n *\n * Sets the bounds of the given cells and fires a <mxEvent.RESIZE_CELLS>\n * event while the transaction is in progress. Returns the cells which\n * have been passed to the function.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounds should be changed.\n * bounds - Array of <mxRectangles> that represent the new bounds.\n */\nmxGraph.prototype.resizeCells = function(cells, bounds, recurse)\n{\n\trecurse = (recurse != null) ? recurse : this.isRecursiveResize();\n\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tthis.cellsResized(cells, bounds, recurse);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.RESIZE_CELLS,\n\t\t\t\t'cells', cells, 'bounds', bounds));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsResized\n *\n * Sets the bounds of the given cells and fires a <mxEvent.CELLS_RESIZED>\n * event. If <extendParents> is true, then the parent is extended if a\n * child size is changed so that it overlaps with the parent.\n *\n * The following example shows how to control group resizes to make sure\n * that all child cells stay within the group.\n *\n * (code)\n * graph.addListener(mxEvent.CELLS_RESIZED, function(sender, evt)\n * {\n *   var cells = evt.getProperty('cells');\n *\n *   if (cells != null)\n *   {\n *     for (var i = 0; i < cells.length; i++)\n *     {\n *       if (graph.getModel().getChildCount(cells[i]) > 0)\n *       {\n *         var geo = graph.getCellGeometry(cells[i]);\n *\n *         if (geo != null)\n *         {\n *           var children = graph.getChildCells(cells[i], true, true);\n *           var bounds = graph.getBoundingBoxFromGeometry(children, true);\n *\n *           geo = geo.clone();\n *           geo.width = Math.max(geo.width, bounds.width);\n *           geo.height = Math.max(geo.height, bounds.height);\n *\n *           graph.getModel().setGeometry(cells[i], geo);\n *         }\n *       }\n *     }\n *   }\n * });\n * (end)\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounds should be changed.\n * bounds - Array of <mxRectangles> that represent the new bounds.\n * recurse - Optional boolean that specifies if the children should be resized.\n */\nmxGraph.prototype.cellsResized = function(cells, bounds, recurse)\n{\n\trecurse = (recurse != null) ? recurse : false;\n\n\tif (cells != null && bounds != null && cells.length == bounds.length)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.cellResized(cells[i], bounds[i], false, recurse);\n\n\t\t\t\tif (this.isExtendParent(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t}\n\n\t\t\tif (this.resetEdgesOnResize)\n\t\t\t{\n\t\t\t\tthis.resetEdges(cells);\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_RESIZED,\n\t\t\t\t\t'cells', cells, 'bounds', bounds));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: cellResized\n *\n * Resizes the parents recursively so that they contain the complete area\n * of the resized child cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose bounds should be changed.\n * bounds - <mxRectangles> that represent the new bounds.\n * ignoreRelative - Boolean that indicates if relative cells should be ignored.\n * recurse - Optional boolean that specifies if the children should be resized.\n */\nmxGraph.prototype.cellResized = function(cell, bounds, ignoreRelative, recurse)\n{\n\tvar geo = this.model.getGeometry(cell);\n\n\tif (geo != null && (geo.x != bounds.x || geo.y != bounds.y ||\n\t\tgeo.width != bounds.width || geo.height != bounds.height))\n\t{\n\t\tgeo = geo.clone();\n\n\t\tif (!ignoreRelative && geo.relative)\n\t\t{\n\t\t\tvar offset = geo.offset;\n\n\t\t\tif (offset != null)\n\t\t\t{\n\t\t\t\toffset.x += bounds.x - geo.x;\n\t\t\t\toffset.y += bounds.y - geo.y;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeo.x = bounds.x;\n\t\t\tgeo.y = bounds.y;\n\t\t}\n\n\t\tgeo.width = bounds.width;\n\t\tgeo.height = bounds.height;\n\n\t\tif (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates())\n\t\t{\n\t\t\tgeo.x = Math.max(0, geo.x);\n\t\t\tgeo.y = Math.max(0, geo.y);\n\t\t}\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (recurse)\n\t\t\t{\n\t\t\t\tthis.resizeChildCells(cell, geo);\n\t\t\t}\n\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t\tthis.constrainChildCells(cell);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: resizeChildCells\n *\n * Resizes the child cells of the given cell for the given new geometry with\n * respect to the current geometry of the cell.\n *\n * Parameters:\n *\n * cell - <mxCell> that has been resized.\n * newGeo - <mxGeometry> that represents the new bounds.\n */\nmxGraph.prototype.resizeChildCells = function(cell, newGeo)\n{\n\tvar geo = this.model.getGeometry(cell);\n\tvar dx = newGeo.width / geo.width;\n\tvar dy = newGeo.height / geo.height;\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.scaleCell(this.model.getChildAt(cell, i), dx, dy, true);\n\t}\n};\n\n/**\n * Function: constrainChildCells\n *\n * Constrains the children of the given cell using <constrainChild>.\n *\n * Parameters:\n *\n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.constrainChildCells = function(cell)\n{\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tthis.constrainChild(this.model.getChildAt(cell, i));\n\t}\n};\n\n/**\n * Function: scaleCell\n *\n * Scales the points, position and size of the given cell according to the\n * given vertical and horizontal scaling factors.\n *\n * Parameters:\n *\n * cell - <mxCell> whose geometry should be scaled.\n * dx - Horizontal scaling factor.\n * dy - Vertical scaling factor.\n * recurse - Boolean indicating if the child cells should be scaled.\n */\nmxGraph.prototype.scaleCell = function(cell, dx, dy, recurse)\n{\n\tvar geo = this.model.getGeometry(cell);\n\n\tif (geo != null)\n\t{\n\t\tvar state = this.view.getState(cell);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\t\tgeo = geo.clone();\n\n\t\t// Stores values for restoring based on style\n\t\tvar x = geo.x;\n\t\tvar y = geo.y\n\t\tvar w = geo.width;\n\t\tvar h = geo.height;\n\n\t\tgeo.scale(dx, dy, style[mxConstants.STYLE_ASPECT] == 'fixed');\n\n\t\tif (style[mxConstants.STYLE_RESIZE_WIDTH] == '1')\n\t\t{\n\t\t\tgeo.width = w * dx;\n\t\t}\n\t\telse if (style[mxConstants.STYLE_RESIZE_WIDTH] == '0')\n\t\t{\n\t\t\tgeo.width = w;\n\t\t}\n\n\t\tif (style[mxConstants.STYLE_RESIZE_HEIGHT] == '1')\n\t\t{\n\t\t\tgeo.height = h * dy;\n\t\t}\n\t\telse if (style[mxConstants.STYLE_RESIZE_HEIGHT] == '0')\n\t\t{\n\t\t\tgeo.height = h;\n\t\t}\n\n\t\tif (!this.isCellMovable(cell))\n\t\t{\n\t\t\tgeo.x = x;\n\t\t\tgeo.y = y;\n\t\t}\n\n\t\tif (!this.isCellResizable(cell))\n\t\t{\n\t\t\tgeo.width = w;\n\t\t\tgeo.height = h;\n\t\t}\n\n\t\tif (this.model.isVertex(cell))\n\t\t{\n\t\t\tthis.cellResized(cell, geo, true, recurse);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.model.setGeometry(cell, geo);\n\t\t}\n\t}\n};\n\n/**\n * Function: extendParent\n *\n * Resizes the parents recursively so that they contain the complete area\n * of the resized child cell.\n *\n * Parameters:\n *\n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.extendParent = function(cell)\n{\n\tif (cell != null)\n\t{\n\t\tvar parent = this.model.getParent(cell);\n\t\tvar p = this.getCellGeometry(parent);\n\n\t\tif (parent != null && p != null && !this.isCellCollapsed(parent))\n\t\t{\n\t\t\tvar geo = this.getCellGeometry(cell);\n\n\t\t\tif (geo != null && !geo.relative &&\n\t\t\t\t(p.width < geo.x + geo.width ||\n\t\t\t\tp.height < geo.y + geo.height))\n\t\t\t{\n\t\t\t\tp = p.clone();\n\n\t\t\t\tp.width = Math.max(p.width, geo.x + geo.width);\n\t\t\t\tp.height = Math.max(p.height, geo.y + geo.height);\n\n\t\t\t\tthis.cellsResized([parent], [p], false);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Group: Cell moving\n */\n\n/**\n * Function: importCells\n *\n * Clones and inserts the given cells into the graph using the move\n * method and returns the inserted cells. This shortcut is used if\n * cells are inserted via datatransfer.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be imported.\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\n * target - <mxCell> that represents the new parent of the cells.\n * evt - Mouseevent that triggered the invocation.\n * mapping - Optional mapping for existing clones.\n */\nmxGraph.prototype.importCells = function(cells, dx, dy, target, evt, mapping)\n{\n\treturn this.moveCells(cells, dx, dy, true, target, evt, mapping);\n};\n\n/**\n * Function: moveCells\n *\n * Moves or clones the specified cells and moves the cells or clones by the\n * given amount, adding them to the optional target cell. The evt is the\n * mouse event as the mouse was released. The change is carried out using\n * <cellsMoved>. This method fires <mxEvent.MOVE_CELLS> while the\n * transaction is in progress. Returns the cells that were moved.\n *\n * Use the following code to move all cells in the graph.\n *\n * (code)\n * graph.moveCells(graph.getChildCells(null, true, true), 10, 10);\n * (end)\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be moved, cloned or added to the target.\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\n * clone - Boolean indicating if the cells should be cloned. Default is false.\n * target - <mxCell> that represents the new parent of the cells.\n * evt - Mouseevent that triggered the invocation.\n * mapping - Optional mapping for existing clones.\n */\nmxGraph.prototype.moveCells = function(cells, dx, dy, clone, target, evt, mapping)\n{\n\tdx = (dx != null) ? dx : 0;\n\tdy = (dy != null) ? dy : 0;\n\tclone = (clone != null) ? clone : false;\n\n\tif (cells != null && (dx != 0 || dy != 0 || clone || target != null))\n\t{\n\t\t// Removes descendants with ancestors in cells to avoid multiple moving\n\t\tcells = this.model.getTopmostCells(cells);\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Faster cell lookups to remove relative edge labels with selected\n\t\t\t// terminals to avoid explicit and implicit move at same time\n\t\t\tvar dict = new mxDictionary();\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\n\t\t\tvar isSelected = mxUtils.bind(this, function(cell)\n\t\t\t{\n\t\t\t\twhile (cell != null)\n\t\t\t\t{\n\t\t\t\t\tif (dict.get(cell))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tcell = this.model.getParent(cell);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t});\n\n\t\t\t// Removes relative edge labels with selected terminals\n\t\t\tvar checked = [];\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\n\t\t\t\tif ((geo == null || !geo.relative) || !this.model.isEdge(parent) ||\n\t\t\t\t\t(!isSelected(this.model.getTerminal(parent, true)) &&\n\t\t\t\t\t!isSelected(this.model.getTerminal(parent, false))))\n\t\t\t\t{\n\t\t\t\t\tchecked.push(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcells = checked;\n\n\t\t\tif (clone)\n\t\t\t{\n\t\t\t\tcells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);\n\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\ttarget = this.getDefaultParent();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// FIXME: Cells should always be inserted first before any other edit\n\t\t\t// to avoid forward references in sessions.\n\t\t\t// Need to disable allowNegativeCoordinates if target not null to\n\t\t\t// allow for temporary negative numbers until cellsAdded is called.\n\t\t\tvar previous = this.isAllowNegativeCoordinates();\n\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tthis.setAllowNegativeCoordinates(true);\n\t\t\t}\n\n\t\t\tthis.cellsMoved(cells, dx, dy, !clone && this.isDisconnectOnMove()\n\t\t\t\t\t&& this.isAllowDanglingEdges(), target == null,\n\t\t\t\t\tthis.isExtendParentsOnMove() && target == null);\n\n\t\t\tthis.setAllowNegativeCoordinates(previous);\n\n\t\t\tif (target != null)\n\t\t\t{\n\t\t\t\tvar index = this.model.getChildCount(target);\n\t\t\t\tthis.cellsAdded(cells, target, index, null, null, true);\n\t\t\t}\n\n\t\t\t// Dispatches a move event\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.MOVE_CELLS, 'cells', cells,\n\t\t\t\t'dx', dx, 'dy', dy, 'clone', clone, 'target', target, 'event', evt));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n\n\treturn cells;\n};\n\n/**\n * Function: cellsMoved\n *\n * Moves the specified cells by the given vector, disconnecting the cells\n * using disconnectGraph is disconnect is true. This method fires\n * <mxEvent.CELLS_MOVED> while the transaction is in progress.\n */\nmxGraph.prototype.cellsMoved = function(cells, dx, dy, disconnect, constrain, extend)\n{\n\tif (cells != null && (dx != 0 || dy != 0))\n\t{\n\t\textend = (extend != null) ? extend : false;\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (disconnect)\n\t\t\t{\n\t\t\t\tthis.disconnectGraph(cells);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tthis.translateCell(cells[i], dx, dy);\n\n\t\t\t\tif (extend && this.isExtendParent(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.extendParent(cells[i]);\n\t\t\t\t}\n\t\t\t\telse if (constrain)\n\t\t\t\t{\n\t\t\t\t\tthis.constrainChild(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.resetEdgesOnMove)\n\t\t\t{\n\t\t\t\tthis.resetEdges(cells);\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELLS_MOVED,\n\t\t\t\t'cells', cells, 'dx', dx, 'dy', dy, 'disconnect', disconnect));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: translateCell\n *\n * Translates the geometry of the given cell and stores the new,\n * translated geometry in the model as an atomic change.\n */\nmxGraph.prototype.translateCell = function(cell, dx, dy)\n{\n\tvar geo = this.model.getGeometry(cell);\n\n\tif (geo != null)\n\t{\n\t\tdx = parseFloat(dx);\n\t\tdy = parseFloat(dy);\n\t\tgeo = geo.clone();\n\t\tgeo.translate(dx, dy);\n\n\t\tif (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates())\n\t\t{\n\t\t\tgeo.x = Math.max(0, parseFloat(geo.x));\n\t\t\tgeo.y = Math.max(0, parseFloat(geo.y));\n\t\t}\n\n\t\tif (geo.relative && !this.model.isEdge(cell))\n\t\t{\n\t\t\tvar parent = this.model.getParent(cell);\n\t\t\tvar angle = 0;\n\n\t\t\tif (this.model.isVertex(parent))\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(parent);\n\t\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(parent);\n\n\t\t\t\tangle = mxUtils.getValue(style, mxConstants.STYLE_ROTATION, 0);\n\t\t\t}\n\n\t\t\tif (angle != 0)\n\t\t\t{\n\t\t\t\tvar rad = mxUtils.toRadians(-angle);\n\t\t\t\tvar cos = Math.cos(rad);\n\t\t\t\tvar sin = Math.sin(rad);\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(dx, dy), cos, sin, new mxPoint(0, 0));\n\t\t\t\tdx = pt.x;\n\t\t\t\tdy = pt.y;\n\t\t\t}\n\n\t\t\tif (geo.offset == null)\n\t\t\t{\n\t\t\t\tgeo.offset = new mxPoint(dx, dy);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgeo.offset.x = parseFloat(geo.offset.x) + dx;\n\t\t\t\tgeo.offset.y = parseFloat(geo.offset.y) + dy;\n\t\t\t}\n\t\t}\n\n\t\tthis.model.setGeometry(cell, geo);\n\t}\n};\n\n/**\n * Function: getCellContainmentArea\n *\n * Returns the <mxRectangle> inside which a cell is to be kept.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the area should be returned.\n */\nmxGraph.prototype.getCellContainmentArea = function(cell)\n{\n\tif (cell != null && !this.model.isEdge(cell))\n\t{\n\t\tvar parent = this.model.getParent(cell);\n\n\t\tif (parent != null && parent != this.getDefaultParent())\n\t\t{\n\t\t\tvar g = this.model.getGeometry(parent);\n\n\t\t\tif (g != null)\n\t\t\t{\n\t\t\t\tvar x = 0;\n\t\t\t\tvar y = 0;\n\t\t\t\tvar w = g.width;\n\t\t\t\tvar h = g.height;\n\n\t\t\t\tif (this.isSwimlane(parent))\n\t\t\t\t{\n\t\t\t\t\tvar size = this.getStartSize(parent);\n\n\t\t\t\t\tvar state = this.view.getState(parent);\n\t\t\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(parent);\n\t\t\t\t\tvar dir = mxUtils.getValue(style, mxConstants.STYLE_DIRECTION, mxConstants.DIRECTION_EAST);\n\t\t\t\t\tvar flipH = mxUtils.getValue(style, mxConstants.STYLE_FLIPH, 0) == 1;\n\t\t\t\t\tvar flipV = mxUtils.getValue(style, mxConstants.STYLE_FLIPV, 0) == 1;\n\n\t\t\t\t\tif (dir == mxConstants.DIRECTION_SOUTH || dir == mxConstants.DIRECTION_NORTH)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = size.width;\n\t\t\t\t\t\tsize.width = size.height;\n\t\t\t\t\t\tsize.height = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((dir == mxConstants.DIRECTION_EAST && !flipV) || (dir == mxConstants.DIRECTION_NORTH && !flipH) ||\n\t\t\t\t\t\t(dir == mxConstants.DIRECTION_WEST && flipV) || (dir == mxConstants.DIRECTION_SOUTH && flipH))\n\t\t\t\t\t{\n\t\t\t\t\t\tx = size.width;\n\t\t\t\t\t\ty = size.height;\n\t\t\t\t\t}\n\n\t\t\t\t\tw -= size.width;\n\t\t\t\t\th -= size.height;\n\t\t\t\t}\n\n\t\t\t\treturn new mxRectangle(x, y, w, h);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getMaximumGraphBounds\n *\n * Returns the bounds inside which the diagram should be kept as an\n * <mxRectangle>.\n */\nmxGraph.prototype.getMaximumGraphBounds = function()\n{\n\treturn this.maximumGraphBounds;\n};\n\n/**\n * Function: constrainChild\n *\n * Keeps the given cell inside the bounds returned by\n * <getCellContainmentArea> for its parent, according to the rules defined by\n * <getOverlap> and <isConstrainChild>. This modifies the cell's geometry\n * in-place and does not clone it.\n *\n * Parameters:\n *\n * cells - <mxCell> which should be constrained.\n * sizeFirst - Specifies if the size should be changed first. Default is true.\n */\nmxGraph.prototype.constrainChild = function(cell, sizeFirst)\n{\n\tsizeFirst = (sizeFirst != null) ? sizeFirst : true;\n\n\tif (cell != null)\n\t{\n\t\tvar geo = this.getCellGeometry(cell);\n\n\t\tif (geo != null && (this.isConstrainRelativeChildren() || !geo.relative))\n\t\t{\n\t\t\tvar parent = this.model.getParent(cell);\n\t\t\tvar pgeo = this.getCellGeometry(parent);\n\t\t\tvar max = this.getMaximumGraphBounds();\n\n\t\t\t// Finds parent offset\n\t\t\tif (max != null)\n\t\t\t{\n\t\t\t\tvar off = this.getBoundingBoxFromGeometry([parent], false);\n\n\t\t\t\tif (off != null)\n\t\t\t\t{\n\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\n\t\t\t\t\tmax.x -= off.x;\n\t\t\t\t\tmax.y -= off.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isConstrainChild(cell))\n\t\t\t{\n\t\t\t\tvar tmp = this.getCellContainmentArea(cell);\n\n\t\t\t\tif (tmp != null)\n\t\t\t\t{\n\t\t\t\t\tvar overlap = this.getOverlap(cell);\n\n\t\t\t\t\tif (overlap > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = mxRectangle.fromRectangle(tmp);\n\n\t\t\t\t\t\ttmp.x -= tmp.width * overlap;\n\t\t\t\t\t\ttmp.y -= tmp.height * overlap;\n\t\t\t\t\t\ttmp.width += 2 * tmp.width * overlap;\n\t\t\t\t\t\ttmp.height += 2 * tmp.height * overlap;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Find the intersection between max and tmp\n\t\t\t\t\tif (max == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\t\t\tmax.intersect(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (max != null)\n\t\t\t{\n\t\t\t\tvar cells = [cell];\n\n\t\t\t\tif (!this.isCellCollapsed(cell))\n\t\t\t\t{\n\t\t\t\t\tvar desc = this.model.getDescendants(cell);\n\n\t\t\t\t\tfor (var i = 0; i < desc.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.isCellVisible(desc[i]))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcells.push(desc[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar bbox = this.getBoundingBoxFromGeometry(cells, false);\n\n\t\t\t\tif (bbox != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\t// Cumulative horizontal movement\n\t\t\t\t\tvar dx = 0;\n\n\t\t\t\t\tif (geo.width > max.width)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx = geo.width - max.width;\n\t\t\t\t\t\tgeo.width -= dx;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bbox.x + bbox.width > max.x + max.width)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx -= bbox.x + bbox.width - max.x - max.width - dx;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cumulative vertical movement\n\t\t\t\t\tvar dy = 0;\n\n\t\t\t\t\tif (geo.height > max.height)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy = geo.height - max.height;\n\t\t\t\t\t\tgeo.height -= dy;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bbox.y + bbox.height > max.y + max.height)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy -= bbox.y + bbox.height - max.y - max.height - dy;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bbox.x < max.x)\n\t\t\t\t\t{\n\t\t\t\t\t\tdx -= bbox.x - max.x;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bbox.y < max.y)\n\t\t\t\t\t{\n\t\t\t\t\t\tdy -= bbox.y - max.y;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dx != 0 || dy != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (geo.relative)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Relative geometries are moved via absolute offset\n\t\t\t\t\t\t\tif (geo.offset == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo.offset = new mxPoint();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeo.offset.x += dx;\n\t\t\t\t\t\t\tgeo.offset.y += dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo.x += dx;\n\t\t\t\t\t\t\tgeo.y += dy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.model.setGeometry(cell, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: resetEdges\n *\n * Resets the control points of the edges that are connected to the given\n * cells if not both ends of the edge are in the given cells array.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> for which the connected edges should be\n * reset.\n */\nmxGraph.prototype.resetEdges = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\t// Prepares faster cells lookup\n\t\tvar dict = new mxDictionary();\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tdict.put(cells[i], true);\n\t\t}\n\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar edges = this.model.getEdges(cells[i]);\n\n\t\t\t\tif (edges != null)\n\t\t\t\t{\n\t\t\t\t\tfor (var j = 0; j < edges.length; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(edges[j]);\n\n\t\t\t\t\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[j], true);\n\t\t\t\t\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[j], false);\n\n\t\t\t\t\t\t// Checks if one of the terminals is not in the given array\n\t\t\t\t\t\tif (!dict.get(source) || !dict.get(target))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.resetEdge(edges[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.resetEdges(this.model.getChildren(cells[i]));\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: resetEdge\n *\n * Resets the control points of the given edge.\n *\n * Parameters:\n *\n * edge - <mxCell> whose points should be reset.\n */\nmxGraph.prototype.resetEdge = function(edge)\n{\n\tvar geo = this.model.getGeometry(edge);\n\n\t// Resets the control points\n\tif (geo != null && geo.points != null && geo.points.length > 0)\n\t{\n\t\tgeo = geo.clone();\n\t\tgeo.points = [];\n\t\tthis.model.setGeometry(edge, geo);\n\t}\n\n\treturn edge;\n};\n\n/**\n * Group: Cell connecting and connection constraints\n */\n\n/**\n * Function: getOutlineConstraint\n *\n * Returns the constraint used to connect to the outline of the given state.\n */\nmxGraph.prototype.getOutlineConstraint = function(point, terminalState, me)\n{\n\tif (terminalState.shape != null)\n\t{\n\t\tvar bounds = this.view.getPerimeterBounds(terminalState);\n\t\tvar direction = terminalState.style[mxConstants.STYLE_DIRECTION];\n\n\t\tif (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH)\n\t\t{\n\t\t\tbounds.x += bounds.width / 2 - bounds.height / 2;\n\t\t\tbounds.y += bounds.height / 2 - bounds.width / 2;\n\t\t\tvar tmp = bounds.width;\n\t\t\tbounds.width = bounds.height;\n\t\t\tbounds.height = tmp;\n\t\t}\n\n\t\tvar alpha = mxUtils.toRadians(terminalState.shape.getShapeRotation());\n\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(-alpha);\n\t\t\tvar sin = Math.sin(-alpha);\n\n\t\t\tvar ct = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\t\t\tpoint = mxUtils.getRotatedPoint(point, cos, sin, ct);\n\t\t}\n\n\t\tvar sx = 1;\n\t\tvar sy = 1;\n\t\tvar dx = 0;\n\t\tvar dy = 0;\n\n\t\t// LATER: Add flipping support for image shapes\n\t\tif (this.getModel().isVertex(terminalState.cell))\n\t\t{\n\t\t\tvar flipH = terminalState.style[mxConstants.STYLE_FLIPH];\n\t\t\tvar flipV = terminalState.style[mxConstants.STYLE_FLIPV];\n\n\t\t\t// Legacy support for stencilFlipH/V\n\t\t\tif (terminalState.shape != null && terminalState.shape.stencil != null)\n\t\t\t{\n\t\t\t\tflipH = mxUtils.getValue(terminalState.style, 'stencilFlipH', 0) == 1 || flipH;\n\t\t\t\tflipV = mxUtils.getValue(terminalState.style, 'stencilFlipV', 0) == 1 || flipV;\n\t\t\t}\n\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tvar tmp = flipH;\n\t\t\t\tflipH = flipV;\n\t\t\t\tflipV = tmp;\n\t\t\t}\n\n\t\t\tif (flipH)\n\t\t\t{\n\t\t\t\tsx = -1;\n\t\t\t\tdx = -bounds.width;\n\t\t\t}\n\n\t\t\tif (flipV)\n\t\t\t{\n\t\t\t\tsy = -1;\n\t\t\t\tdy = -bounds.height ;\n\t\t\t}\n\t\t}\n\n\t\tpoint = new mxPoint((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n\n\t\tvar x = (bounds.width == 0) ? 0 : Math.round((point.x - bounds.x) * 1000 / bounds.width) / 1000;\n\t\tvar y = (bounds.height == 0) ? 0 : Math.round((point.y - bounds.y) * 1000 / bounds.height) / 1000;\n\n\t\treturn new mxConnectionConstraint(new mxPoint(x, y), false);\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getAllConnectionConstraints\n *\n * Returns an array of all <mxConnectionConstraints> for the given terminal. If\n * the shape of the given terminal is a <mxStencilShape> then the constraints\n * of the corresponding <mxStencil> are returned.\n *\n * Parameters:\n *\n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean that specifies if the terminal is the source or target.\n */\nmxGraph.prototype.getAllConnectionConstraints = function(terminal, source)\n{\n\tif (terminal != null && terminal.shape != null && terminal.shape.stencil != null)\n\t{\n\t\treturn terminal.shape.stencil.constraints;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getConnectionConstraint\n *\n * Returns an <mxConnectionConstraint> that describes the given connection\n * point. This result can then be passed to <getConnectionPoint>.\n *\n * Parameters:\n *\n * edge - <mxCellState> that represents the edge.\n * terminal - <mxCellState> that represents the terminal.\n * source - Boolean indicating if the terminal is the source or target.\n */\nmxGraph.prototype.getConnectionConstraint = function(edge, terminal, source)\n{\n\tvar point = null;\n\tvar x = edge.style[(source) ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];\n\n\tif (x != null)\n\t{\n\t\tvar y = edge.style[(source) ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];\n\n\t\tif (y != null)\n\t\t{\n\t\t\tpoint = new mxPoint(parseFloat(x), parseFloat(y));\n\t\t}\n\t}\n\n\tvar perimeter = false;\n\tvar dx = 0, dy = 0;\n\n\tif (point != null)\n\t{\n\t\tperimeter = mxUtils.getValue(edge.style, (source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, true);\n\n\t\t//Add entry/exit offset\n\t\tdx = parseFloat(edge.style[(source) ? mxConstants.STYLE_EXIT_DX : mxConstants.STYLE_ENTRY_DX]);\n\t\tdy = parseFloat(edge.style[(source) ? mxConstants.STYLE_EXIT_DY : mxConstants.STYLE_ENTRY_DY]);\n\n\t\tdx = isFinite(dx)? dx : 0;\n\t\tdy = isFinite(dy)? dy : 0;\n\t}\n\n\treturn new mxConnectionConstraint(point, perimeter, null, dx, dy);\n};\n\n/**\n * Function: setConnectionConstraint\n *\n * Sets the <mxConnectionConstraint> that describes the given connection point.\n * If no constraint is given then nothing is changed. To remove an existing\n * constraint from the given edge, use an empty constraint instead.\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge.\n * terminal - <mxCell> that represents the terminal.\n * source - Boolean indicating if the terminal is the source or target.\n * constraint - Optional <mxConnectionConstraint> to be used for this\n * connection.\n */\nmxGraph.prototype.setConnectionConstraint = function(edge, terminal, source, constraint)\n{\n\tif (constraint != null)\n\t{\n\t\tthis.model.beginUpdate();\n\n\t\ttry\n\t\t{\n\t\t\tif (constraint == null || constraint.point == null)\n\t\t\t{\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_X :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_X, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_Y :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_Y, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DX :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DX, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DY :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DY, null, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);\n\t\t\t}\n\t\t\telse if (constraint.point != null)\n\t\t\t{\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_X :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_X, constraint.point.x, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_Y :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_Y, constraint.point.y, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DX :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DX, constraint.dx, [edge]);\n\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_DY :\n\t\t\t\t\tmxConstants.STYLE_ENTRY_DY, constraint.dy, [edge]);\n\n\t\t\t\t// Only writes 0 since 1 is default\n\t\t\t\tif (!constraint.perimeter)\n\t\t\t\t{\n\t\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, '0', [edge]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.setCellStyles((source) ? mxConstants.STYLE_EXIT_PERIMETER :\n\t\t\t\t\t\tmxConstants.STYLE_ENTRY_PERIMETER, null, [edge]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: getConnectionPoint\n *\n * Returns the nearest point in the list of absolute points or the center\n * of the opposite terminal.\n *\n * Parameters:\n *\n * vertex - <mxCellState> that represents the vertex.\n * constraint - <mxConnectionConstraint> that represents the connection point\n * constraint as returned by <getConnectionConstraint>.\n */\nmxGraph.prototype.getConnectionPoint = function(vertex, constraint)\n{\n\tvar point = null;\n\n\tif (vertex != null && constraint.point != null)\n\t{\n\t\tvar bounds = this.view.getPerimeterBounds(vertex);\n        var cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\t\tvar direction = vertex.style[mxConstants.STYLE_DIRECTION];\n\t\tvar r1 = 0;\n\n\t\t// Bounds need to be rotated by 90 degrees for further computation\n\t\tif (direction != null && mxUtils.getValue(vertex.style,\n\t\t\tmxConstants.STYLE_ANCHOR_POINT_DIRECTION, 1) == 1)\n\t\t{\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH)\n\t\t\t{\n\t\t\t\tr1 += 270;\n\t\t\t}\n\t\t\telse if (direction == mxConstants.DIRECTION_WEST)\n\t\t\t{\n\t\t\t\tr1 += 180;\n\t\t\t}\n\t\t\telse if (direction == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tr1 += 90;\n\t\t\t}\n\n\t\t\t// Bounds need to be rotated by 90 degrees for further computation\n\t\t\tif (direction == mxConstants.DIRECTION_NORTH ||\n\t\t\t\tdirection == mxConstants.DIRECTION_SOUTH)\n\t\t\t{\n\t\t\t\tbounds.rotate90();\n\t\t\t}\n\t\t}\n\n\t\tvar scale = this.view.scale;\n\t\tpoint = new mxPoint(bounds.x + constraint.point.x * bounds.width + constraint.dx * scale,\n\t\t\t\tbounds.y + constraint.point.y * bounds.height + constraint.dy * scale);\n\n\t\t// Rotation for direction before projection on perimeter\n\t\tvar r2 = vertex.style[mxConstants.STYLE_ROTATION] || 0;\n\n\t\tif (constraint.perimeter)\n\t\t{\n\t\t\tif (r1 != 0)\n\t\t\t{\n\t\t\t\t// Only 90 degrees steps possible here so no trig needed\n\t\t\t\tvar cos = 0;\n\t\t\t\tvar sin = 0;\n\n\t\t\t\tif (r1 == 90)\n\t\t\t\t{\n\t\t\t\t\tsin = 1;\n\t\t\t\t}\n\t\t\t\telse if (r1 == 180)\n\t\t\t\t{\n\t\t\t\t\tcos = -1;\n\t\t\t\t}\n\t\t\t\telse if (r1 == 270)\n\t\t\t\t{\n\t\t\t\t\tsin = -1;\n\t\t\t\t}\n\n\t\t        point = mxUtils.getRotatedPoint(point, cos, sin, cx);\n\t\t\t}\n\n\t\t\tpoint = this.view.getPerimeterPoint(vertex, point, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr2 += r1;\n\n\t\t\tif (this.getModel().isVertex(vertex.cell))\n\t\t\t{\n\t\t\t\tvar flipH = vertex.style[mxConstants.STYLE_FLIPH] == 1;\n\t\t\t\tvar flipV = vertex.style[mxConstants.STYLE_FLIPV] == 1;\n\n\t\t\t\t// Legacy support for stencilFlipH/V\n\t\t\t\tif (vertex.shape != null && vertex.shape.stencil != null)\n\t\t\t\t{\n\t\t\t\t\tflipH = (mxUtils.getValue(vertex.style, 'stencilFlipH', 0) == 1) || flipH;\n\t\t\t\t\tflipV = (mxUtils.getValue(vertex.style, 'stencilFlipV', 0) == 1) || flipV;\n\t\t\t\t}\n\n\t\t\t\tif (flipH)\n\t\t\t\t{\n\t\t\t\t\tpoint.x = 2 * bounds.getCenterX() - point.x;\n\t\t\t\t}\n\n\t\t\t\tif (flipV)\n\t\t\t\t{\n\t\t\t\t\tpoint.y = 2 * bounds.getCenterY() - point.y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Generic rotation after projection on perimeter\n\t\tif (r2 != 0 && point != null)\n\t\t{\n\t        var rad = mxUtils.toRadians(r2);\n\t        var cos = Math.cos(rad);\n\t        var sin = Math.sin(rad);\n\n\t        point = mxUtils.getRotatedPoint(point, cos, sin, cx);\n\t\t}\n\t}\n\n\tif (point != null)\n\t{\n\t\tpoint.x = Math.round(point.x);\n\t\tpoint.y = Math.round(point.y);\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: connectCell\n *\n * Connects the specified end of the given edge to the given terminal\n * using <cellConnected> and fires <mxEvent.CONNECT_CELL> while the\n * transaction is in progress. Returns the updated edge.\n *\n * Parameters:\n *\n * edge - <mxCell> whose terminal should be updated.\n * terminal - <mxCell> that represents the new terminal to be used.\n * source - Boolean indicating if the new terminal is the source or target.\n * constraint - Optional <mxConnectionConstraint> to be used for this\n * connection.\n */\nmxGraph.prototype.connectCell = function(edge, terminal, source, constraint)\n{\n\tthis.model.beginUpdate();\n\ttry\n\t{\n\t\tvar previous = this.model.getTerminal(edge, source);\n\t\tthis.cellConnected(edge, terminal, source, constraint);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.CONNECT_CELL,\n\t\t\t'edge', edge, 'terminal', terminal, 'source', source,\n\t\t\t'previous', previous));\n\t}\n\tfinally\n\t{\n\t\tthis.model.endUpdate();\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: cellConnected\n *\n * Sets the new terminal for the given edge and resets the edge points if\n * <resetEdgesOnConnect> is true. This method fires\n * <mxEvent.CELL_CONNECTED> while the transaction is in progress.\n *\n * Parameters:\n *\n * edge - <mxCell> whose terminal should be updated.\n * terminal - <mxCell> that represents the new terminal to be used.\n * source - Boolean indicating if the new terminal is the source or target.\n * constraint - <mxConnectionConstraint> to be used for this connection.\n */\nmxGraph.prototype.cellConnected = function(edge, terminal, source, constraint)\n{\n\tif (edge != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar previous = this.model.getTerminal(edge, source);\n\n\t\t\t// Updates the constraint\n\t\t\tthis.setConnectionConstraint(edge, terminal, source, constraint);\n\n\t\t\t// Checks if the new terminal is a port, uses the ID of the port in the\n\t\t\t// style and the parent of the port as the actual terminal of the edge.\n\t\t\tif (this.isPortsEnabled())\n\t\t\t{\n\t\t\t\tvar id = null;\n\n\t\t\t\tif (this.isPort(terminal))\n\t\t\t\t{\n\t\t\t\t\tid = terminal.getId();\n\t\t\t\t\tterminal = this.getTerminalForPort(terminal, source);\n\t\t\t\t}\n\n\t\t\t\t// Sets or resets all previous information for connecting to a child port\n\t\t\t\tvar key = (source) ? mxConstants.STYLE_SOURCE_PORT :\n\t\t\t\t\tmxConstants.STYLE_TARGET_PORT;\n\t\t\t\tthis.setCellStyles(key, id, [edge]);\n\t\t\t}\n\n\t\t\tthis.model.setTerminal(edge, terminal, source);\n\n\t\t\tif (this.resetEdgesOnConnect)\n\t\t\t{\n\t\t\t\tthis.resetEdge(edge);\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CELL_CONNECTED,\n\t\t\t\t'edge', edge, 'terminal', terminal, 'source', source,\n\t\t\t\t'previous', previous));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: disconnectGraph\n *\n * Disconnects the given edges from the terminals which are not in the\n * given array.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be disconnected.\n */\nmxGraph.prototype.disconnectGraph = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tthis.model.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar scale = this.view.scale;\n\t\t\tvar tr = this.view.translate;\n\n\t\t\t// Fast lookup for finding cells in array\n\t\t\tvar dict = new mxDictionary();\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (this.model.isEdge(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tvar geo = this.model.getGeometry(cells[i]);\n\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = this.view.getState(cells[i]);\n\t\t\t\t\t\tvar pstate = this.view.getState(\n\t\t\t\t\t\t\tthis.model.getParent(cells[i]));\n\n\t\t\t\t\t\tif (state != null &&\n\t\t\t\t\t\t\tpstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\t\t\tvar dx = -pstate.origin.x;\n\t\t\t\t\t\t\tvar dy = -pstate.origin.y;\n\t\t\t\t\t\t\tvar pts = state.absolutePoints;\n\n\t\t\t\t\t\t\tvar src = this.model.getTerminal(cells[i], true);\n\n\t\t\t\t\t\t\tif (src != null && this.isCellDisconnectable(cells[i], src, true))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile (src != null && !dict.get(src))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tsrc = this.model.getParent(src);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (src == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[0].x / scale - tr.x + dx,\n\t\t\t\t\t\t\t\t\t\t\tpts[0].y / scale - tr.y + dy), true);\n\t\t\t\t\t\t\t\t\tthis.model.setTerminal(cells[i], null, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar trg = this.model.getTerminal(cells[i], false);\n\n\t\t\t\t\t\t\tif (trg != null && this.isCellDisconnectable(cells[i], trg, false))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile (trg != null && !dict.get(trg))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttrg = this.model.getParent(trg);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (trg == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar n = pts.length - 1;\n\t\t\t\t\t\t\t\t\tgeo.setTerminalPoint(\n\t\t\t\t\t\t\t\t\t\tnew mxPoint(pts[n].x / scale - tr.x + dx,\n\t\t\t\t\t\t\t\t\t\t\tpts[n].y / scale - tr.y + dy), false);\n\t\t\t\t\t\t\t\t\tthis.model.setTerminal(cells[i], null, false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.model.setGeometry(cells[i], geo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.model.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Group: Drilldown\n */\n\n/**\n * Function: getCurrentRoot\n *\n * Returns the current root of the displayed cell hierarchy. This is a\n * shortcut to <mxGraphView.currentRoot> in <view>.\n */\nmxGraph.prototype.getCurrentRoot = function()\n{\n\treturn this.view.currentRoot;\n};\n\n/**\n * Function: getTranslateForRoot\n *\n * Returns the translation to be used if the given cell is the root cell as\n * an <mxPoint>. This implementation returns null.\n *\n * Example:\n *\n * To keep the children at their absolute position while stepping into groups,\n * this function can be overridden as follows.\n *\n * (code)\n * var offset = new mxPoint(0, 0);\n *\n * while (cell != null)\n * {\n *   var geo = this.model.getGeometry(cell);\n *\n *   if (geo != null)\n *   {\n *     offset.x -= geo.x;\n *     offset.y -= geo.y;\n *   }\n *\n *   cell = this.model.getParent(cell);\n * }\n *\n * return offset;\n * (end)\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the root.\n */\nmxGraph.prototype.getTranslateForRoot = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: isPort\n *\n * Returns true if the given cell is a \"port\", that is, when connecting to\n * it, the cell returned by getTerminalForPort should be used as the\n * terminal and the port should be referenced by the ID in either the\n * mxConstants.STYLE_SOURCE_PORT or the or the\n * mxConstants.STYLE_TARGET_PORT. Note that a port should not be movable.\n * This implementation always returns false.\n *\n * A typical implementation is the following:\n *\n * (code)\n * graph.isPort = function(cell)\n * {\n *   var geo = this.getCellGeometry(cell);\n *\n *   return (geo != null) ? geo.relative : false;\n * };\n * (end)\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the port.\n */\nmxGraph.prototype.isPort = function(cell)\n{\n\treturn false;\n};\n\n/**\n * Function: getTerminalForPort\n *\n * Returns the terminal to be used for a given port. This implementation\n * always returns the parent cell.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the port.\n * source - If the cell is the source or target port.\n */\nmxGraph.prototype.getTerminalForPort = function(cell, source)\n{\n\treturn this.model.getParent(cell);\n};\n\n/**\n * Function: getChildOffsetForCell\n *\n * Returns the offset to be used for the cells inside the given cell. The\n * root and layer cells may be identified using <mxGraphModel.isRoot> and\n * <mxGraphModel.isLayer>. For all other current roots, the\n * <mxGraphView.currentRoot> field points to the respective cell, so that\n * the following holds: cell == this.view.currentRoot. This implementation\n * returns null.\n *\n * Parameters:\n *\n * cell - <mxCell> whose offset should be returned.\n */\nmxGraph.prototype.getChildOffsetForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: enterGroup\n *\n * Uses the given cell as the root of the displayed cell hierarchy. If no\n * cell is specified then the selection cell is used. The cell is only used\n * if <isValidRoot> returns true.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> to be used as the new root. Default is the\n * selection cell.\n */\nmxGraph.prototype.enterGroup = function(cell)\n{\n\tcell = cell || this.getSelectionCell();\n\n\tif (cell != null && this.isValidRoot(cell))\n\t{\n\t\tthis.view.setCurrentRoot(cell);\n\t\tthis.clearSelection();\n\t}\n};\n\n/**\n * Function: exitGroup\n *\n * Changes the current root to the next valid root in the displayed cell\n * hierarchy.\n */\nmxGraph.prototype.exitGroup = function()\n{\n\tvar root = this.model.getRoot();\n\tvar current = this.getCurrentRoot();\n\n\tif (current != null)\n\t{\n\t\tvar next = this.model.getParent(current);\n\n\t\t// Finds the next valid root in the hierarchy\n\t\twhile (next != root && !this.isValidRoot(next) &&\n\t\t\t\tthis.model.getParent(next) != root)\n\t\t{\n\t\t\tnext = this.model.getParent(next);\n\t\t}\n\n\t\t// Clears the current root if the new root is\n\t\t// the model's root or one of the layers.\n\t\tif (next == root || this.model.getParent(next) == root)\n\t\t{\n\t\t\tthis.view.setCurrentRoot(null);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.view.setCurrentRoot(next);\n\t\t}\n\n\t\tvar state = this.view.getState(current);\n\n\t\t// Selects the previous root in the graph\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.setSelectionCell(current);\n\t\t}\n\t}\n};\n\n/**\n * Function: home\n *\n * Uses the root of the model as the root of the displayed cell hierarchy\n * and selects the previous root.\n */\nmxGraph.prototype.home = function()\n{\n\tvar current = this.getCurrentRoot();\n\n\tif (current != null)\n\t{\n\t\tthis.view.setCurrentRoot(null);\n\t\tvar state = this.view.getState(current);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tthis.setSelectionCell(current);\n\t\t}\n\t}\n};\n\n/**\n * Function: isValidRoot\n *\n * Returns true if the given cell is a valid root for the cell display\n * hierarchy. This implementation returns true for all non-null values.\n *\n * Parameters:\n *\n * cell - <mxCell> which should be checked as a possible root.\n */\nmxGraph.prototype.isValidRoot = function(cell)\n{\n\treturn (cell != null);\n};\n\n/**\n * Group: Graph display\n */\n\n/**\n * Function: getGraphBounds\n *\n * Returns the bounds of the visible graph. Shortcut to\n * <mxGraphView.getGraphBounds>. See also: <getBoundingBoxFromGeometry>.\n */\n mxGraph.prototype.getGraphBounds = function()\n {\n \treturn this.view.getGraphBounds();\n };\n\n/**\n * Function: getCellBounds\n *\n * Returns the scaled, translated bounds for the given cell. See\n * <mxGraphView.getBounds> for arrays.\n *\n * Parameters:\n *\n * cell - <mxCell> whose bounds should be returned.\n * includeEdge - Optional boolean that specifies if the bounds of\n * the connected edges should be included. Default is false.\n * includeDescendants - Optional boolean that specifies if the bounds\n * of all descendants should be included. Default is false.\n */\nmxGraph.prototype.getCellBounds = function(cell, includeEdges, includeDescendants)\n{\n\tvar cells = [cell];\n\n\t// Includes all connected edges\n\tif (includeEdges)\n\t{\n\t\tcells = cells.concat(this.model.getEdges(cell));\n\t}\n\n\tvar result = this.view.getBounds(cells);\n\n\t// Recursively includes the bounds of the children\n\tif (includeDescendants)\n\t{\n\t\tvar childCount = this.model.getChildCount(cell);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar tmp = this.getCellBounds(this.model.getChildAt(cell, i),\n\t\t\t\tincludeEdges, true);\n\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\tresult.add(tmp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getBoundingBoxFromGeometry\n *\n * Returns the bounding box for the geometries of the vertices in the\n * given array of cells. This can be used to find the graph bounds during\n * a layout operation (ie. before the last endUpdate) as follows:\n *\n * (code)\n * var cells = graph.getChildCells(graph.getDefaultParent(), true, true);\n * var bounds = graph.getBoundingBoxFromGeometry(cells, true);\n * (end)\n *\n * This can then be used to move cells to the origin:\n *\n * (code)\n * if (bounds.x < 0 || bounds.y < 0)\n * {\n *   graph.moveCells(cells, -Math.min(bounds.x, 0), -Math.min(bounds.y, 0))\n * }\n * (end)\n *\n * Or to translate the graph view:\n *\n * (code)\n * if (bounds.x < 0 || bounds.y < 0)\n * {\n *   graph.view.setTranslate(-Math.min(bounds.x, 0), -Math.min(bounds.y, 0));\n * }\n * (end)\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounds should be returned.\n * includeEdges - Specifies if edge bounds should be included by computing\n * the bounding box for all points in geometry. Default is false.\n */\nmxGraph.prototype.getBoundingBoxFromGeometry = function(cells, includeEdges)\n{\n\tincludeEdges = (includeEdges != null) ? includeEdges : false;\n\tvar result = null;\n\n\tif (cells != null)\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (includeEdges || this.model.isVertex(cells[i]))\n\t\t\t{\n\t\t\t\t// Computes the bounding box for the points in the geometry\n\t\t\t\tvar geo = this.getCellGeometry(cells[i]);\n\n\t\t\t\tif (geo != null)\n\t\t\t\t{\n\t\t\t\t\tvar bbox = null;\n\n\t\t\t\t\tif (this.model.isEdge(cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar addPoint = function(pt)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (pt != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (tmp == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp = new mxRectangle(pt.x, pt.y, 0, 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttmp.add(new mxRectangle(pt.x, pt.y, 0, 0));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (this.model.getTerminal(cells[i], true) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddPoint(geo.getTerminalPoint(true));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.model.getTerminal(cells[i], false) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddPoint(geo.getTerminalPoint(false));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar pts = geo.points;\n\n\t\t\t\t\t\tif (pts != null && pts.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmp = new mxRectangle(pts[0].x, pts[0].y, 0, 0);\n\n\t\t\t\t\t\t\tfor (var j = 1; j < pts.length; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddPoint(pts[j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbbox = tmp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar parent = this.model.getParent(cells[i]);\n\n\t\t\t\t\t\tif (geo.relative)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (this.model.isVertex(parent) && parent != this.view.currentRoot)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tmp = this.getBoundingBoxFromGeometry([parent], false);\n\n\t\t\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbbox = new mxRectangle(geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);\n\n\t\t\t\t\t\t\t\t\tif (mxUtils.indexOf(cells, parent) >= 0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tbbox.x += tmp.x;\n\t\t\t\t\t\t\t\t\t\tbbox.y += tmp.y;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbbox = mxRectangle.fromRectangle(geo);\n\n\t\t\t\t\t\t\tif (this.model.isVertex(parent) && mxUtils.indexOf(cells, parent) >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar tmp = this.getBoundingBoxFromGeometry([parent], false);\n\n\t\t\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbbox.x += tmp.x;\n\t\t\t\t\t\t\t\t\tbbox.y += tmp.y;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (bbox != null && geo.offset != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbbox.x += geo.offset.x;\n\t\t\t\t\t\t\tbbox.y += geo.offset.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bbox != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (result == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: refresh\n *\n * Clears all cell states or the states for the hierarchy starting at the\n * given cell and validates the graph. This fires a refresh event as the\n * last step.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> for which the cell states should be cleared.\n */\nmxGraph.prototype.refresh = function(cell)\n{\n\tthis.view.clear(cell, cell == null);\n\tthis.view.validate();\n\tthis.sizeDidChange();\n\tthis.fireEvent(new mxEventObject(mxEvent.REFRESH));\n};\n\n/**\n * Function: snap\n *\n * Snaps the given numeric value to the grid if <gridEnabled> is true.\n *\n * Parameters:\n *\n * value - Numeric value to be snapped to the grid.\n */\nmxGraph.prototype.snap = function(value)\n{\n\tif (this.gridEnabled)\n\t{\n\t\tvalue = Math.round(value / this.gridSize ) * this.gridSize;\n\t}\n\n\treturn value;\n};\n\n/**\n * Function: panGraph\n *\n * Shifts the graph display by the given amount. This is used to preview\n * panning operations, use <mxGraphView.setTranslate> to set a persistent\n * translation of the view. Fires <mxEvent.PAN>.\n *\n * Parameters:\n *\n * dx - Amount to shift the graph along the x-axis.\n * dy - Amount to shift the graph along the y-axis.\n */\nmxGraph.prototype.panGraph = function(dx, dy)\n{\n\tif (this.useScrollbarsForPanning && mxUtils.hasScrollbars(this.container))\n\t{\n\t\tthis.container.scrollLeft = -dx;\n\t\tthis.container.scrollTop = -dy;\n\t}\n\telse\n\t{\n\t\tvar canvas = this.view.getCanvas();\n\n\t\tif (this.dialect == mxConstants.DIALECT_SVG)\n\t\t{\n\t\t\t// Puts everything inside the container in a DIV so that it\n\t\t\t// can be moved without changing the state of the container\n\t\t\tif (dx == 0 && dy == 0)\n\t\t\t{\n\t\t\t\t// Workaround for ignored removeAttribute on SVG element in IE9 standards\n\t\t\t\tif (mxClient.IS_IE)\n\t\t\t\t{\n\t\t\t\t\tcanvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcanvas.removeAttribute('transform');\n\t\t\t\t}\n\n\t\t\t\tif (this.shiftPreview1 != null)\n\t\t\t\t{\n\t\t\t\t\tvar child = this.shiftPreview1.firstChild;\n\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\tthis.container.appendChild(child);\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shiftPreview1.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.shiftPreview1 = null;\n\n\t\t\t\t\tthis.container.appendChild(canvas.parentNode);\n\n\t\t\t\t\tchild = this.shiftPreview2.firstChild;\n\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\t\t\t\t\t\tthis.container.appendChild(child);\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shiftPreview2.parentNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shiftPreview2.parentNode.removeChild(this.shiftPreview2);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.shiftPreview2 = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcanvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n\n\t\t\t\tif (this.shiftPreview1 == null)\n\t\t\t\t{\n\t\t\t\t\t// Needs two divs for stuff before and after the SVG element\n\t\t\t\t\tthis.shiftPreview1 = document.createElement('div');\n\t\t\t\t\tthis.shiftPreview1.style.position = 'absolute';\n\t\t\t\t\tthis.shiftPreview1.style.overflow = 'visible';\n\n\t\t\t\t\tthis.shiftPreview2 = document.createElement('div');\n\t\t\t\t\tthis.shiftPreview2.style.position = 'absolute';\n\t\t\t\t\tthis.shiftPreview2.style.overflow = 'visible';\n\n\t\t\t\t\tvar current = this.shiftPreview1;\n\t\t\t\t\tvar child = this.container.firstChild;\n\n\t\t\t\t\twhile (child != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar next = child.nextSibling;\n\n\t\t\t\t\t\t// SVG element is moved via transform attribute\n\t\t\t\t\t\tif (child != canvas.parentNode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent.appendChild(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent = this.shiftPreview2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tchild = next;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Inserts elements only if not empty\n\t\t\t\t\tif (this.shiftPreview1.firstChild != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.container.insertBefore(this.shiftPreview1, canvas.parentNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.shiftPreview2.firstChild != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.container.appendChild(this.shiftPreview2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.shiftPreview1.style.left = dx + 'px';\n\t\t\t\tthis.shiftPreview1.style.top = dy + 'px';\n\t\t\t\tthis.shiftPreview2.style.left = dx + 'px';\n\t\t\t\tthis.shiftPreview2.style.top = dy + 'px';\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcanvas.style.left = dx + 'px';\n\t\t\tcanvas.style.top = dy + 'px';\n\t\t}\n\n\t\tthis.panDx = dx;\n\t\tthis.panDy = dy;\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN));\n\t}\n};\n\n/**\n * Function: zoomIn\n *\n * Zooms into the graph by <zoomFactor>.\n */\nmxGraph.prototype.zoomIn = function()\n{\n\tthis.zoom(this.zoomFactor);\n};\n\n/**\n * Function: zoomOut\n *\n * Zooms out of the graph by <zoomFactor>.\n */\nmxGraph.prototype.zoomOut = function()\n{\n\tthis.zoom(1 / this.zoomFactor);\n};\n\n/**\n * Function: zoomActual\n *\n * Resets the zoom and panning in the view.\n */\nmxGraph.prototype.zoomActual = function()\n{\n\tif (this.view.scale == 1)\n\t{\n\t\tthis.view.setTranslate(0, 0);\n\t}\n\telse\n\t{\n\t\tthis.view.translate.x = 0;\n\t\tthis.view.translate.y = 0;\n\n\t\tthis.view.setScale(1);\n\t}\n};\n\n/**\n * Function: zoomTo\n *\n * Zooms the graph to the given scale with an optional boolean center\n * argument, which is passd to <zoom>.\n */\nmxGraph.prototype.zoomTo = function(scale, center)\n{\n\tthis.zoom(scale / this.view.scale, center);\n};\n\n/**\n * Function: center\n *\n * Centers the graph in the container.\n *\n * Parameters:\n *\n * horizontal - Optional boolean that specifies if the graph should be centered\n * horizontally. Default is true.\n * vertical - Optional boolean that specifies if the graph should be centered\n * vertically. Default is true.\n * cx - Optional float that specifies the horizontal center. Default is 0.5.\n * cy - Optional float that specifies the vertical center. Default is 0.5.\n */\nmxGraph.prototype.center = function(horizontal, vertical, cx, cy)\n{\n\thorizontal = (horizontal != null) ? horizontal : true;\n\tvertical = (vertical != null) ? vertical : true;\n\tcx = (cx != null) ? cx : 0.5;\n\tcy = (cy != null) ? cy : 0.5;\n\n\tvar hasScrollbars = mxUtils.hasScrollbars(this.container);\n\tvar cw = this.container.clientWidth;\n\tvar ch = this.container.clientHeight;\n\tvar bounds = this.getGraphBounds();\n\n\tvar t = this.view.translate;\n\tvar s = this.view.scale;\n\n\tvar dx = (horizontal) ? cw - bounds.width : 0;\n\tvar dy = (vertical) ? ch - bounds.height : 0;\n\n\tif (!hasScrollbars)\n\t{\n\t\tthis.view.setTranslate((horizontal) ? Math.floor(t.x - bounds.x * s + dx * cx / s) : t.x,\n\t\t\t(vertical) ? Math.floor(t.y - bounds.y * s + dy * cy / s) : t.y);\n\t}\n\telse\n\t{\n\t\tbounds.x -= t.x;\n\t\tbounds.y -= t.y;\n\n\t\tvar sw = this.container.scrollWidth;\n\t\tvar sh = this.container.scrollHeight;\n\n\t\tif (sw > cw)\n\t\t{\n\t\t\tdx = 0;\n\t\t}\n\n\t\tif (sh > ch)\n\t\t{\n\t\t\tdy = 0;\n\t\t}\n\n\t\tthis.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));\n\t\tthis.container.scrollLeft = (sw - cw) / 2;\n\t\tthis.container.scrollTop = (sh - ch) / 2;\n\t}\n};\n\n/**\n * Function: zoom\n *\n * Zooms the graph using the given factor. Center is an optional boolean\n * argument that keeps the graph scrolled to the center. If the center argument\n * is omitted, then <centerZoom> will be used as its value.\n */\nmxGraph.prototype.zoom = function(factor, center)\n{\n\tcenter = (center != null) ? center : this.centerZoom;\n\tvar scale = Math.round(this.view.scale * factor * 100) / 100;\n\tvar state = this.view.getState(this.getSelectionCell());\n\tfactor = scale / this.view.scale;\n\n\tif (this.keepSelectionVisibleOnZoom && state != null)\n\t{\n\t\tvar rect = new mxRectangle(state.x * factor, state.y * factor,\n\t\t\tstate.width * factor, state.height * factor);\n\n\t\t// Refreshes the display only once if a scroll is carried out\n\t\tthis.view.scale = scale;\n\n\t\tif (!this.scrollRectToVisible(rect))\n\t\t{\n\t\t\tthis.view.revalidate();\n\n\t\t\t// Forces an event to be fired but does not revalidate again\n\t\t\tthis.view.setScale(scale);\n\t\t}\n\t}\n\telse\n\t{\n\t\tvar hasScrollbars = mxUtils.hasScrollbars(this.container);\n\n\t\tif (center && !hasScrollbars)\n\t\t{\n\t\t\tvar dx = this.container.offsetWidth;\n\t\t\tvar dy = this.container.offsetHeight;\n\n\t\t\tif (factor > 1)\n\t\t\t{\n\t\t\t\tvar f = (factor - 1) / (scale * 2);\n\t\t\t\tdx *= -f;\n\t\t\t\tdy *= -f;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar f = (1 / factor - 1) / (this.view.scale * 2);\n\t\t\t\tdx *= f;\n\t\t\t\tdy *= f;\n\t\t\t}\n\n\t\t\tthis.view.scaleAndTranslate(scale,\n\t\t\t\tthis.view.translate.x + dx,\n\t\t\t\tthis.view.translate.y + dy);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Allows for changes of translate and scrollbars during setscale\n\t\t\tvar tx = this.view.translate.x;\n\t\t\tvar ty = this.view.translate.y;\n\t\t\tvar sl = this.container.scrollLeft;\n\t\t\tvar st = this.container.scrollTop;\n\n\t\t\tthis.view.setScale(scale);\n\n\t\t\tif (hasScrollbars)\n\t\t\t{\n\t\t\t\tvar dx = 0;\n\t\t\t\tvar dy = 0;\n\n\t\t\t\tif (center)\n\t\t\t\t{\n\t\t\t\t\tdx = this.container.offsetWidth * (factor - 1) / 2;\n\t\t\t\t\tdy = this.container.offsetHeight * (factor - 1) / 2;\n\t\t\t\t}\n\n\t\t\t\tthis.container.scrollLeft = (this.view.translate.x - tx) * this.view.scale + Math.round(sl * factor + dx);\n\t\t\t\tthis.container.scrollTop = (this.view.translate.y - ty) * this.view.scale + Math.round(st * factor + dy);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: zoomToRect\n *\n * Zooms the graph to the specified rectangle. If the rectangle does not have same aspect\n * ratio as the display container, it is increased in the smaller relative dimension only\n * until the aspect match. The original rectangle is centralised within this expanded one.\n *\n * Note that the input rectangular must be un-scaled and un-translated.\n *\n * Parameters:\n *\n * rect - The un-scaled and un-translated rectangluar region that should be just visible\n * after the operation\n */\nmxGraph.prototype.zoomToRect = function(rect)\n{\n\tvar scaleX = this.container.clientWidth / rect.width;\n\tvar scaleY = this.container.clientHeight / rect.height;\n\tvar aspectFactor = scaleX / scaleY;\n\n\t// Remove any overlap of the rect outside the client area\n\trect.x = Math.max(0, rect.x);\n\trect.y = Math.max(0, rect.y);\n\tvar rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n\tvar rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n\trect.width = rectRight - rect.x;\n\trect.height = rectBottom - rect.y;\n\n\t// The selection area has to be increased to the same aspect\n\t// ratio as the container, centred around the centre point of the\n\t// original rect passed in.\n\tif (aspectFactor < 1.0)\n\t{\n\t\t// Height needs increasing\n\t\tvar newHeight = rect.height / aspectFactor;\n\t\tvar deltaHeightBuffer = (newHeight - rect.height) / 2.0;\n\t\trect.height = newHeight;\n\n\t\t// Assign up to half the buffer to the upper part of the rect, not crossing 0\n\t\t// put the rest on the bottom\n\t\tvar upperBuffer = Math.min(rect.y , deltaHeightBuffer);\n\t\trect.y = rect.y - upperBuffer;\n\n\t\t// Check if the bottom has extended too far\n\t\trectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n\t\trect.height = rectBottom - rect.y;\n\t}\n\telse\n\t{\n\t\t// Width needs increasing\n\t\tvar newWidth = rect.width * aspectFactor;\n\t\tvar deltaWidthBuffer = (newWidth - rect.width) / 2.0;\n\t\trect.width = newWidth;\n\n\t\t// Assign up to half the buffer to the upper part of the rect, not crossing 0\n\t\t// put the rest on the bottom\n\t\tvar leftBuffer = Math.min(rect.x , deltaWidthBuffer);\n\t\trect.x = rect.x - leftBuffer;\n\n\t\t// Check if the right hand side has extended too far\n\t\trectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n\t\trect.width = rectRight - rect.x;\n\t}\n\n\tvar scale = this.container.clientWidth / rect.width;\n\tvar newScale = this.view.scale * scale;\n\n\tif (!mxUtils.hasScrollbars(this.container))\n\t{\n\t\tthis.view.scaleAndTranslate(newScale, (this.view.translate.x - rect.x / this.view.scale), (this.view.translate.y - rect.y / this.view.scale));\n\t}\n\telse\n\t{\n\t\tthis.view.setScale(newScale);\n\t\tthis.container.scrollLeft = Math.round(rect.x * scale);\n\t\tthis.container.scrollTop = Math.round(rect.y * scale);\n\t}\n};\n\n/**\n * Function: scrollCellToVisible\n *\n * Pans the graph so that it shows the given cell. Optionally the cell may\n * be centered in the container.\n *\n * To center a given graph if the <container> has no scrollbars, use the following code.\n *\n * [code]\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,\n * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);\n * [/code]\n *\n * Parameters:\n *\n * cell - <mxCell> to be made visible.\n * center - Optional boolean flag. Default is false.\n */\nmxGraph.prototype.scrollCellToVisible = function(cell, center)\n{\n\tvar x = -this.view.translate.x;\n\tvar y = -this.view.translate.y;\n\n\tvar state = this.view.getState(cell);\n\n\tif (state != null)\n\t{\n\t\tvar bounds = new mxRectangle(x + state.x, y + state.y, state.width,\n\t\t\tstate.height);\n\n\t\tif (center && this.container != null)\n\t\t{\n\t\t\tvar w = this.container.clientWidth;\n\t\t\tvar h = this.container.clientHeight;\n\n\t\t\tbounds.x = bounds.getCenterX() - w / 2;\n\t\t\tbounds.width = w;\n\t\t\tbounds.y = bounds.getCenterY() - h / 2;\n\t\t\tbounds.height = h;\n\t\t}\n\n\t\tvar tr = new mxPoint(this.view.translate.x, this.view.translate.y);\n\n\t\tif (this.scrollRectToVisible(bounds))\n\t\t{\n\t\t\t// Triggers an update via the view's event source\n\t\t\tvar tr2 = new mxPoint(this.view.translate.x, this.view.translate.y);\n\t\t\tthis.view.translate.x = tr.x;\n\t\t\tthis.view.translate.y = tr.y;\n\t\t\tthis.view.setTranslate(tr2.x, tr2.y);\n\t\t}\n\t}\n};\n\n/**\n * Function: scrollRectToVisible\n *\n * Pans the graph so that it shows the given rectangle.\n *\n * Parameters:\n *\n * rect - <mxRectangle> to be made visible.\n */\nmxGraph.prototype.scrollRectToVisible = function(rect)\n{\n\tvar isChanged = false;\n\n\tif (rect != null)\n\t{\n\t\tvar w = this.container.offsetWidth;\n\t\tvar h = this.container.offsetHeight;\n\n        var widthLimit = Math.min(w, rect.width);\n        var heightLimit = Math.min(h, rect.height);\n\n\t\tif (mxUtils.hasScrollbars(this.container))\n\t\t{\n\t\t\tvar c = this.container;\n\t\t\trect.x += this.view.translate.x;\n\t\t\trect.y += this.view.translate.y;\n\t\t\tvar dx = c.scrollLeft - rect.x;\n\t\t\tvar ddx = Math.max(dx - c.scrollLeft, 0);\n\n\t\t\tif (dx > 0)\n\t\t\t{\n\t\t\t\tc.scrollLeft -= dx + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdx = rect.x + widthLimit - c.scrollLeft - c.clientWidth;\n\n\t\t\t\tif (dx > 0)\n\t\t\t\t{\n\t\t\t\t\tc.scrollLeft += dx + 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dy = c.scrollTop - rect.y;\n\t\t\tvar ddy = Math.max(0, dy - c.scrollTop);\n\n\t\t\tif (dy > 0)\n\t\t\t{\n\t\t\t\tc.scrollTop -= dy + 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdy = rect.y + heightLimit - c.scrollTop - c.clientHeight;\n\n\t\t\t\tif (dy > 0)\n\t\t\t\t{\n\t\t\t\t\tc.scrollTop += dy + 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0))\n\t\t\t{\n\t\t\t\tthis.view.setTranslate(ddx, ddy);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar x = -this.view.translate.x;\n\t\t\tvar y = -this.view.translate.y;\n\n\t\t\tvar s = this.view.scale;\n\n\t\t\tif (rect.x + widthLimit > x + w)\n\t\t\t{\n\t\t\t\tthis.view.translate.x -= (rect.x + widthLimit - w - x) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.y + heightLimit > y + h)\n\t\t\t{\n\t\t\t\tthis.view.translate.y -= (rect.y + heightLimit - h - y) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.x < x)\n\t\t\t{\n\t\t\t\tthis.view.translate.x += (x - rect.x) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (rect.y  < y)\n\t\t\t{\n\t\t\t\tthis.view.translate.y += (y - rect.y) / s;\n\t\t\t\tisChanged = true;\n\t\t\t}\n\n\t\t\tif (isChanged)\n\t\t\t{\n\t\t\t\tthis.view.refresh();\n\n\t\t\t\t// Repaints selection marker (ticket 18)\n\t\t\t\tif (this.selectionCellsHandler != null)\n\t\t\t\t{\n\t\t\t\t\tthis.selectionCellsHandler.refresh();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn isChanged;\n};\n\n/**\n * Function: getCellGeometry\n *\n * Returns the <mxGeometry> for the given cell. This implementation uses\n * <mxGraphModel.getGeometry>. Subclasses can override this to implement\n * specific geometries for cells in only one graph, that is, it can return\n * geometries that depend on the current state of the view.\n *\n * Parameters:\n *\n * cell - <mxCell> whose geometry should be returned.\n */\nmxGraph.prototype.getCellGeometry = function(cell)\n{\n\treturn this.model.getGeometry(cell);\n};\n\n/**\n * Function: isCellVisible\n *\n * Returns true if the given cell is visible in this graph. This\n * implementation uses <mxGraphModel.isVisible>. Subclassers can override\n * this to implement specific visibility for cells in only one graph, that\n * is, without affecting the visible state of the cell.\n *\n * When using dynamic filter expressions for cell visibility, then the\n * graph should be revalidated after the filter expression has changed.\n *\n * Parameters:\n *\n * cell - <mxCell> whose visible state should be returned.\n */\nmxGraph.prototype.isCellVisible = function(cell)\n{\n\treturn this.model.isVisible(cell);\n};\n\n/**\n * Function: isCellCollapsed\n *\n * Returns true if the given cell is collapsed in this graph. This\n * implementation uses <mxGraphModel.isCollapsed>. Subclassers can override\n * this to implement specific collapsed states for cells in only one graph,\n * that is, without affecting the collapsed state of the cell.\n *\n * When using dynamic filter expressions for the collapsed state, then the\n * graph should be revalidated after the filter expression has changed.\n *\n * Parameters:\n *\n * cell - <mxCell> whose collapsed state should be returned.\n */\nmxGraph.prototype.isCellCollapsed = function(cell)\n{\n\treturn this.model.isCollapsed(cell);\n};\n\n/**\n * Function: isCellConnectable\n *\n * Returns true if the given cell is connectable in this graph. This\n * implementation uses <mxGraphModel.isConnectable>. Subclassers can override\n * this to implement specific connectable states for cells in only one graph,\n * that is, without affecting the connectable state of the cell in the model.\n *\n * Parameters:\n *\n * cell - <mxCell> whose connectable state should be returned.\n */\nmxGraph.prototype.isCellConnectable = function(cell)\n{\n\treturn this.model.isConnectable(cell);\n};\n\n/**\n * Function: isOrthogonal\n *\n * Returns true if perimeter points should be computed such that the\n * resulting edge has only horizontal or vertical segments.\n *\n * Parameters:\n *\n * edge - <mxCellState> that represents the edge.\n */\nmxGraph.prototype.isOrthogonal = function(edge)\n{\n\tvar orthogonal = edge.style[mxConstants.STYLE_ORTHOGONAL];\n\n\tif (orthogonal != null)\n\t{\n\t\treturn orthogonal;\n\t}\n\n\tvar tmp = this.view.getEdgeStyle(edge);\n\n\treturn tmp == mxEdgeStyle.SegmentConnector ||\n\t\ttmp == mxEdgeStyle.ElbowConnector ||\n\t\ttmp == mxEdgeStyle.SideToSide ||\n\t\ttmp == mxEdgeStyle.TopToBottom ||\n\t\ttmp == mxEdgeStyle.EntityRelation ||\n\t\ttmp == mxEdgeStyle.OrthConnector;\n};\n\n/**\n * Function: isLoop\n *\n * Returns true if the given cell state is a loop.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents a potential loop.\n */\nmxGraph.prototype.isLoop = function(state)\n{\n\tvar src = state.getVisibleTerminalState(true);\n\tvar trg = state.getVisibleTerminalState(false);\n\n\treturn (src != null && src == trg);\n};\n\n/**\n * Function: isCloneEvent\n *\n * Returns true if the given event is a clone event. This implementation\n * returns true if control is pressed.\n */\nmxGraph.prototype.isCloneEvent = function(evt)\n{\n\treturn mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: isTransparentClickEvent\n *\n * Hook for implementing click-through behaviour on selected cells. If this\n * returns true the cell behind the selected cell will be selected. This\n * implementation returns false;\n */\nmxGraph.prototype.isTransparentClickEvent = function(evt)\n{\n\treturn false;\n};\n\n/**\n * Function: isToggleEvent\n *\n * Returns true if the given event is a toggle event. This implementation\n * returns true if the meta key (Cmd) is pressed on Macs or if control is\n * pressed on any other platform.\n */\nmxGraph.prototype.isToggleEvent = function(evt)\n{\n\treturn (mxClient.IS_MAC) ? mxEvent.isMetaDown(evt) : mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: isGridEnabledEvent\n *\n * Returns true if the given mouse event should be aligned to the grid.\n */\nmxGraph.prototype.isGridEnabledEvent = function(evt)\n{\n\treturn evt != null && !mxEvent.isAltDown(evt);\n};\n\n/**\n * Function: isConstrainedEvent\n *\n * Returns true if the given mouse event should be aligned to the grid.\n */\nmxGraph.prototype.isConstrainedEvent = function(evt)\n{\n\treturn mxEvent.isShiftDown(evt);\n};\n\n/**\n * Function: isIgnoreTerminalEvent\n *\n * Returns true if the given mouse event should not allow any connections to be\n * made. This implementation returns false.\n */\nmxGraph.prototype.isIgnoreTerminalEvent = function(evt)\n{\n\treturn false;\n};\n\n/**\n * Group: Validation\n */\n\n/**\n * Function: validationAlert\n *\n * Displays the given validation error in a dialog. This implementation uses\n * mxUtils.alert.\n */\nmxGraph.prototype.validationAlert = function(message)\n{\n\tmxUtils.alert(message);\n};\n\n/**\n * Function: isEdgeValid\n *\n * Checks if the return value of <getEdgeValidationError> for the given\n * arguments is null.\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.isEdgeValid = function(edge, source, target)\n{\n\treturn this.getEdgeValidationError(edge, source, target) == null;\n};\n\n/**\n * Function: getEdgeValidationError\n *\n * Returns the validation error message to be displayed when inserting or\n * changing an edges' connectivity. A return value of null means the edge\n * is valid, a return value of '' means it's not valid, but do not display\n * an error message. Any other (non-empty) string returned from this method\n * is displayed as an error message when trying to connect an edge to a\n * source and target. This implementation uses the <multiplicities>, and\n * checks <multigraph>, <allowDanglingEdges> and <allowLoops> to generate\n * validation errors.\n *\n * For extending this method with specific checks for source/target cells,\n * the method can be extended as follows. Returning an empty string means\n * the edge is invalid with no error message, a non-null string specifies\n * the error message, and null means the edge is valid.\n *\n * (code)\n * graph.getEdgeValidationError = function(edge, source, target)\n * {\n *   if (source != null && target != null &&\n *     this.model.getValue(source) != null &&\n *     this.model.getValue(target) != null)\n *   {\n *     if (target is not valid for source)\n *     {\n *       return 'Invalid Target';\n *     }\n *   }\n *\n *   // \"Supercall\"\n *   return mxGraph.prototype.getEdgeValidationError.apply(this, arguments);\n * }\n * (end)\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.getEdgeValidationError = function(edge, source, target)\n{\n\tif (edge != null && !this.isAllowDanglingEdges() && (source == null || target == null))\n\t{\n\t\treturn '';\n\t}\n\n\tif (edge != null && this.model.getTerminal(edge, true) == null &&\n\t\tthis.model.getTerminal(edge, false) == null)\n\t{\n\t\treturn null;\n\t}\n\n\t// Checks if we're dealing with a loop\n\tif (!this.allowLoops && source == target && source != null)\n\t{\n\t\treturn '';\n\t}\n\n\t// Checks if the connection is generally allowed\n\tif (!this.isValidConnection(source, target))\n\t{\n\t\treturn '';\n\t}\n\n\tif (source != null && target != null)\n\t{\n\t\tvar error = '';\n\n\t\t// Checks if the cells are already connected\n\t\t// and adds an error message if required\n\t\tif (!this.multigraph)\n\t\t{\n\t\t\tvar tmp = this.model.getEdgesBetween(source, target, true);\n\n\t\t\t// Checks if the source and target are not connected by another edge\n\t\t\tif (tmp.length > 1 || (tmp.length == 1 && tmp[0] != edge))\n\t\t\t{\n\t\t\t\terror += (mxResources.get(this.alreadyConnectedResource) ||\n\t\t\t\t\tthis.alreadyConnectedResource)+'\\n';\n\t\t\t}\n\t\t}\n\n\t\t// Gets the number of outgoing edges from the source\n\t\t// and the number of incoming edges from the target\n\t\t// without counting the edge being currently changed.\n\t\tvar sourceOut = this.model.getDirectedEdgeCount(source, true, edge);\n\t\tvar targetIn = this.model.getDirectedEdgeCount(target, false, edge);\n\n\t\t// Checks the change against each multiplicity rule\n\t\tif (this.multiplicities != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.multiplicities.length; i++)\n\t\t\t{\n\t\t\t\tvar err = this.multiplicities[i].check(this, edge, source,\n\t\t\t\t\ttarget, sourceOut, targetIn);\n\n\t\t\t\tif (err != null)\n\t\t\t\t{\n\t\t\t\t\terror += err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Validates the source and target terminals independently\n\t\tvar err = this.validateEdge(edge, source, target);\n\n\t\tif (err != null)\n\t\t{\n\t\t\terror += err;\n\t\t}\n\n\t\treturn (error.length > 0) ? error : null;\n\t}\n\n\treturn (this.allowDanglingEdges) ? null : '';\n};\n\n/**\n * Function: validateEdge\n *\n * Hook method for subclassers to return an error message for the given\n * edge and terminals. This implementation returns null.\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxGraph.prototype.validateEdge = function(edge, source, target)\n{\n\treturn null;\n};\n\n/**\n * Function: validateGraph\n *\n * Validates the graph by validating each descendant of the given cell or\n * the root of the model. Context is an object that contains the validation\n * state for the complete validation run. The validation errors are\n * attached to their cells using <setCellWarning>. Returns null in the case of\n * successful validation or an array of strings (warnings) in the case of\n * failed validations.\n *\n * Paramters:\n *\n * cell - Optional <mxCell> to start the validation recursion. Default is\n * the graph root.\n * context - Object that represents the global validation state.\n */\nmxGraph.prototype.validateGraph = function(cell, context)\n{\n\tcell = (cell != null) ? cell : this.model.getRoot();\n\tcontext = (context != null) ? context : new Object();\n\n\tvar isValid = true;\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar tmp = this.model.getChildAt(cell, i);\n\t\tvar ctx = context;\n\n\t\tif (this.isValidRoot(tmp))\n\t\t{\n\t\t\tctx = new Object();\n\t\t}\n\n\t\tvar warn = this.validateGraph(tmp, ctx);\n\n\t\tif (warn != null)\n\t\t{\n\t\t\tthis.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.setCellWarning(tmp, null);\n\t\t}\n\n\t\tisValid = isValid && warn == null;\n\t}\n\n\tvar warning = '';\n\n\t// Adds error for invalid children if collapsed (children invisible)\n\tif (this.isCellCollapsed(cell) && !isValid)\n\t{\n\t\twarning += (mxResources.get(this.containsValidationErrorsResource) ||\n\t\t\tthis.containsValidationErrorsResource) + '\\n';\n\t}\n\n\t// Checks edges and cells using the defined multiplicities\n\tif (this.model.isEdge(cell))\n\t{\n\t\twarning += this.getEdgeValidationError(cell,\n\t\tthis.model.getTerminal(cell, true),\n\t\tthis.model.getTerminal(cell, false)) || '';\n\t}\n\telse\n\t{\n\t\twarning += this.getCellValidationError(cell) || '';\n\t}\n\n\t// Checks custom validation rules\n\tvar err = this.validateCell(cell, context);\n\n\tif (err != null)\n\t{\n\t\twarning += err;\n\t}\n\n\t// Updates the display with the warning icons\n\t// before any potential alerts are displayed.\n\t// LATER: Move this into addCellOverlay. Redraw\n\t// should check if overlay was added or removed.\n\tif (this.model.getParent(cell) == null)\n\t{\n\t\tthis.view.validate();\n\t}\n\n\treturn (warning.length > 0 || !isValid) ? warning : null;\n};\n\n/**\n * Function: getCellValidationError\n *\n * Checks all <multiplicities> that cannot be enforced while the graph is\n * being modified, namely, all multiplicities that require a minimum of\n * 1 edge.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the multiplicities should be checked.\n */\nmxGraph.prototype.getCellValidationError = function(cell)\n{\n\tvar outCount = this.model.getDirectedEdgeCount(cell, true);\n\tvar inCount = this.model.getDirectedEdgeCount(cell, false);\n\tvar value = this.model.getValue(cell);\n\tvar error = '';\n\n\tif (this.multiplicities != null)\n\t{\n\t\tfor (var i = 0; i < this.multiplicities.length; i++)\n\t\t{\n\t\t\tvar rule = this.multiplicities[i];\n\n\t\t\tif (rule.source && mxUtils.isNode(value, rule.type,\n\t\t\t\trule.attr, rule.value) && (outCount > rule.max ||\n\t\t\t\toutCount < rule.min))\n\t\t\t{\n\t\t\t\terror += rule.countError + '\\n';\n\t\t\t}\n\t\t\telse if (!rule.source && mxUtils.isNode(value, rule.type,\n\t\t\t\t\trule.attr, rule.value) && (inCount > rule.max ||\n\t\t\t\t\tinCount < rule.min))\n\t\t\t{\n\t\t\t\terror += rule.countError + '\\n';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error.length > 0) ? error : null;\n};\n\n/**\n * Function: validateCell\n *\n * Hook method for subclassers to return an error message for the given\n * cell and validation context. This implementation returns null. Any HTML\n * breaks will be converted to linefeeds in the calling method.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the cell to validate.\n * context - Object that represents the global validation state.\n */\nmxGraph.prototype.validateCell = function(cell, context)\n{\n\treturn null;\n};\n\n/**\n * Group: Graph appearance\n */\n\n/**\n * Function: getBackgroundImage\n *\n * Returns the <backgroundImage> as an <mxImage>.\n */\nmxGraph.prototype.getBackgroundImage = function()\n{\n\treturn this.backgroundImage;\n};\n\n/**\n * Function: setBackgroundImage\n *\n * Sets the new <backgroundImage>.\n *\n * Parameters:\n *\n * image - New <mxImage> to be used for the background.\n */\nmxGraph.prototype.setBackgroundImage = function(image)\n{\n\tthis.backgroundImage = image;\n};\n\n/**\n * Function: getFoldingImage\n *\n * Returns the <mxImage> used to display the collapsed state of\n * the specified cell state. This returns null for all edges.\n */\nmxGraph.prototype.getFoldingImage = function(state)\n{\n\tif (state != null && this.foldingEnabled && !this.getModel().isEdge(state.cell))\n\t{\n\t\tvar tmp = this.isCellCollapsed(state.cell);\n\n\t\tif (this.isCellFoldable(state.cell, !tmp))\n\t\t{\n\t\t\treturn (tmp) ? this.collapsedImage : this.expandedImage;\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: convertValueToString\n *\n * Returns the textual representation for the given cell. This\n * implementation returns the nodename or string-representation of the user\n * object.\n *\n * Example:\n *\n * The following returns the label attribute from the cells user\n * object if it is an XML node.\n *\n * (code)\n * graph.convertValueToString = function(cell)\n * {\n * \treturn cell.getAttribute('label');\n * }\n * (end)\n *\n * See also: <cellLabelChanged>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose textual representation should be returned.\n */\nmxGraph.prototype.convertValueToString = function(cell)\n{\n\tvar value = this.model.getValue(cell);\n\n\tif (value != null)\n\t{\n\t\tif (mxUtils.isNode(value))\n\t\t{\n\t\t\treturn value.nodeName;\n\t\t}\n\t\telse if (typeof(value.toString) == 'function')\n\t\t{\n\t\t\treturn value.toString();\n\t\t}\n\t}\n\n\treturn '';\n};\n\n/**\n * Function: getLabel\n *\n * Returns a string or DOM node that represents the label for the given\n * cell. This implementation uses <convertValueToString> if <labelsVisible>\n * is true. Otherwise it returns an empty string.\n *\n * To truncate a label to match the size of the cell, the following code\n * can be used.\n *\n * (code)\n * graph.getLabel = function(cell)\n * {\n *   var label = mxGraph.prototype.getLabel.apply(this, arguments);\n *\n *   if (label != null && this.model.isVertex(cell))\n *   {\n *     var geo = this.getCellGeometry(cell);\n *\n *     if (geo != null)\n *     {\n *       var max = parseInt(geo.width / 8);\n *\n *       if (label.length > max)\n *       {\n *         label = label.substring(0, max)+'...';\n *       }\n *     }\n *   }\n *   return mxUtils.htmlEntities(label);\n * }\n * (end)\n *\n * A resize listener is needed in the graph to force a repaint of the label\n * after a resize.\n *\n * (code)\n * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)\n * {\n *   var cells = evt.getProperty('cells');\n *\n *   for (var i = 0; i < cells.length; i++)\n *   {\n *     this.view.removeState(cells[i]);\n *   }\n * });\n * (end)\n *\n * Parameters:\n *\n * cell - <mxCell> whose label should be returned.\n */\nmxGraph.prototype.getLabel = function(cell)\n{\n\tvar result = '';\n\n\tif (this.labelsVisible && cell != null)\n\t{\n\t\tvar state = this.view.getState(cell);\n\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\t\tif (!mxUtils.getValue(style, mxConstants.STYLE_NOLABEL, false))\n\t\t{\n\t\t\tresult = this.convertValueToString(cell);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isHtmlLabel\n *\n * Returns true if the label must be rendered as HTML markup. The default\n * implementation returns <htmlLabels>.\n *\n * Parameters:\n *\n * cell - <mxCell> whose label should be displayed as HTML markup.\n */\nmxGraph.prototype.isHtmlLabel = function(cell)\n{\n\treturn this.isHtmlLabels();\n};\n\n/**\n * Function: isHtmlLabels\n *\n * Returns <htmlLabels>.\n */\nmxGraph.prototype.isHtmlLabels = function()\n{\n\treturn this.htmlLabels;\n};\n\n/**\n * Function: setHtmlLabels\n *\n * Sets <htmlLabels>.\n */\nmxGraph.prototype.setHtmlLabels = function(value)\n{\n\tthis.htmlLabels = value;\n};\n\n/**\n * Function: isWrapping\n *\n * This enables wrapping for HTML labels.\n *\n * Returns true if no white-space CSS style directive should be used for\n * displaying the given cells label. This implementation returns true if\n * <mxConstants.STYLE_WHITE_SPACE> in the style of the given cell is 'wrap'.\n *\n * This is used as a workaround for IE ignoring the white-space directive\n * of child elements if the directive appears in a parent element. It\n * should be overridden to return true if a white-space directive is used\n * in the HTML markup that represents the given cells label. In order for\n * HTML markup to work in labels, <isHtmlLabel> must also return true\n * for the given cell.\n *\n * Example:\n *\n * (code)\n * graph.getLabel = function(cell)\n * {\n *   var tmp = mxGraph.prototype.getLabel.apply(this, arguments); // \"supercall\"\n *\n *   if (this.model.isEdge(cell))\n *   {\n *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';\n *   }\n *\n *   return tmp;\n * }\n *\n * graph.isWrapping = function(state)\n * {\n * \t return this.model.isEdge(state.cell);\n * }\n * (end)\n *\n * Makes sure no edge label is wider than 150 pixels, otherwise the content\n * is wrapped. Note: No width must be specified for wrapped vertex labels as\n * the vertex defines the width in its geometry.\n *\n * Parameters:\n *\n * state - <mxCell> whose label should be wrapped.\n */\nmxGraph.prototype.isWrapping = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn (style != null) ? style[mxConstants.STYLE_WHITE_SPACE] == 'wrap' : false;\n};\n\n/**\n * Function: isLabelClipped\n *\n * Returns true if the overflow portion of labels should be hidden. If this\n * returns true then vertex labels will be clipped to the size of the vertices.\n * This implementation returns true if <mxConstants.STYLE_OVERFLOW> in the\n * style of the given cell is 'hidden'.\n *\n * Parameters:\n *\n * state - <mxCell> whose label should be clipped.\n */\nmxGraph.prototype.isLabelClipped = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn (style != null) ? style[mxConstants.STYLE_OVERFLOW] == 'hidden' : false;\n};\n\n/**\n * Function: getTooltip\n *\n * Returns the string or DOM node that represents the tooltip for the given\n * state, node and coordinate pair. This implementation checks if the given\n * node is a folding icon or overlay and returns the respective tooltip. If\n * this does not result in a tooltip, the handler for the cell is retrieved\n * from <selectionCellsHandler> and the optional getTooltipForNode method is\n * called. If no special tooltip exists here then <getTooltipForCell> is used\n * with the cell in the given state as the argument to return a tooltip for the\n * given state.\n *\n * Parameters:\n *\n * state - <mxCellState> whose tooltip should be returned.\n * node - DOM node that is currently under the mouse.\n * x - X-coordinate of the mouse.\n * y - Y-coordinate of the mouse.\n */\nmxGraph.prototype.getTooltip = function(state, node, x, y)\n{\n\tvar tip = null;\n\n\tif (state != null)\n\t{\n\t\t// Checks if the mouse is over the folding icon\n\t\tif (state.control != null && (node == state.control.node ||\n\t\t\tnode.parentNode == state.control.node))\n\t\t{\n\t\t\ttip = this.collapseExpandResource;\n\t\t\ttip = mxUtils.htmlEntities(mxResources.get(tip) || tip).replace(/\\\\n/g, '<br>');\n\t\t}\n\n\t\tif (tip == null && state.overlays != null)\n\t\t{\n\t\t\tstate.overlays.visit(function(id, shape)\n\t\t\t{\n\t\t\t\t// LATER: Exit loop if tip is not null\n\t\t\t\tif (tip == null && (node == shape.node || node.parentNode == shape.node))\n\t\t\t\t{\n\t\t\t\t\ttip = shape.overlay.toString();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (tip == null)\n\t\t{\n\t\t\tvar handler = this.selectionCellsHandler.getHandler(state.cell);\n\n\t\t\tif (handler != null && typeof(handler.getTooltipForNode) == 'function')\n\t\t\t{\n\t\t\t\ttip = handler.getTooltipForNode(node);\n\t\t\t}\n\t\t}\n\n\t\tif (tip == null)\n\t\t{\n\t\t\ttip = this.getTooltipForCell(state.cell);\n\t\t}\n\t}\n\n\treturn tip;\n};\n\n/**\n * Function: getTooltipForCell\n *\n * Returns the string or DOM node to be used as the tooltip for the given\n * cell. This implementation uses the cells getTooltip function if it\n * exists, or else it returns <convertValueToString> for the cell.\n *\n * Example:\n *\n * (code)\n * graph.getTooltipForCell = function(cell)\n * {\n *   return 'Hello, World!';\n * }\n * (end)\n *\n * Replaces all tooltips with the string Hello, World!\n *\n * Parameters:\n *\n * cell - <mxCell> whose tooltip should be returned.\n */\nmxGraph.prototype.getTooltipForCell = function(cell)\n{\n\tvar tip = null;\n\n\tif (cell != null && cell.getTooltip != null)\n\t{\n\t\ttip = cell.getTooltip();\n\t}\n\telse\n\t{\n\t\ttip = this.convertValueToString(cell);\n\t}\n\n\treturn tip;\n};\n\n/**\n * Function: getLinkForCell\n *\n * Returns the string to be used as the link for the given cell. This\n * implementation returns null.\n *\n * Parameters:\n *\n * cell - <mxCell> whose tooltip should be returned.\n */\nmxGraph.prototype.getLinkForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: getCursorForMouseEvent\n *\n * Returns the cursor value to be used for the CSS of the shape for the\n * given event. This implementation calls <getCursorForCell>.\n *\n * Parameters:\n *\n * me - <mxMouseEvent> whose cursor should be returned.\n */\nmxGraph.prototype.getCursorForMouseEvent = function(me)\n{\n\treturn this.getCursorForCell(me.getCell());\n};\n\n/**\n * Function: getCursorForCell\n *\n * Returns the cursor value to be used for the CSS of the shape for the\n * given cell. This implementation returns null.\n *\n * Parameters:\n *\n * cell - <mxCell> whose cursor should be returned.\n */\nmxGraph.prototype.getCursorForCell = function(cell)\n{\n\treturn null;\n};\n\n/**\n * Function: getStartSize\n *\n * Returns the start size of the given swimlane, that is, the width or\n * height of the part that contains the title, depending on the\n * horizontal style. The return value is an <mxRectangle> with either\n * width or height set as appropriate.\n *\n * Parameters:\n *\n * swimlane - <mxCell> whose start size should be returned.\n */\nmxGraph.prototype.getStartSize = function(swimlane)\n{\n\tvar result = new mxRectangle();\n\tvar state = this.view.getState(swimlane);\n\tvar style = (state != null) ? state.style : this.getCellStyle(swimlane);\n\n\tif (style != null)\n\t{\n\t\tvar size = parseInt(mxUtils.getValue(style,\n\t\t\tmxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));\n\n\t\tif (mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, true))\n\t\t{\n\t\t\tresult.height = size;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.width = size;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getImage\n *\n * Returns the image URL for the given cell state. This implementation\n * returns the value stored under <mxConstants.STYLE_IMAGE> in the cell\n * style.\n *\n * Parameters:\n *\n * state - <mxCellState> whose image URL should be returned.\n */\nmxGraph.prototype.getImage = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_IMAGE] : null;\n};\n\n/**\n * Function: getVerticalAlign\n *\n * Returns the vertical alignment for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_VERTICAL_ALIGN> in the cell style.\n *\n * Parameters:\n *\n * state - <mxCellState> whose vertical alignment should be\n * returned.\n */\nmxGraph.prototype.getVerticalAlign = function(state)\n{\n\treturn (state != null && state.style != null) ?\n\t\t(state.style[mxConstants.STYLE_VERTICAL_ALIGN] ||\n\t\tmxConstants.ALIGN_MIDDLE) : null;\n};\n\n/**\n * Function: getIndicatorColor\n *\n * Returns the indicator color for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_COLOR> in the cell style.\n *\n * Parameters:\n *\n * state - <mxCellState> whose indicator color should be\n * returned.\n */\nmxGraph.prototype.getIndicatorColor = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_COLOR] : null;\n};\n\n/**\n * Function: getIndicatorGradientColor\n *\n * Returns the indicator gradient color for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_GRADIENTCOLOR> in the cell style.\n *\n * Parameters:\n *\n * state - <mxCellState> whose indicator gradient color should be\n * returned.\n */\nmxGraph.prototype.getIndicatorGradientColor = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_GRADIENTCOLOR] : null;\n};\n\n/**\n * Function: getIndicatorShape\n *\n * Returns the indicator shape for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_SHAPE> in the cell style.\n *\n * Parameters:\n *\n * state - <mxCellState> whose indicator shape should be returned.\n */\nmxGraph.prototype.getIndicatorShape = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_SHAPE] : null;\n};\n\n/**\n * Function: getIndicatorImage\n *\n * Returns the indicator image for the given cell state. This\n * implementation returns the value stored under\n * <mxConstants.STYLE_INDICATOR_IMAGE> in the cell style.\n *\n * Parameters:\n *\n * state - <mxCellState> whose indicator image should be returned.\n */\nmxGraph.prototype.getIndicatorImage = function(state)\n{\n\treturn (state != null && state.style != null) ? state.style[mxConstants.STYLE_INDICATOR_IMAGE] : null;\n};\n\n/**\n * Function: getBorder\n *\n * Returns the value of <border>.\n */\nmxGraph.prototype.getBorder = function()\n{\n\treturn this.border;\n};\n\n/**\n * Function: setBorder\n *\n * Sets the value of <border>.\n *\n * Parameters:\n *\n * value - Positive integer that represents the border to be used.\n */\nmxGraph.prototype.setBorder = function(value)\n{\n\tthis.border = value;\n};\n\n/**\n * Function: isSwimlane\n *\n * Returns true if the given cell is a swimlane in the graph. A swimlane is\n * a container cell with some specific behaviour. This implementation\n * checks if the shape associated with the given cell is a <mxSwimlane>.\n *\n * Parameters:\n *\n * cell - <mxCell> to be checked.\n */\nmxGraph.prototype.isSwimlane = function (cell)\n{\n\tif (cell != null)\n\t{\n\t\tif (this.model.getParent(cell) != this.model.getRoot())\n\t\t{\n\t\t\tvar state = this.view.getState(cell);\n\t\t\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\t\t\tif (style != null && !this.model.isEdge(cell))\n\t\t\t{\n\t\t\t\treturn style[mxConstants.STYLE_SHAPE] == mxConstants.SHAPE_SWIMLANE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n};\n\n/**\n * Group: Graph behaviour\n */\n\n/**\n * Function: isResizeContainer\n *\n * Returns <resizeContainer>.\n */\nmxGraph.prototype.isResizeContainer = function()\n{\n\treturn this.resizeContainer;\n};\n\n/**\n * Function: setResizeContainer\n *\n * Sets <resizeContainer>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the container should be resized.\n */\nmxGraph.prototype.setResizeContainer = function(value)\n{\n\tthis.resizeContainer = value;\n};\n\n/**\n * Function: isEnabled\n *\n * Returns true if the graph is <enabled>.\n */\nmxGraph.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Specifies if the graph should allow any interactions. This\n * implementation updates <enabled>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph should be enabled.\n */\nmxGraph.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isEscapeEnabled\n *\n * Returns <escapeEnabled>.\n */\nmxGraph.prototype.isEscapeEnabled = function()\n{\n\treturn this.escapeEnabled;\n};\n\n/**\n * Function: setEscapeEnabled\n *\n * Sets <escapeEnabled>.\n *\n * Parameters:\n *\n * enabled - Boolean indicating if escape should be enabled.\n */\nmxGraph.prototype.setEscapeEnabled = function(value)\n{\n\tthis.escapeEnabled = value;\n};\n\n/**\n * Function: isInvokesStopCellEditing\n *\n * Returns <invokesStopCellEditing>.\n */\nmxGraph.prototype.isInvokesStopCellEditing = function()\n{\n\treturn this.invokesStopCellEditing;\n};\n\n/**\n * Function: setInvokesStopCellEditing\n *\n * Sets <invokesStopCellEditing>.\n */\nmxGraph.prototype.setInvokesStopCellEditing = function(value)\n{\n\tthis.invokesStopCellEditing = value;\n};\n\n/**\n * Function: isEnterStopsCellEditing\n *\n * Returns <enterStopsCellEditing>.\n */\nmxGraph.prototype.isEnterStopsCellEditing = function()\n{\n\treturn this.enterStopsCellEditing;\n};\n\n/**\n * Function: setEnterStopsCellEditing\n *\n * Sets <enterStopsCellEditing>.\n */\nmxGraph.prototype.setEnterStopsCellEditing = function(value)\n{\n\tthis.enterStopsCellEditing = value;\n};\n\n/**\n * Function: isCellLocked\n *\n * Returns true if the given cell may not be moved, sized, bended,\n * disconnected, edited or selected. This implementation returns true for\n * all vertices with a relative geometry if <locked> is false.\n *\n * Parameters:\n *\n * cell - <mxCell> whose locked state should be returned.\n */\nmxGraph.prototype.isCellLocked = function(cell)\n{\n\tvar geometry = this.model.getGeometry(cell);\n\n\treturn this.isCellsLocked() || (geometry != null && this.model.isVertex(cell) && geometry.relative);\n};\n\n/**\n * Function: isCellsLocked\n *\n * Returns true if the given cell may not be moved, sized, bended,\n * disconnected, edited or selected. This implementation returns true for\n * all vertices with a relative geometry if <locked> is false.\n *\n * Parameters:\n *\n * cell - <mxCell> whose locked state should be returned.\n */\nmxGraph.prototype.isCellsLocked = function()\n{\n\treturn this.cellsLocked;\n};\n\n/**\n * Function: setCellsLocked\n *\n * Sets if any cell may be moved, sized, bended, disconnected, edited or\n * selected.\n *\n * Parameters:\n *\n * value - Boolean that defines the new value for <cellsLocked>.\n */\nmxGraph.prototype.setCellsLocked = function(value)\n{\n\tthis.cellsLocked = value;\n};\n\n/**\n * Function: getCloneableCells\n *\n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getCloneableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellCloneable(cell);\n\t}));\n};\n\n/**\n * Function: isCellCloneable\n *\n * Returns true if the given cell is cloneable. This implementation returns\n * <isCellsCloneable> for all cells unless a cell style specifies\n * <mxConstants.STYLE_CLONEABLE> to be 0.\n *\n * Parameters:\n *\n * cell - Optional <mxCell> whose cloneable state should be returned.\n */\nmxGraph.prototype.isCellCloneable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsCloneable() && style[mxConstants.STYLE_CLONEABLE] != 0;\n};\n\n/**\n * Function: isCellsCloneable\n *\n * Returns <cellsCloneable>, that is, if the graph allows cloning of cells\n * by using control-drag.\n */\nmxGraph.prototype.isCellsCloneable = function()\n{\n\treturn this.cellsCloneable;\n};\n\n/**\n * Function: setCellsCloneable\n *\n * Specifies if the graph should allow cloning of cells by holding down the\n * control key while cells are being moved. This implementation updates\n * <cellsCloneable>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph should be cloneable.\n */\nmxGraph.prototype.setCellsCloneable = function(value)\n{\n\tthis.cellsCloneable = value;\n};\n\n/**\n * Function: getExportableCells\n *\n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getExportableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.canExportCell(cell);\n\t}));\n};\n\n/**\n * Function: canExportCell\n *\n * Returns true if the given cell may be exported to the clipboard. This\n * implementation returns <exportEnabled> for all cells.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the cell to be exported.\n */\nmxGraph.prototype.canExportCell = function(cell)\n{\n\treturn this.exportEnabled;\n};\n\n/**\n * Function: getImportableCells\n *\n * Returns the cells which may be imported in the given array of cells.\n */\nmxGraph.prototype.getImportableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.canImportCell(cell);\n\t}));\n};\n\n/**\n * Function: canImportCell\n *\n * Returns true if the given cell may be imported from the clipboard.\n * This implementation returns <importEnabled> for all cells.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the cell to be imported.\n */\nmxGraph.prototype.canImportCell = function(cell)\n{\n\treturn this.importEnabled;\n};\n\n/**\n * Function: isCellSelectable\n *\n * Returns true if the given cell is selectable. This implementation\n * returns <cellsSelectable>.\n *\n * To add a new style for making cells (un)selectable, use the following code.\n *\n * (code)\n * mxGraph.prototype.isCellSelectable = function(cell)\n * {\n *   var state = this.view.getState(cell);\n *   var style = (state != null) ? state.style : this.getCellStyle(cell);\n *\n *   return this.isCellsSelectable() && !this.isCellLocked(cell) && style['selectable'] != 0;\n * };\n * (end)\n *\n * You can then use the new style as shown in this example.\n *\n * (code)\n * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'selectable=0');\n * (end)\n *\n * Parameters:\n *\n * cell - <mxCell> whose selectable state should be returned.\n */\nmxGraph.prototype.isCellSelectable = function(cell)\n{\n\treturn this.isCellsSelectable();\n};\n\n/**\n * Function: isCellsSelectable\n *\n * Returns <cellsSelectable>.\n */\nmxGraph.prototype.isCellsSelectable = function()\n{\n\treturn this.cellsSelectable;\n};\n\n/**\n * Function: setCellsSelectable\n *\n * Sets <cellsSelectable>.\n */\nmxGraph.prototype.setCellsSelectable = function(value)\n{\n\tthis.cellsSelectable = value;\n};\n\n/**\n * Function: getDeletableCells\n *\n * Returns the cells which may be exported in the given array of cells.\n */\nmxGraph.prototype.getDeletableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellDeletable(cell);\n\t}));\n};\n\n/**\n * Function: isCellDeletable\n *\n * Returns true if the given cell is moveable. This returns\n * <cellsDeletable> for all given cells if a cells style does not specify\n * <mxConstants.STYLE_DELETABLE> to be 0.\n *\n * Parameters:\n *\n * cell - <mxCell> whose deletable state should be returned.\n */\nmxGraph.prototype.isCellDeletable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsDeletable() && style[mxConstants.STYLE_DELETABLE] != 0;\n};\n\n/**\n * Function: isCellsDeletable\n *\n * Returns <cellsDeletable>.\n */\nmxGraph.prototype.isCellsDeletable = function()\n{\n\treturn this.cellsDeletable;\n};\n\n/**\n * Function: setCellsDeletable\n *\n * Sets <cellsDeletable>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph should allow deletion of cells.\n */\nmxGraph.prototype.setCellsDeletable = function(value)\n{\n\tthis.cellsDeletable = value;\n};\n\n/**\n * Function: isLabelMovable\n *\n * Returns true if the given edges's label is moveable. This returns\n * <movable> for all given cells if <isLocked> does not return true\n * for the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose label should be moved.\n */\nmxGraph.prototype.isLabelMovable = function(cell)\n{\n\treturn !this.isCellLocked(cell) &&\n\t\t((this.model.isEdge(cell) && this.edgeLabelsMovable) ||\n\t\t(this.model.isVertex(cell) && this.vertexLabelsMovable));\n};\n\n/**\n * Function: isCellRotatable\n *\n * Returns true if the given cell is rotatable. This returns true for the given\n * cell if its style does not specify <mxConstants.STYLE_ROTATABLE> to be 0.\n *\n * Parameters:\n *\n * cell - <mxCell> whose rotatable state should be returned.\n */\nmxGraph.prototype.isCellRotatable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn style[mxConstants.STYLE_ROTATABLE] != 0;\n};\n\n/**\n * Function: getMovableCells\n *\n * Returns the cells which are movable in the given array of cells.\n */\nmxGraph.prototype.getMovableCells = function(cells)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellMovable(cell);\n\t}));\n};\n\n/**\n * Function: isCellMovable\n *\n * Returns true if the given cell is moveable. This returns <cellsMovable>\n * for all given cells if <isCellLocked> does not return true for the given\n * cell and its style does not specify <mxConstants.STYLE_MOVABLE> to be 0.\n *\n * Parameters:\n *\n * cell - <mxCell> whose movable state should be returned.\n */\nmxGraph.prototype.isCellMovable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsMovable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_MOVABLE] != 0;\n};\n\n/**\n * Function: isCellsMovable\n *\n * Returns <cellsMovable>.\n */\nmxGraph.prototype.isCellsMovable = function()\n{\n\treturn this.cellsMovable;\n};\n\n/**\n * Function: setCellsMovable\n *\n * Specifies if the graph should allow moving of cells. This implementation\n * updates <cellsMsovable>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph should allow moving of cells.\n */\nmxGraph.prototype.setCellsMovable = function(value)\n{\n\tthis.cellsMovable = value;\n};\n\n/**\n * Function: isGridEnabled\n *\n * Returns <gridEnabled> as a boolean.\n */\nmxGraph.prototype.isGridEnabled = function()\n{\n\treturn this.gridEnabled;\n};\n\n/**\n * Function: setGridEnabled\n *\n * Specifies if the grid should be enabled.\n *\n * Parameters:\n *\n * value - Boolean indicating if the grid should be enabled.\n */\nmxGraph.prototype.setGridEnabled = function(value)\n{\n\tthis.gridEnabled = value;\n};\n\n/**\n * Function: isPortsEnabled\n *\n * Returns <portsEnabled> as a boolean.\n */\nmxGraph.prototype.isPortsEnabled = function()\n{\n\treturn this.portsEnabled;\n};\n\n/**\n * Function: setPortsEnabled\n *\n * Specifies if the ports should be enabled.\n *\n * Parameters:\n *\n * value - Boolean indicating if the ports should be enabled.\n */\nmxGraph.prototype.setPortsEnabled = function(value)\n{\n\tthis.portsEnabled = value;\n};\n\n/**\n * Function: getGridSize\n *\n * Returns <gridSize>.\n */\nmxGraph.prototype.getGridSize = function()\n{\n\treturn this.gridSize;\n};\n\n/**\n * Function: setGridSize\n *\n * Sets <gridSize>.\n */\nmxGraph.prototype.setGridSize = function(value)\n{\n\tthis.gridSize = value;\n};\n\n/**\n * Function: getTolerance\n *\n * Returns <tolerance>.\n */\nmxGraph.prototype.getTolerance = function()\n{\n\treturn this.tolerance;\n};\n\n/**\n * Function: setTolerance\n *\n * Sets <tolerance>.\n */\nmxGraph.prototype.setTolerance = function(value)\n{\n\tthis.tolerance = value;\n};\n\n/**\n * Function: isVertexLabelsMovable\n *\n * Returns <vertexLabelsMovable>.\n */\nmxGraph.prototype.isVertexLabelsMovable = function()\n{\n\treturn this.vertexLabelsMovable;\n};\n\n/**\n * Function: setVertexLabelsMovable\n *\n * Sets <vertexLabelsMovable>.\n */\nmxGraph.prototype.setVertexLabelsMovable = function(value)\n{\n\tthis.vertexLabelsMovable = value;\n};\n\n/**\n * Function: isEdgeLabelsMovable\n *\n * Returns <edgeLabelsMovable>.\n */\nmxGraph.prototype.isEdgeLabelsMovable = function()\n{\n\treturn this.edgeLabelsMovable;\n};\n\n/**\n * Function: isEdgeLabelsMovable\n *\n * Sets <edgeLabelsMovable>.\n */\nmxGraph.prototype.setEdgeLabelsMovable = function(value)\n{\n\tthis.edgeLabelsMovable = value;\n};\n\n/**\n * Function: isSwimlaneNesting\n *\n * Returns <swimlaneNesting> as a boolean.\n */\nmxGraph.prototype.isSwimlaneNesting = function()\n{\n\treturn this.swimlaneNesting;\n};\n\n/**\n * Function: setSwimlaneNesting\n *\n * Specifies if swimlanes can be nested by drag and drop. This is only\n * taken into account if dropEnabled is true.\n *\n * Parameters:\n *\n * value - Boolean indicating if swimlanes can be nested.\n */\nmxGraph.prototype.setSwimlaneNesting = function(value)\n{\n\tthis.swimlaneNesting = value;\n};\n\n/**\n * Function: isSwimlaneSelectionEnabled\n *\n * Returns <swimlaneSelectionEnabled> as a boolean.\n */\nmxGraph.prototype.isSwimlaneSelectionEnabled = function()\n{\n\treturn this.swimlaneSelectionEnabled;\n};\n\n/**\n * Function: setSwimlaneSelectionEnabled\n *\n * Specifies if swimlanes should be selected if the mouse is released\n * over their content area.\n *\n * Parameters:\n *\n * value - Boolean indicating if swimlanes content areas\n * should be selected when the mouse is released over them.\n */\nmxGraph.prototype.setSwimlaneSelectionEnabled = function(value)\n{\n\tthis.swimlaneSelectionEnabled = value;\n};\n\n/**\n * Function: isMultigraph\n *\n * Returns <multigraph> as a boolean.\n */\nmxGraph.prototype.isMultigraph = function()\n{\n\treturn this.multigraph;\n};\n\n/**\n * Function: setMultigraph\n *\n * Specifies if the graph should allow multiple connections between the\n * same pair of vertices.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph allows multiple connections\n * between the same pair of vertices.\n */\nmxGraph.prototype.setMultigraph = function(value)\n{\n\tthis.multigraph = value;\n};\n\n/**\n * Function: isAllowLoops\n *\n * Returns <allowLoops> as a boolean.\n */\nmxGraph.prototype.isAllowLoops = function()\n{\n\treturn this.allowLoops;\n};\n\n/**\n * Function: setAllowDanglingEdges\n *\n * Specifies if dangling edges are allowed, that is, if edges are allowed\n * that do not have a source and/or target terminal defined.\n *\n * Parameters:\n *\n * value - Boolean indicating if dangling edges are allowed.\n */\nmxGraph.prototype.setAllowDanglingEdges = function(value)\n{\n\tthis.allowDanglingEdges = value;\n};\n\n/**\n * Function: isAllowDanglingEdges\n *\n * Returns <allowDanglingEdges> as a boolean.\n */\nmxGraph.prototype.isAllowDanglingEdges = function()\n{\n\treturn this.allowDanglingEdges;\n};\n\n/**\n * Function: setConnectableEdges\n *\n * Specifies if edges should be connectable.\n *\n * Parameters:\n *\n * value - Boolean indicating if edges should be connectable.\n */\nmxGraph.prototype.setConnectableEdges = function(value)\n{\n\tthis.connectableEdges = value;\n};\n\n/**\n * Function: isConnectableEdges\n *\n * Returns <connectableEdges> as a boolean.\n */\nmxGraph.prototype.isConnectableEdges = function()\n{\n\treturn this.connectableEdges;\n};\n\n/**\n * Function: setCloneInvalidEdges\n *\n * Specifies if edges should be inserted when cloned but not valid wrt.\n * <getEdgeValidationError>. If false such edges will be silently ignored.\n *\n * Parameters:\n *\n * value - Boolean indicating if cloned invalid edges should be\n * inserted into the graph or ignored.\n */\nmxGraph.prototype.setCloneInvalidEdges = function(value)\n{\n\tthis.cloneInvalidEdges = value;\n};\n\n/**\n * Function: isCloneInvalidEdges\n *\n * Returns <cloneInvalidEdges> as a boolean.\n */\nmxGraph.prototype.isCloneInvalidEdges = function()\n{\n\treturn this.cloneInvalidEdges;\n};\n\n/**\n * Function: setAllowLoops\n *\n * Specifies if loops are allowed.\n *\n * Parameters:\n *\n * value - Boolean indicating if loops are allowed.\n */\nmxGraph.prototype.setAllowLoops = function(value)\n{\n\tthis.allowLoops = value;\n};\n\n/**\n * Function: isDisconnectOnMove\n *\n * Returns <disconnectOnMove> as a boolean.\n */\nmxGraph.prototype.isDisconnectOnMove = function()\n{\n\treturn this.disconnectOnMove;\n};\n\n/**\n * Function: setDisconnectOnMove\n *\n * Specifies if edges should be disconnected when moved. (Note: Cloned\n * edges are always disconnected.)\n *\n * Parameters:\n *\n * value - Boolean indicating if edges should be disconnected\n * when moved.\n */\nmxGraph.prototype.setDisconnectOnMove = function(value)\n{\n\tthis.disconnectOnMove = value;\n};\n\n/**\n * Function: isDropEnabled\n *\n * Returns <dropEnabled> as a boolean.\n */\nmxGraph.prototype.isDropEnabled = function()\n{\n\treturn this.dropEnabled;\n};\n\n/**\n * Function: setDropEnabled\n *\n * Specifies if the graph should allow dropping of cells onto or into other\n * cells.\n *\n * Parameters:\n *\n * dropEnabled - Boolean indicating if the graph should allow dropping\n * of cells into other cells.\n */\nmxGraph.prototype.setDropEnabled = function(value)\n{\n\tthis.dropEnabled = value;\n};\n\n/**\n * Function: isSplitEnabled\n *\n * Returns <splitEnabled> as a boolean.\n */\nmxGraph.prototype.isSplitEnabled = function()\n{\n\treturn this.splitEnabled;\n};\n\n/**\n * Function: setSplitEnabled\n *\n * Specifies if the graph should allow dropping of cells onto or into other\n * cells.\n *\n * Parameters:\n *\n * dropEnabled - Boolean indicating if the graph should allow dropping\n * of cells into other cells.\n */\nmxGraph.prototype.setSplitEnabled = function(value)\n{\n\tthis.splitEnabled = value;\n};\n\n/**\n * Function: isCellResizable\n *\n * Returns true if the given cell is resizable. This returns\n * <cellsResizable> for all given cells if <isCellLocked> does not return\n * true for the given cell and its style does not specify\n * <mxConstants.STYLE_RESIZABLE> to be 0.\n *\n * Parameters:\n *\n * cell - <mxCell> whose resizable state should be returned.\n */\nmxGraph.prototype.isCellResizable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsResizable() && !this.isCellLocked(cell) &&\n\t\tmxUtils.getValue(style, mxConstants.STYLE_RESIZABLE, '1') != '0';\n};\n\n/**\n * Function: isCellsResizable\n *\n * Returns <cellsResizable>.\n */\nmxGraph.prototype.isCellsResizable = function()\n{\n\treturn this.cellsResizable;\n};\n\n/**\n * Function: setCellsResizable\n *\n * Specifies if the graph should allow resizing of cells. This\n * implementation updates <cellsResizable>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph should allow resizing of\n * cells.\n */\nmxGraph.prototype.setCellsResizable = function(value)\n{\n\tthis.cellsResizable = value;\n};\n\n/**\n * Function: isTerminalPointMovable\n *\n * Returns true if the given terminal point is movable. This is independent\n * from <isCellConnectable> and <isCellDisconnectable> and controls if terminal\n * points can be moved in the graph if the edge is not connected. Note that it\n * is required for this to return true to connect unconnected edges. This\n * implementation returns true.\n *\n * Parameters:\n *\n * cell - <mxCell> whose terminal point should be moved.\n * source - Boolean indicating if the source or target terminal should be moved.\n */\nmxGraph.prototype.isTerminalPointMovable = function(cell, source)\n{\n\treturn true;\n};\n\n/**\n * Function: isCellBendable\n *\n * Returns true if the given cell is bendable. This returns <cellsBendable>\n * for all given cells if <isLocked> does not return true for the given\n * cell and its style does not specify <mxConstants.STYLE_BENDABLE> to be 0.\n *\n * Parameters:\n *\n * cell - <mxCell> whose bendable state should be returned.\n */\nmxGraph.prototype.isCellBendable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsBendable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_BENDABLE] != 0;\n};\n\n/**\n * Function: isCellsBendable\n *\n * Returns <cellsBenadable>.\n */\nmxGraph.prototype.isCellsBendable = function()\n{\n\treturn this.cellsBendable;\n};\n\n/**\n * Function: setCellsBendable\n *\n * Specifies if the graph should allow bending of edges. This\n * implementation updates <bendable>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph should allow bending of\n * edges.\n */\nmxGraph.prototype.setCellsBendable = function(value)\n{\n\tthis.cellsBendable = value;\n};\n\n/**\n * Function: isCellEditable\n *\n * Returns true if the given cell is editable. This returns <cellsEditable> for\n * all given cells if <isCellLocked> does not return true for the given cell\n * and its style does not specify <mxConstants.STYLE_EDITABLE> to be 0.\n *\n * Parameters:\n *\n * cell - <mxCell> whose editable state should be returned.\n */\nmxGraph.prototype.isCellEditable = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isCellsEditable() && !this.isCellLocked(cell) && style[mxConstants.STYLE_EDITABLE] != 0;\n};\n\n/**\n * Function: isCellsEditable\n *\n * Returns <cellsEditable>.\n */\nmxGraph.prototype.isCellsEditable = function()\n{\n\treturn this.cellsEditable;\n};\n\n/**\n * Function: setCellsEditable\n *\n * Specifies if the graph should allow in-place editing for cell labels.\n * This implementation updates <cellsEditable>.\n *\n * Parameters:\n *\n * value - Boolean indicating if the graph should allow in-place\n * editing.\n */\nmxGraph.prototype.setCellsEditable = function(value)\n{\n\tthis.cellsEditable = value;\n};\n\n/**\n * Function: isCellDisconnectable\n *\n * Returns true if the given cell is disconnectable from the source or\n * target terminal. This returns <isCellsDisconnectable> for all given\n * cells if <isCellLocked> does not return true for the given cell.\n *\n * Parameters:\n *\n * cell - <mxCell> whose disconnectable state should be returned.\n * terminal - <mxCell> that represents the source or target terminal.\n * source - Boolean indicating if the source or target terminal is to be\n * disconnected.\n */\nmxGraph.prototype.isCellDisconnectable = function(cell, terminal, source)\n{\n\treturn this.isCellsDisconnectable() && !this.isCellLocked(cell);\n};\n\n/**\n * Function: isCellsDisconnectable\n *\n * Returns <cellsDisconnectable>.\n */\nmxGraph.prototype.isCellsDisconnectable = function()\n{\n\treturn this.cellsDisconnectable;\n};\n\n/**\n * Function: setCellsDisconnectable\n *\n * Sets <cellsDisconnectable>.\n */\nmxGraph.prototype.setCellsDisconnectable = function(value)\n{\n\tthis.cellsDisconnectable = value;\n};\n\n/**\n * Function: isValidSource\n *\n * Returns true if the given cell is a valid source for new connections.\n * This implementation returns true for all non-null values and is\n * called by is called by <isValidConnection>.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents a possible source or null.\n */\nmxGraph.prototype.isValidSource = function(cell)\n{\n\treturn (cell == null && this.allowDanglingEdges) ||\n\t\t(cell != null && (!this.model.isEdge(cell) ||\n\t\tthis.connectableEdges) && this.isCellConnectable(cell));\n};\n\n/**\n * Function: isValidTarget\n *\n * Returns <isValidSource> for the given cell. This is called by\n * <isValidConnection>.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents a possible target or null.\n */\nmxGraph.prototype.isValidTarget = function(cell)\n{\n\treturn this.isValidSource(cell);\n};\n\n/**\n * Function: isValidConnection\n *\n * Returns true if the given target cell is a valid target for source.\n * This is a boolean implementation for not allowing connections between\n * certain pairs of vertices and is called by <getEdgeValidationError>.\n * This implementation returns true if <isValidSource> returns true for\n * the source and <isValidTarget> returns true for the target.\n *\n * Parameters:\n *\n * source - <mxCell> that represents the source cell.\n * target - <mxCell> that represents the target cell.\n */\nmxGraph.prototype.isValidConnection = function(source, target)\n{\n\treturn this.isValidSource(source) && this.isValidTarget(target);\n};\n\n/**\n * Function: setConnectable\n *\n * Specifies if the graph should allow new connections. This implementation\n * updates <mxConnectionHandler.enabled> in <connectionHandler>.\n *\n * Parameters:\n *\n * connectable - Boolean indicating if new connections should be allowed.\n */\nmxGraph.prototype.setConnectable = function(connectable)\n{\n\tthis.connectionHandler.setEnabled(connectable);\n};\n\n/**\n * Function: isConnectable\n *\n * Returns true if the <connectionHandler> is enabled.\n */\nmxGraph.prototype.isConnectable = function()\n{\n\treturn this.connectionHandler.isEnabled();\n};\n\n/**\n * Function: setTooltips\n *\n * Specifies if tooltips should be enabled. This implementation updates\n * <mxTooltipHandler.enabled> in <tooltipHandler>.\n *\n * Parameters:\n *\n * enabled - Boolean indicating if tooltips should be enabled.\n */\nmxGraph.prototype.setTooltips = function (enabled)\n{\n\tthis.tooltipHandler.setEnabled(enabled);\n};\n\n/**\n * Function: setPanning\n *\n * Specifies if panning should be enabled. This implementation updates\n * <mxPanningHandler.panningEnabled> in <panningHandler>.\n *\n * Parameters:\n *\n * enabled - Boolean indicating if panning should be enabled.\n */\nmxGraph.prototype.setPanning = function(enabled)\n{\n\tthis.panningHandler.panningEnabled = enabled;\n};\n\n/**\n * Function: isEditing\n *\n * Returns true if the given cell is currently being edited.\n * If no cell is specified then this returns true if any\n * cell is currently being edited.\n *\n * Parameters:\n *\n * cell - <mxCell> that should be checked.\n */\nmxGraph.prototype.isEditing = function(cell)\n{\n\tif (this.cellEditor != null)\n\t{\n\t\tvar editingCell = this.cellEditor.getEditingCell();\n\n\t\treturn (cell == null) ? editingCell != null : cell == editingCell;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: isAutoSizeCell\n *\n * Returns true if the size of the given cell should automatically be\n * updated after a change of the label. This implementation returns\n * <autoSizeCells> or checks if the cell style does specify\n * <mxConstants.STYLE_AUTOSIZE> to be 1.\n *\n * Parameters:\n *\n * cell - <mxCell> that should be resized.\n */\nmxGraph.prototype.isAutoSizeCell = function(cell)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.isAutoSizeCells() || style[mxConstants.STYLE_AUTOSIZE] == 1;\n};\n\n/**\n * Function: isAutoSizeCells\n *\n * Returns <autoSizeCells>.\n */\nmxGraph.prototype.isAutoSizeCells = function()\n{\n\treturn this.autoSizeCells;\n};\n\n/**\n * Function: setAutoSizeCells\n *\n * Specifies if cell sizes should be automatically updated after a label\n * change. This implementation sets <autoSizeCells> to the given parameter.\n * To update the size of cells when the cells are added, set\n * <autoSizeCellsOnAdd> to true.\n *\n * Parameters:\n *\n * value - Boolean indicating if cells should be resized\n * automatically.\n */\nmxGraph.prototype.setAutoSizeCells = function(value)\n{\n\tthis.autoSizeCells = value;\n};\n\n/**\n * Function: isExtendParent\n *\n * Returns true if the parent of the given cell should be extended if the\n * child has been resized so that it overlaps the parent. This\n * implementation returns <isExtendParents> if the cell is not an edge.\n *\n * Parameters:\n *\n * cell - <mxCell> that has been resized.\n */\nmxGraph.prototype.isExtendParent = function(cell)\n{\n\treturn !this.getModel().isEdge(cell) && this.isExtendParents();\n};\n\n/**\n * Function: isExtendParents\n *\n * Returns <extendParents>.\n */\nmxGraph.prototype.isExtendParents = function()\n{\n\treturn this.extendParents;\n};\n\n/**\n * Function: setExtendParents\n *\n * Sets <extendParents>.\n *\n * Parameters:\n *\n * value - New boolean value for <extendParents>.\n */\nmxGraph.prototype.setExtendParents = function(value)\n{\n\tthis.extendParents = value;\n};\n\n/**\n * Function: isExtendParentsOnAdd\n *\n * Returns <extendParentsOnAdd>.\n */\nmxGraph.prototype.isExtendParentsOnAdd = function(cell)\n{\n\treturn this.extendParentsOnAdd;\n};\n\n/**\n * Function: setExtendParentsOnAdd\n *\n * Sets <extendParentsOnAdd>.\n *\n * Parameters:\n *\n * value - New boolean value for <extendParentsOnAdd>.\n */\nmxGraph.prototype.setExtendParentsOnAdd = function(value)\n{\n\tthis.extendParentsOnAdd = value;\n};\n\n/**\n * Function: isExtendParentsOnMove\n *\n * Returns <extendParentsOnMove>.\n */\nmxGraph.prototype.isExtendParentsOnMove = function()\n{\n\treturn this.extendParentsOnMove;\n};\n\n/**\n * Function: setExtendParentsOnMove\n *\n * Sets <extendParentsOnMove>.\n *\n * Parameters:\n *\n * value - New boolean value for <extendParentsOnAdd>.\n */\nmxGraph.prototype.setExtendParentsOnMove = function(value)\n{\n\tthis.extendParentsOnMove = value;\n};\n\n/**\n * Function: isRecursiveResize\n *\n * Returns <recursiveResize>.\n *\n * Parameters:\n *\n * state - <mxCellState> that is being resized.\n */\nmxGraph.prototype.isRecursiveResize = function(state)\n{\n\treturn this.recursiveResize;\n};\n\n/**\n * Function: setRecursiveResize\n *\n * Sets <recursiveResize>.\n *\n * Parameters:\n *\n * value - New boolean value for <recursiveResize>.\n */\nmxGraph.prototype.setRecursiveResize = function(value)\n{\n\tthis.recursiveResize = value;\n};\n\n/**\n * Function: isConstrainChild\n *\n * Returns true if the given cell should be kept inside the bounds of its\n * parent according to the rules defined by <getOverlap> and\n * <isAllowOverlapParent>. This implementation returns false for all children\n * of edges and <isConstrainChildren> otherwise.\n *\n * Parameters:\n *\n * cell - <mxCell> that should be constrained.\n */\nmxGraph.prototype.isConstrainChild = function(cell)\n{\n\treturn this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(cell));\n};\n\n/**\n * Function: isConstrainChildren\n *\n * Returns <constrainChildren>.\n */\nmxGraph.prototype.isConstrainChildren = function()\n{\n\treturn this.constrainChildren;\n};\n\n/**\n * Function: setConstrainChildren\n *\n * Sets <constrainChildren>.\n */\nmxGraph.prototype.setConstrainChildren = function(value)\n{\n\tthis.constrainChildren = value;\n};\n\n/**\n * Function: isConstrainRelativeChildren\n *\n * Returns <constrainRelativeChildren>.\n */\nmxGraph.prototype.isConstrainRelativeChildren = function()\n{\n\treturn this.constrainRelativeChildren;\n};\n\n/**\n * Function: setConstrainRelativeChildren\n *\n * Sets <constrainRelativeChildren>.\n */\nmxGraph.prototype.setConstrainRelativeChildren = function(value)\n{\n\tthis.constrainRelativeChildren = value;\n};\n\n/**\n * Function: isConstrainChildren\n *\n * Returns <allowNegativeCoordinates>.\n */\nmxGraph.prototype.isAllowNegativeCoordinates = function()\n{\n\treturn this.allowNegativeCoordinates;\n};\n\n/**\n * Function: setConstrainChildren\n *\n * Sets <allowNegativeCoordinates>.\n */\nmxGraph.prototype.setAllowNegativeCoordinates = function(value)\n{\n\tthis.allowNegativeCoordinates = value;\n};\n\n/**\n * Function: getOverlap\n *\n * Returns a decimal number representing the amount of the width and height\n * of the given cell that is allowed to overlap its parent. A value of 0\n * means all children must stay inside the parent, 1 means the child is\n * allowed to be placed outside of the parent such that it touches one of\n * the parents sides. If <isAllowOverlapParent> returns false for the given\n * cell, then this method returns 0.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the overlap ratio should be returned.\n */\nmxGraph.prototype.getOverlap = function(cell)\n{\n\treturn (this.isAllowOverlapParent(cell)) ? this.defaultOverlap : 0;\n};\n\n/**\n * Function: isAllowOverlapParent\n *\n * Returns true if the given cell is allowed to be placed outside of the\n * parents area.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the child to be checked.\n */\nmxGraph.prototype.isAllowOverlapParent = function(cell)\n{\n\treturn false;\n};\n\n/**\n * Function: getFoldableCells\n *\n * Returns the cells which are movable in the given array of cells.\n */\nmxGraph.prototype.getFoldableCells = function(cells, collapse)\n{\n\treturn this.model.filterCells(cells, mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.isCellFoldable(cell, collapse);\n\t}));\n};\n\n/**\n * Function: isCellFoldable\n *\n * Returns true if the given cell is foldable. This implementation\n * returns true if the cell has at least one child and its style\n * does not specify <mxConstants.STYLE_FOLDABLE> to be 0.\n *\n * Parameters:\n *\n * cell - <mxCell> whose foldable state should be returned.\n */\nmxGraph.prototype.isCellFoldable = function(cell, collapse)\n{\n\tvar state = this.view.getState(cell);\n\tvar style = (state != null) ? state.style : this.getCellStyle(cell);\n\n\treturn this.model.getChildCount(cell) > 0 && style[mxConstants.STYLE_FOLDABLE] != 0;\n};\n\n/**\n * Function: isValidDropTarget\n *\n * Returns true if the given cell is a valid drop target for the specified\n * cells. If <splitEnabled> is true then this returns <isSplitTarget> for\n * the given arguments else it returns true if the cell is not collapsed\n * and its child count is greater than 0.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the possible drop target.\n * cells - <mxCells> that should be dropped into the target.\n * evt - Mouseevent that triggered the invocation.\n */\nmxGraph.prototype.isValidDropTarget = function(cell, cells, evt)\n{\n\treturn cell != null && ((this.isSplitEnabled() &&\n\t\tthis.isSplitTarget(cell, cells, evt)) || (!this.model.isEdge(cell) &&\n\t\t(this.isSwimlane(cell) || (this.model.getChildCount(cell) > 0 &&\n\t\t!this.isCellCollapsed(cell)))));\n};\n\n/**\n * Function: isSplitTarget\n *\n * Returns true if the given edge may be splitted into two edges with the\n * given cell as a new terminal between the two.\n *\n * Parameters:\n *\n * target - <mxCell> that represents the edge to be splitted.\n * cells - <mxCells> that should split the edge.\n * evt - Mouseevent that triggered the invocation.\n */\nmxGraph.prototype.isSplitTarget = function(target, cells, evt)\n{\n\tif (this.model.isEdge(target) && cells != null && cells.length == 1 &&\n\t\tthis.isCellConnectable(cells[0]) && this.getEdgeValidationError(target,\n\t\t\tthis.model.getTerminal(target, true), cells[0]) == null)\n\t{\n\t\tvar src = this.model.getTerminal(target, true);\n\t\tvar trg = this.model.getTerminal(target, false);\n\n\t\treturn (!this.model.isAncestor(cells[0], src) &&\n\t\t\t\t!this.model.isAncestor(cells[0], trg));\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getDropTarget\n *\n * Returns the given cell if it is a drop target for the given cells or the\n * nearest ancestor that may be used as a drop target for the given cells.\n * If the given array contains a swimlane and <swimlaneNesting> is false\n * then this always returns null. If no cell is given, then the bottommost\n * swimlane at the location of the given event is returned.\n *\n * This function should only be used if <isDropEnabled> returns true.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> which are to be dropped onto the target.\n * evt - Mouseevent for the drag and drop.\n * cell - <mxCell> that is under the mousepointer.\n * clone - Optional boolean to indicate of cells will be cloned.\n */\nmxGraph.prototype.getDropTarget = function(cells, evt, cell, clone)\n{\n\tif (!this.isSwimlaneNesting())\n\t{\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (this.isSwimlane(cells[i]))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar pt = mxUtils.convertPoint(this.container,\n\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\tpt.x -= this.panDx;\n\tpt.y -= this.panDy;\n\tvar swimlane = this.getSwimlaneAt(pt.x, pt.y);\n\n\tif (cell == null)\n\t{\n\t\tcell = swimlane;\n\t}\n\telse if (swimlane != null)\n\t{\n\t\t// Checks if the cell is an ancestor of the swimlane\n\t\t// under the mouse and uses the swimlane in that case\n\t\tvar tmp = this.model.getParent(swimlane);\n\n\t\twhile (tmp != null && this.isSwimlane(tmp) && tmp != cell)\n\t\t{\n\t\t\ttmp = this.model.getParent(tmp);\n\t\t}\n\n\t\tif (tmp == cell)\n\t\t{\n\t\t\tcell = swimlane;\n\t\t}\n\t}\n\n\twhile (cell != null && !this.isValidDropTarget(cell, cells, evt) &&\n\t\t!this.model.isLayer(cell))\n\t{\n\t\tcell = this.model.getParent(cell);\n\t}\n\n\t// Checks if parent is dropped into child if not cloning\n\tif (clone == null || !clone)\n\t{\n\t\tvar parent = cell;\n\n\t\twhile (parent != null && mxUtils.indexOf(cells, parent) < 0)\n\t\t{\n\t\t\tparent = this.model.getParent(parent);\n\t\t}\n\t}\n\n\treturn (!this.model.isLayer(cell) && parent == null) ? cell : null;\n};\n\n/**\n * Group: Cell retrieval\n */\n\n/**\n * Function: getDefaultParent\n *\n * Returns <defaultParent> or <mxGraphView.currentRoot> or the first child\n * child of <mxGraphModel.root> if both are null. The value returned by\n * this function should be used as the parent for new cells (aka default\n * layer).\n */\nmxGraph.prototype.getDefaultParent = function()\n{\n\tvar parent = this.getCurrentRoot();\n\n\tif (parent == null)\n\t{\n\t\tparent = this.defaultParent;\n\n\t\tif (parent == null)\n\t\t{\n\t\t\tvar root = this.model.getRoot();\n\t\t\tparent = this.model.getChildAt(root, 0);\n\t\t}\n\t}\n\n\treturn parent;\n};\n\n/**\n * Function: setDefaultParent\n *\n * Sets the <defaultParent> to the given cell. Set this to null to return\n * the first child of the root in getDefaultParent.\n */\nmxGraph.prototype.setDefaultParent = function(cell)\n{\n\tthis.defaultParent = cell;\n};\n\n/**\n * Function: getSwimlane\n *\n * Returns the nearest ancestor of the given cell which is a swimlane, or\n * the given cell, if it is itself a swimlane.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the ancestor swimlane should be returned.\n */\nmxGraph.prototype.getSwimlane = function(cell)\n{\n\twhile (cell != null && !this.isSwimlane(cell))\n\t{\n\t\tcell = this.model.getParent(cell);\n\t}\n\n\treturn cell;\n};\n\n/**\n * Function: getSwimlaneAt\n *\n * Returns the bottom-most swimlane that intersects the given point (x, y)\n * in the cell hierarchy that starts at the given parent.\n *\n * Parameters:\n *\n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is <defaultParent>.\n */\nmxGraph.prototype.getSwimlaneAt = function (x, y, parent)\n{\n\tparent = parent || this.getDefaultParent();\n\n\tif (parent != null)\n\t{\n\t\tvar childCount = this.model.getChildCount(parent);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = this.model.getChildAt(parent, i);\n\t\t\tvar result = this.getSwimlaneAt(x, y, child);\n\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse if (this.isSwimlane(child))\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(child);\n\n\t\t\t\tif (this.intersects(state, x, y))\n\t\t\t\t{\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: getCellAt\n *\n * Returns the bottom-most cell that intersects the given point (x, y) in\n * the cell hierarchy starting at the given parent. This will also return\n * swimlanes if the given location intersects the content area of the\n * swimlane. If this is not desired, then the <hitsSwimlaneContent> may be\n * used if the returned cell is a swimlane to determine if the location\n * is inside the content area or on the actual title of the swimlane.\n *\n * Parameters:\n *\n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is current root of the view or the root of the model.\n * vertices - Optional boolean indicating if vertices should be returned.\n * Default is true.\n * edges - Optional boolean indicating if edges should be returned. Default\n * is true.\n * ignoreFn - Optional function that returns true if cell should be ignored.\n * The function is passed the cell state and the x and y parameter.\n */\nmxGraph.prototype.getCellAt = function(x, y, parent, vertices, edges, ignoreFn)\n{\n\tvertices = (vertices != null) ? vertices : true;\n\tedges = (edges != null) ? edges : true;\n\n\tif (parent == null)\n\t{\n\t\tparent = this.getCurrentRoot();\n\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getModel().getRoot();\n\t\t}\n\t}\n\n\tif (parent != null)\n\t{\n\t\tvar childCount = this.model.getChildCount(parent);\n\n\t\tfor (var i = childCount - 1; i >= 0; i--)\n\t\t{\n\t\t\tvar cell = this.model.getChildAt(parent, i);\n\t\t\tvar result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);\n\n\t\t\tif (result != null)\n\t\t\t{\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse if (this.isCellVisible(cell) && (edges && this.model.isEdge(cell) ||\n\t\t\t\tvertices && this.model.isVertex(cell)))\n\t\t\t{\n\t\t\t\tvar state = this.view.getState(cell);\n\n\t\t\t\tif (state != null && (ignoreFn == null || !ignoreFn(state, x, y)) &&\n\t\t\t\t\tthis.intersects(state, x, y))\n\t\t\t\t{\n\t\t\t\t\treturn cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: intersects\n *\n * Returns the bottom-most cell that intersects the given point (x, y) in\n * the cell hierarchy that starts at the given parent.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the cell state.\n * x - X-coordinate of the location to be checked.\n * y - Y-coordinate of the location to be checked.\n */\nmxGraph.prototype.intersects = function(state, x, y)\n{\n\tif (state != null)\n\t{\n\t\tvar pts = state.absolutePoints;\n\n\t\tif (pts != null)\n\t\t{\n\t\t\tvar t2 = this.tolerance * this.tolerance;\n\t\t\tvar pt = pts[0];\n\n\t\t\tfor (var i = 1; i < pts.length; i++)\n\t\t\t{\n\t\t\t\tvar next = pts[i];\n\t\t\t\tvar dist = mxUtils.ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);\n\n\t\t\t\tif (dist <= t2)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tpt = next;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\tvar cx = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(x, y), cos, sin, cx);\n\t\t\t\tx = pt.x;\n\t\t\t\ty = pt.y;\n\t\t\t}\n\n\t\t\tif (mxUtils.contains(state, x, y))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: hitsSwimlaneContent\n *\n * Returns true if the given coordinate pair is inside the content\n * are of the given swimlane.\n *\n * Parameters:\n *\n * swimlane - <mxCell> that specifies the swimlane.\n * x - X-coordinate of the mouse event.\n * y - Y-coordinate of the mouse event.\n */\nmxGraph.prototype.hitsSwimlaneContent = function(swimlane, x, y)\n{\n\tvar state = this.getView().getState(swimlane);\n\tvar size = this.getStartSize(swimlane);\n\n\tif (state != null)\n\t{\n\t\tvar scale = this.getView().getScale();\n\t\tx -= state.x;\n\t\ty -= state.y;\n\n\t\tif (size.width > 0 && x > 0 && x > size.width * scale)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse if (size.height > 0 && y > 0 && y > size.height * scale)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: getChildVertices\n *\n * Returns the visible child vertices of the given parent.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be returned.\n */\nmxGraph.prototype.getChildVertices = function(parent)\n{\n\treturn this.getChildCells(parent, true, false);\n};\n\n/**\n * Function: getChildEdges\n *\n * Returns the visible child edges of the given parent.\n *\n * Parameters:\n *\n * parent - <mxCell> whose child vertices should be returned.\n */\nmxGraph.prototype.getChildEdges = function(parent)\n{\n\treturn this.getChildCells(parent, false, true);\n};\n\n/**\n * Function: getChildCells\n *\n * Returns the visible child vertices or edges in the given parent. If\n * vertices and edges is false, then all children are returned.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be returned.\n * vertices - Optional boolean that specifies if child vertices should\n * be returned. Default is false.\n * edges - Optional boolean that specifies if child edges should\n * be returned. Default is false.\n */\nmxGraph.prototype.getChildCells = function(parent, vertices, edges)\n{\n\tparent = (parent != null) ? parent : this.getDefaultParent();\n\tvertices = (vertices != null) ? vertices : false;\n\tedges = (edges != null) ? edges : false;\n\n\tvar cells = this.model.getChildCells(parent, vertices, edges);\n\tvar result = [];\n\n\t// Filters out the non-visible child cells\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\tif (this.isCellVisible(cells[i]))\n\t\t{\n\t\t\tresult.push(cells[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getConnections\n *\n * Returns all visible edges connected to the given cell without loops.\n *\n * Parameters:\n *\n * cell - <mxCell> whose connections should be returned.\n * parent - Optional parent of the opposite end for a connection to be\n * returned.\n */\nmxGraph.prototype.getConnections = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, true, true, false);\n};\n\n/**\n * Function: getIncomingEdges\n *\n * Returns the visible incoming edges for the given cell. If the optional\n * parent argument is specified, then only child edges of the given parent\n * are returned.\n *\n * Parameters:\n *\n * cell - <mxCell> whose incoming edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n */\nmxGraph.prototype.getIncomingEdges = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, true, false, false);\n};\n\n/**\n * Function: getOutgoingEdges\n *\n * Returns the visible outgoing edges for the given cell. If the optional\n * parent argument is specified, then only child edges of the given parent\n * are returned.\n *\n * Parameters:\n *\n * cell - <mxCell> whose outgoing edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n */\nmxGraph.prototype.getOutgoingEdges = function(cell, parent)\n{\n\treturn this.getEdges(cell, parent, false, true, false);\n};\n\n/**\n * Function: getEdges\n *\n * Returns the incoming and/or outgoing edges for the given cell.\n * If the optional parent argument is specified, then only edges are returned\n * where the opposite is in the given parent cell. If at least one of incoming\n * or outgoing is true, then loops are ignored, if both are false, then all\n * edges connected to the given cell are returned including loops.\n *\n * Parameters:\n *\n * cell - <mxCell> whose edges should be returned.\n * parent - Optional parent of the opposite end for an edge to be\n * returned.\n * incoming - Optional boolean that specifies if incoming edges should\n * be included in the result. Default is true.\n * outgoing - Optional boolean that specifies if outgoing edges should\n * be included in the result. Default is true.\n * includeLoops - Optional boolean that specifies if loops should be\n * included in the result. Default is true.\n * recurse - Optional boolean the specifies if the parent specified only\n * need be an ancestral parent, true, or the direct parent, false.\n * Default is false\n */\nmxGraph.prototype.getEdges = function(cell, parent, incoming, outgoing, includeLoops, recurse)\n{\n\tincoming = (incoming != null) ? incoming : true;\n\toutgoing = (outgoing != null) ? outgoing : true;\n\tincludeLoops = (includeLoops != null) ? includeLoops : true;\n\trecurse = (recurse != null) ? recurse : false;\n\n\tvar edges = [];\n\tvar isCollapsed = this.isCellCollapsed(cell);\n\tvar childCount = this.model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = this.model.getChildAt(cell, i);\n\n\t\tif (isCollapsed || !this.isCellVisible(child))\n\t\t{\n\t\t\tedges = edges.concat(this.model.getEdges(child, incoming, outgoing));\n\t\t}\n\t}\n\n\tedges = edges.concat(this.model.getEdges(cell, incoming, outgoing));\n\tvar result = [];\n\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar state = this.view.getState(edges[i]);\n\n\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n\t\tif ((includeLoops && source == target) || ((source != target) && ((incoming &&\n\t\t\ttarget == cell && (parent == null || this.isValidAncestor(source, parent, recurse))) ||\n\t\t\t(outgoing && source == cell && (parent == null ||\n\t\t\t\t\tthis.isValidAncestor(target, parent, recurse))))))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isValidAncestor\n *\n * Returns whether or not the specified parent is a valid\n * ancestor of the specified cell, either direct or indirectly\n * based on whether ancestor recursion is enabled.\n *\n * Parameters:\n *\n * cell - <mxCell> the possible child cell\n * parent - <mxCell> the possible parent cell\n * recurse - boolean whether or not to recurse the child ancestors\n */\nmxGraph.prototype.isValidAncestor = function(cell, parent, recurse)\n{\n\treturn (recurse ? this.model.isAncestor(parent, cell) : this.model\n\t\t\t.getParent(cell) == parent);\n};\n\n/**\n * Function: getOpposites\n *\n * Returns all distinct visible opposite cells for the specified terminal\n * on the given edges.\n *\n * Parameters:\n *\n * edges - Array of <mxCells> that contains the edges whose opposite\n * terminals should be returned.\n * terminal - Terminal that specifies the end whose opposite should be\n * returned.\n * source - Optional boolean that specifies if source terminals should be\n * included in the result. Default is true.\n * targets - Optional boolean that specifies if targer terminals should be\n * included in the result. Default is true.\n */\nmxGraph.prototype.getOpposites = function(edges, terminal, sources, targets)\n{\n\tsources = (sources != null) ? sources : true;\n\ttargets = (targets != null) ? targets : true;\n\n\tvar terminals = [];\n\n\t// Fast lookup to avoid duplicates in terminals array\n\tvar dict = new mxDictionary();\n\n\tif (edges != null)\n\t{\n\t\tfor (var i = 0; i < edges.length; i++)\n\t\t{\n\t\t\tvar state = this.view.getState(edges[i]);\n\n\t\t\tvar source = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\t\tvar target = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n\t\t\t// Checks if the terminal is the source of the edge and if the\n\t\t\t// target should be stored in the result\n\t\t\tif (source == terminal && target != null && target != terminal && targets)\n\t\t\t{\n\t\t\t\tif (!dict.get(target))\n\t\t\t\t{\n\t\t\t\t\tdict.put(target, true);\n\t\t\t\t\tterminals.push(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Checks if the terminal is the taget of the edge and if the\n\t\t\t// source should be stored in the result\n\t\t\telse if (target == terminal && source != null && source != terminal && sources)\n\t\t\t{\n\t\t\t\tif (!dict.get(source))\n\t\t\t\t{\n\t\t\t\t\tdict.put(source, true);\n\t\t\t\t\tterminals.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn terminals;\n};\n\n/**\n * Function: getEdgesBetween\n *\n * Returns the edges between the given source and target. This takes into\n * account collapsed and invisible cells and returns the connected edges\n * as displayed on the screen.\n *\n * Parameters:\n *\n * source -\n * target -\n * directed -\n */\nmxGraph.prototype.getEdgesBetween = function(source, target, directed)\n{\n\tdirected = (directed != null) ? directed : false;\n\tvar edges = this.getEdges(source);\n\tvar result = [];\n\n\t// Checks if the edge is connected to the correct\n\t// cell and returns the first match\n\tfor (var i = 0; i < edges.length; i++)\n\t{\n\t\tvar state = this.view.getState(edges[i]);\n\n\t\tvar src = (state != null) ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n\t\tvar trg = (state != null) ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n\t\tif ((src == source && trg == target) || (!directed && src == target && trg == source))\n\t\t{\n\t\t\tresult.push(edges[i]);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getPointForEvent\n *\n * Returns an <mxPoint> representing the given event in the unscaled,\n * non-translated coordinate space of <container> and applies the grid.\n *\n * Parameters:\n *\n * evt - Mousevent that contains the mouse pointer location.\n * addOffset - Optional boolean that specifies if the position should be\n * offset by half of the <gridSize>. Default is true.\n */\n mxGraph.prototype.getPointForEvent = function(evt, addOffset)\n {\n\tvar p = mxUtils.convertPoint(this.container,\n\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\n\tvar s = this.view.scale;\n\tvar tr = this.view.translate;\n\tvar off = (addOffset != false) ? this.gridSize / 2 : 0;\n\n\tp.x = this.snap(p.x / s - tr.x - off);\n\tp.y = this.snap(p.y / s - tr.y - off);\n\n\treturn p;\n };\n\n/**\n * Function: getCells\n *\n * Returns the child vertices and edges of the given parent that are contained\n * in the given rectangle. The result is added to the optional result array,\n * which is returned. If no result array is specified then a new array is\n * created and returned.\n *\n * Parameters:\n *\n * x - X-coordinate of the rectangle.\n * y - Y-coordinate of the rectangle.\n * width - Width of the rectangle.\n * height - Height of the rectangle.\n * parent - <mxCell> that should be used as the root of the recursion.\n * Default is current root of the view or the root of the model.\n * result - Optional array to store the result in.\n */\nmxGraph.prototype.getCells = function(x, y, width, height, parent, result)\n{\n\tresult = (result != null) ? result : [];\n\n\tif (width > 0 || height > 0)\n\t{\n\t\tvar model = this.getModel();\n\t\tvar right = x + width;\n\t\tvar bottom = y + height;\n\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getCurrentRoot();\n\n\t\t\tif (parent == null)\n\t\t\t{\n\t\t\t\tparent = model.getRoot();\n\t\t\t}\n\t\t}\n\n\t\tif (parent != null)\n\t\t{\n\t\t\tvar childCount = model.getChildCount(parent);\n\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar cell = model.getChildAt(parent, i);\n\t\t\t\tvar state = this.view.getState(cell);\n\n\t\t\t\tif (state != null && this.isCellVisible(cell))\n\t\t\t\t{\n\t\t\t\t\tvar deg = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0;\n\t\t\t\t\tvar box = state;\n\n\t\t\t\t\tif (deg != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbox = mxUtils.getBoundingBox(box, deg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((model.isEdge(cell) || model.isVertex(cell)) &&\n\t\t\t\t\t\tbox.x >= x && box.y + box.height <= bottom &&\n\t\t\t\t\t\tbox.y >= y && box.x + box.width <= right)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(cell);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.getCells(x, y, width, height, cell, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getCellsBeyond\n *\n * Returns the children of the given parent that are contained in the\n * halfpane from the given point (x0, y0) rightwards or downwards\n * depending on rightHalfpane and bottomHalfpane.\n *\n * Parameters:\n *\n * x0 - X-coordinate of the origin.\n * y0 - Y-coordinate of the origin.\n * parent - Optional <mxCell> whose children should be checked. Default is\n * <defaultParent>.\n * rightHalfpane - Boolean indicating if the cells in the right halfpane\n * from the origin should be returned.\n * bottomHalfpane - Boolean indicating if the cells in the bottom halfpane\n * from the origin should be returned.\n */\nmxGraph.prototype.getCellsBeyond = function(x0, y0, parent, rightHalfpane, bottomHalfpane)\n{\n\tvar result = [];\n\n\tif (rightHalfpane || bottomHalfpane)\n\t{\n\t\tif (parent == null)\n\t\t{\n\t\t\tparent = this.getDefaultParent();\n\t\t}\n\n\t\tif (parent != null)\n\t\t{\n\t\t\tvar childCount = this.model.getChildCount(parent);\n\n\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t{\n\t\t\t\tvar child = this.model.getChildAt(parent, i);\n\t\t\t\tvar state = this.view.getState(child);\n\n\t\t\t\tif (this.isCellVisible(child) && state != null)\n\t\t\t\t{\n\t\t\t\t\tif ((!rightHalfpane || state.x >= x0) &&\n\t\t\t\t\t\t(!bottomHalfpane || state.y >= y0))\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: findTreeRoots\n *\n * Returns all children in the given parent which do not have incoming\n * edges. If the result is empty then the with the greatest difference\n * between incoming and outgoing edges is returned.\n *\n * Parameters:\n *\n * parent - <mxCell> whose children should be checked.\n * isolate - Optional boolean that specifies if edges should be ignored if\n * the opposite end is not a child of the given parent cell. Default is\n * false.\n * invert - Optional boolean that specifies if outgoing or incoming edges\n * should be counted for a tree root. If false then outgoing edges will be\n * counted. Default is false.\n */\nmxGraph.prototype.findTreeRoots = function(parent, isolate, invert)\n{\n\tisolate = (isolate != null) ? isolate : false;\n\tinvert = (invert != null) ? invert : false;\n\tvar roots = [];\n\n\tif (parent != null)\n\t{\n\t\tvar model = this.getModel();\n\t\tvar childCount = model.getChildCount(parent);\n\t\tvar best = null;\n\t\tvar maxDiff = 0;\n\n\t\tfor (var i=0; i<childCount; i++)\n\t\t{\n\t\t\tvar cell = model.getChildAt(parent, i);\n\n\t\t\tif (this.model.isVertex(cell) && this.isCellVisible(cell))\n\t\t\t{\n\t\t\t\tvar conns = this.getConnections(cell, (isolate) ? parent : null);\n\t\t\t\tvar fanOut = 0;\n\t\t\t\tvar fanIn = 0;\n\n\t\t\t\tfor (var j = 0; j < conns.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar src = this.view.getVisibleTerminal(conns[j], true);\n\n                    if (src == cell)\n                    {\n                        fanOut++;\n                    }\n                    else\n                    {\n                        fanIn++;\n                    }\n\t\t\t\t}\n\n\t\t\t\tif ((invert && fanOut == 0 && fanIn > 0) ||\n\t\t\t\t\t(!invert && fanIn == 0 && fanOut > 0))\n\t\t\t\t{\n\t\t\t\t\troots.push(cell);\n\t\t\t\t}\n\n\t\t\t\tvar diff = (invert) ? fanIn - fanOut : fanOut - fanIn;\n\n\t\t\t\tif (diff > maxDiff)\n\t\t\t\t{\n\t\t\t\t\tmaxDiff = diff;\n\t\t\t\t\tbest = cell;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (roots.length == 0 && best != null)\n\t\t{\n\t\t\troots.push(best);\n\t\t}\n\t}\n\n\treturn roots;\n};\n\n/**\n * Function: traverse\n *\n * Traverses the (directed) graph invoking the given function for each\n * visited vertex and edge. The function is invoked with the current vertex\n * and the incoming edge as a parameter. This implementation makes sure\n * each vertex is only visited once. The function may return false if the\n * traversal should stop at the given vertex.\n *\n * Example:\n *\n * (code)\n * mxLog.show();\n * var cell = graph.getSelectionCell();\n * graph.traverse(cell, false, function(vertex, edge)\n * {\n *   mxLog.debug(graph.getLabel(vertex));\n * });\n * (end)\n *\n * Parameters:\n *\n * vertex - <mxCell> that represents the vertex where the traversal starts.\n * directed - Optional boolean indicating if edges should only be traversed\n * from source to target. Default is true.\n * func - Visitor function that takes the current vertex and the incoming\n * edge as arguments. The traversal stops if the function returns false.\n * edge - Optional <mxCell> that represents the incoming edge. This is\n * null for the first step of the traversal.\n * visited - Optional <mxDictionary> from cells to true for the visited cells.\n * inverse - Optional boolean to traverse in inverse direction. Default is false.\n * This is ignored if directed is false.\n */\nmxGraph.prototype.traverse = function(vertex, directed, func, edge, visited, inverse)\n{\n\tif (func != null && vertex != null)\n\t{\n\t\tdirected = (directed != null) ? directed : true;\n\t\tinverse = (inverse != null) ? inverse : false;\n\t\tvisited = visited || new mxDictionary();\n\n\t\tif (!visited.get(vertex))\n\t\t{\n\t\t\tvisited.put(vertex, true);\n\t\t\tvar result = func(vertex, edge);\n\n\t\t\tif (result == null || result)\n\t\t\t{\n\t\t\t\tvar edgeCount = this.model.getEdgeCount(vertex);\n\n\t\t\t\tif (edgeCount > 0)\n\t\t\t\t{\n\t\t\t\t\tfor (var i = 0; i < edgeCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar e = this.model.getEdgeAt(vertex, i);\n\t\t\t\t\t\tvar isSource = this.model.getTerminal(e, true) == vertex;\n\n\t\t\t\t\t\tif (!directed || (!inverse == isSource))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar next = this.model.getTerminal(e, !isSource);\n\t\t\t\t\t\t\tthis.traverse(next, directed, func, e, visited, inverse);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Group: Selection\n */\n\n/**\n * Function: isCellSelected\n *\n * Returns true if the given cell is selected.\n *\n * Parameters:\n *\n * cell - <mxCell> for which the selection state should be returned.\n */\nmxGraph.prototype.isCellSelected = function(cell)\n{\n\treturn this.getSelectionModel().isSelected(cell);\n};\n\n/**\n * Function: isSelectionEmpty\n *\n * Returns true if the selection is empty.\n */\nmxGraph.prototype.isSelectionEmpty = function()\n{\n\treturn this.getSelectionModel().isEmpty();\n};\n\n/**\n * Function: clearSelection\n *\n * Clears the selection using <mxGraphSelectionModel.clear>.\n */\nmxGraph.prototype.clearSelection = function()\n{\n\treturn this.getSelectionModel().clear();\n};\n\n/**\n * Function: getSelectionCount\n *\n * Returns the number of selected cells.\n */\nmxGraph.prototype.getSelectionCount = function()\n{\n\treturn this.getSelectionModel().cells.length;\n};\n\n/**\n * Function: getSelectionCell\n *\n * Returns the first cell from the array of selected <mxCells>.\n */\nmxGraph.prototype.getSelectionCell = function()\n{\n\treturn this.getSelectionModel().cells[0];\n};\n\n/**\n * Function: getSelectionCells\n *\n * Returns the array of selected <mxCells>.\n */\nmxGraph.prototype.getSelectionCells = function()\n{\n\treturn this.getSelectionModel().cells.slice();\n};\n\n/**\n * Function: setSelectionCell\n *\n * Sets the selection cell.\n *\n * Parameters:\n *\n * cell - <mxCell> to be selected.\n */\nmxGraph.prototype.setSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().setCell(cell);\n};\n\n/**\n * Function: setSelectionCells\n *\n * Sets the selection cell.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be selected.\n */\nmxGraph.prototype.setSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().setCells(cells);\n};\n\n/**\n * Function: addSelectionCell\n *\n * Adds the given cell to the selection.\n *\n * Parameters:\n *\n * cell - <mxCell> to be add to the selection.\n */\nmxGraph.prototype.addSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().addCell(cell);\n};\n\n/**\n * Function: addSelectionCells\n *\n * Adds the given cells to the selection.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be added to the selection.\n */\nmxGraph.prototype.addSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().addCells(cells);\n};\n\n/**\n * Function: removeSelectionCell\n *\n * Removes the given cell from the selection.\n *\n * Parameters:\n *\n * cell - <mxCell> to be removed from the selection.\n */\nmxGraph.prototype.removeSelectionCell = function(cell)\n{\n\tthis.getSelectionModel().removeCell(cell);\n};\n\n/**\n * Function: removeSelectionCells\n *\n * Removes the given cells from the selection.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be removed from the selection.\n */\nmxGraph.prototype.removeSelectionCells = function(cells)\n{\n\tthis.getSelectionModel().removeCells(cells);\n};\n\n/**\n * Function: selectRegion\n *\n * Selects and returns the cells inside the given rectangle for the\n * specified event.\n *\n * Parameters:\n *\n * rect - <mxRectangle> that represents the region to be selected.\n * evt - Mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectRegion = function(rect, evt)\n{\n\tvar cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n\tthis.selectCellsForEvent(cells, evt);\n\n\treturn cells;\n};\n\n/**\n * Function: selectNextCell\n *\n * Selects the next cell.\n */\nmxGraph.prototype.selectNextCell = function()\n{\n\tthis.selectCell(true);\n};\n\n/**\n * Function: selectPreviousCell\n *\n * Selects the previous cell.\n */\nmxGraph.prototype.selectPreviousCell = function()\n{\n\tthis.selectCell();\n};\n\n/**\n * Function: selectParentCell\n *\n * Selects the parent cell.\n */\nmxGraph.prototype.selectParentCell = function()\n{\n\tthis.selectCell(false, true);\n};\n\n/**\n * Function: selectChildCell\n *\n * Selects the first child cell.\n */\nmxGraph.prototype.selectChildCell = function()\n{\n\tthis.selectCell(false, false, true);\n};\n\n/**\n * Function: selectCell\n *\n * Selects the next, parent, first child or previous cell, if all arguments\n * are false.\n *\n * Parameters:\n *\n * isNext - Boolean indicating if the next cell should be selected.\n * isParent - Boolean indicating if the parent cell should be selected.\n * isChild - Boolean indicating if the first child cell should be selected.\n */\nmxGraph.prototype.selectCell = function(isNext, isParent, isChild)\n{\n\tvar sel = this.selectionModel;\n\tvar cell = (sel.cells.length > 0) ? sel.cells[0] : null;\n\n\tif (sel.cells.length > 1)\n\t{\n\t\tsel.clear();\n\t}\n\n\tvar parent = (cell != null) ?\n\t\tthis.model.getParent(cell) :\n\t\tthis.getDefaultParent();\n\n\tvar childCount = this.model.getChildCount(parent);\n\n\tif (cell == null && childCount > 0)\n\t{\n\t\tvar child = this.model.getChildAt(parent, 0);\n\t\tthis.setSelectionCell(child);\n\t}\n\telse if ((cell == null || isParent) &&\n\t\tthis.view.getState(parent) != null &&\n\t\tthis.model.getGeometry(parent) != null)\n\t{\n\t\tif (this.getCurrentRoot() != parent)\n\t\t{\n\t\t\tthis.setSelectionCell(parent);\n\t\t}\n\t}\n\telse if (cell != null && isChild)\n\t{\n\t\tvar tmp = this.model.getChildCount(cell);\n\n\t\tif (tmp > 0)\n\t\t{\n\t\t\tvar child = this.model.getChildAt(cell, 0);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t}\n\telse if (childCount > 0)\n\t{\n\t\tvar i = parent.getIndex(cell);\n\n\t\tif (isNext)\n\t\t{\n\t\t\ti++;\n\t\t\tvar child = this.model.getChildAt(parent, i % childCount);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti--;\n\t\t\tvar index =  (i < 0) ? childCount - 1 : i;\n\t\t\tvar child = this.model.getChildAt(parent, index);\n\t\t\tthis.setSelectionCell(child);\n\t\t}\n\t}\n};\n\n/**\n * Function: selectAll\n *\n * Selects all children of the given parent cell or the children of the\n * default parent if no parent is specified. To select leaf vertices and/or\n * edges use <selectCells>.\n *\n * Parameters:\n *\n * parent - Optional <mxCell> whose children should be selected.\n * Default is <defaultParent>.\n * descendants - Optional boolean specifying whether all descendants should be\n * selected. Default is false.\n */\nmxGraph.prototype.selectAll = function(parent, descendants)\n{\n\tparent = parent || this.getDefaultParent();\n\n\tvar cells = (descendants) ? this.model.filterDescendants(function(cell)\n\t{\n\t\treturn cell != parent;\n\t}, parent) : this.model.getChildren(parent);\n\n\tif (cells != null)\n\t{\n\t\tthis.setSelectionCells(cells);\n\t}\n};\n\n/**\n * Function: selectVertices\n *\n * Select all vertices inside the given parent or the default parent.\n */\nmxGraph.prototype.selectVertices = function(parent)\n{\n\tthis.selectCells(true, false, parent);\n};\n\n/**\n * Function: selectVertices\n *\n * Select all vertices inside the given parent or the default parent.\n */\nmxGraph.prototype.selectEdges = function(parent)\n{\n\tthis.selectCells(false, true, parent);\n};\n\n/**\n * Function: selectCells\n *\n * Selects all vertices and/or edges depending on the given boolean\n * arguments recursively, starting at the given parent or the default\n * parent if no parent is specified. Use <selectAll> to select all cells.\n * For vertices, only cells with no children are selected.\n *\n * Parameters:\n *\n * vertices - Boolean indicating if vertices should be selected.\n * edges - Boolean indicating if edges should be selected.\n * parent - Optional <mxCell> that acts as the root of the recursion.\n * Default is <defaultParent>.\n */\nmxGraph.prototype.selectCells = function(vertices, edges, parent)\n{\n\tparent = parent || this.getDefaultParent();\n\n\tvar filter = mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.view.getState(cell) != null &&\n\t\t\t((this.model.getChildCount(cell) == 0 && this.model.isVertex(cell) && vertices\n\t\t\t&& !this.model.isEdge(this.model.getParent(cell))) ||\n\t\t\t(this.model.isEdge(cell) && edges));\n\t});\n\n\tvar cells = this.model.filterDescendants(filter, parent);\n\tthis.setSelectionCells(cells);\n};\n\n/**\n * Function: selectCellForEvent\n *\n * Selects the given cell by either adding it to the selection or\n * replacing the selection depending on whether the given mouse event is a\n * toggle event.\n *\n * Parameters:\n *\n * cell - <mxCell> to be selected.\n * evt - Optional mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectCellForEvent = function(cell, evt)\n{\n\tvar isSelected = this.isCellSelected(cell);\n\n\tif (this.isToggleEvent(evt))\n\t{\n\t\tif (isSelected)\n\t\t{\n\t\t\tthis.removeSelectionCell(cell);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.addSelectionCell(cell);\n\t\t}\n\t}\n\telse if (!isSelected || this.getSelectionCount() != 1)\n\t{\n\t\tthis.setSelectionCell(cell);\n\t}\n};\n\n/**\n * Function: selectCellsForEvent\n *\n * Selects the given cells by either adding them to the selection or\n * replacing the selection depending on whether the given mouse event is a\n * toggle event.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> to be selected.\n * evt - Optional mouseevent that triggered the selection.\n */\nmxGraph.prototype.selectCellsForEvent = function(cells, evt)\n{\n\tif (this.isToggleEvent(evt))\n\t{\n\t\tthis.addSelectionCells(cells);\n\t}\n\telse\n\t{\n\t\tthis.setSelectionCells(cells);\n\t}\n};\n\n/**\n * Group: Selection state\n */\n\n/**\n * Function: createHandler\n *\n * Creates a new handler for the given cell state. This implementation\n * returns a new <mxEdgeHandler> of the corresponding cell is an edge,\n * otherwise it returns an <mxVertexHandler>.\n *\n * Parameters:\n *\n * state - <mxCellState> whose handler should be created.\n */\nmxGraph.prototype.createHandler = function(state)\n{\n\tvar result = null;\n\n\tif (state != null)\n\t{\n\t\tif (this.model.isEdge(state.cell))\n\t\t{\n\t\t\tvar source = state.getVisibleTerminalState(true);\n\t\t\tvar target = state.getVisibleTerminalState(false);\n\t\t\tvar geo = this.getCellGeometry(state.cell);\n\n\t\t\tvar edgeStyle = this.view.getEdgeStyle(state, (geo != null) ? geo.points : null, source, target);\n\t\t\tresult = this.createEdgeHandler(state, edgeStyle);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = this.createVertexHandler(state);\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: createVertexHandler\n *\n * Hooks to create a new <mxVertexHandler> for the given <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createVertexHandler = function(state)\n{\n\treturn new mxVertexHandler(state);\n};\n\n/**\n * Function: createEdgeHandler\n *\n * Hooks to create a new <mxEdgeHandler> for the given <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createEdgeHandler = function(state, edgeStyle)\n{\n\tvar result = null;\n\n\tif (edgeStyle == mxEdgeStyle.Loop ||\n\t\tedgeStyle == mxEdgeStyle.ElbowConnector ||\n\t\tedgeStyle == mxEdgeStyle.SideToSide ||\n\t\tedgeStyle == mxEdgeStyle.TopToBottom)\n\t{\n\t\tresult = this.createElbowEdgeHandler(state);\n\t}\n\telse if (edgeStyle == mxEdgeStyle.SegmentConnector ||\n\t\t\tedgeStyle == mxEdgeStyle.OrthConnector)\n\t{\n\t\tresult = this.createEdgeSegmentHandler(state);\n\t}\n\telse\n\t{\n\t\tresult = new mxEdgeHandler(state);\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: createEdgeSegmentHandler\n *\n * Hooks to create a new <mxEdgeSegmentHandler> for the given <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createEdgeSegmentHandler = function(state)\n{\n\treturn new mxEdgeSegmentHandler(state);\n};\n\n/**\n * Function: createElbowEdgeHandler\n *\n * Hooks to create a new <mxElbowEdgeHandler> for the given <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> to create the handler for.\n */\nmxGraph.prototype.createElbowEdgeHandler = function(state)\n{\n\treturn new mxElbowEdgeHandler(state);\n};\n\n/**\n * Group: Graph events\n */\n\n/**\n * Function: addMouseListener\n *\n * Adds a listener to the graph event dispatch loop. The listener\n * must implement the mouseDown, mouseMove and mouseUp methods\n * as shown in the <mxMouseEvent> class.\n *\n * Parameters:\n *\n * listener - Listener to be added to the graph event listeners.\n */\nmxGraph.prototype.addMouseListener = function(listener)\n{\n\tif (this.mouseListeners == null)\n\t{\n\t\tthis.mouseListeners = [];\n\t}\n\n\tthis.mouseListeners.push(listener);\n};\n\n/**\n * Function: removeMouseListener\n *\n * Removes the specified graph listener.\n *\n * Parameters:\n *\n * listener - Listener to be removed from the graph event listeners.\n */\nmxGraph.prototype.removeMouseListener = function(listener)\n{\n\tif (this.mouseListeners != null)\n\t{\n\t\tfor (var i = 0; i < this.mouseListeners.length; i++)\n\t\t{\n\t\t\tif (this.mouseListeners[i] == listener)\n\t\t\t{\n\t\t\t\tthis.mouseListeners.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: updateMouseEvent\n *\n * Sets the graphX and graphY properties if the given <mxMouseEvent> if\n * required and returned the event.\n *\n * Parameters:\n *\n * me - <mxMouseEvent> to be updated.\n * evtName - Name of the mouse event.\n */\nmxGraph.prototype.updateMouseEvent = function(me, evtName)\n{\n\tif (me.graphX == null || me.graphY == null)\n\t{\n\t\tvar pt = mxUtils.convertPoint(this.container, me.getX(), me.getY());\n\n\t\tme.graphX = pt.x - this.panDx;\n\t\tme.graphY = pt.y - this.panDy;\n\n\t\t// Searches for rectangles using method if native hit detection is disabled on shape\n\t\tif (me.getCell() == null && this.isMouseDown && evtName == mxEvent.MOUSE_MOVE)\n\t\t{\n\t\t\tme.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function(state)\n\t\t\t{\n\t\t\t\treturn state.shape == null || state.shape.paintBackground != mxRectangleShape.prototype.paintBackground ||\n\t\t\t\t\tmxUtils.getValue(state.style, mxConstants.STYLE_POINTER_EVENTS, '1') == '1' ||\n\t\t\t\t\t(state.shape.fill != null && state.shape.fill != mxConstants.NONE);\n\t\t\t}));\n\t\t}\n\t}\n\n\treturn me;\n};\n\n/**\n * Function: getStateForEvent\n *\n * Returns the state for the given touch event.\n */\nmxGraph.prototype.getStateForTouchEvent = function(evt)\n{\n\tvar x = mxEvent.getClientX(evt);\n\tvar y = mxEvent.getClientY(evt);\n\n\t// Dispatches the drop event to the graph which\n\t// consumes and executes the source function\n\tvar pt = mxUtils.convertPoint(this.container, x, y);\n\n\treturn this.view.getState(this.getCellAt(pt.x, pt.y));\n};\n\n/**\n * Function: isEventIgnored\n *\n * Returns true if the event should be ignored in <fireMouseEvent>.\n */\nmxGraph.prototype.isEventIgnored = function(evtName, me, sender)\n{\n\tvar mouseEvent = mxEvent.isMouseEvent(me.getEvent());\n\tvar result = false;\n\n\t// Drops events that are fired more than once\n\tif (me.getEvent() == this.lastEvent)\n\t{\n\t\tresult = true;\n\t}\n\telse\n\t{\n\t\tthis.lastEvent = me.getEvent();\n\t}\n\n\t// Installs event listeners to capture the complete gesture from the event source\n\t// for non-MS touch events as a workaround for all events for the same geture being\n\t// fired from the event source even if that was removed from the DOM.\n\tif (this.eventSource != null && evtName != mxEvent.MOUSE_MOVE)\n\t{\n\t\tmxEvent.removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n\t\tthis.mouseMoveRedirect = null;\n\t\tthis.mouseUpRedirect = null;\n\t\tthis.eventSource = null;\n\t}\n\telse if (!mxClient.IS_GC && this.eventSource != null && me.getSource() != this.eventSource)\n\t{\n\t\tresult = true;\n\t}\n\telse if (mxClient.IS_TOUCH && evtName == mxEvent.MOUSE_DOWN && !mouseEvent && !mxEvent.isPenEvent(me.getEvent()))\n\t{\n\t\tthis.eventSource = me.getSource();\n\n\t\tthis.mouseMoveRedirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));\n\t\t});\n\t\tthis.mouseUpRedirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt, this.getStateForTouchEvent(evt)));\n\t\t});\n\n\t\tmxEvent.addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n\t}\n\n\t// Factored out the workarounds for FF to make it easier to override/remove\n\t// Note this method has side-effects!\n\tif (this.isSyntheticEventIgnored(evtName, me, sender))\n\t{\n\t\tresult = true;\n\t}\n\n\t// Never fires mouseUp/-Down for double clicks\n\tif (!mxEvent.isPopupTrigger(this.lastEvent) && evtName != mxEvent.MOUSE_MOVE && this.lastEvent.detail == 2)\n\t{\n\t\treturn true;\n\t}\n\n\t// Filters out of sequence events or mixed event types during a gesture\n\tif (evtName == mxEvent.MOUSE_UP && this.isMouseDown)\n\t{\n\t\tthis.isMouseDown = false;\n\t}\n\telse if (evtName == mxEvent.MOUSE_DOWN && !this.isMouseDown)\n\t{\n\t\tthis.isMouseDown = true;\n\t\tthis.isMouseTrigger = mouseEvent;\n\t}\n\t// Drops mouse events that are fired during touch gestures as a workaround for Webkit\n\t// and mouse events that are not in sync with the current internal button state\n\telse if (!result && (((!mxClient.IS_FF || evtName != mxEvent.MOUSE_MOVE) &&\n\t\tthis.isMouseDown && this.isMouseTrigger != mouseEvent) ||\n\t\t(evtName == mxEvent.MOUSE_DOWN && this.isMouseDown) ||\n\t\t(evtName == mxEvent.MOUSE_UP && !this.isMouseDown)))\n\t{\n\t\tresult = true;\n\t}\n\n\tif (!result && evtName == mxEvent.MOUSE_DOWN)\n\t{\n\t\tthis.lastMouseX = me.getX();\n\t\tthis.lastMouseY = me.getY();\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isSyntheticEventIgnored\n *\n * Hook for ignoring synthetic mouse events after touchend in Firefox.\n */\nmxGraph.prototype.isSyntheticEventIgnored = function(evtName, me, sender)\n{\n\tvar result = false;\n\tvar mouseEvent = mxEvent.isMouseEvent(me.getEvent());\n\n\t// LATER: This does not cover all possible cases that can go wrong in FF\n\tif (this.ignoreMouseEvents && mouseEvent && evtName != mxEvent.MOUSE_MOVE)\n\t{\n\t\tthis.ignoreMouseEvents = evtName != mxEvent.MOUSE_UP;\n\t\tresult = true;\n\t}\n\telse if (mxClient.IS_FF && !mouseEvent && evtName == mxEvent.MOUSE_UP)\n\t{\n\t\tthis.ignoreMouseEvents = true;\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isEventSourceIgnored\n *\n * Returns true if the event should be ignored in <fireMouseEvent>. This\n * implementation returns true for select, option and input (if not of type\n * checkbox, radio, button, submit or file) event sources if the event is not\n * a mouse event or a left mouse button press event.\n *\n * Parameters:\n *\n * evtName - The name of the event.\n * me - <mxMouseEvent> that should be ignored.\n */\nmxGraph.prototype.isEventSourceIgnored = function(evtName, me)\n{\n\tvar source = me.getSource();\n\tvar name = (source.nodeName != null) ? source.nodeName.toLowerCase() : '';\n\tvar candidate = !mxEvent.isMouseEvent(me.getEvent()) || mxEvent.isLeftMouseButton(me.getEvent());\n\n\treturn evtName == mxEvent.MOUSE_DOWN && candidate && (name == 'select' || name == 'option' ||\n\t\t(name == 'input' && source.type != 'checkbox' && source.type != 'radio' &&\n\t\tsource.type != 'button' && source.type != 'submit' && source.type != 'file'));\n};\n\n/**\n * Function: getEventState\n *\n * Returns the <mxCellState> to be used when firing the mouse event for the\n * given state. This implementation returns the given state.\n *\n * Parameters:\n *\n * <mxCellState> - State whose event source should be returned.\n */\nmxGraph.prototype.getEventState = function(state)\n{\n\treturn state;\n};\n\n/**\n * Function: fireMouseEvent\n *\n * Dispatches the given event in the graph event dispatch loop. Possible\n * event names are <mxEvent.MOUSE_DOWN>, <mxEvent.MOUSE_MOVE> and\n * <mxEvent.MOUSE_UP>. All listeners are invoked for all events regardless\n * of the consumed state of the event.\n *\n * Parameters:\n *\n * evtName - String that specifies the type of event to be dispatched.\n * me - <mxMouseEvent> to be fired.\n * sender - Optional sender argument. Default is this.\n */\nmxGraph.prototype.fireMouseEvent = function(evtName, me, sender)\n{\n\tif (this.isEventSourceIgnored(evtName, me))\n\t{\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.hide();\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (sender == null)\n\t{\n\t\tsender = this;\n\t}\n\n\t// Updates the graph coordinates in the event\n\tme = this.updateMouseEvent(me, evtName);\n\n\t// Detects and processes double taps for touch-based devices which do not have native double click events\n\t// or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n\t// double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n\t// two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n\t// detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n\tif ((!this.nativeDblClickEnabled && !mxEvent.isPopupTrigger(me.getEvent())) || (this.doubleTapEnabled &&\n\t\tmxClient.IS_TOUCH && (mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent()))))\n\t{\n\t\tvar currentTime = new Date().getTime();\n\n\t\t// NOTE: Second mouseDown for double click missing in quirks mode\n\t\tif ((!mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_DOWN) || (mxClient.IS_QUIRKS && evtName == mxEvent.MOUSE_UP && !this.fireDoubleClick))\n\t\t{\n\t\t\tif (this.lastTouchEvent != null && this.lastTouchEvent != me.getEvent() &&\n\t\t\t\tcurrentTime - this.lastTouchTime < this.doubleTapTimeout &&\n\t\t\t\tMath.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n\t\t\t\tMath.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance &&\n\t\t\t\tthis.doubleClickCounter < 2)\n\t\t\t{\n\t\t\t\tthis.doubleClickCounter++;\n\t\t\t\tvar doubleClickFired = false;\n\n\t\t\t\tif (evtName == mxEvent.MOUSE_UP)\n\t\t\t\t{\n\t\t\t\t\tif (me.getCell() == this.lastTouchCell && this.lastTouchCell != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.lastTouchTime = 0;\n\t\t\t\t\t\tvar cell = this.lastTouchCell;\n\t\t\t\t\t\tthis.lastTouchCell = null;\n\n\t\t\t\t\t\t// Fires native dblclick event via event source\n\t\t\t\t\t\t// NOTE: This fires two double click events on edges in quirks mode. While\n\t\t\t\t\t\t// trying to fix this, we realized that nativeDoubleClick can be disabled for\n\t\t\t\t\t\t// quirks and IE10+ (or we didn't find the case mentioned above where it\n\t\t\t\t\t\t// would not work), ie. all double clicks seem to be working without this.\n\t\t\t\t\t\tif (mxClient.IS_QUIRKS)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tme.getSource().fireEvent('ondblclick');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.dblClick(me.getEvent(), cell);\n\t\t\t\t\t\tdoubleClickFired = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.fireDoubleClick = true;\n\t\t\t\t\tthis.lastTouchTime = 0;\n\t\t\t\t}\n\n\t\t\t\t// Do not ignore mouse up in quirks in this case\n\t\t\t\tif (!mxClient.IS_QUIRKS || doubleClickFired)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(me.getEvent());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.lastTouchEvent == null || this.lastTouchEvent != me.getEvent())\n\t\t\t{\n\t\t\t\tthis.lastTouchCell = me.getCell();\n\t\t\t\tthis.lastTouchX = me.getX();\n\t\t\t\tthis.lastTouchY = me.getY();\n\t\t\t\tthis.lastTouchTime = currentTime;\n\t\t\t\tthis.lastTouchEvent = me.getEvent();\n\t\t\t\tthis.doubleClickCounter = 0;\n\t\t\t}\n\t\t}\n\t\telse if ((this.isMouseDown || evtName == mxEvent.MOUSE_UP) && this.fireDoubleClick)\n\t\t{\n\t\t\tthis.fireDoubleClick = false;\n\t\t\tvar cell = this.lastTouchCell;\n\t\t\tthis.lastTouchCell = null;\n\t\t\tthis.isMouseDown = false;\n\n\t\t\t// Workaround for Chrome/Safari not firing native double click events for double touch on background\n\t\t\tvar valid = (cell != null) || ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) &&\n\t\t\t\t(mxClient.IS_GC || mxClient.IS_SF));\n\n\t\t\tif (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance &&\n\t\t\t\tMath.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance)\n\t\t\t{\n\t\t\t\tthis.dblClick(me.getEvent(), cell);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmxEvent.consume(me.getEvent());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!this.isEventIgnored(evtName, me, sender))\n\t{\n\t\t// Updates the event state via getEventState\n\t\tme.state = this.getEventState(me.getState());\n\t\tthis.fireEvent(new mxEventObject(mxEvent.FIRE_MOUSE_EVENT, 'eventName', evtName, 'event', me));\n\n\t\tif ((mxClient.IS_OP || mxClient.IS_SF || mxClient.IS_GC || mxClient.IS_IE11 ||\n\t\t\t(mxClient.IS_IE && mxClient.IS_SVG) || me.getEvent().target != this.container))\n\t\t{\n\t\t\tif (evtName == mxEvent.MOUSE_MOVE && this.isMouseDown && this.autoScroll && !mxEvent.isMultiTouchEvent(me.getEvent))\n\t\t\t{\n\t\t\t\tthis.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);\n\t\t\t}\n\t\t\telse if (evtName == mxEvent.MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition &&\n\t\t\t\t\t(this.container.scrollLeft != 0 || this.container.scrollTop != 0))\n\t\t\t{\n\t\t\t\tvar s = this.view.scale;\n\t\t\t\tvar tr = this.view.translate;\n\t\t\t\tthis.view.setTranslate(tr.x - this.container.scrollLeft / s, tr.y - this.container.scrollTop / s);\n\t\t\t\tthis.container.scrollLeft = 0;\n\t\t\t\tthis.container.scrollTop = 0;\n\t\t\t}\n\n\t\t\tif (this.mouseListeners != null)\n\t\t\t{\n\t\t\t\tvar args = [sender, me];\n\n\t\t\t\t// Does not change returnValue in Opera\n\t\t\t\tif (!me.getEvent().preventDefault)\n\t\t\t\t{\n\t\t\t\t\tme.getEvent().returnValue = true;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < this.mouseListeners.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar l = this.mouseListeners[i];\n\n\t\t\t\t\tif (evtName == mxEvent.MOUSE_DOWN)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseDown.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t\telse if (evtName == mxEvent.MOUSE_MOVE)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseMove.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t\telse if (evtName == mxEvent.MOUSE_UP)\n\t\t\t\t\t{\n\t\t\t\t\t\tl.mouseUp.apply(l, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Invokes the click handler\n\t\t\tif (evtName == mxEvent.MOUSE_UP)\n\t\t\t{\n\t\t\t\tthis.click(me);\n\t\t\t}\n\t\t}\n\n\t\t// Detects tapAndHold events using a timer\n\t\tif ((mxEvent.isTouchEvent(me.getEvent()) || mxEvent.isPenEvent(me.getEvent())) &&\n\t\t\tevtName == mxEvent.MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress)\n\t\t{\n\t\t\tthis.tapAndHoldInProgress = true;\n\t\t\tthis.initialTouchX = me.getGraphX();\n\t\t\tthis.initialTouchY = me.getGraphY();\n\n\t\t\tvar handler = function()\n\t\t\t{\n\t\t\t\tif (this.tapAndHoldValid)\n\t\t\t\t{\n\t\t\t\t\tthis.tapAndHold(me);\n\t\t\t\t}\n\n\t\t\t\tthis.tapAndHoldInProgress = false;\n\t\t\t\tthis.tapAndHoldValid = false;\n\t\t\t};\n\n\t\t\tif (this.tapAndHoldThread)\n\t\t\t{\n\t\t\t\twindow.clearTimeout(this.tapAndHoldThread);\n\t\t\t}\n\n\t\t\tthis.tapAndHoldThread = window.setTimeout(mxUtils.bind(this, handler), this.tapAndHoldDelay);\n\t\t\tthis.tapAndHoldValid = true;\n\t\t}\n\t\telse if (evtName == mxEvent.MOUSE_UP)\n\t\t{\n\t\t\tthis.tapAndHoldInProgress = false;\n\t\t\tthis.tapAndHoldValid = false;\n\t\t}\n\t\telse if (this.tapAndHoldValid)\n\t\t{\n\t\t\tthis.tapAndHoldValid =\n\t\t\t\tMath.abs(this.initialTouchX - me.getGraphX()) < this.tolerance &&\n\t\t\t\tMath.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n\t\t}\n\n\t\t// Stops editing for all events other than from cellEditor\n\t\tif (evtName == mxEvent.MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent()))\n\t\t{\n\t\t\tthis.stopEditing(!this.isInvokesStopCellEditing());\n\t\t}\n\n\t\tthis.consumeMouseEvent(evtName, me, sender);\n\t}\n};\n\n/**\n * Function: consumeMouseEvent\n *\n * Consumes the given <mxMouseEvent> if it's a touchStart event.\n */\nmxGraph.prototype.consumeMouseEvent = function(evtName, me, sender)\n{\n\t// Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n\tif (evtName == mxEvent.MOUSE_DOWN && mxEvent.isTouchEvent(me.getEvent()))\n\t{\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: fireGestureEvent\n *\n * Dispatches a <mxEvent.GESTURE> event. The following example will resize the\n * cell under the mouse based on the scale property of the native touch event.\n *\n * (code)\n * graph.addListener(mxEvent.GESTURE, function(sender, eo)\n * {\n *   var evt = eo.getProperty('event');\n *   var state = graph.view.getState(eo.getProperty('cell'));\n *\n *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)\n *   {\n *     var scale = graph.view.scale;\n *     var tr = graph.view.translate;\n *\n *     var w = state.width * evt.scale;\n *     var h = state.height * evt.scale;\n *     var x = state.x - (w - state.width) / 2;\n *     var y = state.y - (h - state.height) / 2;\n *\n *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,\n *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));\n *     graph.resizeCell(state.cell, bounds);\n *     eo.consume();\n *   }\n * });\n * (end)\n *\n * Parameters:\n *\n * evt - Gestureend event that represents the gesture.\n * cell - Optional <mxCell> associated with the gesture.\n */\nmxGraph.prototype.fireGestureEvent = function(evt, cell)\n{\n\t// Resets double tap event handling when gestures take place\n\tthis.lastTouchTime = 0;\n\tthis.fireEvent(new mxEventObject(mxEvent.GESTURE, 'event', evt, 'cell', cell));\n};\n\n/**\n * Function: destroy\n *\n * Destroys the graph and all its resources.\n */\nmxGraph.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\n\t\tif (this.tooltipHandler != null)\n\t\t{\n\t\t\tthis.tooltipHandler.destroy();\n\t\t}\n\n\t\tif (this.selectionCellsHandler != null)\n\t\t{\n\t\t\tthis.selectionCellsHandler.destroy();\n\t\t}\n\n\t\tif (this.panningHandler != null)\n\t\t{\n\t\t\tthis.panningHandler.destroy();\n\t\t}\n\n\t\tif (this.popupMenuHandler != null)\n\t\t{\n\t\t\tthis.popupMenuHandler.destroy();\n\t\t}\n\n\t\tif (this.connectionHandler != null)\n\t\t{\n\t\t\tthis.connectionHandler.destroy();\n\t\t}\n\n\t\tif (this.graphHandler != null)\n\t\t{\n\t\t\tthis.graphHandler.destroy();\n\t\t}\n\n\t\tif (this.cellEditor != null)\n\t\t{\n\t\t\tthis.cellEditor.destroy();\n\t\t}\n\n\t\tif (this.view != null)\n\t\t{\n\t\t\tthis.view.destroy();\n\t\t}\n\n\t\tif (this.model != null && this.graphModelChangeListener != null)\n\t\t{\n\t\t\tthis.model.removeListener(this.graphModelChangeListener);\n\t\t\tthis.graphModelChangeListener = null;\n\t\t}\n\n\t\tthis.container = null;\n\t}\n};\n\n__mxOutput.mxGraph = typeof mxGraph !== 'undefined' ? mxGraph : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellOverlay\n *\n * Extends <mxEventSource> to implement a graph overlay, represented by an icon\n * and a tooltip. Overlays can handle and fire <click> events and are added to\n * the graph using <mxGraph.addCellOverlay>, and removed using\n * <mxGraph.removeCellOverlay>, or <mxGraph.removeCellOverlays> to remove all overlays.\n * The <mxGraph.getCellOverlays> function returns the array of overlays for a given\n * cell in a graph. If multiple overlays exist for the same cell, then\n * <getBounds> should be overridden in at least one of the overlays.\n *\n * Overlays appear on top of all cells in a special layer. If this is not\n * desirable, then the image must be rendered as part of the shape or label of\n * the cell instead.\n *\n * Example:\n *\n * The following adds a new overlays for a given vertex and selects the cell\n * if the overlay is clicked.\n *\n * (code)\n * var overlay = new mxCellOverlay(img, html);\n * graph.addCellOverlay(vertex, overlay);\n * overlay.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var cell = evt.getProperty('cell');\n *   graph.setSelectionCell(cell);\n * });\n * (end)\n *\n * For cell overlays to be printed use <mxPrintPreview.printOverlays>.\n *\n * Event: mxEvent.CLICK\n *\n * Fires when the user clicks on the overlay. The <code>event</code> property\n * contains the corresponding mouse event and the <code>cell</code> property\n * contains the cell. For touch devices this is fired if the element receives\n * a touchend event.\n *\n * Constructor: mxCellOverlay\n *\n * Constructs a new overlay using the given image and tooltip.\n *\n * Parameters:\n *\n * image - <mxImage> that represents the icon to be displayed.\n * tooltip - Optional string that specifies the tooltip.\n * align - Optional horizontal alignment for the overlay. Possible\n * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>\n * (default).\n * verticalAlign - Vertical alignment for the overlay. Possible\n * values are <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>\n * (default).\n */\nfunction mxCellOverlay(image, tooltip, align, verticalAlign, offset, cursor)\n{\n\tthis.image = image;\n\tthis.tooltip = tooltip;\n\tthis.align = (align != null) ? align : this.align;\n\tthis.verticalAlign = (verticalAlign != null) ? verticalAlign : this.verticalAlign;\n\tthis.offset = (offset != null) ? offset : new mxPoint();\n\tthis.cursor = (cursor != null) ? cursor : 'help';\n};\n\n/**\n * Extends mxEventSource.\n */\nmxCellOverlay.prototype = new mxEventSource();\nmxCellOverlay.prototype.constructor = mxCellOverlay;\n\n/**\n * Variable: image\n *\n * Holds the <mxImage> to be used as the icon.\n */\nmxCellOverlay.prototype.image = null;\n\n/**\n * Variable: tooltip\n *\n * Holds the optional string to be used as the tooltip.\n */\nmxCellOverlay.prototype.tooltip = null;\n\n/**\n * Variable: align\n *\n * Holds the horizontal alignment for the overlay. Default is\n * <mxConstants.ALIGN_RIGHT>. For edges, the overlay always appears in the\n * center of the edge.\n */\nmxCellOverlay.prototype.align = mxConstants.ALIGN_RIGHT;\n\n/**\n * Variable: verticalAlign\n *\n * Holds the vertical alignment for the overlay. Default is\n * <mxConstants.ALIGN_BOTTOM>. For edges, the overlay always appears in the\n * center of the edge.\n */\nmxCellOverlay.prototype.verticalAlign = mxConstants.ALIGN_BOTTOM;\n\n/**\n * Variable: offset\n *\n * Holds the offset as an <mxPoint>. The offset will be scaled according to the\n * current scale.\n */\nmxCellOverlay.prototype.offset = null;\n\n/**\n * Variable: cursor\n *\n * Holds the cursor for the overlay. Default is 'help'.\n */\nmxCellOverlay.prototype.cursor = null;\n\n/**\n * Variable: defaultOverlap\n *\n * Defines the overlapping for the overlay, that is, the proportional distance\n * from the origin to the point defined by the alignment. Default is 0.5.\n */\nmxCellOverlay.prototype.defaultOverlap = 0.5;\n\n/**\n * Function: getBounds\n *\n * Returns the bounds of the overlay for the given <mxCellState> as an\n * <mxRectangle>. This should be overridden when using multiple overlays\n * per cell so that the overlays do not overlap.\n *\n * The following example will place the overlay along an edge (where\n * x=[-1..1] from the start to the end of the edge and y is the\n * orthogonal offset in px).\n *\n * (code)\n * overlay.getBounds = function(state)\n * {\n *   var bounds = mxCellOverlay.prototype.getBounds.apply(this, arguments);\n *\n *   if (state.view.graph.getModel().isEdge(state.cell))\n *   {\n *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});\n *\n *     bounds.x = pt.x - bounds.width / 2;\n *     bounds.y = pt.y - bounds.height / 2;\n *   }\n *\n *   return bounds;\n * };\n * (end)\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the current state of the\n * associated cell.\n */\nmxCellOverlay.prototype.getBounds = function(state)\n{\n\tvar isEdge = state.view.graph.getModel().isEdge(state.cell);\n\tvar s = state.view.scale;\n\tvar pt = null;\n\n\tvar w = this.image.width;\n\tvar h = this.image.height;\n\n\tif (isEdge)\n\t{\n\t\tvar pts = state.absolutePoints;\n\n\t\tif (pts.length % 2 == 1)\n\t\t{\n\t\t\tpt = pts[Math.floor(pts.length / 2)];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar idx = pts.length / 2;\n\t\t\tvar p0 = pts[idx-1];\n\t\t\tvar p1 = pts[idx];\n\t\t\tpt = new mxPoint(p0.x + (p1.x - p0.x) / 2,\n\t\t\t\tp0.y + (p1.y - p0.y) / 2);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpt = new mxPoint();\n\n\t\tif (this.align == mxConstants.ALIGN_LEFT)\n\t\t{\n\t\t\tpt.x = state.x;\n\t\t}\n\t\telse if (this.align == mxConstants.ALIGN_CENTER)\n\t\t{\n\t\t\tpt.x = state.x + state.width / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpt.x = state.x + state.width;\n\t\t}\n\n\t\tif (this.verticalAlign == mxConstants.ALIGN_TOP)\n\t\t{\n\t\t\tpt.y = state.y;\n\t\t}\n\t\telse if (this.verticalAlign == mxConstants.ALIGN_MIDDLE)\n\t\t{\n\t\t\tpt.y = state.y + state.height / 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpt.y = state.y + state.height;\n\t\t}\n\t}\n\n\treturn new mxRectangle(Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s),\n\t\tMath.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);\n};\n\n/**\n * Function: toString\n *\n * Returns the textual representation of the overlay to be used as the\n * tooltip. This implementation returns <tooltip>.\n */\nmxCellOverlay.prototype.toString = function()\n{\n\treturn this.tooltip;\n};\n\n__mxOutput.mxCellOverlay = typeof mxCellOverlay !== 'undefined' ? mxCellOverlay : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxOutline\n *\n * Implements an outline (aka overview) for a graph. Set <updateOnPan> to true\n * to enable updates while the source graph is panning.\n *\n * Example:\n *\n * (code)\n * var outline = new mxOutline(graph, div);\n * (end)\n *\n * If an outline is used in an <mxWindow> in IE8 standards mode, the following\n * code makes sure that the shadow filter is not inherited and that any\n * transparent elements in the graph do not show the page background, but the\n * background of the graph container.\n *\n * (code)\n * if (document.documentMode == 8)\n * {\n *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n * }\n * (end)\n *\n * To move the graph to the top, left corner the following code can be used.\n *\n * (code)\n * var scale = graph.view.scale;\n * var bounds = graph.getGraphBounds();\n * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);\n * (end)\n *\n * To toggle the suspended mode, the following can be used.\n *\n * (code)\n * outline.suspended = !outln.suspended;\n * if (!outline.suspended)\n * {\n *   outline.update(true);\n * }\n * (end)\n *\n * Constructor: mxOutline\n *\n * Constructs a new outline for the specified graph inside the given\n * container.\n *\n * Parameters:\n *\n * source - <mxGraph> to create the outline for.\n * container - DOM node that will contain the outline.\n */\nfunction mxOutline(source, container)\n{\n\tthis.source = source;\n\n\tif (container != null)\n\t{\n\t\tthis.init(container);\n\t}\n};\n\n/**\n * Function: source\n *\n * Reference to the source <mxGraph>.\n */\nmxOutline.prototype.source = null;\n\n/**\n * Function: outline\n *\n * Reference to the <mxGraph> that renders the outline.\n */\nmxOutline.prototype.outline = null;\n\n/**\n * Function: graphRenderHint\n *\n * Renderhint to be used for the outline graph. Default is faster.\n */\nmxOutline.prototype.graphRenderHint = mxConstants.RENDERING_HINT_FASTER;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxOutline.prototype.enabled = true;\n\n/**\n * Variable: showViewport\n *\n * Specifies a viewport rectangle should be shown. Default is true.\n */\nmxOutline.prototype.showViewport = true;\n\n/**\n * Variable: border\n *\n * Border to be added at the bottom and right. Default is 10.\n */\nmxOutline.prototype.border = 10;\n\n/**\n * Variable: enabled\n *\n * Specifies the size of the sizer handler. Default is 8.\n */\nmxOutline.prototype.sizerSize = 8;\n\n/**\n * Variable: labelsVisible\n *\n * Specifies if labels should be visible in the outline. Default is false.\n */\nmxOutline.prototype.labelsVisible = false;\n\n/**\n * Variable: updateOnPan\n *\n * Specifies if <update> should be called for <mxEvent.PAN> in the source\n * graph. Default is false.\n */\nmxOutline.prototype.updateOnPan = false;\n\n/**\n * Variable: sizerImage\n *\n * Optional <mxImage> to be used for the sizer. Default is null.\n */\nmxOutline.prototype.sizerImage = null;\n\n/**\n * Variable: minScale\n *\n * Minimum scale to be used. Default is 0.001.\n */\nmxOutline.prototype.minScale = 0.0001;\n\n/**\n * Variable: suspended\n *\n * Optional boolean flag to suspend updates. Default is false. This flag will\n * also suspend repaints of the outline. To toggle this switch, use the\n * following code.\n *\n * (code)\n * nav.suspended = !nav.suspended;\n *\n * if (!nav.suspended)\n * {\n *   nav.update(true);\n * }\n * (end)\n */\nmxOutline.prototype.suspended = false;\n\n/**\n * Variable: forceVmlHandles\n *\n * Specifies if VML should be used to render the handles in this control. This\n * is true for IE8 standards mode and false for all other browsers and modes.\n * This is a workaround for rendering issues of HTML elements over elements\n * with filters in IE 8 standards mode.\n */\nmxOutline.prototype.forceVmlHandles = document.documentMode == 8;\n\n/**\n * Function: createGraph\n *\n * Creates the <mxGraph> used in the outline.\n */\nmxOutline.prototype.createGraph = function(container)\n{\n\tvar graph = new mxGraph(container, this.source.getModel(), this.graphRenderHint, this.source.getStylesheet());\n\tgraph.foldingEnabled = false;\n\tgraph.autoScroll = false;\n\n\treturn graph;\n};\n\n/**\n * Function: init\n *\n * Initializes the outline inside the given container.\n */\nmxOutline.prototype.init = function(container)\n{\n\tthis.outline = this.createGraph(container);\n\n\t// Do not repaint when suspended\n\tvar outlineGraphModelChanged = this.outline.graphModelChanged;\n\tthis.outline.graphModelChanged = mxUtils.bind(this, function(changes)\n\t{\n\t\tif (!this.suspended && this.outline != null)\n\t\t{\n\t\t\toutlineGraphModelChanged.apply(this.outline, arguments);\n\t\t}\n\t});\n\n\t// Enables faster painting in SVG\n\tif (mxClient.IS_SVG)\n\t{\n\t\tvar node = this.outline.getView().getCanvas().parentNode;\n\t\tnode.setAttribute('shape-rendering', 'optimizeSpeed');\n\t\tnode.setAttribute('image-rendering', 'optimizeSpeed');\n\t}\n\n\t// Hides cursors and labels\n\tthis.outline.labelsVisible = this.labelsVisible;\n\tthis.outline.setEnabled(false);\n\n\tthis.updateHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (!this.suspended && !this.active)\n\t\t{\n\t\t\tthis.update();\n\t\t}\n\t});\n\n\t// Updates the scale of the outline after a change of the main graph\n\tthis.source.getModel().addListener(mxEvent.CHANGE, this.updateHandler);\n\tthis.outline.addMouseListener(this);\n\n\t// Adds listeners to keep the outline in sync with the source graph\n\tvar view = this.source.getView();\n\tview.addListener(mxEvent.SCALE, this.updateHandler);\n\tview.addListener(mxEvent.TRANSLATE, this.updateHandler);\n\tview.addListener(mxEvent.SCALE_AND_TRANSLATE, this.updateHandler);\n\tview.addListener(mxEvent.DOWN, this.updateHandler);\n\tview.addListener(mxEvent.UP, this.updateHandler);\n\n\t// Updates blue rectangle on scroll\n\tmxEvent.addListener(this.source.container, 'scroll', this.updateHandler);\n\n\tthis.panHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tif (this.updateOnPan)\n\t\t{\n\t\t\tthis.updateHandler.apply(this, arguments);\n\t\t}\n\t});\n\tthis.source.addListener(mxEvent.PAN, this.panHandler);\n\n\t// Refreshes the graph in the outline after a refresh of the main graph\n\tthis.refreshHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tthis.outline.setStylesheet(this.source.getStylesheet());\n\t\tthis.outline.refresh();\n\t});\n\tthis.source.addListener(mxEvent.REFRESH, this.refreshHandler);\n\n\t// Creates the blue rectangle for the viewport\n\tthis.bounds = new mxRectangle(0, 0, 0, 0);\n\tthis.selectionBorder = new mxRectangleShape(this.bounds, null,\n\t\tmxConstants.OUTLINE_COLOR, mxConstants.OUTLINE_STROKEWIDTH);\n\tthis.selectionBorder.dialect = this.outline.dialect;\n\n\tif (this.forceVmlHandles)\n\t{\n\t\tthis.selectionBorder.isHtmlAllowed = function()\n\t\t{\n\t\t\treturn false;\n\t\t};\n\t}\n\n\tthis.selectionBorder.init(this.outline.getView().getOverlayPane());\n\n\t// Handles event by catching the initial pointer start and then listening to the\n\t// complete gesture on the event target. This is needed because all the events\n\t// are routed via the initial element even if that element is removed from the\n\t// DOM, which happens when we repaint the selection border and zoom handles.\n\tvar handler = mxUtils.bind(this, function(evt)\n\t{\n\t\tvar t = mxEvent.getSource(evt);\n\n\t\tvar redirect = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.outline.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));\n\t\t});\n\n\t\tvar redirect2 = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tmxEvent.removeGestureListeners(t, null, redirect, redirect2);\n\t\t\tthis.outline.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));\n\t\t});\n\n\t\tmxEvent.addGestureListeners(t, null, redirect, redirect2);\n\t\tthis.outline.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));\n\t});\n\n\tmxEvent.addGestureListeners(this.selectionBorder.node, handler);\n\n\t// Creates a small blue rectangle for sizing (sizer handle)\n\tthis.sizer = this.createSizer();\n\n\tif (this.forceVmlHandles)\n\t{\n\t\tthis.sizer.isHtmlAllowed = function()\n\t\t{\n\t\t\treturn false;\n\t\t};\n\t}\n\n\tthis.sizer.init(this.outline.getView().getOverlayPane());\n\n\tif (this.enabled)\n\t{\n\t\tthis.sizer.node.style.cursor = 'nwse-resize';\n\t}\n\n\tmxEvent.addGestureListeners(this.sizer.node, handler);\n\n\tthis.selectionBorder.node.style.display = (this.showViewport) ? '' : 'none';\n\tthis.sizer.node.style.display = this.selectionBorder.node.style.display;\n\tthis.selectionBorder.node.style.cursor = 'move';\n\n\tthis.update(false);\n};\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxOutline.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n *\n * Parameters:\n *\n * value - Boolean that specifies the new enabled state.\n */\nmxOutline.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: setZoomEnabled\n *\n * Enables or disables the zoom handling by showing or hiding the respective\n * handle.\n *\n * Parameters:\n *\n * value - Boolean that specifies the new enabled state.\n */\nmxOutline.prototype.setZoomEnabled = function(value)\n{\n\tthis.sizer.node.style.visibility = (value) ? 'visible' : 'hidden';\n};\n\n/**\n * Function: refresh\n *\n * Invokes <update> and revalidate the outline. This method is deprecated.\n */\nmxOutline.prototype.refresh = function()\n{\n\tthis.update(true);\n};\n\n/**\n * Function: createSizer\n *\n * Creates the shape used as the sizer.\n */\nmxOutline.prototype.createSizer = function()\n{\n\tif (this.sizerImage != null)\n\t{\n\t\tvar sizer = new mxImageShape(new mxRectangle(0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);\n\t\tsizer.dialect = this.outline.dialect;\n\n\t\treturn sizer;\n\t}\n\telse\n\t{\n\t\tvar sizer = new mxRectangleShape(new mxRectangle(0, 0, this.sizerSize, this.sizerSize),\n\t\t\tmxConstants.OUTLINE_HANDLE_FILLCOLOR, mxConstants.OUTLINE_HANDLE_STROKECOLOR);\n\t\tsizer.dialect = this.outline.dialect;\n\n\t\treturn sizer;\n\t}\n};\n\n/**\n * Function: getSourceContainerSize\n *\n * Returns the size of the source container.\n */\nmxOutline.prototype.getSourceContainerSize = function()\n{\n\treturn new mxRectangle(0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);\n};\n\n/**\n * Function: getOutlineOffset\n *\n * Returns the offset for drawing the outline graph.\n */\nmxOutline.prototype.getOutlineOffset = function(scale)\n{\n\treturn null;\n};\n\n/**\n * Function: getOutlineOffset\n *\n * Returns the offset for drawing the outline graph.\n */\nmxOutline.prototype.getSourceGraphBounds = function()\n{\n\treturn this.source.getGraphBounds();\n};\n\n/**\n * Function: update\n *\n * Updates the outline.\n */\nmxOutline.prototype.update = function(revalidate)\n{\n\tif (this.source != null && this.source.container != null &&\n\t\tthis.outline != null && this.outline.container != null)\n\t{\n\t\tvar sourceScale = this.source.view.scale;\n\t\tvar scaledGraphBounds = this.getSourceGraphBounds();\n\t\tvar unscaledGraphBounds = new mxRectangle(scaledGraphBounds.x / sourceScale + this.source.panDx,\n\t\t\t\tscaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale,\n\t\t\t\tscaledGraphBounds.height / sourceScale);\n\n\t\tvar unscaledFinderBounds = new mxRectangle(0, 0,\n\t\t\tthis.source.container.clientWidth / sourceScale,\n\t\t\tthis.source.container.clientHeight / sourceScale);\n\n\t\tvar union = unscaledGraphBounds.clone();\n\t\tunion.add(unscaledFinderBounds);\n\n\t\t// Zooms to the scrollable area if that is bigger than the graph\n\t\tvar size = this.getSourceContainerSize();\n\t\tvar completeWidth = Math.max(size.width / sourceScale, union.width);\n\t\tvar completeHeight = Math.max(size.height / sourceScale, union.height);\n\n\t\tvar availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);\n\t\tvar availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);\n\n\t\tvar outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);\n\t\tvar scale = (isNaN(outlineScale)) ? this.minScale : Math.max(this.minScale, outlineScale);\n\n\t\tif (scale > 0)\n\t\t{\n\t\t\tif (this.outline.getView().scale != scale)\n\t\t\t{\n\t\t\t\tthis.outline.getView().scale = scale;\n\t\t\t\trevalidate = true;\n\t\t\t}\n\n\t\t\tvar navView = this.outline.getView();\n\n\t\t\tif (navView.currentRoot != this.source.getView().currentRoot)\n\t\t\t{\n\t\t\t\tnavView.setCurrentRoot(this.source.getView().currentRoot);\n\t\t\t}\n\n\t\t\tvar t = this.source.view.translate;\n\t\t\tvar tx = t.x + this.source.panDx;\n\t\t\tvar ty = t.y + this.source.panDy;\n\n\t\t\tvar off = this.getOutlineOffset(scale);\n\n\t\t\tif (off != null)\n\t\t\t{\n\t\t\t\ttx += off.x;\n\t\t\t\tty += off.y;\n\t\t\t}\n\n\t\t\tif (unscaledGraphBounds.x < 0)\n\t\t\t{\n\t\t\t\ttx = tx - unscaledGraphBounds.x;\n\t\t\t}\n\t\t\tif (unscaledGraphBounds.y < 0)\n\t\t\t{\n\t\t\t\tty = ty - unscaledGraphBounds.y;\n\t\t\t}\n\n\t\t\tif (navView.translate.x != tx || navView.translate.y != ty)\n\t\t\t{\n\t\t\t\tnavView.translate.x = tx;\n\t\t\t\tnavView.translate.y = ty;\n\t\t\t\trevalidate = true;\n\t\t\t}\n\n\t\t\t// Prepares local variables for computations\n\t\t\tvar t2 = navView.translate;\n\t\t\tscale = this.source.getView().scale;\n\t\t\tvar scale2 = scale / navView.scale;\n\t\t\tvar scale3 = 1.0 / navView.scale;\n\t\t\tvar container = this.source.container;\n\n\t\t\t// Updates the bounds of the viewrect in the navigation\n\t\t\tthis.bounds = new mxRectangle(\n\t\t\t\t(t2.x - t.x - this.source.panDx) / scale3,\n\t\t\t\t(t2.y - t.y - this.source.panDy) / scale3,\n\t\t\t\t(container.clientWidth / scale2),\n\t\t\t\t(container.clientHeight / scale2));\n\n\t\t\t// Adds the scrollbar offset to the finder\n\t\t\tthis.bounds.x += this.source.container.scrollLeft * navView.scale / scale;\n\t\t\tthis.bounds.y += this.source.container.scrollTop * navView.scale / scale;\n\n\t\t\tvar b = this.selectionBorder.bounds;\n\n\t\t\tif (b.x != this.bounds.x || b.y != this.bounds.y || b.width != this.bounds.width || b.height != this.bounds.height)\n\t\t\t{\n\t\t\t\tthis.selectionBorder.bounds = this.bounds;\n\t\t\t\tthis.selectionBorder.redraw();\n\t\t\t}\n\n\t\t\t// Updates the bounds of the zoom handle at the bottom right\n\t\t\tvar b = this.sizer.bounds;\n\t\t\tvar b2 = new mxRectangle(this.bounds.x + this.bounds.width - b.width / 2,\n\t\t\t\t\tthis.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);\n\n\t\t\tif (b.x != b2.x || b.y != b2.y || b.width != b2.width || b.height != b2.height)\n\t\t\t{\n\t\t\t\tthis.sizer.bounds = b2;\n\n\t\t\t\t// Avoids update of visibility in redraw for VML\n\t\t\t\tif (this.sizer.node.style.visibility != 'hidden')\n\t\t\t\t{\n\t\t\t\t\tthis.sizer.redraw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (revalidate)\n\t\t\t{\n\t\t\t\tthis.outline.view.revalidate();\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by starting a translation or zoom.\n */\nmxOutline.prototype.mouseDown = function(sender, me)\n{\n\tif (this.enabled && this.showViewport)\n\t{\n\t\tvar tol = (!mxEvent.isMouseEvent(me.getEvent())) ? this.source.tolerance : 0;\n\t\tvar hit = (this.source.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0)) ?\n\t\t\t\tnew mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n\t\tthis.zoom = me.isSource(this.sizer) || (hit != null && mxUtils.intersects(shape.bounds, hit));\n\t\tthis.startX = me.getX();\n\t\tthis.startY = me.getY();\n\t\tthis.active = true;\n\n\t\tif (this.source.useScrollbarsForPanning && mxUtils.hasScrollbars(this.source.container))\n\t\t{\n\t\t\tthis.dx0 = this.source.container.scrollLeft;\n\t\t\tthis.dy0 = this.source.container.scrollTop;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.dx0 = 0;\n\t\t\tthis.dy0 = 0;\n\t\t}\n\t}\n\n\tme.consume();\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by previewing the viewrect in <graph> and updating the\n * rectangle that represents the viewrect in the outline.\n */\nmxOutline.prototype.mouseMove = function(sender, me)\n{\n\tif (this.active)\n\t{\n\t\tthis.selectionBorder.node.style.display = (this.showViewport) ? '' : 'none';\n\t\tthis.sizer.node.style.display = this.selectionBorder.node.style.display;\n\n\t\tvar delta = this.getTranslateForEvent(me);\n\t\tvar dx = delta.x;\n\t\tvar dy = delta.y;\n\t\tvar bounds = null;\n\n\t\tif (!this.zoom)\n\t\t{\n\t\t\t// Previews the panning on the source graph\n\t\t\tvar scale = this.outline.getView().scale;\n\t\t\tbounds = new mxRectangle(this.bounds.x + dx,\n\t\t\t\tthis.bounds.y + dy, this.bounds.width, this.bounds.height);\n\t\t\tthis.selectionBorder.bounds = bounds;\n\t\t\tthis.selectionBorder.redraw();\n\t\t\tdx /= scale;\n\t\t\tdx *= this.source.getView().scale;\n\t\t\tdy /= scale;\n\t\t\tdy *= this.source.getView().scale;\n\t\t\tthis.source.panGraph(-dx - this.dx0, -dy - this.dy0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Does *not* preview zooming on the source graph\n\t\t\tvar container = this.source.container;\n\t\t\tvar viewRatio = container.clientWidth / container.clientHeight;\n\t\t\tdy = dx / viewRatio;\n\t\t\tbounds = new mxRectangle(this.bounds.x,\n\t\t\t\tthis.bounds.y,\n\t\t\t\tMath.max(1, this.bounds.width + dx),\n\t\t\t\tMath.max(1, this.bounds.height + dy));\n\t\t\tthis.selectionBorder.bounds = bounds;\n\t\t\tthis.selectionBorder.redraw();\n\t\t}\n\n\t\t// Updates the zoom handle\n\t\tvar b = this.sizer.bounds;\n\t\tthis.sizer.bounds = new mxRectangle(\n\t\t\tbounds.x + bounds.width - b.width / 2,\n\t\t\tbounds.y + bounds.height - b.height / 2,\n\t\t\tb.width, b.height);\n\n\t\t// Avoids update of visibility in redraw for VML\n\t\tif (this.sizer.node.style.visibility != 'hidden')\n\t\t{\n\t\t\tthis.sizer.redraw();\n\t\t}\n\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: getTranslateForEvent\n *\n * Gets the translate for the given mouse event. Here is an example to limit\n * the outline to stay within positive coordinates:\n *\n * (code)\n * outline.getTranslateForEvent = function(me)\n * {\n *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\n *\n *   if (!this.zoom)\n *   {\n *     var tr = this.source.view.translate;\n *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);\n *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);\n *   }\n *\n *   return pt;\n * };\n * (end)\n */\nmxOutline.prototype.getTranslateForEvent = function(me)\n{\n\treturn new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by applying the translation or zoom to <graph>.\n */\nmxOutline.prototype.mouseUp = function(sender, me)\n{\n\tif (this.active)\n\t{\n\t\tvar delta = this.getTranslateForEvent(me);\n\t\tvar dx = delta.x;\n\t\tvar dy = delta.y;\n\n\t\tif (Math.abs(dx) > 0 || Math.abs(dy) > 0)\n\t\t{\n\t\t\tif (!this.zoom)\n\t\t\t{\n\t\t\t\t// Applies the new translation if the source\n\t\t\t\t// has no scrollbars\n\t\t\t\tif (!this.source.useScrollbarsForPanning ||\n\t\t\t\t\t!mxUtils.hasScrollbars(this.source.container))\n\t\t\t\t{\n\t\t\t\t\tthis.source.panGraph(0, 0);\n\t\t\t\t\tdx /= this.outline.getView().scale;\n\t\t\t\t\tdy /= this.outline.getView().scale;\n\t\t\t\t\tvar t = this.source.getView().translate;\n\t\t\t\t\tthis.source.getView().setTranslate(t.x - dx, t.y - dy);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Applies the new zoom\n\t\t\t\tvar w = this.selectionBorder.bounds.width;\n\t\t\t\tvar scale = this.source.getView().scale;\n\t\t\t\tthis.source.zoomTo(Math.max(this.minScale, scale - (dx * scale) / w), false);\n\t\t\t}\n\n\t\t\tthis.update();\n\t\t\tme.consume();\n\t\t}\n\n\t\t// Resets the state of the handler\n\t\tthis.index = null;\n\t\tthis.active = false;\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroy this outline and removes all listeners from <source>.\n */\nmxOutline.prototype.destroy = function()\n{\n\tif (this.source != null)\n\t{\n\t\tthis.source.removeListener(this.panHandler);\n\t\tthis.source.removeListener(this.refreshHandler);\n\t\tthis.source.getModel().removeListener(this.updateHandler);\n\t\tthis.source.getView().removeListener(this.updateHandler);\n\t\tmxEvent.removeListener(this.source.container, 'scroll', this.updateHandler);\n\t\tthis.source = null;\n\t}\n\n\tif (this.outline != null)\n\t{\n\t\tthis.outline.removeMouseListener(this);\n\t\tthis.outline.destroy();\n\t\tthis.outline = null;\n\t}\n\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.destroy();\n\t\tthis.selectionBorder = null;\n\t}\n\n\tif (this.sizer != null)\n\t{\n\t\tthis.sizer.destroy();\n\t\tthis.sizer = null;\n\t}\n};\n\n__mxOutput.mxOutline = typeof mxOutline !== 'undefined' ? mxOutline : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxMultiplicity\n *\n * Defines invalid connections along with the error messages that they produce.\n * To add or remove rules on a graph, you must add/remove instances of this\n * class to <mxGraph.multiplicities>.\n *\n * Example:\n *\n * (code)\n * graph.multiplicities.push(new mxMultiplicity(\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\n *   'Only 2 targets allowed',\n *   'Only circle targets allowed'));\n * (end)\n *\n * Defines a rule where each rectangle must be connected to no more than 2\n * circles and no other types of targets are allowed.\n *\n * Constructor: mxMultiplicity\n *\n * Instantiate class mxMultiplicity in order to describe allowed\n * connections in a graph. Not all constraints can be enforced while\n * editing, some must be checked at validation time. The <countError> and\n * <typeError> are treated as resource keys in <mxResources>.\n *\n * Parameters:\n *\n * source - Boolean indicating if this rule applies to the source or target\n * terminal.\n * type - Type of the source or target terminal that this rule applies to.\n * See <type> for more information.\n * attr - Optional attribute name to match the source or target terminal.\n * value - Optional attribute value to match the source or target terminal.\n * min - Minimum number of edges for this rule. Default is 1.\n * max - Maximum number of edges for this rule. n means infinite. Default\n * is n.\n * validNeighbors - Array of types of the opposite terminal for which this\n * rule applies.\n * countError - Error to be displayed for invalid number of edges.\n * typeError - Error to be displayed for invalid opposite terminals.\n * validNeighborsAllowed - Optional boolean indicating if the array of\n * opposite types should be valid or invalid.\n */\nfunction mxMultiplicity(source, type, attr, value, min, max,\n\tvalidNeighbors, countError, typeError, validNeighborsAllowed)\n{\n\tthis.source = source;\n\tthis.type = type;\n\tthis.attr = attr;\n\tthis.value = value;\n\tthis.min = (min != null) ? min : 0;\n\tthis.max = (max != null) ? max : 'n';\n\tthis.validNeighbors = validNeighbors;\n\tthis.countError = mxResources.get(countError) || countError;\n\tthis.typeError = mxResources.get(typeError) || typeError;\n\tthis.validNeighborsAllowed = (validNeighborsAllowed != null) ?\n\t\tvalidNeighborsAllowed : true;\n};\n\n/**\n * Variable: type\n *\n * Defines the type of the source or target terminal. The type is a string\n * passed to <mxUtils.isNode> together with the source or target vertex\n * value as the first argument.\n */\nmxMultiplicity.prototype.type = null;\n\n/**\n * Variable: attr\n *\n * Optional string that specifies the attributename to be passed to\n * <mxUtils.isNode> to check if the rule applies to a cell.\n */\nmxMultiplicity.prototype.attr = null;\n\n/**\n * Variable: value\n *\n * Optional string that specifies the value of the attribute to be passed\n * to <mxUtils.isNode> to check if the rule applies to a cell.\n */\nmxMultiplicity.prototype.value = null;\n\n/**\n * Variable: source\n *\n * Boolean that specifies if the rule is applied to the source or target\n * terminal of an edge.\n */\nmxMultiplicity.prototype.source = null;\n\n/**\n * Variable: min\n *\n * Defines the minimum number of connections for which this rule applies.\n * Default is 0.\n */\nmxMultiplicity.prototype.min = null;\n\n/**\n * Variable: max\n *\n * Defines the maximum number of connections for which this rule applies.\n * A value of 'n' means unlimited times. Default is 'n'.\n */\nmxMultiplicity.prototype.max = null;\n\n/**\n * Variable: validNeighbors\n *\n * Holds an array of strings that specify the type of neighbor for which\n * this rule applies. The strings are used in <mxCell.is> on the opposite\n * terminal to check if the rule applies to the connection.\n */\nmxMultiplicity.prototype.validNeighbors = null;\n\n/**\n * Variable: validNeighborsAllowed\n *\n * Boolean indicating if the list of validNeighbors are those that are allowed\n * for this rule or those that are not allowed for this rule.\n */\nmxMultiplicity.prototype.validNeighborsAllowed = true;\n\n/**\n * Variable: countError\n *\n * Holds the localized error message to be displayed if the number of\n * connections for which the rule applies is smaller than <min> or greater\n * than <max>.\n */\nmxMultiplicity.prototype.countError = null;\n\n/**\n * Variable: typeError\n *\n * Holds the localized error message to be displayed if the type of the\n * neighbor for a connection does not match the rule.\n */\nmxMultiplicity.prototype.typeError = null;\n\n/**\n * Function: check\n *\n * Checks the multiplicity for the given arguments and returns the error\n * for the given connection or null if the multiplicity does not apply.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph> instance.\n * edge - <mxCell> that represents the edge to validate.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * sourceOut - Number of outgoing edges from the source terminal.\n * targetIn - Number of incoming edges for the target terminal.\n */\nmxMultiplicity.prototype.check = function(graph, edge, source, target, sourceOut, targetIn)\n{\n\tvar error = '';\n\n\tif ((this.source && this.checkTerminal(graph, source, edge)) ||\n\t\t(!this.source && this.checkTerminal(graph, target, edge)))\n\t{\n\t\tif (this.countError != null &&\n\t\t\t((this.source && (this.max == 0 || (sourceOut >= this.max))) ||\n\t\t\t(!this.source && (this.max == 0 || (targetIn >= this.max)))))\n\t\t{\n\t\t\terror += this.countError + '\\n';\n\t\t}\n\n\t\tif (this.validNeighbors != null && this.typeError != null && this.validNeighbors.length > 0)\n\t\t{\n\t\t\tvar isValid = this.checkNeighbors(graph, edge, source, target);\n\n\t\t\tif (!isValid)\n\t\t\t{\n\t\t\t\terror += this.typeError + '\\n';\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (error.length > 0) ? error : null;\n};\n\n/**\n * Function: checkNeighbors\n *\n * Checks if there are any valid neighbours in <validNeighbors>. This is only\n * called if <validNeighbors> is a non-empty array.\n */\nmxMultiplicity.prototype.checkNeighbors = function(graph, edge, source, target)\n{\n\tvar sourceValue = graph.model.getValue(source);\n\tvar targetValue = graph.model.getValue(target);\n\tvar isValid = !this.validNeighborsAllowed;\n\tvar valid = this.validNeighbors;\n\n\tfor (var j = 0; j < valid.length; j++)\n\t{\n\t\tif (this.source &&\n\t\t\tthis.checkType(graph, targetValue, valid[j]))\n\t\t{\n\t\t\tisValid = this.validNeighborsAllowed;\n\t\t\tbreak;\n\t\t}\n\t\telse if (!this.source &&\n\t\t\tthis.checkType(graph, sourceValue, valid[j]))\n\t\t{\n\t\t\tisValid = this.validNeighborsAllowed;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn isValid;\n};\n\n/**\n * Function: checkTerminal\n *\n * Checks the given terminal cell and returns true if this rule applies. The\n * given cell is the source or target of the given edge, depending on\n * <source>. This implementation uses <checkType> on the terminal's value.\n */\nmxMultiplicity.prototype.checkTerminal = function(graph, terminal, edge)\n{\n\tvar value = graph.model.getValue(terminal);\n\n\treturn this.checkType(graph, value, this.type, this.attr, this.value);\n};\n\n/**\n * Function: checkType\n *\n * Checks the type of the given value.\n */\nmxMultiplicity.prototype.checkType = function(graph, value, type, attr, attrValue)\n{\n\tif (value != null)\n\t{\n\t\tif (!isNaN(value.nodeType)) // Checks if value is a DOM node\n\t\t{\n\t\t\treturn mxUtils.isNode(value, type, attr, attrValue);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn value == type;\n\t\t}\n\t}\n\n\treturn false;\n};\n\n__mxOutput.mxMultiplicity = typeof mxMultiplicity !== 'undefined' ? mxMultiplicity : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxLayoutManager\n *\n * Implements a layout manager that runs a given layout after any changes to the graph:\n *\n * Example:\n *\n * (code)\n * var layoutMgr = new mxLayoutManager(graph);\n * layoutMgr.getLayout = function(cell)\n * {\n *   return layout;\n * };\n * (end)\n *\n * Event: mxEvent.LAYOUT_CELLS\n *\n * Fires between begin- and endUpdate after all cells have been layouted in\n * <layoutCells>. The <code>cells</code> property contains all cells that have\n * been passed to <layoutCells>.\n *\n * Constructor: mxLayoutManager\n *\n * Constructs a new automatic layout for the given graph.\n *\n * Arguments:\n *\n * graph - Reference to the enclosing graph.\n */\nfunction mxLayoutManager(graph)\n{\n\t// Executes the layout before the changes are dispatched\n\tthis.undoHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.beforeUndo(evt.getProperty('edit'));\n\t\t}\n\t});\n\n\t// Notifies the layout of a move operation inside a parent\n\tthis.moveHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.cellsMoved(evt.getProperty('cells'), evt.getProperty('event'));\n\t\t}\n\t});\n\n\tthis.setGraph(graph);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxLayoutManager.prototype = new mxEventSource();\nmxLayoutManager.prototype.constructor = mxLayoutManager;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxLayoutManager.prototype.graph = null;\n\n/**\n * Variable: bubbling\n *\n * Specifies if the layout should bubble along\n * the cell hierarchy. Default is true.\n */\nmxLayoutManager.prototype.bubbling = true;\n\n/**\n * Variable: enabled\n *\n * Specifies if event handling is enabled. Default is true.\n */\nmxLayoutManager.prototype.enabled = true;\n\n/**\n * Variable: updateHandler\n *\n * Holds the function that handles the endUpdate event.\n */\nmxLayoutManager.prototype.updateHandler = null;\n\n/**\n * Variable: moveHandler\n *\n * Holds the function that handles the move event.\n */\nmxLayoutManager.prototype.moveHandler = null;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxLayoutManager.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n *\n * Parameters:\n *\n * enabled - Boolean that specifies the new enabled state.\n */\nmxLayoutManager.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isBubbling\n *\n * Returns true if a layout should bubble, that is, if the parent layout\n * should be executed whenever a cell layout (layout of the children of\n * a cell) has been executed. This implementation returns <bubbling>.\n */\nmxLayoutManager.prototype.isBubbling = function()\n{\n\treturn this.bubbling;\n};\n\n/**\n * Function: setBubbling\n *\n * Sets <bubbling>.\n */\nmxLayoutManager.prototype.setBubbling = function(value)\n{\n\tthis.bubbling = value;\n};\n\n/**\n * Function: getGraph\n *\n * Returns the graph that this layout operates on.\n */\nmxLayoutManager.prototype.getGraph = function()\n{\n\treturn this.graph;\n};\n\n/**\n * Function: setGraph\n *\n * Sets the graph that the layouts operate on.\n */\nmxLayoutManager.prototype.setGraph = function(graph)\n{\n\tif (this.graph != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\tmodel.removeListener(this.undoHandler);\n\t\tthis.graph.removeListener(this.moveHandler);\n\t}\n\n\tthis.graph = graph;\n\n\tif (this.graph != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\tmodel.addListener(mxEvent.BEFORE_UNDO, this.undoHandler);\n\t\tthis.graph.addListener(mxEvent.MOVE_CELLS, this.moveHandler);\n\t}\n};\n\n/**\n * Function: getLayout\n *\n * Returns the layout to be executed for the given graph and parent.\n */\nmxLayoutManager.prototype.getLayout = function(parent)\n{\n\treturn null;\n};\n\n/**\n * Function: beforeUndo\n *\n * Called from the undoHandler.\n *\n * Parameters:\n *\n * cell - Array of <mxCells> that have been moved.\n * evt - Mouse event that represents the mousedown.\n */\nmxLayoutManager.prototype.beforeUndo = function(undoableEdit)\n{\n\tvar cells = this.getCellsForChanges(undoableEdit.changes);\n\tvar model = this.getGraph().getModel();\n\n\t// Adds all descendants\n\tvar tmp = [];\n\n\tfor (var i = 0; i < cells.length; i++)\n\t{\n\t\ttmp = tmp.concat(model.getDescendants(cells[i]));\n\t}\n\n\tcells = tmp;\n\n\t// Adds all parent ancestors\n\tif (this.isBubbling())\n\t{\n\t\ttmp = model.getParents(cells);\n\n\t\twhile (tmp.length > 0)\n\t\t{\n\t\t\tcells = cells.concat(tmp);\n\t\t\ttmp = model.getParents(tmp);\n\t\t}\n\t}\n\n\tthis.executeLayoutForCells(cells);\n};\n\n/**\n * Function: executeLayout\n *\n * Executes the given layout on the given parent.\n */\nmxLayoutManager.prototype.executeLayoutForCells = function(cells)\n{\n\t// Adds reverse to this array to avoid duplicate execution of leafes\n\t// Works like capture/bubble for events, first executes all layout\n\t// from top to bottom and in reverse order and removes duplicates.\n\tvar sorted = mxUtils.sortCells(cells, true);\n\tsorted = sorted.concat(sorted.slice().reverse());\n\tthis.layoutCells(sorted);\n};\n\n/**\n * Function: cellsMoved\n *\n * Called from the moveHandler.\n *\n * Parameters:\n *\n * cell - Array of <mxCells> that have been moved.\n * evt - Mouse event that represents the mousedown.\n */\nmxLayoutManager.prototype.cellsMoved = function(cells, evt)\n{\n\tif (cells != null && evt != null)\n\t{\n\t\tvar point = mxUtils.convertPoint(this.getGraph().container,\n\t\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\tvar model = this.getGraph().getModel();\n\n\t\t// Checks if a layout exists to take care of the moving if the\n\t\t// parent itself is not being moved\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar parent = model.getParent(cells[i]);\n\n\t\t\tif (mxUtils.indexOf(cells, parent) < 0)\n\t\t\t{\n\t\t\t\tvar layout = this.getLayout(parent);\n\n\t\t\t\tif (layout != null)\n\t\t\t\t{\n\t\t\t\t\tlayout.moveCell(cells[i], point.x, point.y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: getCellsForEdit\n *\n * Returns the cells to be layouted for the given sequence of changes.\n */\nmxLayoutManager.prototype.getCellsForChanges = function(changes)\n{\n\tvar dict = new mxDictionary();\n\tvar result = [];\n\n\tfor (var i = 0; i < changes.length; i++)\n\t{\n\t\tvar change = changes[i];\n\n\t\tif (change instanceof mxRootChange)\n\t\t{\n\t\t\treturn [];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar cells = this.getCellsForChange(change);\n\n\t\t\tfor (var j = 0; j < cells.length; j++)\n\t\t\t{\n\t\t\t\tif (cells[j] != null && !dict.get(cells[j]))\n\t\t\t\t{\n\t\t\t\t\tdict.put(cells[j], true);\n\t\t\t\t\tresult.push(cells[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getCellsForChange\n *\n * Executes all layouts which have been scheduled during the\n * changes.\n */\nmxLayoutManager.prototype.getCellsForChange = function(change)\n{\n\tvar model = this.getGraph().getModel();\n\n\tif (change instanceof mxChildChange)\n\t{\n\t\treturn [change.child, change.previous, model.getParent(change.child)];\n\t}\n\telse if (change instanceof mxTerminalChange || change instanceof mxGeometryChange)\n\t{\n\t\treturn [change.cell, model.getParent(change.cell)];\n\t}\n\telse if (change instanceof mxVisibleChange || change instanceof mxStyleChange)\n\t{\n\t\treturn [change.cell];\n\t}\n\n\treturn [];\n};\n\n/**\n * Function: layoutCells\n *\n * Executes all layouts which have been scheduled during the\n * changes.\n */\nmxLayoutManager.prototype.layoutCells = function(cells)\n{\n\tif (cells.length > 0)\n\t{\n\t\t// Invokes the layouts while removing duplicates\n\t\tvar model = this.getGraph().getModel();\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar last = null;\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (cells[i] != model.getRoot() && cells[i] != last)\n\t\t\t\t{\n\t\t\t\t\tif (this.executeLayout(this.getLayout(cells[i]), cells[i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tlast = cells[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.LAYOUT_CELLS, 'cells', cells));\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: executeLayout\n *\n * Executes the given layout on the given parent.\n */\nmxLayoutManager.prototype.executeLayout = function(layout, parent)\n{\n\tvar result = false;\n\n\tif (layout != null && parent != null)\n\t{\n\t\tlayout.execute(parent);\n\t\tresult = true;\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: destroy\n *\n * Removes all handlers from the <graph> and deletes the reference to it.\n */\nmxLayoutManager.prototype.destroy = function()\n{\n\tthis.setGraph(null);\n};\n\n__mxOutput.mxLayoutManager = typeof mxLayoutManager !== 'undefined' ? mxLayoutManager : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSwimlaneManager\n *\n * Manager for swimlanes and nested swimlanes that sets the size of newly added\n * swimlanes to that of their siblings, and propagates changes to the size of a\n * swimlane to its siblings, if <siblings> is true, and its ancestors, if\n * <bubbling> is true.\n *\n * Constructor: mxSwimlaneManager\n *\n * Constructs a new swimlane manager for the given graph.\n *\n * Arguments:\n *\n * graph - Reference to the enclosing graph.\n */\nfunction mxSwimlaneManager(graph, horizontal, addEnabled, resizeEnabled)\n{\n\tthis.horizontal = (horizontal != null) ? horizontal : true;\n\tthis.addEnabled = (addEnabled != null) ? addEnabled : true;\n\tthis.resizeEnabled = (resizeEnabled != null) ? resizeEnabled : true;\n\n\tthis.addHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled() && this.isAddEnabled())\n\t\t{\n\t\t\tthis.cellsAdded(evt.getProperty('cells'));\n\t\t}\n\t});\n\n\tthis.resizeHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled() && this.isResizeEnabled())\n\t\t{\n\t\t\tthis.cellsResized(evt.getProperty('cells'));\n\t\t}\n\t});\n\n\tthis.setGraph(graph);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxSwimlaneManager.prototype = new mxEventSource();\nmxSwimlaneManager.prototype.constructor = mxSwimlaneManager;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxSwimlaneManager.prototype.graph = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if event handling is enabled. Default is true.\n */\nmxSwimlaneManager.prototype.enabled = true;\n\n/**\n * Variable: horizontal\n *\n * Specifies the orientation of the swimlanes. Default is true.\n */\nmxSwimlaneManager.prototype.horizontal = true;\n\n/**\n * Variable: addEnabled\n *\n * Specifies if newly added cells should be resized to match the size of their\n * existing siblings. Default is true.\n */\nmxSwimlaneManager.prototype.addEnabled = true;\n\n/**\n * Variable: resizeEnabled\n *\n * Specifies if resizing of swimlanes should be handled. Default is true.\n */\nmxSwimlaneManager.prototype.resizeEnabled = true;\n\n/**\n * Variable: moveHandler\n *\n * Holds the function that handles the move event.\n */\nmxSwimlaneManager.prototype.addHandler = null;\n\n/**\n * Variable: moveHandler\n *\n * Holds the function that handles the move event.\n */\nmxSwimlaneManager.prototype.resizeHandler = null;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxSwimlaneManager.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n *\n * Parameters:\n *\n * enabled - Boolean that specifies the new enabled state.\n */\nmxSwimlaneManager.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isHorizontal\n *\n * Returns <horizontal>.\n */\nmxSwimlaneManager.prototype.isHorizontal = function()\n{\n\treturn this.horizontal;\n};\n\n/**\n * Function: setHorizontal\n *\n * Sets <horizontal>.\n */\nmxSwimlaneManager.prototype.setHorizontal = function(value)\n{\n\tthis.horizontal = value;\n};\n\n/**\n * Function: isAddEnabled\n *\n * Returns <addEnabled>.\n */\nmxSwimlaneManager.prototype.isAddEnabled = function()\n{\n\treturn this.addEnabled;\n};\n\n/**\n * Function: setAddEnabled\n *\n * Sets <addEnabled>.\n */\nmxSwimlaneManager.prototype.setAddEnabled = function(value)\n{\n\tthis.addEnabled = value;\n};\n\n/**\n * Function: isResizeEnabled\n *\n * Returns <resizeEnabled>.\n */\nmxSwimlaneManager.prototype.isResizeEnabled = function()\n{\n\treturn this.resizeEnabled;\n};\n\n/**\n * Function: setResizeEnabled\n *\n * Sets <resizeEnabled>.\n */\nmxSwimlaneManager.prototype.setResizeEnabled = function(value)\n{\n\tthis.resizeEnabled = value;\n};\n\n/**\n * Function: getGraph\n *\n * Returns the graph that this manager operates on.\n */\nmxSwimlaneManager.prototype.getGraph = function()\n{\n\treturn this.graph;\n};\n\n/**\n * Function: setGraph\n *\n * Sets the graph that the manager operates on.\n */\nmxSwimlaneManager.prototype.setGraph = function(graph)\n{\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.removeListener(this.addHandler);\n\t\tthis.graph.removeListener(this.resizeHandler);\n\t}\n\n\tthis.graph = graph;\n\n\tif (this.graph != null)\n\t{\n\t\tthis.graph.addListener(mxEvent.ADD_CELLS, this.addHandler);\n\t\tthis.graph.addListener(mxEvent.CELLS_RESIZED, this.resizeHandler);\n\t}\n};\n\n/**\n * Function: isSwimlaneIgnored\n *\n * Returns true if the given swimlane should be ignored.\n */\nmxSwimlaneManager.prototype.isSwimlaneIgnored = function(swimlane)\n{\n\treturn !this.getGraph().isSwimlane(swimlane);\n};\n\n/**\n * Function: isCellHorizontal\n *\n * Returns true if the given cell is horizontal. If the given cell is not a\n * swimlane, then the global orientation is returned.\n */\nmxSwimlaneManager.prototype.isCellHorizontal = function(cell)\n{\n\tif (this.graph.isSwimlane(cell))\n\t{\n\t\tvar style = this.graph.getCellStyle(cell);\n\n\t\treturn mxUtils.getValue(style, mxConstants.STYLE_HORIZONTAL, 1) == 1;\n\t}\n\n\treturn !this.isHorizontal();\n};\n\n/**\n * Function: cellsAdded\n *\n * Called if any cells have been added.\n *\n * Parameters:\n *\n * cell - Array of <mxCells> that have been added.\n */\nmxSwimlaneManager.prototype.cellsAdded = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar model = this.getGraph().getModel();\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (!this.isSwimlaneIgnored(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tthis.swimlaneAdded(cells[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: swimlaneAdded\n *\n * Updates the size of the given swimlane to match that of any existing\n * siblings swimlanes.\n *\n * Parameters:\n *\n * swimlane - <mxCell> that represents the new swimlane.\n */\nmxSwimlaneManager.prototype.swimlaneAdded = function(swimlane)\n{\n\tvar model = this.getGraph().getModel();\n\tvar parent = model.getParent(swimlane);\n\tvar childCount = model.getChildCount(parent);\n\tvar geo = null;\n\n\t// Finds the first valid sibling swimlane as reference\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(parent, i);\n\n\t\tif (child != swimlane && !this.isSwimlaneIgnored(child))\n\t\t{\n\t\t\tgeo = model.getGeometry(child);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Applies the size of the refernece to the newly added swimlane\n\tif (geo != null)\n\t{\n\t\tvar parentHorizontal = (parent != null) ? this.isCellHorizontal(parent) : this.horizontal;\n\t\tthis.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);\n\t}\n};\n\n/**\n * Function: cellsResized\n *\n * Called if any cells have been resizes. Calls <swimlaneResized> for all\n * swimlanes where <isSwimlaneIgnored> returns false.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose size was changed.\n */\nmxSwimlaneManager.prototype.cellsResized = function(cells)\n{\n\tif (cells != null)\n\t{\n\t\tvar model = this.getGraph().getModel();\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\t// Finds the top-level swimlanes and adds offsets\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tif (!this.isSwimlaneIgnored(cells[i]))\n\t\t\t\t{\n\t\t\t\t\tvar geo = model.getGeometry(cells[i]);\n\n\t\t\t\t\tif (geo != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar size = new mxRectangle(0, 0, geo.width, geo.height);\n\t\t\t\t\t\tvar top = cells[i];\n\t\t\t\t\t\tvar current = top;\n\n\t\t\t\t\t\twhile (current != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttop = current;\n\t\t\t\t\t\t\tcurrent = model.getParent(current);\n\t\t\t\t\t\t\tvar tmp = (this.graph.isSwimlane(current)) ?\n\t\t\t\t\t\t\t\t\tthis.graph.getStartSize(current) :\n\t\t\t\t\t\t\t\t\tnew mxRectangle();\n\t\t\t\t\t\t\tsize.width += tmp.width;\n\t\t\t\t\t\t\tsize.height += tmp.height;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar parentHorizontal = (current != null) ? this.isCellHorizontal(current) : this.horizontal;\n\t\t\t\t\t\tthis.resizeSwimlane(top, size.width, size.height, parentHorizontal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\t}\n};\n\n/**\n * Function: resizeSwimlane\n *\n * Called from <cellsResized> for all swimlanes that are not ignored to update\n * the size of the siblings and the size of the parent swimlanes, recursively,\n * if <bubbling> is true.\n *\n * Parameters:\n *\n * swimlane - <mxCell> whose size has changed.\n */\nmxSwimlaneManager.prototype.resizeSwimlane = function(swimlane, w, h, parentHorizontal)\n{\n\tvar model = this.getGraph().getModel();\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tvar horizontal = this.isCellHorizontal(swimlane);\n\n\t\tif (!this.isSwimlaneIgnored(swimlane))\n\t\t{\n\t\t\tvar geo = model.getGeometry(swimlane);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tif ((parentHorizontal && geo.height != h) || (!parentHorizontal && geo.width != w))\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\tif (parentHorizontal)\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.height = h;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgeo.width = w;\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel.setGeometry(swimlane, geo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar tmp = (this.graph.isSwimlane(swimlane)) ?\n\t\t\t\tthis.graph.getStartSize(swimlane) :\n\t\t\t\tnew mxRectangle();\n\t\tw -= tmp.width;\n\t\th -= tmp.height;\n\n\t\tvar childCount = model.getChildCount(swimlane);\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tvar child = model.getChildAt(swimlane, i);\n\t\t\tthis.resizeSwimlane(child, w, h, horizontal);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Removes all handlers from the <graph> and deletes the reference to it.\n */\nmxSwimlaneManager.prototype.destroy = function()\n{\n\tthis.setGraph(null);\n};\n\n__mxOutput.mxSwimlaneManager = typeof mxSwimlaneManager !== 'undefined' ? mxSwimlaneManager : undefined;\n\n/**\n * Copyright (c) 2006-2017, JGraph Ltd\n * Copyright (c) 2006-2017, Gaudenz Alder\n */\n/**\n * Class: mxTemporaryCellStates\n *\n * Creates a temporary set of cell states.\n */\nfunction mxTemporaryCellStates(view, scale, cells, isCellVisibleFn, getLinkForCellState)\n{\n\tscale = (scale != null) ? scale : 1;\n\tthis.view = view;\n\n\t// Stores the previous state\n\tthis.oldValidateCellState = view.validateCellState;\n\tthis.oldBounds = view.getGraphBounds();\n\tthis.oldStates = view.getStates();\n\tthis.oldScale = view.getScale();\n\tthis.oldDoRedrawShape = view.graph.cellRenderer.doRedrawShape;\n\n\tvar self = this;\n\n\t// Overrides doRedrawShape and paint shape to add links on shapes\n\tif (getLinkForCellState != null)\n\t{\n\t\tview.graph.cellRenderer.doRedrawShape = function(state)\n\t\t{\n\t\t\tvar oldPaint = state.shape.paint;\n\n\t\t\tstate.shape.paint = function(c)\n\t\t\t{\n\t\t\t\tvar link = getLinkForCellState(state);\n\n\t\t\t\tif (link != null)\n\t\t\t\t{\n\t\t\t\t\tc.setLink(link);\n\t\t\t\t}\n\n\t\t\t\toldPaint.apply(this, arguments);\n\n\t\t\t\tif (link != null)\n\t\t\t\t{\n\t\t\t\t\tc.setLink(null);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tself.oldDoRedrawShape.apply(view.graph.cellRenderer, arguments);\n\t\t\tstate.shape.paint = oldPaint;\n\t\t};\n\t}\n\n\t// Overrides validateCellState to ignore invisible cells\n\tview.validateCellState = function(cell, resurse)\n\t{\n\t\tif (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell))\n\t\t{\n\t\t\treturn self.oldValidateCellState.apply(view, arguments);\n\t\t}\n\n\t\treturn null;\n\t};\n\n\t// Creates space for new states\n\tview.setStates(new mxDictionary());\n\tview.setScale(scale);\n\n\tif (cells != null)\n\t{\n\t\tview.resetValidationState();\n\t\tvar bbox = null;\n\n\t\t// Validates the vertices and edges without adding them to\n\t\t// the model so that the original cells are not modified\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tvar bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cells[i])));\n\n\t\t\tif (bbox == null)\n\t\t\t{\n\t\t\t\tbbox = bounds;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbbox.add(bounds);\n\t\t\t}\n\t\t}\n\n\t\tview.setGraphBounds(bbox || new mxRectangle());\n\t}\n};\n\n/**\n * Variable: view\n *\n * Holds the width of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.view = null;\n\n/**\n * Variable: oldStates\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.oldStates = null;\n\n/**\n * Variable: oldBounds\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.oldBounds = null;\n\n/**\n * Variable: oldScale\n *\n * Holds the height of the rectangle. Default is 0.\n */\nmxTemporaryCellStates.prototype.oldScale = null;\n\n/**\n * Function: destroy\n *\n * Returns the top, left corner as a new <mxPoint>.\n */\nmxTemporaryCellStates.prototype.destroy = function()\n{\n\tthis.view.setScale(this.oldScale);\n\tthis.view.setStates(this.oldStates);\n\tthis.view.setGraphBounds(this.oldBounds);\n\tthis.view.validateCellState = this.oldValidateCellState;\n\tthis.view.graph.cellRenderer.doRedrawShape = this.oldDoRedrawShape;\n};\n\n__mxOutput.mxTemporaryCellStates = typeof mxTemporaryCellStates !== 'undefined' ? mxTemporaryCellStates : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n *\n * Class: mxCellStatePreview\n *\n * Implements a live preview for moving cells.\n *\n * Constructor: mxCellStatePreview\n *\n * Constructs a move preview for the given graph.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxCellStatePreview(graph)\n{\n\tthis.deltas = new mxDictionary();\n\tthis.graph = graph;\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxCellStatePreview.prototype.graph = null;\n\n/**\n * Variable: deltas\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxCellStatePreview.prototype.deltas = null;\n\n/**\n * Variable: count\n *\n * Contains the number of entries in the map.\n */\nmxCellStatePreview.prototype.count = 0;\n\n/**\n * Function: isEmpty\n *\n * Returns true if this contains no entries.\n */\nmxCellStatePreview.prototype.isEmpty = function()\n{\n\treturn this.count == 0;\n};\n\n/**\n * Function: moveState\n */\nmxCellStatePreview.prototype.moveState = function(state, dx, dy, add, includeEdges)\n{\n\tadd = (add != null) ? add : true;\n\tincludeEdges = (includeEdges != null) ? includeEdges : true;\n\n\tvar delta = this.deltas.get(state.cell);\n\n\tif (delta == null)\n\t{\n\t\t// Note: Deltas stores the point and the state since the key is a string.\n\t\tdelta = {point: new mxPoint(dx, dy), state: state};\n\t\tthis.deltas.put(state.cell, delta);\n\t\tthis.count++;\n\t}\n\telse if (add)\n\t{\n\t\tdelta.point.x += dx;\n\t\tdelta.point.y += dy;\n\t}\n\telse\n\t{\n\t\tdelta.point.x = dx;\n\t\tdelta.point.y = dy;\n\t}\n\n\tif (includeEdges)\n\t{\n\t\tthis.addEdges(state);\n\t}\n\n\treturn delta.point;\n};\n\n/**\n * Function: show\n */\nmxCellStatePreview.prototype.show = function(visitor)\n{\n\tthis.deltas.visit(mxUtils.bind(this, function(key, delta)\n\t{\n\t\tthis.translateState(delta.state, delta.point.x, delta.point.y);\n\t}));\n\n\tthis.deltas.visit(mxUtils.bind(this, function(key, delta)\n\t{\n\t\tthis.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);\n\t}));\n};\n\n/**\n * Function: translateState\n */\nmxCellStatePreview.prototype.translateState = function(state, dx, dy)\n{\n\tif (state != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tif (model.isVertex(state.cell))\n\t\t{\n\t\t\tstate.view.updateCellState(state);\n\t\t\tvar geo = model.getGeometry(state.cell);\n\n\t\t\t// Moves selection cells and non-relative vertices in\n\t\t\t// the first phase so that edge terminal points will\n\t\t\t// be updated in the second phase\n\t\t\tif ((dx != 0 || dy != 0) && geo != null && (!geo.relative || this.deltas.get(state.cell) != null))\n\t\t\t{\n\t\t\t\tstate.x += dx;\n\t\t\t\tstate.y += dy;\n\t\t\t}\n\t\t}\n\n\t    var childCount = model.getChildCount(state.cell);\n\n\t    for (var i = 0; i < childCount; i++)\n\t    {\n\t    \tthis.translateState(state.view.getState(model.getChildAt(state.cell, i)), dx, dy);\n\t    }\n\t}\n};\n\n/**\n * Function: revalidateState\n */\nmxCellStatePreview.prototype.revalidateState = function(state, dx, dy, visitor)\n{\n\tif (state != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\t// Updates the edge terminal points and restores the\n\t\t// (relative) positions of any (relative) children\n\t\tif (model.isEdge(state.cell))\n\t\t{\n\t\t\tstate.view.updateCellState(state);\n\t\t}\n\n\t\tvar geo = this.graph.getCellGeometry(state.cell);\n\t\tvar pState = state.view.getState(model.getParent(state.cell));\n\n\t\t// Moves selection vertices which are relative\n\t\tif ((dx != 0 || dy != 0) && geo != null && geo.relative &&\n\t\t\tmodel.isVertex(state.cell) && (pState == null ||\n\t\t\tmodel.isVertex(pState.cell) || this.deltas.get(state.cell) != null))\n\t\t{\n\t\t\tstate.x += dx;\n\t\t\tstate.y += dy;\n\t\t}\n\n\t\tthis.graph.cellRenderer.redraw(state);\n\n\t\t// Invokes the visitor on the given state\n\t\tif (visitor != null)\n\t\t{\n\t\t\tvisitor(state);\n\t\t}\n\n\t    var childCount = model.getChildCount(state.cell);\n\n\t    for (var i = 0; i < childCount; i++)\n\t    {\n\t    \tthis.revalidateState(this.graph.view.getState(model.getChildAt(state.cell, i)), dx, dy, visitor);\n\t    }\n\t}\n};\n\n/**\n * Function: addEdges\n */\nmxCellStatePreview.prototype.addEdges = function(state)\n{\n\tvar model = this.graph.getModel();\n\tvar edgeCount = model.getEdgeCount(state.cell);\n\n\tfor (var i = 0; i < edgeCount; i++)\n\t{\n\t\tvar s = state.view.getState(model.getEdgeAt(state.cell, i));\n\n\t\tif (s != null)\n\t\t{\n\t\t\tthis.moveState(s, 0, 0);\n\t\t}\n\t}\n};\n\n__mxOutput.mxCellStatePreview = typeof mxCellStatePreview !== 'undefined' ? mxCellStatePreview : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxConnectionConstraint\n *\n * Defines an object that contains the constraints about how to connect one\n * side of an edge to its terminal.\n *\n * Constructor: mxConnectionConstraint\n *\n * Constructs a new connection constraint for the given point and boolean\n * arguments.\n *\n * Parameters:\n *\n * point - Optional <mxPoint> that specifies the fixed location of the point\n * in relative coordinates. Default is null.\n * perimeter - Optional boolean that specifies if the fixed point should be\n * projected onto the perimeter of the terminal. Default is true.\n */\nfunction mxConnectionConstraint(point, perimeter, name, dx, dy)\n{\n\tthis.point = point;\n\tthis.perimeter = (perimeter != null) ? perimeter : true;\n\tthis.name = name;\n\tthis.dx = dx? dx : 0;\n\tthis.dy = dy? dy : 0;\n};\n\n/**\n * Variable: point\n *\n * <mxPoint> that specifies the fixed location of the connection point.\n */\nmxConnectionConstraint.prototype.point = null;\n\n/**\n * Variable: perimeter\n *\n * Boolean that specifies if the point should be projected onto the perimeter\n * of the terminal.\n */\nmxConnectionConstraint.prototype.perimeter = null;\n\n/**\n * Variable: name\n *\n * Optional string that specifies the name of the constraint.\n */\nmxConnectionConstraint.prototype.name = null;\n\n/**\n * Variable: dx\n *\n * Optional float that specifies the horizontal offset of the constraint.\n */\nmxConnectionConstraint.prototype.dx = null;\n\n/**\n * Variable: dy\n *\n * Optional float that specifies the vertical offset of the constraint.\n */\nmxConnectionConstraint.prototype.dy = null;\n\n\n__mxOutput.mxConnectionConstraint = typeof mxConnectionConstraint !== 'undefined' ? mxConnectionConstraint : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGraphHandler\n *\n * Graph event handler that handles selection. Individual cells are handled\n * separately using <mxVertexHandler> or one of the edge handlers. These\n * handlers are created using <mxGraph.createHandler> in\n * <mxGraphSelectionModel.cellAdded>.\n *\n * To avoid the container to scroll a moved cell into view, set\n * <scrollAfterMove> to false.\n *\n * Constructor: mxGraphHandler\n *\n * Constructs an event handler that creates handles for the\n * selection cells.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxGraphHandler(graph)\n{\n\tthis.graph = graph;\n\tthis.graph.addMouseListener(this);\n\n\t// Repaints the handler after autoscroll\n\tthis.panHandler = mxUtils.bind(this, function()\n\t{\n\t\tthis.updatePreviewShape();\n\t\tthis.updateHint();\n\t});\n\n\tthis.graph.addListener(mxEvent.PAN, this.panHandler);\n\n\t// Handles escape keystrokes\n\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tthis.reset();\n\t});\n\n\tthis.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\n\t// Updates the preview box for remote changes\n\tthis.refreshHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.first != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis.bounds = this.graph.getView().getBounds(this.cells);\n\t\t\t\tthis.pBounds = this.getPreviewBounds(this.cells);\n\t\t\t\tthis.updatePreviewShape();\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\t// Resets the handler if cells have vanished\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t}\n\t});\n\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxGraphHandler.prototype.graph = null;\n\n/**\n * Variable: maxCells\n *\n * Defines the maximum number of cells to paint subhandles\n * for. Default is 50 for Firefox and 20 for IE. Set this\n * to 0 if you want an unlimited number of handles to be\n * displayed. This is only recommended if the number of\n * cells in the graph is limited to a small number, eg.\n * 500.\n */\nmxGraphHandler.prototype.maxCells = (mxClient.IS_IE) ? 20 : 50;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxGraphHandler.prototype.enabled = true;\n\n/**\n * Variable: highlightEnabled\n *\n * Specifies if drop targets under the mouse should be enabled. Default is\n * true.\n */\nmxGraphHandler.prototype.highlightEnabled = true;\n\n/**\n * Variable: cloneEnabled\n *\n * Specifies if cloning by control-drag is enabled. Default is true.\n */\nmxGraphHandler.prototype.cloneEnabled = true;\n\n/**\n * Variable: moveEnabled\n *\n * Specifies if moving is enabled. Default is true.\n */\nmxGraphHandler.prototype.moveEnabled = true;\n\n/**\n * Variable: guidesEnabled\n *\n * Specifies if other cells should be used for snapping the right, center or\n * left side of the current selection. Default is false.\n */\nmxGraphHandler.prototype.guidesEnabled = false;\n\n/**\n * Variable: guide\n *\n * Holds the <mxGuide> instance that is used for alignment.\n */\nmxGraphHandler.prototype.guide = null;\n\n/**\n * Variable: currentDx\n *\n * Stores the x-coordinate of the current mouse move.\n */\nmxGraphHandler.prototype.currentDx = null;\n\n/**\n * Variable: currentDy\n *\n * Stores the y-coordinate of the current mouse move.\n */\nmxGraphHandler.prototype.currentDy = null;\n\n/**\n * Variable: updateCursor\n *\n * Specifies if a move cursor should be shown if the mouse is over a movable\n * cell. Default is true.\n */\nmxGraphHandler.prototype.updateCursor = true;\n\n/**\n * Variable: selectEnabled\n *\n * Specifies if selecting is enabled. Default is true.\n */\nmxGraphHandler.prototype.selectEnabled = true;\n\n/**\n * Variable: removeCellsFromParent\n *\n * Specifies if cells may be moved out of their parents. Default is true.\n */\nmxGraphHandler.prototype.removeCellsFromParent = true;\n\n/**\n * Variable: removeEmptyParents\n *\n * If empty parents should be removed from the model after all child cells\n * have been moved out. Default is true.\n */\nmxGraphHandler.prototype.removeEmptyParents = false;\n\n/**\n * Variable: connectOnDrop\n *\n * Specifies if drop events are interpreted as new connections if no other\n * drop action is defined. Default is false.\n */\nmxGraphHandler.prototype.connectOnDrop = false;\n\n/**\n * Variable: scrollOnMove\n *\n * Specifies if the view should be scrolled so that a moved cell is\n * visible. Default is true.\n */\nmxGraphHandler.prototype.scrollOnMove = true;\n\n/**\n * Variable: minimumSize\n *\n * Specifies the minimum number of pixels for the width and height of a\n * selection border. Default is 6.\n */\nmxGraphHandler.prototype.minimumSize = 6;\n\n/**\n * Variable: previewColor\n *\n * Specifies the color of the preview shape. Default is black.\n */\nmxGraphHandler.prototype.previewColor = 'black';\n\n/**\n * Variable: htmlPreview\n *\n * Specifies if the graph container should be used for preview. If this is used\n * then drop target detection relies entirely on <mxGraph.getCellAt> because\n * the HTML preview does not \"let events through\". Default is false.\n */\nmxGraphHandler.prototype.htmlPreview = false;\n\n/**\n * Variable: shape\n *\n * Reference to the <mxShape> that represents the preview.\n */\nmxGraphHandler.prototype.shape = null;\n\n/**\n * Variable: scaleGrid\n *\n * Specifies if the grid should be scaled. Default is false.\n */\nmxGraphHandler.prototype.scaleGrid = false;\n\n/**\n * Variable: rotationEnabled\n *\n * Specifies if the bounding box should allow for rotation. Default is true.\n */\nmxGraphHandler.prototype.rotationEnabled = true;\n\n/**\n * Function: isEnabled\n *\n * Returns <enabled>.\n */\nmxGraphHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Sets <enabled>.\n */\nmxGraphHandler.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: isCloneEnabled\n *\n * Returns <cloneEnabled>.\n */\nmxGraphHandler.prototype.isCloneEnabled = function()\n{\n\treturn this.cloneEnabled;\n};\n\n/**\n * Function: setCloneEnabled\n *\n * Sets <cloneEnabled>.\n *\n * Parameters:\n *\n * value - Boolean that specifies the new clone enabled state.\n */\nmxGraphHandler.prototype.setCloneEnabled = function(value)\n{\n\tthis.cloneEnabled = value;\n};\n\n/**\n * Function: isMoveEnabled\n *\n * Returns <moveEnabled>.\n */\nmxGraphHandler.prototype.isMoveEnabled = function()\n{\n\treturn this.moveEnabled;\n};\n\n/**\n * Function: setMoveEnabled\n *\n * Sets <moveEnabled>.\n */\nmxGraphHandler.prototype.setMoveEnabled = function(value)\n{\n\tthis.moveEnabled = value;\n};\n\n/**\n * Function: isSelectEnabled\n *\n * Returns <selectEnabled>.\n */\nmxGraphHandler.prototype.isSelectEnabled = function()\n{\n\treturn this.selectEnabled;\n};\n\n/**\n * Function: setSelectEnabled\n *\n * Sets <selectEnabled>.\n */\nmxGraphHandler.prototype.setSelectEnabled = function(value)\n{\n\tthis.selectEnabled = value;\n};\n\n/**\n * Function: isRemoveCellsFromParent\n *\n * Returns <removeCellsFromParent>.\n */\nmxGraphHandler.prototype.isRemoveCellsFromParent = function()\n{\n\treturn this.removeCellsFromParent;\n};\n\n/**\n * Function: setRemoveCellsFromParent\n *\n * Sets <removeCellsFromParent>.\n */\nmxGraphHandler.prototype.setRemoveCellsFromParent = function(value)\n{\n\tthis.removeCellsFromParent = value;\n};\n\n/**\n * Function: getInitialCellForEvent\n *\n * Hook to return initial cell for the given event.\n */\nmxGraphHandler.prototype.getInitialCellForEvent = function(me)\n{\n\treturn me.getCell();\n};\n\n/**\n * Function: isDelayedSelection\n *\n * Hook to return true for delayed selections.\n */\nmxGraphHandler.prototype.isDelayedSelection = function(cell, me)\n{\n\treturn this.graph.isCellSelected(cell);\n};\n\n/**\n * Function: consumeMouseEvent\n *\n * Consumes the given mouse event. NOTE: This may be used to enable click\n * events for links in labels on iOS as follows as consuming the initial\n * touchStart disables firing the subsequent click event on the link.\n *\n * <code>\n * mxGraphHandler.prototype.consumeMouseEvent = function(evtName, me)\n * {\n *   var source = mxEvent.getSource(me.getEvent());\n *\n *   if (!mxEvent.isTouchEvent(me.getEvent()) || source.nodeName != 'A')\n *   {\n *     me.consume();\n *   }\n * }\n * </code>\n */\nmxGraphHandler.prototype.consumeMouseEvent = function(evtName, me)\n{\n\tme.consume();\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by selecing the given cell and creating a handle for\n * it. By consuming the event all subsequent events of the gesture are\n * redirected to this handler.\n */\nmxGraphHandler.prototype.mouseDown = function(sender, me)\n{\n\tif (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() &&\n\t\tme.getState() != null && !mxEvent.isMultiTouchEvent(me.getEvent()))\n\t{\n\t\tvar cell = this.getInitialCellForEvent(me);\n\t\tthis.delayedSelection = this.isDelayedSelection(cell, me);\n\t\tthis.cell = null;\n\n\t\tif (this.isSelectEnabled() && !this.delayedSelection)\n\t\t{\n\t\t\tthis.graph.selectCellForEvent(cell, me.getEvent());\n\t\t}\n\n\t\tif (this.isMoveEnabled())\n\t\t{\n\t\t\tvar model = this.graph.model;\n\t\t\tvar geo = model.getGeometry(cell);\n\n\t\t\tif (this.graph.isCellMovable(cell) && ((!model.isEdge(cell) || this.graph.getSelectionCount() > 1 ||\n\t\t\t\t(geo.points != null && geo.points.length > 0) || model.getTerminal(cell, true) == null ||\n\t\t\t\tmodel.getTerminal(cell, false) == null) || this.graph.allowDanglingEdges ||\n\t\t\t\t(this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())))\n\t\t\t{\n\t\t\t\tthis.start(cell, me.getX(), me.getY());\n\t\t\t}\n\t\t\telse if (this.delayedSelection)\n\t\t\t{\n\t\t\t\tthis.cell = cell;\n\t\t\t}\n\n\t\t\tthis.cellWasClicked = true;\n\t\t\tthis.consumeMouseEvent(mxEvent.MOUSE_DOWN, me);\n\t\t}\n\t}\n};\n\n/**\n * Function: getGuideStates\n *\n * Creates an array of cell states which should be used as guides.\n */\nmxGraphHandler.prototype.getGuideStates = function()\n{\n\tvar parent = this.graph.getDefaultParent();\n\tvar model = this.graph.getModel();\n\n\tvar filter = mxUtils.bind(this, function(cell)\n\t{\n\t\treturn this.graph.view.getState(cell) != null &&\n\t\t\tmodel.isVertex(cell) &&\n\t\t\tmodel.getGeometry(cell) != null &&\n\t\t\t!model.getGeometry(cell).relative;\n\t});\n\n\treturn this.graph.view.getCellStates(model.filterDescendants(filter, parent));\n};\n\n/**\n * Function: getCells\n *\n * Returns the cells to be modified by this handler. This implementation\n * returns all selection cells that are movable, or the given initial cell if\n * the given cell is not selected and movable. This handles the case of moving\n * unselectable or unselected cells.\n *\n * Parameters:\n *\n * initialCell - <mxCell> that triggered this handler.\n */\nmxGraphHandler.prototype.getCells = function(initialCell)\n{\n\tif (!this.delayedSelection && this.graph.isCellMovable(initialCell))\n\t{\n\t\treturn [initialCell];\n\t}\n\telse\n\t{\n\t\treturn this.graph.getMovableCells(this.graph.getSelectionCells());\n\t}\n};\n\n/**\n * Function: getPreviewBounds\n *\n * Returns the <mxRectangle> used as the preview bounds for\n * moving the given cells.\n */\nmxGraphHandler.prototype.getPreviewBounds = function(cells)\n{\n\tvar bounds = this.getBoundingBox(cells);\n\n\tif (bounds != null)\n\t{\n\t\t// Corrects width and height\n\t\tbounds.width = Math.max(0, bounds.width - 1);\n\t\tbounds.height = Math.max(0, bounds.height - 1);\n\n\t\tif (bounds.width < this.minimumSize)\n\t\t{\n\t\t\tvar dx = this.minimumSize - bounds.width;\n\t\t\tbounds.x -= dx / 2;\n\t\t\tbounds.width = this.minimumSize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbounds.x = Math.round(bounds.x);\n\t\t\tbounds.width = Math.ceil(bounds.width);\n\t\t}\n\n\t\tvar tr = this.graph.view.translate;\n\t\tvar s = this.graph.view.scale;\n\n\t\tif (bounds.height < this.minimumSize)\n\t\t{\n\t\t\tvar dy = this.minimumSize - bounds.height;\n\t\t\tbounds.y -= dy / 2;\n\t\t\tbounds.height = this.minimumSize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbounds.y = Math.round(bounds.y);\n\t\t\tbounds.height = Math.ceil(bounds.height);\n\t\t}\n\t}\n\n\treturn bounds;\n};\n\n/**\n * Function: getBoundingBox\n *\n * Returns the union of the <mxCellStates> for the given array of <mxCells>.\n * For vertices, this method uses the bounding box of the corresponding shape\n * if one exists. The bounding box of the corresponding text label and all\n * controls and overlays are ignored. See also: <mxGraphView.getBounds> and\n * <mxGraph.getBoundingBox>.\n *\n * Parameters:\n *\n * cells - Array of <mxCells> whose bounding box should be returned.\n */\nmxGraphHandler.prototype.getBoundingBox = function(cells)\n{\n\tvar result = null;\n\n\tif (cells != null && cells.length > 0)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tfor (var i = 0; i < cells.length; i++)\n\t\t{\n\t\t\tif (model.isVertex(cells[i]) || model.isEdge(cells[i]))\n\t\t\t{\n\t\t\t\tvar state = this.graph.view.getState(cells[i]);\n\n\t\t\t\tif (state != null)\n\t\t\t\t{\n\t\t\t\t\tvar bbox = state;\n\n\t\t\t\t\tif (model.isVertex(cells[i]) && state.shape != null && state.shape.boundingBox != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbbox = state.shape.boundingBox;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (result == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tresult = mxRectangle.fromRectangle(bbox);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresult.add(bbox);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: createPreviewShape\n *\n * Creates the shape used to draw the preview for the given bounds.\n */\nmxGraphHandler.prototype.createPreviewShape = function(bounds)\n{\n\tvar shape = new mxRectangleShape(bounds, null, this.previewColor);\n\tshape.isDashed = true;\n\n\tif (this.htmlPreview)\n\t{\n\t\tshape.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tshape.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\t// Makes sure to use either VML or SVG shapes in order to implement\n\t\t// event-transparency on the background area of the rectangle since\n\t\t// HTML shapes do not let mouseevents through even when transparent\n\t\tshape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\tshape.init(this.graph.getView().getOverlayPane());\n\t\tshape.pointerEvents = false;\n\n\t\t// Workaround for artifacts on iOS\n\t\tif (mxClient.IS_IOS)\n\t\t{\n\t\t\tshape.getSvgScreenOffset = function()\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\t}\n\n\treturn shape;\n};\n\n/**\n * Function: start\n *\n * Starts the handling of the mouse gesture.\n */\nmxGraphHandler.prototype.start = function(cell, x, y)\n{\n\tthis.cell = cell;\n\tthis.first = mxUtils.convertPoint(this.graph.container, x, y);\n\tthis.cells = this.getCells(this.cell);\n\tthis.bounds = this.graph.getView().getBounds(this.cells);\n\tthis.pBounds = this.getPreviewBounds(this.cells);\n\n\tif (this.guidesEnabled)\n\t{\n\t\tthis.guide = new mxGuide(this.graph, this.getGuideStates());\n\t}\n};\n\n/**\n * Function: useGuidesForEvent\n *\n * Returns true if the guides should be used for the given <mxMouseEvent>.\n * This implementation returns <mxGuide.isEnabledForEvent>.\n */\nmxGraphHandler.prototype.useGuidesForEvent = function(me)\n{\n\treturn (this.guide != null) ? this.guide.isEnabledForEvent(me.getEvent()) : true;\n};\n\n\n/**\n * Function: snap\n *\n * Snaps the given vector to the grid and returns the given mxPoint instance.\n */\nmxGraphHandler.prototype.snap = function(vector)\n{\n\tvar scale = (this.scaleGrid) ? this.graph.view.scale : 1;\n\n\tvector.x = this.graph.snap(vector.x / scale) * scale;\n\tvector.y = this.graph.snap(vector.y / scale) * scale;\n\n\treturn vector;\n};\n\n/**\n * Function: getDelta\n *\n * Returns an <mxPoint> that represents the vector for moving the cells\n * for the given <mxMouseEvent>.\n */\nmxGraphHandler.prototype.getDelta = function(me)\n{\n\tvar point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());\n\tvar s = this.graph.view.scale;\n\n\treturn new mxPoint(this.roundLength((point.x - this.first.x) / s) * s,\n\t\tthis.roundLength((point.y - this.first.y) / s) * s);\n};\n\n/**\n * Function: updateHint\n *\n * Hook for subclassers do show details while the handler is active.\n */\nmxGraphHandler.prototype.updateHint = function(me) { };\n\n/**\n * Function: removeHint\n *\n * Hooks for subclassers to hide details when the handler gets inactive.\n */\nmxGraphHandler.prototype.removeHint = function() { };\n\n/**\n * Function: roundLength\n *\n * Hook for rounding the unscaled vector. This uses Math.round.\n */\nmxGraphHandler.prototype.roundLength = function(length)\n{\n\treturn Math.round(length * 2) / 2;\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by highlighting possible drop targets and updating the\n * preview.\n */\nmxGraphHandler.prototype.mouseMove = function(sender, me)\n{\n\tvar graph = this.graph;\n\n\tif (!me.isConsumed() && graph.isMouseDown && this.cell != null &&\n\t\tthis.first != null && this.bounds != null)\n\t{\n\t\t// Stops moving if a multi touch event is received\n\t\tif (mxEvent.isMultiTouchEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.reset();\n\t\t\treturn;\n\t\t}\n\n\t\tvar delta = this.getDelta(me);\n\t\tvar dx = delta.x;\n\t\tvar dy = delta.y;\n\t\tvar tol = graph.tolerance;\n\n\t\tif (this.shape != null || Math.abs(dx) > tol || Math.abs(dy) > tol)\n\t\t{\n\t\t\t// Highlight is used for highlighting drop targets\n\t\t\tif (this.highlight == null)\n\t\t\t{\n\t\t\t\tthis.highlight = new mxCellHighlight(this.graph,\n\t\t\t\t\tmxConstants.DROP_TARGET_COLOR, 3);\n\t\t\t}\n\n\t\t\tif (this.shape == null)\n\t\t\t{\n\t\t\t\tthis.shape = this.createPreviewShape(this.bounds);\n\t\t\t}\n\n\t\t\tvar clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n\t\t\tvar gridEnabled = graph.isGridEnabledEvent(me.getEvent());\n\t\t\tvar hideGuide = true;\n\n\t\t\tif (this.guide != null && this.useGuidesForEvent(me))\n\t\t\t{\n\t\t\t\tdelta = this.guide.move(this.bounds, new mxPoint(dx, dy), gridEnabled, clone);\n\t\t\t\thideGuide = false;\n\t\t\t\tdx = delta.x;\n\t\t\t\tdy = delta.y;\n\t\t\t}\n\t\t\telse if (gridEnabled)\n\t\t\t{\n\t\t\t\tvar trx = graph.getView().translate;\n\t\t\t\tvar scale = graph.getView().scale;\n\n\t\t\t\tvar tx = this.bounds.x - (graph.snap(this.bounds.x / scale - trx.x) + trx.x) * scale;\n\t\t\t\tvar ty = this.bounds.y - (graph.snap(this.bounds.y / scale - trx.y) + trx.y) * scale;\n\t\t\t\tvar v = this.snap(new mxPoint(dx, dy));\n\n\t\t\t\tdx = v.x - tx;\n\t\t\t\tdy = v.y - ty;\n\t\t\t}\n\n\t\t\tif (this.guide != null && hideGuide)\n\t\t\t{\n\t\t\t\tthis.guide.hide();\n\t\t\t}\n\n\t\t\t// Constrained movement if shift key is pressed\n\t\t\tif (graph.isConstrainedEvent(me.getEvent()))\n\t\t\t{\n\t\t\t\tif (Math.abs(dx) > Math.abs(dy))\n\t\t\t\t{\n\t\t\t\t\tdy = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdx = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.currentDx = dx;\n\t\t\tthis.currentDy = dy;\n\t\t\tthis.updatePreviewShape();\n\n\t\t\tvar target = null;\n\t\t\tvar cell = me.getCell();\n\n\t\t\tif (graph.isDropEnabled() && this.highlightEnabled)\n\t\t\t{\n\t\t\t\t// Contains a call to getCellAt to find the cell under the mouse\n\t\t\t\ttarget = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);\n\t\t\t}\n\n\t\t\tvar state = graph.getView().getState(target);\n\t\t\tvar highlight = false;\n\n\t\t\tif (state != null && (graph.model.getParent(this.cell) != target || clone))\n\t\t\t{\n\t\t\t    if (this.target != target)\n\t\t\t    {\n\t\t\t\t    this.target = target;\n\t\t\t\t    this.setHighlightColor(mxConstants.DROP_TARGET_COLOR);\n\t\t\t\t}\n\n\t\t\t    highlight = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.target = null;\n\n\t\t\t\tif (this.connectOnDrop && cell != null && this.cells.length == 1 &&\n\t\t\t\t\tgraph.getModel().isVertex(cell) && graph.isCellConnectable(cell))\n\t\t\t\t{\n\t\t\t\t\tstate = graph.getView().getState(cell);\n\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar error = graph.getEdgeValidationError(null, this.cell, cell);\n\t\t\t\t\t\tvar color = (error == null) ?\n\t\t\t\t\t\t\tmxConstants.VALID_COLOR :\n\t\t\t\t\t\t\tmxConstants.INVALID_CONNECT_TARGET_COLOR;\n\t\t\t\t\t\tthis.setHighlightColor(color);\n\t\t\t\t\t\thighlight = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state != null && highlight)\n\t\t\t{\n\t\t\t\tthis.highlight.highlight(state);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.highlight.hide();\n\t\t\t}\n\t\t}\n\n\t\tthis.updateHint(me);\n\t\tthis.consumeMouseEvent(mxEvent.MOUSE_MOVE, me);\n\n\t\t// Cancels the bubbling of events to the container so\n\t\t// that the droptarget is not reset due to an mouseMove\n\t\t// fired on the container with no associated state.\n\t\tmxEvent.consume(me.getEvent());\n\t}\n\telse if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() &&\n\t\t(me.getState() != null || me.sourceState != null) && !graph.isMouseDown)\n\t{\n\t\tvar cursor = graph.getCursorForMouseEvent(me);\n\n\t\tif (cursor == null && graph.isEnabled() && graph.isCellMovable(me.getCell()))\n\t\t{\n\t\t\tif (graph.getModel().isEdge(me.getCell()))\n\t\t\t{\n\t\t\t\tcursor = mxConstants.CURSOR_MOVABLE_EDGE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcursor = mxConstants.CURSOR_MOVABLE_VERTEX;\n\t\t\t}\n\t\t}\n\n\t\t// Sets the cursor on the original source state under the mouse\n\t\t// instead of the event source state which can be the parent\n\t\tif (cursor != null && me.sourceState != null)\n\t\t{\n\t\t\tme.sourceState.setCursor(cursor);\n\t\t}\n\t}\n};\n\n/**\n * Function: updatePreviewShape\n *\n * Updates the bounds of the preview shape.\n */\nmxGraphHandler.prototype.updatePreviewShape = function()\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.bounds = new mxRectangle(Math.round(this.pBounds.x + this.currentDx - this.graph.panDx),\n\t\t\t\tMath.round(this.pBounds.y + this.currentDy - this.graph.panDy), this.pBounds.width, this.pBounds.height);\n\t\tthis.shape.redraw();\n\t}\n};\n\n/**\n * Function: setHighlightColor\n *\n * Sets the color of the rectangle used to highlight drop targets.\n *\n * Parameters:\n *\n * color - String that represents the new highlight color.\n */\nmxGraphHandler.prototype.setHighlightColor = function(color)\n{\n\tif (this.highlight != null)\n\t{\n\t\tthis.highlight.setHighlightColor(color);\n\t}\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by applying the changes to the selection cells.\n */\nmxGraphHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (!me.isConsumed())\n\t{\n\t\tvar graph = this.graph;\n\n\t\tif (this.cell != null && this.first != null && this.shape != null &&\n\t\t\tthis.currentDx != null && this.currentDy != null)\n\t\t{\n\t\t\tvar cell = me.getCell();\n\n\t\t\tif (this.connectOnDrop && this.target == null && cell != null && graph.getModel().isVertex(cell) &&\n\t\t\t\tgraph.isCellConnectable(cell) && graph.isEdgeValid(null, this.cell, cell))\n\t\t\t{\n\t\t\t\tgraph.connectionHandler.connect(this.cell, cell, me.getEvent());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n\t\t\t\tvar scale = graph.getView().scale;\n\t\t\t\tvar dx = this.roundLength(this.currentDx / scale);\n\t\t\t\tvar dy = this.roundLength(this.currentDy / scale);\n\t\t\t\tvar target = this.target;\n\n\t\t\t\tif (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent()))\n\t\t\t\t{\n\t\t\t\t\tgraph.splitEdge(target, this.cells, null, dx, dy);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (this.isSelectEnabled() && this.delayedSelection && this.cell != null)\n\t\t{\n\t\t\tthis.selectDelayed(me);\n\t\t}\n\t}\n\n\t// Consumes the event if a cell was initially clicked\n\tif (this.cellWasClicked)\n\t{\n\t\tthis.consumeMouseEvent(mxEvent.MOUSE_UP, me);\n\t}\n\n\tthis.reset();\n};\n\n/**\n * Function: selectDelayed\n *\n * Implements the delayed selection for the given mouse event.\n */\nmxGraphHandler.prototype.selectDelayed = function(me)\n{\n\tif (!this.graph.isCellSelected(this.cell) || !this.graph.popupMenuHandler.isPopupTrigger(me))\n\t{\n\t\tthis.graph.selectCellForEvent(this.cell, me.getEvent());\n\t}\n};\n\n/**\n * Function: reset\n *\n * Resets the state of this handler.\n */\nmxGraphHandler.prototype.reset = function()\n{\n\tthis.destroyShapes();\n\tthis.removeHint();\n\n\tthis.cellWasClicked = false;\n\tthis.delayedSelection = false;\n\tthis.currentDx = null;\n\tthis.currentDy = null;\n\tthis.guides = null;\n\tthis.first = null;\n\tthis.cell = null;\n\tthis.target = null;\n};\n\n/**\n * Function: shouldRemoveCellsFromParent\n *\n * Returns true if the given cells should be removed from the parent for the specified\n * mousereleased event.\n */\nmxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent, cells, evt)\n{\n\tif (this.graph.getModel().isVertex(parent))\n\t{\n\t\tvar pState = this.graph.getView().getState(parent);\n\n\t\tif (pState != null)\n\t\t{\n\t\t\tvar pt = mxUtils.convertPoint(this.graph.container,\n\t\t\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\t\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(pState.style, mxConstants.STYLE_ROTATION) || 0);\n\n\t\t\tif (alpha != 0)\n\t\t\t{\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\t\t\t\tvar cx = new mxPoint(pState.getCenterX(), pState.getCenterY());\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, cx);\n\t\t\t}\n\n\t\t\treturn !mxUtils.contains(pState, pt.x, pt.y);\n\t\t}\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: moveCells\n *\n * Moves the given cells by the specified amount.\n */\nmxGraphHandler.prototype.moveCells = function(cells, dx, dy, clone, target, evt)\n{\n\tif (clone)\n\t{\n\t\tcells = this.graph.getCloneableCells(cells);\n\t}\n\n\t// Removes cells from parent\n\tvar parent = this.graph.getModel().getParent(this.cell);\n\n\tif (target == null && this.isRemoveCellsFromParent() &&\n\t\tthis.shouldRemoveCellsFromParent(parent, cells, evt))\n\t{\n\t\ttarget = this.graph.getDefaultParent();\n\t}\n\n\t// Cloning into locked cells is not allowed\n\tclone = clone && !this.graph.isCellLocked(target || this.graph.getDefaultParent());\n\n\tthis.graph.getModel().beginUpdate();\n\ttry\n\t{\n\t\tvar parents = [];\n\n\t\t// Removes parent if all child cells are removed\n\t\tif (!clone && target != null && this.removeEmptyParents)\n\t\t{\n\t\t\t// Collects all non-selected parents\n\t\t\tvar dict = new mxDictionary();\n\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tdict.put(cells[i], true);\n\t\t\t}\n\n\t\t\t// LATER: Recurse up the cell hierarchy\n\t\t\tfor (var i = 0; i < cells.length; i++)\n\t\t\t{\n\t\t\t\tvar par = this.graph.model.getParent(cells[i]);\n\n\t\t\t\tif (par != null && !dict.get(par))\n\t\t\t\t{\n\t\t\t\t\tdict.put(par, true);\n\t\t\t\t\tparents.push(par);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Passes all selected cells in order to correctly clone or move into\n\t\t// the target cell. The method checks for each cell if its movable.\n\t\tcells = this.graph.moveCells(cells, dx - this.graph.panDx / this.graph.view.scale,\n\t\t\t\tdy - this.graph.panDy / this.graph.view.scale, clone, target, evt);\n\n\t\t// Removes parent if all child cells are removed\n\t\tvar temp = [];\n\n\t\tfor (var i = 0; i < parents.length; i++)\n\t\t{\n\t\t\tif (this.shouldRemoveParent(parents[i]))\n\t\t\t{\n\t\t\t\ttemp.push(parents[i]);\n\t\t\t}\n\t\t}\n\n\t\tthis.graph.removeCells(temp, false);\n\t}\n\tfinally\n\t{\n\t\tthis.graph.getModel().endUpdate();\n\t}\n\n\t// Selects the new cells if cells have been cloned\n\tif (clone)\n\t{\n\t\tthis.graph.setSelectionCells(cells);\n\t}\n\n\tif (this.isSelectEnabled() && this.scrollOnMove)\n\t{\n\t\tthis.graph.scrollCellToVisible(cells[0]);\n\t}\n};\n\n/**\n * Function: moveCells\n *\n * Moves the given cells by the specified amount.\n */\nmxGraphHandler.prototype.shouldRemoveParent = function(parent)\n{\n\tvar state = this.graph.view.getState(parent);\n\n\tconsole.log('state', state, this.graph.model.getChildCount(state.cell));\n\n\tif (state != null && (this.graph.model.isEdge(state.cell) || this.graph.model.isVertex(state.cell)) &&\n\t\tthis.graph.isCellDeletable(state.cell) && this.graph.model.getChildCount(state.cell) == 0)\n\t{\n\t\tvar stroke = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);\n\t\tvar fill = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);\n\n\t\treturn stroke == mxConstants.NONE && fill == mxConstants.NONE;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: destroyShapes\n *\n * Destroy the preview and highlight shapes.\n */\nmxGraphHandler.prototype.destroyShapes = function()\n{\n\t// Destroys the preview dashed rectangle\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\n\tif (this.guide != null)\n\t{\n\t\tthis.guide.destroy();\n\t\tthis.guide = null;\n\t}\n\n\t// Destroys the drop target highlight\n\tif (this.highlight != null)\n\t{\n\t\tthis.highlight.destroy();\n\t\tthis.highlight = null;\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxGraphHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\tthis.graph.removeListener(this.panHandler);\n\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n\n\tif (this.refreshHandler != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.refreshHandler);\n\t\tthis.refreshHandler = null;\n\t}\n\n\tthis.destroyShapes();\n\tthis.removeHint();\n};\n\n__mxOutput.mxGraphHandler = typeof mxGraphHandler !== 'undefined' ? mxGraphHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPanningHandler\n *\n * Event handler that pans and creates popupmenus. To use the left\n * mousebutton for panning without interfering with cell moving and\n * resizing, use <isUseLeftButton> and <isIgnoreCell>. For grid size\n * steps while panning, use <useGrid>. This handler is built-into\n * <mxGraph.panningHandler> and enabled using <mxGraph.setPanning>.\n *\n * Constructor: mxPanningHandler\n *\n * Constructs an event handler that creates a <mxPopupMenu>\n * and pans the graph.\n *\n * Event: mxEvent.PAN_START\n *\n * Fires when the panning handler changes its <active> state to true. The\n * <code>event</code> property contains the corresponding <mxMouseEvent>.\n *\n * Event: mxEvent.PAN\n *\n * Fires while handle is processing events. The <code>event</code> property contains\n * the corresponding <mxMouseEvent>.\n *\n * Event: mxEvent.PAN_END\n *\n * Fires when the panning handler changes its <active> state to false. The\n * <code>event</code> property contains the corresponding <mxMouseEvent>.\n */\nfunction mxPanningHandler(graph)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.graph.addMouseListener(this);\n\n\t\t// Handles force panning event\n\t\tthis.forcePanningHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar evtName = evt.getProperty('eventName');\n\t\t\tvar me = evt.getProperty('event');\n\n\t\t\tif (evtName == mxEvent.MOUSE_DOWN && this.isForcePanningEvent(me))\n\t\t\t{\n\t\t\t\tthis.start(me);\n\t\t\t\tthis.active = true;\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN_START, 'event', me));\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forcePanningHandler);\n\n\t\t// Handles pinch gestures\n\t\tthis.gestureHandler = mxUtils.bind(this, function(sender, eo)\n\t\t{\n\t\t\tif (this.isPinchEnabled())\n\t\t\t{\n\t\t\t\tvar evt = eo.getProperty('event');\n\n\t\t\t\tif (!mxEvent.isConsumed(evt) && evt.type == 'gesturestart')\n\t\t\t\t{\n\t\t\t\t\tthis.initialScale = this.graph.view.scale;\n\n\t\t\t\t\t// Forces start of panning when pinch gesture starts\n\t\t\t\t\tif (!this.active && this.mouseDownEvent != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.start(this.mouseDownEvent);\n\t\t\t\t\t\tthis.mouseDownEvent = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (evt.type == 'gestureend' && this.initialScale != null)\n\t\t\t\t{\n\t\t\t\t\tthis.initialScale = null;\n\t\t\t\t}\n\n\t\t\t\tif (this.initialScale != null)\n\t\t\t\t{\n\t\t\t\t\tvar value = Math.round(this.initialScale * evt.scale * 100) / 100;\n\n\t\t\t\t\tif (this.minScale != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue = Math.max(this.minScale, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.maxScale != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue = Math.min(this.maxScale, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.graph.view.scale != value)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.graph.zoomTo(value);\n\t\t\t\t\t\tmxEvent.consume(evt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.GESTURE, this.gestureHandler);\n\n\t\tthis.mouseUpListener = mxUtils.bind(this, function()\n\t\t{\n\t\t    \tif (this.active)\n\t\t    \t{\n\t\t    \t\tthis.reset();\n\t\t    \t}\n\t\t});\n\n\t\t// Stops scrolling on every mouseup anywhere in the document\n\t\tmxEvent.addListener(document, 'mouseup', this.mouseUpListener);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxPanningHandler.prototype = new mxEventSource();\nmxPanningHandler.prototype.constructor = mxPanningHandler;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxPanningHandler.prototype.graph = null;\n\n/**\n * Variable: useLeftButtonForPanning\n *\n * Specifies if panning should be active for the left mouse button.\n * Setting this to true may conflict with <mxRubberband>. Default is false.\n */\nmxPanningHandler.prototype.useLeftButtonForPanning = false;\n\n/**\n * Variable: usePopupTrigger\n *\n * Specifies if <mxEvent.isPopupTrigger> should also be used for panning.\n */\nmxPanningHandler.prototype.usePopupTrigger = true;\n\n/**\n * Variable: ignoreCell\n *\n * Specifies if panning should be active even if there is a cell under the\n * mousepointer. Default is false.\n */\nmxPanningHandler.prototype.ignoreCell = false;\n\n/**\n * Variable: previewEnabled\n *\n * Specifies if the panning should be previewed. Default is true.\n */\nmxPanningHandler.prototype.previewEnabled = true;\n\n/**\n * Variable: useGrid\n *\n * Specifies if the panning steps should be aligned to the grid size.\n * Default is false.\n */\nmxPanningHandler.prototype.useGrid = false;\n\n/**\n * Variable: panningEnabled\n *\n * Specifies if panning should be enabled. Default is true.\n */\nmxPanningHandler.prototype.panningEnabled = true;\n\n/**\n * Variable: pinchEnabled\n *\n * Specifies if pinch gestures should be handled as zoom. Default is true.\n */\nmxPanningHandler.prototype.pinchEnabled = true;\n\n/**\n * Variable: maxScale\n *\n * Specifies the maximum scale. Default is 8.\n */\nmxPanningHandler.prototype.maxScale = 8;\n\n/**\n * Variable: minScale\n *\n * Specifies the minimum scale. Default is 0.01.\n */\nmxPanningHandler.prototype.minScale = 0.01;\n\n/**\n * Variable: dx\n *\n * Holds the current horizontal offset.\n */\nmxPanningHandler.prototype.dx = null;\n\n/**\n * Variable: dy\n *\n * Holds the current vertical offset.\n */\nmxPanningHandler.prototype.dy = null;\n\n/**\n * Variable: startX\n *\n * Holds the x-coordinate of the start point.\n */\nmxPanningHandler.prototype.startX = 0;\n\n/**\n * Variable: startY\n *\n * Holds the y-coordinate of the start point.\n */\nmxPanningHandler.prototype.startY = 0;\n\n/**\n * Function: isActive\n *\n * Returns true if the handler is currently active.\n */\nmxPanningHandler.prototype.isActive = function()\n{\n\treturn this.active || this.initialScale != null;\n};\n\n/**\n * Function: isPanningEnabled\n *\n * Returns <panningEnabled>.\n */\nmxPanningHandler.prototype.isPanningEnabled = function()\n{\n\treturn this.panningEnabled;\n};\n\n/**\n * Function: setPanningEnabled\n *\n * Sets <panningEnabled>.\n */\nmxPanningHandler.prototype.setPanningEnabled = function(value)\n{\n\tthis.panningEnabled = value;\n};\n\n/**\n * Function: isPinchEnabled\n *\n * Returns <pinchEnabled>.\n */\nmxPanningHandler.prototype.isPinchEnabled = function()\n{\n\treturn this.pinchEnabled;\n};\n\n/**\n * Function: setPinchEnabled\n *\n * Sets <pinchEnabled>.\n */\nmxPanningHandler.prototype.setPinchEnabled = function(value)\n{\n\tthis.pinchEnabled = value;\n};\n\n/**\n * Function: isPanningTrigger\n *\n * Returns true if the given event is a panning trigger for the optional\n * given cell. This returns true if control-shift is pressed or if\n * <usePopupTrigger> is true and the event is a popup trigger.\n */\nmxPanningHandler.prototype.isPanningTrigger = function(me)\n{\n\tvar evt = me.getEvent();\n\n\treturn (this.useLeftButtonForPanning && me.getState() == null &&\n\t\t\tmxEvent.isLeftMouseButton(evt)) || (mxEvent.isControlDown(evt) &&\n\t\t\tmxEvent.isShiftDown(evt)) || (this.usePopupTrigger && mxEvent.isPopupTrigger(evt));\n};\n\n/**\n * Function: isForcePanningEvent\n *\n * Returns true if the given <mxMouseEvent> should start panning. This\n * implementation always returns true if <ignoreCell> is true or for\n * multi touch events.\n */\nmxPanningHandler.prototype.isForcePanningEvent = function(me)\n{\n\treturn this.ignoreCell || mxEvent.isMultiTouchEvent(me.getEvent());\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by initiating the panning. By consuming the event all\n * subsequent events of the gesture are redirected to this handler.\n */\nmxPanningHandler.prototype.mouseDown = function(sender, me)\n{\n\tthis.mouseDownEvent = me;\n\n\tif (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me))\n\t{\n\t\tthis.start(me);\n\t\tthis.consumePanningTrigger(me);\n\t}\n};\n\n/**\n * Function: start\n *\n * Starts panning at the given event.\n */\nmxPanningHandler.prototype.start = function(me)\n{\n\tthis.dx0 = -this.graph.container.scrollLeft;\n\tthis.dy0 = -this.graph.container.scrollTop;\n\n\t// Stores the location of the trigger event\n\tthis.startX = me.getX();\n\tthis.startY = me.getY();\n\tthis.dx = null;\n\tthis.dy = null;\n\n\tthis.panningTrigger = true;\n};\n\n/**\n * Function: consumePanningTrigger\n *\n * Consumes the given <mxMouseEvent> if it was a panning trigger in\n * <mouseDown>. The default is to invoke <mxMouseEvent.consume>. Note that this\n * will block any further event processing. If you haven't disabled built-in\n * context menus and require immediate selection of the cell on mouseDown in\n * Safari and/or on the Mac, then use the following code:\n *\n * (code)\n * mxPanningHandler.prototype.consumePanningTrigger = function(me)\n * {\n *   if (me.evt.preventDefault)\n *   {\n *     me.evt.preventDefault();\n *   }\n *\n *   // Stops event processing in IE\n *   me.evt.returnValue = false;\n *\n *   // Sets local consumed state\n *   if (!mxClient.IS_SF && !mxClient.IS_MAC)\n *   {\n *     me.consumed = true;\n *   }\n * };\n * (end)\n */\nmxPanningHandler.prototype.consumePanningTrigger = function(me)\n{\n\tme.consume();\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by updating the panning on the graph.\n */\nmxPanningHandler.prototype.mouseMove = function(sender, me)\n{\n\tthis.dx = me.getX() - this.startX;\n\tthis.dy = me.getY() - this.startY;\n\n\tif (this.active)\n\t{\n\t\tif (this.previewEnabled)\n\t\t{\n\t\t\t// Applies the grid to the panning steps\n\t\t\tif (this.useGrid)\n\t\t\t{\n\t\t\t\tthis.dx = this.graph.snap(this.dx);\n\t\t\t\tthis.dy = this.graph.snap(this.dy);\n\t\t\t}\n\n\t\t\tthis.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN, 'event', me));\n\t}\n\telse if (this.panningTrigger)\n\t{\n\t\tvar tmp = this.active;\n\n\t\t// Panning is activated only if the mouse is moved\n\t\t// beyond the graph tolerance\n\t\tthis.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;\n\n\t\tif (!tmp && this.active)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN_START, 'event', me));\n\t\t}\n\t}\n\n\tif (this.active || this.panningTrigger)\n\t{\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by setting the translation on the view or showing the\n * popupmenu.\n */\nmxPanningHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.active)\n\t{\n\t\tif (this.dx != null && this.dy != null)\n\t\t{\n\t\t\t// Ignores if scrollbars have been used for panning\n\t\t\tif (!this.graph.useScrollbarsForPanning || !mxUtils.hasScrollbars(this.graph.container))\n\t\t\t{\n\t\t\t\tvar scale = this.graph.getView().scale;\n\t\t\t\tvar t = this.graph.getView().translate;\n\t\t\t\tthis.graph.panGraph(0, 0);\n\t\t\t\tthis.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);\n\t\t\t}\n\n\t\t\tme.consume();\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.PAN_END, 'event', me));\n\t}\n\n\tthis.reset();\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by setting the translation on the view or showing the\n * popupmenu.\n */\nmxPanningHandler.prototype.reset = function()\n{\n\tthis.panningTrigger = false;\n\tthis.mouseDownEvent = null;\n\tthis.active = false;\n\tthis.dx = null;\n\tthis.dy = null;\n};\n\n/**\n * Function: panGraph\n *\n * Pans <graph> by the given amount.\n */\nmxPanningHandler.prototype.panGraph = function(dx, dy)\n{\n\tthis.graph.getView().setTranslate(dx, dy);\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxPanningHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\tthis.graph.removeListener(this.forcePanningHandler);\n\tthis.graph.removeListener(this.gestureHandler);\n\tmxEvent.removeListener(document, 'mouseup', this.mouseUpListener);\n};\n\n__mxOutput.mxPanningHandler = typeof mxPanningHandler !== 'undefined' ? mxPanningHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxPopupMenuHandler\n *\n * Event handler that creates popupmenus.\n *\n * Constructor: mxPopupMenuHandler\n *\n * Constructs an event handler that creates a <mxPopupMenu>.\n */\nfunction mxPopupMenuHandler(graph, factoryMethod)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.factoryMethod = factoryMethod;\n\t\tthis.graph.addMouseListener(this);\n\n\t\t// Does not show menu if any touch gestures take place after the trigger\n\t\tthis.gestureHandler = mxUtils.bind(this, function(sender, eo)\n\t\t{\n\t\t\tthis.inTolerance = false;\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.GESTURE, this.gestureHandler);\n\n\t\tthis.init();\n\t}\n};\n\n/**\n * Extends mxPopupMenu.\n */\nmxPopupMenuHandler.prototype = new mxPopupMenu();\nmxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxPopupMenuHandler.prototype.graph = null;\n\n/**\n * Variable: selectOnPopup\n *\n * Specifies if cells should be selected if a popupmenu is displayed for\n * them. Default is true.\n */\nmxPopupMenuHandler.prototype.selectOnPopup = true;\n\n/**\n * Variable: clearSelectionOnBackground\n *\n * Specifies if cells should be deselected if a popupmenu is displayed for\n * the diagram background. Default is true.\n */\nmxPopupMenuHandler.prototype.clearSelectionOnBackground = true;\n\n/**\n * Variable: triggerX\n *\n * X-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.triggerX = null;\n\n/**\n * Variable: triggerY\n *\n * Y-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.triggerY = null;\n\n/**\n * Variable: screenX\n *\n * Screen X-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.screenX = null;\n\n/**\n * Variable: screenY\n *\n * Screen Y-coordinate of the mouse down event.\n */\nmxPopupMenuHandler.prototype.screenY = null;\n\n/**\n * Function: init\n *\n * Initializes the shapes required for this vertex handler.\n */\nmxPopupMenuHandler.prototype.init = function()\n{\n\t// Supercall\n\tmxPopupMenu.prototype.init.apply(this);\n\n\t// Hides the tooltip if the mouse is over\n\t// the context menu\n\tmxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.graph.tooltipHandler.hide();\n\t}));\n};\n\n/**\n * Function: isSelectOnPopup\n *\n * Hook for returning if a cell should be selected for a given <mxMouseEvent>.\n * This implementation returns <selectOnPopup>.\n */\nmxPopupMenuHandler.prototype.isSelectOnPopup = function(me)\n{\n\treturn this.selectOnPopup;\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by initiating the panning. By consuming the event all\n * subsequent events of the gesture are redirected to this handler.\n */\nmxPopupMenuHandler.prototype.mouseDown = function(sender, me)\n{\n\tif (this.isEnabled() && !mxEvent.isMultiTouchEvent(me.getEvent()))\n\t{\n\t\t// Hides the popupmenu if is is being displayed\n\t\tthis.hideMenu();\n\t\tthis.triggerX = me.getGraphX();\n\t\tthis.triggerY = me.getGraphY();\n\t\tthis.screenX = mxEvent.getMainEvent(me.getEvent()).screenX;\n\t\tthis.screenY = mxEvent.getMainEvent(me.getEvent()).screenY;\n\t\tthis.popupTrigger = this.isPopupTrigger(me);\n\t\tthis.inTolerance = true;\n\t}\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by updating the panning on the graph.\n */\nmxPopupMenuHandler.prototype.mouseMove = function(sender, me)\n{\n\t// Popup trigger may change on mouseUp so ignore it\n\tif (this.inTolerance && this.screenX != null && this.screenY != null)\n\t{\n\t\tif (Math.abs(mxEvent.getMainEvent(me.getEvent()).screenX - this.screenX) > this.graph.tolerance ||\n\t\t\tMath.abs(mxEvent.getMainEvent(me.getEvent()).screenY - this.screenY) > this.graph.tolerance)\n\t\t{\n\t\t\tthis.inTolerance = false;\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by setting the translation on the view or showing the\n * popupmenu.\n */\nmxPopupMenuHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null)\n\t{\n\t\tvar cell = this.getCellForPopupEvent(me);\n\n\t\t// Selects the cell for which the context menu is being displayed\n\t\tif (this.graph.isEnabled() && this.isSelectOnPopup(me) &&\n\t\t\tcell != null && !this.graph.isCellSelected(cell))\n\t\t{\n\t\t\tthis.graph.setSelectionCell(cell);\n\t\t}\n\t\telse if (this.clearSelectionOnBackground && cell == null)\n\t\t{\n\t\t\tthis.graph.clearSelection();\n\t\t}\n\n\t\t// Hides the tooltip if there is one\n\t\tthis.graph.tooltipHandler.hide();\n\n\t\t// Menu is shifted by 1 pixel so that the mouse up event\n\t\t// is routed via the underlying shape instead of the DIV\n\t\tvar origin = mxUtils.getScrollOrigin();\n\t\tthis.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell, me.getEvent());\n\t\tme.consume();\n\t}\n\n\tthis.popupTrigger = false;\n\tthis.inTolerance = false;\n};\n\n/**\n * Function: getCellForPopupEvent\n *\n * Hook to return the cell for the mouse up popup trigger handling.\n */\nmxPopupMenuHandler.prototype.getCellForPopupEvent = function(me)\n{\n\treturn me.getCell();\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxPopupMenuHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\tthis.graph.removeListener(this.gestureHandler);\n\n\t// Supercall\n\tmxPopupMenu.prototype.destroy.apply(this);\n};\n\n__mxOutput.mxPopupMenuHandler = typeof mxPopupMenuHandler !== 'undefined' ? mxPopupMenuHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellMarker\n *\n * A helper class to process mouse locations and highlight cells.\n *\n * Helper class to highlight cells. To add a cell marker to an existing graph\n * for highlighting all cells, the following code is used:\n *\n * (code)\n * var marker = new mxCellMarker(graph);\n * graph.addMouseListener({\n *   mouseDown: function() {},\n *   mouseMove: function(sender, me)\n *   {\n *     marker.process(me);\n *   },\n *   mouseUp: function() {}\n * });\n * (end)\n *\n * Event: mxEvent.MARK\n *\n * Fires after a cell has been marked or unmarked. The <code>state</code>\n * property contains the marked <mxCellState> or null if no state is marked.\n *\n * Constructor: mxCellMarker\n *\n * Constructs a new cell marker.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * validColor - Optional marker color for valid states. Default is\n * <mxConstants.DEFAULT_VALID_COLOR>.\n * invalidColor - Optional marker color for invalid states. Default is\n * <mxConstants.DEFAULT_INVALID_COLOR>.\n * hotspot - Portion of the width and hight where a state intersects a\n * given coordinate pair. A value of 0 means always highlight. Default is\n * <mxConstants.DEFAULT_HOTSPOT>.\n */\nfunction mxCellMarker(graph, validColor, invalidColor, hotspot)\n{\n\tmxEventSource.call(this);\n\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.validColor = (validColor != null) ? validColor : mxConstants.DEFAULT_VALID_COLOR;\n\t\tthis.invalidColor = (invalidColor != null) ? invalidColor : mxConstants.DEFAULT_INVALID_COLOR;\n\t\tthis.hotspot = (hotspot != null) ? hotspot : mxConstants.DEFAULT_HOTSPOT;\n\n\t\tthis.highlight = new mxCellHighlight(graph);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxCellMarker, mxEventSource);\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxCellMarker.prototype.graph = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if the marker is enabled. Default is true.\n */\nmxCellMarker.prototype.enabled = true;\n\n/**\n * Variable: hotspot\n *\n * Specifies the portion of the width and height that should trigger\n * a highlight. The area around the center of the cell to be marked is used\n * as the hotspot. Possible values are between 0 and 1. Default is\n * mxConstants.DEFAULT_HOTSPOT.\n */\nmxCellMarker.prototype.hotspot = mxConstants.DEFAULT_HOTSPOT;\n\n/**\n * Variable: hotspotEnabled\n *\n * Specifies if the hotspot is enabled. Default is false.\n */\nmxCellMarker.prototype.hotspotEnabled = false;\n\n/**\n * Variable: validColor\n *\n * Holds the valid marker color.\n */\nmxCellMarker.prototype.validColor = null;\n\n/**\n * Variable: invalidColor\n *\n * Holds the invalid marker color.\n */\nmxCellMarker.prototype.invalidColor = null;\n\n/**\n * Variable: currentColor\n *\n * Holds the current marker color.\n */\nmxCellMarker.prototype.currentColor = null;\n\n/**\n * Variable: validState\n *\n * Holds the marked <mxCellState> if it is valid.\n */\nmxCellMarker.prototype.validState = null;\n\n/**\n * Variable: markedState\n *\n * Holds the marked <mxCellState>.\n */\nmxCellMarker.prototype.markedState = null;\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n *\n * Parameters:\n *\n * enabled - Boolean that specifies the new enabled state.\n */\nmxCellMarker.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxCellMarker.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setHotspot\n *\n * Sets the <hotspot>.\n */\nmxCellMarker.prototype.setHotspot = function(hotspot)\n{\n\tthis.hotspot = hotspot;\n};\n\n/**\n * Function: getHotspot\n *\n * Returns the <hotspot>.\n */\nmxCellMarker.prototype.getHotspot = function()\n{\n\treturn this.hotspot;\n};\n\n/**\n * Function: setHotspotEnabled\n *\n * Specifies whether the hotspot should be used in <intersects>.\n */\nmxCellMarker.prototype.setHotspotEnabled = function(enabled)\n{\n\tthis.hotspotEnabled = enabled;\n};\n\n/**\n * Function: isHotspotEnabled\n *\n * Returns true if hotspot is used in <intersects>.\n */\nmxCellMarker.prototype.isHotspotEnabled = function()\n{\n\treturn this.hotspotEnabled;\n};\n\n/**\n * Function: hasValidState\n *\n * Returns true if <validState> is not null.\n */\nmxCellMarker.prototype.hasValidState = function()\n{\n\treturn this.validState != null;\n};\n\n/**\n * Function: getValidState\n *\n * Returns the <validState>.\n */\nmxCellMarker.prototype.getValidState = function()\n{\n\treturn this.validState;\n};\n\n/**\n * Function: getMarkedState\n *\n * Returns the <markedState>.\n */\nmxCellMarker.prototype.getMarkedState = function()\n{\n\treturn this.markedState;\n};\n\n/**\n * Function: reset\n *\n * Resets the state of the cell marker.\n */\nmxCellMarker.prototype.reset = function()\n{\n\tthis.validState = null;\n\n\tif (this.markedState != null)\n\t{\n\t\tthis.markedState = null;\n\t\tthis.unmark();\n\t}\n};\n\n/**\n * Function: process\n *\n * Processes the given event and cell and marks the state returned by\n * <getState> with the color returned by <getMarkerColor>. If the\n * markerColor is not null, then the state is stored in <markedState>. If\n * <isValidState> returns true, then the state is stored in <validState>\n * regardless of the marker color. The state is returned regardless of the\n * marker color and valid state.\n */\nmxCellMarker.prototype.process = function(me)\n{\n\tvar state = null;\n\n\tif (this.isEnabled())\n\t{\n\t\tstate = this.getState(me);\n\t\tthis.setCurrentState(state, me);\n\t}\n\n\treturn state;\n};\n\n/**\n * Function: setCurrentState\n *\n * Sets and marks the current valid state.\n */\nmxCellMarker.prototype.setCurrentState = function(state, me, color)\n{\n\tvar isValid = (state != null) ? this.isValidState(state) : false;\n\tcolor = (color != null) ? color : this.getMarkerColor(me.getEvent(), state, isValid);\n\n\tif (isValid)\n\t{\n\t\tthis.validState = state;\n\t}\n\telse\n\t{\n\t\tthis.validState = null;\n\t}\n\n\tif (state != this.markedState || color != this.currentColor)\n\t{\n\t\tthis.currentColor = color;\n\n\t\tif (state != null && this.currentColor != null)\n\t\t{\n\t\t\tthis.markedState = state;\n\t\t\tthis.mark();\n\t\t}\n\t\telse if (this.markedState != null)\n\t\t{\n\t\t\tthis.markedState = null;\n\t\t\tthis.unmark();\n\t\t}\n\t}\n};\n\n/**\n * Function: markCell\n *\n * Marks the given cell using the given color, or <validColor> if no color is specified.\n */\nmxCellMarker.prototype.markCell = function(cell, color)\n{\n\tvar state = this.graph.getView().getState(cell);\n\n\tif (state != null)\n\t{\n\t\tthis.currentColor = (color != null) ? color : this.validColor;\n\t\tthis.markedState = state;\n\t\tthis.mark();\n\t}\n};\n\n/**\n * Function: mark\n *\n * Marks the <markedState> and fires a <mark> event.\n */\nmxCellMarker.prototype.mark = function()\n{\n\tthis.highlight.setHighlightColor(this.currentColor);\n\tthis.highlight.highlight(this.markedState);\n\tthis.fireEvent(new mxEventObject(mxEvent.MARK, 'state', this.markedState));\n};\n\n/**\n * Function: unmark\n *\n * Hides the marker and fires a <mark> event.\n */\nmxCellMarker.prototype.unmark = function()\n{\n\tthis.mark();\n};\n\n/**\n * Function: isValidState\n *\n * Returns true if the given <mxCellState> is a valid state. If this\n * returns true, then the state is stored in <validState>. The return value\n * of this method is used as the argument for <getMarkerColor>.\n */\nmxCellMarker.prototype.isValidState = function(state)\n{\n\treturn true;\n};\n\n/**\n * Function: getMarkerColor\n *\n * Returns the valid- or invalidColor depending on the value of isValid.\n * The given <mxCellState> is ignored by this implementation.\n */\nmxCellMarker.prototype.getMarkerColor = function(evt, state, isValid)\n{\n\treturn (isValid) ? this.validColor : this.invalidColor;\n};\n\n/**\n * Function: getState\n *\n * Uses <getCell>, <getStateToMark> and <intersects> to return the\n * <mxCellState> for the given <mxMouseEvent>.\n */\nmxCellMarker.prototype.getState = function(me)\n{\n\tvar view = this.graph.getView();\n\tvar cell = this.getCell(me);\n\tvar state = this.getStateToMark(view.getState(cell));\n\n\treturn (state != null && this.intersects(state, me)) ? state : null;\n};\n\n/**\n * Function: getCell\n *\n * Returns the <mxCell> for the given event and cell. This returns the\n * given cell.\n */\nmxCellMarker.prototype.getCell = function(me)\n{\n\treturn me.getCell();\n};\n\n/**\n * Function: getStateToMark\n *\n * Returns the <mxCellState> to be marked for the given <mxCellState> under\n * the mouse. This returns the given state.\n */\nmxCellMarker.prototype.getStateToMark = function(state)\n{\n\treturn state;\n};\n\n/**\n * Function: intersects\n *\n * Returns true if the given coordinate pair intersects the given state.\n * This returns true if the <hotspot> is 0 or the coordinates are inside\n * the hotspot for the given cell state.\n */\nmxCellMarker.prototype.intersects = function(state, me)\n{\n\tif (this.hotspotEnabled)\n\t{\n\t\treturn mxUtils.intersectsHotspot(state, me.getGraphX(), me.getGraphY(),\n\t\t\tthis.hotspot, mxConstants.MIN_HOTSPOT_SIZE,\n\t\t\tmxConstants.MAX_HOTSPOT_SIZE);\n\t}\n\n\treturn true;\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxCellMarker.prototype.destroy = function()\n{\n\tthis.graph.getView().removeListener(this.resetHandler);\n\tthis.graph.getModel().removeListener(this.resetHandler);\n\tthis.highlight.destroy();\n};\n\n__mxOutput.mxCellMarker = typeof mxCellMarker !== 'undefined' ? mxCellMarker : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxSelectionCellsHandler\n *\n * An event handler that manages cell handlers and invokes their mouse event\n * processing functions.\n *\n * Group: Events\n *\n * Event: mxEvent.ADD\n *\n * Fires if a cell has been added to the selection. The <code>state</code>\n * property contains the <mxCellState> that has been added.\n *\n * Event: mxEvent.REMOVE\n *\n * Fires if a cell has been remove from the selection. The <code>state</code>\n * property contains the <mxCellState> that has been removed.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n */\nfunction mxSelectionCellsHandler(graph)\n{\n\tmxEventSource.call(this);\n\n\tthis.graph = graph;\n\tthis.handlers = new mxDictionary();\n\tthis.graph.addMouseListener(this);\n\n\tthis.refreshHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.isEnabled())\n\t\t{\n\t\t\tthis.refresh();\n\t\t}\n\t});\n\n\tthis.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.refreshHandler);\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.TRANSLATE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.DOWN, this.refreshHandler);\n\tthis.graph.getView().addListener(mxEvent.UP, this.refreshHandler);\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxSelectionCellsHandler, mxEventSource);\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxSelectionCellsHandler.prototype.graph = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxSelectionCellsHandler.prototype.enabled = true;\n\n/**\n * Variable: refreshHandler\n *\n * Keeps a reference to an event listener for later removal.\n */\nmxSelectionCellsHandler.prototype.refreshHandler = null;\n\n/**\n * Variable: maxHandlers\n *\n * Defines the maximum number of handlers to paint individually. Default is 100.\n */\nmxSelectionCellsHandler.prototype.maxHandlers = 100;\n\n/**\n * Variable: handlers\n *\n * <mxDictionary> that maps from cells to handlers.\n */\nmxSelectionCellsHandler.prototype.handlers = null;\n\n/**\n * Function: isEnabled\n *\n * Returns <enabled>.\n */\nmxSelectionCellsHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Sets <enabled>.\n */\nmxSelectionCellsHandler.prototype.setEnabled = function(value)\n{\n\tthis.enabled = value;\n};\n\n/**\n * Function: getHandler\n *\n * Returns the handler for the given cell.\n */\nmxSelectionCellsHandler.prototype.getHandler = function(cell)\n{\n\treturn this.handlers.get(cell);\n};\n\n/**\n * Function: reset\n *\n * Resets all handlers.\n */\nmxSelectionCellsHandler.prototype.reset = function()\n{\n\tthis.handlers.visit(function(key, handler)\n\t{\n\t\thandler.reset.apply(handler);\n\t});\n};\n\n/**\n * Function: refresh\n *\n * Reloads or updates all handlers.\n */\nmxSelectionCellsHandler.prototype.refresh = function()\n{\n\t// Removes all existing handlers\n\tvar oldHandlers = this.handlers;\n\tthis.handlers = new mxDictionary();\n\n\t// Creates handles for all selection cells\n\tvar tmp = this.graph.getSelectionCells();\n\n\tfor (var i = 0; i < tmp.length; i++)\n\t{\n\t\tvar state = this.graph.view.getState(tmp[i]);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tvar handler = oldHandlers.remove(tmp[i]);\n\n\t\t\tif (handler != null)\n\t\t\t{\n\t\t\t\tif (handler.state != state)\n\t\t\t\t{\n\t\t\t\t\thandler.destroy();\n\t\t\t\t\thandler = null;\n\t\t\t\t}\n\t\t\t\telse if (!this.isHandlerActive(handler))\n\t\t\t\t{\n\t\t\t\t\tif (handler.refresh != null)\n\t\t\t\t\t{\n\t\t\t\t\t\thandler.refresh();\n\t\t\t\t\t}\n\n\t\t\t\t\thandler.redraw();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (handler == null)\n\t\t\t{\n\t\t\t\thandler = this.graph.createHandler(state);\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ADD, 'state', state));\n\t\t\t}\n\n\t\t\tif (handler != null)\n\t\t\t{\n\t\t\t\tthis.handlers.put(tmp[i], handler);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Destroys all unused handlers\n\toldHandlers.visit(mxUtils.bind(this, function(key, handler)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.REMOVE, 'state', handler.state));\n\t\thandler.destroy();\n\t}));\n};\n\n/**\n * Function: isHandlerActive\n *\n * Returns true if the given handler is active and should not be redrawn.\n */\nmxSelectionCellsHandler.prototype.isHandlerActive = function(handler)\n{\n\treturn handler.index != null;\n};\n\n/**\n * Function: updateHandler\n *\n * Updates the handler for the given shape if one exists.\n */\nmxSelectionCellsHandler.prototype.updateHandler = function(state)\n{\n\tvar handler = this.handlers.remove(state.cell);\n\n\tif (handler != null)\n\t{\n\t\t// Transfers the current state to the new handler\n\t\tvar index = handler.index;\n\t\tvar x = handler.startX;\n\t\tvar y = handler.startY;\n\n\t\thandler.destroy();\n\t\thandler = this.graph.createHandler(state);\n\n\t\tif (handler != null)\n\t\t{\n\t\t\tthis.handlers.put(state.cell, handler);\n\n\t\t\tif (index != null && x != null && y != null)\n\t\t\t{\n\t\t\t\thandler.start(x, y, index);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseDown\n *\n * Redirects the given event to the handlers.\n */\nmxSelectionCellsHandler.prototype.mouseDown = function(sender, me)\n{\n\tif (this.graph.isEnabled() && this.isEnabled())\n\t{\n\t\tvar args = [sender, me];\n\n\t\tthis.handlers.visit(function(key, handler)\n\t\t{\n\t\t\thandler.mouseDown.apply(handler, args);\n\t\t});\n\t}\n};\n\n/**\n * Function: mouseMove\n *\n * Redirects the given event to the handlers.\n */\nmxSelectionCellsHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (this.graph.isEnabled() && this.isEnabled())\n\t{\n\t\tvar args = [sender, me];\n\n\t\tthis.handlers.visit(function(key, handler)\n\t\t{\n\t\t\thandler.mouseMove.apply(handler, args);\n\t\t});\n\t}\n};\n\n/**\n * Function: mouseUp\n *\n * Redirects the given event to the handlers.\n */\nmxSelectionCellsHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.graph.isEnabled() && this.isEnabled())\n\t{\n\t\tvar args = [sender, me];\n\n\t\tthis.handlers.visit(function(key, handler)\n\t\t{\n\t\t\thandler.mouseUp.apply(handler, args);\n\t\t});\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxSelectionCellsHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\n\tif (this.refreshHandler != null)\n\t{\n\t\tthis.graph.getSelectionModel().removeListener(this.refreshHandler);\n\t\tthis.graph.getModel().removeListener(this.refreshHandler);\n\t\tthis.graph.getView().removeListener(this.refreshHandler);\n\t\tthis.refreshHandler = null;\n\t}\n};\n\n__mxOutput.mxSelectionCellsHandler = typeof mxSelectionCellsHandler !== 'undefined' ? mxSelectionCellsHandler : undefined;\n\n/**\n * Copyright (c) 2006-2016, JGraph Ltd\n * Copyright (c) 2006-2016, Gaudenz Alder\n */\n/**\n * Class: mxConnectionHandler\n *\n * Graph event handler that creates new connections. Uses <mxTerminalMarker>\n * for finding and highlighting the source and target vertices and\n * <factoryMethod> to create the edge instance. This handler is built-into\n * <mxGraph.connectionHandler> and enabled using <mxGraph.setConnectable>.\n *\n * Example:\n *\n * (code)\n * new mxConnectionHandler(graph, function(source, target, style)\n * {\n *   edge = new mxCell('', new mxGeometry());\n *   edge.setEdge(true);\n *   edge.setStyle(style);\n *   edge.geometry.relative = true;\n *   return edge;\n * });\n * (end)\n *\n * Here is an alternative solution that just sets a specific user object for\n * new edges by overriding <insertEdge>.\n *\n * (code)\n * mxConnectionHandlerInsertEdge = mxConnectionHandler.prototype.insertEdge;\n * mxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\n * {\n *   value = 'Test';\n *\n *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\n * };\n * (end)\n *\n * Using images to trigger connections:\n *\n * This handler uses mxTerminalMarker to find the source and target cell for\n * the new connection and creates a new edge using <connect>. The new edge is\n * created using <createEdge> which in turn uses <factoryMethod> or creates a\n * new default edge.\n *\n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\n * used as a source or target terminal, as seen in other diagramming products.\n * In order to allow both, moving and connecting cells at the same time,\n * <mxConstants.DEFAULT_HOTSPOT> is used in the handler to determine the hotspot\n * of a cell, that is, the region of the cell which is used to trigger a new\n * connection. The constant is a value between 0 and 1 that specifies the\n * amount of the width and height around the center to be used for the hotspot\n * of a cell and its default value is 0.5. In addition,\n * <mxConstants.MIN_HOTSPOT_SIZE> defines the minimum number of pixels for the\n * width and height of the hotspot.\n *\n * This solution, while standards compliant, may be somewhat confusing because\n * there is no visual indicator for the hotspot and the highlight is seen to\n * switch on and off while the mouse is being moved in and out. Furthermore,\n * this paradigm does not allow to create different connections depending on\n * the highlighted hotspot as there is only one hotspot per cell and it\n * normally does not allow cells to be moved and connected at the same time as\n * there is no clear indication of the connectable area of the cell.\n *\n * To come across these issues, the handle has an additional <createIcons> hook\n * with a default implementation that allows to create one icon to be used to\n * trigger new connections. If this icon is specified, then new connections can\n * only be created if the image is clicked while the cell is being highlighted.\n * The <createIcons> hook may be overridden to create more than one\n * <mxImageShape> for creating new connections, but the default implementation\n * supports one image and is used as follows:\n *\n * In order to display the \"connect image\" whenever the mouse is over the cell,\n * an DEFAULT_HOTSPOT of 1 should be used:\n *\n * (code)\n * mxConstants.DEFAULT_HOTSPOT = 1;\n * (end)\n *\n * In order to avoid confusion with the highlighting, the highlight color\n * should not be used with a connect image:\n *\n * (code)\n * mxConstants.HIGHLIGHT_COLOR = null;\n * (end)\n *\n * To install the image, the connectImage field of the mxConnectionHandler must\n * be assigned a new <mxImage> instance:\n *\n * (code)\n * mxConnectionHandler.prototype.connectImage = new mxImage('images/green-dot.gif', 14, 14);\n * (end)\n *\n * This will use the green-dot.gif with a width and height of 14 pixels as the\n * image to trigger new connections. In createIcons the icon field of the\n * handler will be set in order to remember the icon that has been clicked for\n * creating the new connection. This field will be available under selectedIcon\n * in the connect method, which may be overridden to take the icon that\n * triggered the new connection into account. This is useful if more than one\n * icon may be used to create a connection.\n *\n * Group: Events\n *\n * Event: mxEvent.START\n *\n * Fires when a new connection is being created by the user. The <code>state</code>\n * property contains the state of the source cell.\n *\n * Event: mxEvent.CONNECT\n *\n * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\n * property contains the inserted edge, the <code>event</code> and <code>target</code>\n * properties contain the respective arguments that were passed to <connect> (where\n * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\n * property corresponds to the target argument in <connect> or the clone of the source\n * terminal if <createTarget> is enabled.\n *\n * Note that the target is the cell under the mouse where the mouse button was released.\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\n * of the inserted edge. To print the source, target or any optional ports IDs that the\n * edge is connected to, the following code can be used. To get more details about the\n * actual connection point, <mxGraph.getConnectionConstraint> can be used. To resolve\n * the port IDs, use <mxGraphModel.getCell>.\n *\n * (code)\n * graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt)\n * {\n *   var edge = evt.getProperty('cell');\n *   var source = graph.getModel().getTerminal(edge, true);\n *   var target = graph.getModel().getTerminal(edge, false);\n *\n *   var style = graph.getCellStyle(edge);\n *   var sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\n *   var targetPortId = style[mxConstants.STYLE_TARGET_PORT];\n *\n *   mxLog.show();\n *   mxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\n * });\n * (end)\n *\n * Event: mxEvent.RESET\n *\n * Fires when the <reset> method is invoked.\n *\n * Constructor: mxConnectionHandler\n *\n * Constructs an event handler that connects vertices using the specified\n * factory method to create the new edges. Modify\n * <mxConstants.ACTIVE_REGION> to setup the region on a cell which triggers\n * the creation of a new connection or use connect icons as explained\n * above.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * factoryMethod - Optional function to create the edge. The function takes\n * the source and target <mxCell> as the first and second argument and an\n * optional cell style from the preview as the third argument. It returns\n * the <mxCell> that represents the new edge.\n */\nfunction mxConnectionHandler(graph, factoryMethod)\n{\n\tmxEventSource.call(this);\n\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.factoryMethod = factoryMethod;\n\t\tthis.init();\n\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tthis.reset();\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n};\n\n/**\n * Extends mxEventSource.\n */\nmxUtils.extend(mxConnectionHandler, mxEventSource);\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxConnectionHandler.prototype.graph = null;\n\n/**\n * Variable: factoryMethod\n *\n * Function that is used for creating new edges. The function takes the\n * source and target <mxCell> as the first and second argument and returns\n * a new <mxCell> that represents the edge. This is used in <createEdge>.\n */\nmxConnectionHandler.prototype.factoryMethod = true;\n\n/**\n * Variable: moveIconFront\n *\n * Specifies if icons should be displayed inside the graph container instead\n * of the overlay pane. This is used for HTML labels on vertices which hide\n * the connect icon. This has precendence over <moveIconBack> when set\n * to true. Default is false.\n */\nmxConnectionHandler.prototype.moveIconFront = false;\n\n/**\n * Variable: moveIconBack\n *\n * Specifies if icons should be moved to the back of the overlay pane. This can\n * be set to true if the icons of the connection handler conflict with other\n * handles, such as the vertex label move handle. Default is false.\n */\nmxConnectionHandler.prototype.moveIconBack = false;\n\n/**\n * Variable: connectImage\n *\n * <mxImage> that is used to trigger the creation of a new connection. This\n * is used in <createIcons>. Default is null.\n */\nmxConnectionHandler.prototype.connectImage = null;\n\n/**\n * Variable: targetConnectImage\n *\n * Specifies if the connect icon should be centered on the target state\n * while connections are being previewed. Default is false.\n */\nmxConnectionHandler.prototype.targetConnectImage = false;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxConnectionHandler.prototype.enabled = true;\n\n/**\n * Variable: select\n *\n * Specifies if new edges should be selected. Default is true.\n */\nmxConnectionHandler.prototype.select = true;\n\n/**\n * Variable: createTarget\n *\n * Specifies if <createTargetVertex> should be called if no target was under the\n * mouse for the new connection. Setting this to true means the connection\n * will be drawn as valid if no target is under the mouse, and\n * <createTargetVertex> will be called before the connection is created between\n * the source cell and the newly created vertex in <createTargetVertex>, which\n * can be overridden to create a new target. Default is false.\n */\nmxConnectionHandler.prototype.createTarget = false;\n\n/**\n * Variable: marker\n *\n * Holds the <mxTerminalMarker> used for finding source and target cells.\n */\nmxConnectionHandler.prototype.marker = null;\n\n/**\n * Variable: constraintHandler\n *\n * Holds the <mxConstraintHandler> used for drawing and highlighting\n * constraints.\n */\nmxConnectionHandler.prototype.constraintHandler = null;\n\n/**\n * Variable: error\n *\n * Holds the current validation error while connections are being created.\n */\nmxConnectionHandler.prototype.error = null;\n\n/**\n * Variable: waypointsEnabled\n *\n * Specifies if single clicks should add waypoints on the new edge. Default is\n * false.\n */\nmxConnectionHandler.prototype.waypointsEnabled = false;\n\n/**\n * Variable: ignoreMouseDown\n *\n * Specifies if the connection handler should ignore the state of the mouse\n * button when highlighting the source. Default is false, that is, the\n * handler only highlights the source if no button is being pressed.\n */\nmxConnectionHandler.prototype.ignoreMouseDown = false;\n\n/**\n * Variable: first\n *\n * Holds the <mxPoint> where the mouseDown took place while the handler is\n * active.\n */\nmxConnectionHandler.prototype.first = null;\n\n/**\n * Variable: connectIconOffset\n *\n * Holds the offset for connect icons during connection preview.\n * Default is mxPoint(0, <mxConstants.TOOLTIP_VERTICAL_OFFSET>).\n * Note that placing the icon under the mouse pointer with an\n * offset of (0,0) will affect hit detection.\n */\nmxConnectionHandler.prototype.connectIconOffset = new mxPoint(0, mxConstants.TOOLTIP_VERTICAL_OFFSET);\n\n/**\n * Variable: edgeState\n *\n * Optional <mxCellState> that represents the preview edge while the\n * handler is active. This is created in <createEdgeState>.\n */\nmxConnectionHandler.prototype.edgeState = null;\n\n/**\n * Variable: changeHandler\n *\n * Holds the change event listener for later removal.\n */\nmxConnectionHandler.prototype.changeHandler = null;\n\n/**\n * Variable: drillHandler\n *\n * Holds the drill event listener for later removal.\n */\nmxConnectionHandler.prototype.drillHandler = null;\n\n/**\n * Variable: mouseDownCounter\n *\n * Counts the number of mouseDown events since the start. The initial mouse\n * down event counts as 1.\n */\nmxConnectionHandler.prototype.mouseDownCounter = 0;\n\n/**\n * Variable: movePreviewAway\n *\n * Switch to enable moving the preview away from the mousepointer. This is required in browsers\n * where the preview cannot be made transparent to events and if the built-in hit detection on\n * the HTML elements in the page should be used. Default is the value of <mxClient.IS_VML>.\n */\nmxConnectionHandler.prototype.movePreviewAway = mxClient.IS_VML;\n\n/**\n * Variable: outlineConnect\n *\n * Specifies if connections to the outline of a highlighted target should be\n * enabled. This will allow to place the connection point along the outline of\n * the highlighted target. Default is false.\n */\nmxConnectionHandler.prototype.outlineConnect = false;\n\n/**\n * Variable: livePreview\n *\n * Specifies if the actual shape of the edge state should be used for the preview.\n * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\n */\nmxConnectionHandler.prototype.livePreview = false;\n\n/**\n * Variable: cursor\n *\n * Specifies the cursor to be used while the handler is active. Default is null.\n */\nmxConnectionHandler.prototype.cursor = null;\n\n/**\n * Variable: insertBeforeSource\n *\n * Specifies if new edges should be inserted before the source vertex in the\n * cell hierarchy. Default is false for backwards compatibility.\n */\nmxConnectionHandler.prototype.insertBeforeSource = false;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxConnectionHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n *\n * Parameters:\n *\n * enabled - Boolean that specifies the new enabled state.\n */\nmxConnectionHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isInsertBefore\n *\n * Returns <insertBeforeSource> for non-loops and false for loops.\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge to be inserted.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * evt - Mousedown event of the connect gesture.\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\n * released.\n */\nmxConnectionHandler.prototype.isInsertBefore = function(edge, source, target, evt, dropTarget)\n{\n\treturn this.insertBeforeSource && source != target;\n};\n\n/**\n * Function: isCreateTarget\n *\n * Returns <createTarget>.\n *\n * Parameters:\n *\n * evt - Current active native pointer event.\n */\nmxConnectionHandler.prototype.isCreateTarget = function(evt)\n{\n\treturn this.createTarget;\n};\n\n/**\n * Function: setCreateTarget\n *\n * Sets <createTarget>.\n */\nmxConnectionHandler.prototype.setCreateTarget = function(value)\n{\n\tthis.createTarget = value;\n};\n\n/**\n * Function: createShape\n *\n * Creates the preview shape for new connections.\n */\nmxConnectionHandler.prototype.createShape = function()\n{\n\t// Creates the edge preview\n\tvar shape = (this.livePreview && this.edgeState != null) ?\n\t\tthis.graph.cellRenderer.createShape(this.edgeState) :\n\t\tnew mxPolyline([], mxConstants.INVALID_COLOR);\n\tshape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\tshape.scale = this.graph.view.scale;\n\tshape.pointerEvents = false;\n\tshape.isDashed = true;\n\tshape.init(this.graph.getView().getOverlayPane());\n\tmxEvent.redirectMouseEvents(shape.node, this.graph, null);\n\n\treturn shape;\n};\n\n/**\n * Function: init\n *\n * Initializes the shapes required for this connection handler. This should\n * be invoked if <mxGraph.container> is assigned after the connection\n * handler has been created.\n */\nmxConnectionHandler.prototype.init = function()\n{\n\tthis.graph.addMouseListener(this);\n\tthis.marker = this.createMarker();\n\tthis.constraintHandler = new mxConstraintHandler(this.graph);\n\n\t// Redraws the icons if the graph changes\n\tthis.changeHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tif (this.iconState != null)\n\t\t{\n\t\t\tthis.iconState = this.graph.getView().getState(this.iconState.cell);\n\t\t}\n\n\t\tif (this.iconState != null)\n\t\t{\n\t\t\tthis.redrawIcons(this.icons, this.iconState);\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\t\telse if (this.previous != null && this.graph.view.getState(this.previous.cell) == null)\n\t\t{\n\t\t\tthis.reset();\n\t\t}\n\t});\n\n\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.TRANSLATE, this.changeHandler);\n\tthis.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.changeHandler);\n\n\t// Removes the icon if we step into/up or start editing\n\tthis.drillHandler = mxUtils.bind(this, function(sender)\n\t{\n\t\tthis.reset();\n\t});\n\n\tthis.graph.addListener(mxEvent.START_EDITING, this.drillHandler);\n\tthis.graph.getView().addListener(mxEvent.DOWN, this.drillHandler);\n\tthis.graph.getView().addListener(mxEvent.UP, this.drillHandler);\n};\n\n/**\n * Function: isConnectableCell\n *\n * Returns true if the given cell is connectable. This is a hook to\n * disable floating connections. This implementation returns true.\n */\nmxConnectionHandler.prototype.isConnectableCell = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: createMarker\n *\n * Creates and returns the <mxCellMarker> used in <marker>.\n */\nmxConnectionHandler.prototype.createMarker = function()\n{\n\tvar marker = new mxCellMarker(this.graph);\n\tmarker.hotspotEnabled = true;\n\n\t// Overrides to return cell at location only if valid (so that\n\t// there is no highlight for invalid cells)\n\tmarker.getCell = mxUtils.bind(this, function(me)\n\t{\n\t\tvar cell = mxCellMarker.prototype.getCell.apply(marker, arguments);\n\t\tthis.error = null;\n\n\t\t// Checks for cell at preview point (with grid)\n\t\tif (cell == null && this.currentPoint != null)\n\t\t{\n\t\t\tcell = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);\n\t\t}\n\n\t\t// Uses connectable parent vertex if one exists\n\t\tif (cell != null && !this.graph.isCellConnectable(cell))\n\t\t{\n\t\t\tvar parent = this.graph.getModel().getParent(cell);\n\n\t\t\tif (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))\n\t\t\t{\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\n\t\tif ((this.graph.isSwimlane(cell) && this.currentPoint != null &&\n\t\t\tthis.graph.hitsSwimlaneContent(cell, this.currentPoint.x, this.currentPoint.y)) ||\n\t\t\t!this.isConnectableCell(cell))\n\t\t{\n\t\t\tcell = null;\n\t\t}\n\n\t\tif (cell != null)\n\t\t{\n\t\t\tif (this.isConnecting())\n\t\t\t{\n\t\t\t\tif (this.previous != null)\n\t\t\t\t{\n\t\t\t\t\tthis.error = this.validateConnection(this.previous.cell, cell);\n\n\t\t\t\t\tif (this.error != null && this.error.length == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcell = null;\n\n\t\t\t\t\t\t// Enables create target inside groups\n\t\t\t\t\t\tif (this.isCreateTarget(me.getEvent()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.error = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!this.isValidSource(cell, me))\n\t\t\t{\n\t\t\t\tcell = null;\n\t\t\t}\n\t\t}\n\t\telse if (this.isConnecting() && !this.isCreateTarget(me.getEvent()) &&\n\t\t\t\t!this.graph.allowDanglingEdges)\n\t\t{\n\t\t\tthis.error = '';\n\t\t}\n\n\t\treturn cell;\n\t});\n\n\t// Sets the highlight color according to validateConnection\n\tmarker.isValidState = mxUtils.bind(this, function(state)\n\t{\n\t\tif (this.isConnecting())\n\t\t{\n\t\t\treturn this.error == null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn mxCellMarker.prototype.isValidState.apply(marker, arguments);\n\t\t}\n\t});\n\n\t// Overrides to use marker color only in highlight mode or for\n\t// target selection\n\tmarker.getMarkerColor = mxUtils.bind(this, function(evt, state, isValid)\n\t{\n\t\treturn (this.connectImage == null || this.isConnecting()) ?\n\t\t\tmxCellMarker.prototype.getMarkerColor.apply(marker, arguments) :\n\t\t\tnull;\n\t});\n\n\t// Overrides to use hotspot only for source selection otherwise\n\t// intersects always returns true when over a cell\n\tmarker.intersects = mxUtils.bind(this, function(state, evt)\n\t{\n\t\tif (this.connectImage != null || this.isConnecting())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn mxCellMarker.prototype.intersects.apply(marker, arguments);\n\t});\n\n\treturn marker;\n};\n\n/**\n * Function: start\n *\n * Starts a new connection for the given state and coordinates.\n */\nmxConnectionHandler.prototype.start = function(state, x, y, edgeState)\n{\n\tthis.previous = state;\n\tthis.first = new mxPoint(x, y);\n\tthis.edgeState = (edgeState != null) ? edgeState : this.createEdgeState(null);\n\n\t// Marks the source state\n\tthis.marker.currentColor = this.marker.validColor;\n\tthis.marker.markedState = state;\n\tthis.marker.mark();\n\n\tthis.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));\n};\n\n/**\n * Function: isConnecting\n *\n * Returns true if the source terminal has been clicked and a new\n * connection is currently being previewed.\n */\nmxConnectionHandler.prototype.isConnecting = function()\n{\n\treturn this.first != null && this.shape != null;\n};\n\n/**\n * Function: isValidSource\n *\n * Returns <mxGraph.isValidSource> for the given source terminal.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the source terminal.\n * me - <mxMouseEvent> that is associated with this call.\n */\nmxConnectionHandler.prototype.isValidSource = function(cell, me)\n{\n\treturn this.graph.isValidSource(cell);\n};\n\n/**\n * Function: isValidTarget\n *\n * Returns true. The call to <mxGraph.isValidTarget> is implicit by calling\n * <mxGraph.getEdgeValidationError> in <validateConnection>. This is an\n * additional hook for disabling certain targets in this specific handler.\n *\n * Parameters:\n *\n * cell - <mxCell> that represents the target terminal.\n */\nmxConnectionHandler.prototype.isValidTarget = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: validateConnection\n *\n * Returns the error message or an empty string if the connection for the\n * given source target pair is not valid. Otherwise it returns null. This\n * implementation uses <mxGraph.getEdgeValidationError>.\n *\n * Parameters:\n *\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxConnectionHandler.prototype.validateConnection = function(source, target)\n{\n\tif (!this.isValidTarget(target))\n\t{\n\t\treturn '';\n\t}\n\n\treturn this.graph.getEdgeValidationError(null, source, target);\n};\n\n/**\n * Function: getConnectImage\n *\n * Hook to return the <mxImage> used for the connection icon of the given\n * <mxCellState>. This implementation returns <connectImage>.\n *\n * Parameters:\n *\n * state - <mxCellState> whose connect image should be returned.\n */\nmxConnectionHandler.prototype.getConnectImage = function(state)\n{\n\treturn this.connectImage;\n};\n\n/**\n * Function: isMoveIconToFrontForState\n *\n * Returns true if the state has a HTML label in the graph's container, otherwise\n * it returns <moveIconFront>.\n *\n * Parameters:\n *\n * state - <mxCellState> whose connect icons should be returned.\n */\nmxConnectionHandler.prototype.isMoveIconToFrontForState = function(state)\n{\n\tif (state.text != null && state.text.node.parentNode == this.graph.container)\n\t{\n\t\treturn true;\n\t}\n\n\treturn this.moveIconFront;\n};\n\n/**\n * Function: createIcons\n *\n * Creates the array <mxImageShapes> that represent the connect icons for\n * the given <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> whose connect icons should be returned.\n */\nmxConnectionHandler.prototype.createIcons = function(state)\n{\n\tvar image = this.getConnectImage(state);\n\n\tif (image != null && state != null)\n\t{\n\t\tthis.iconState = state;\n\t\tvar icons = [];\n\n\t\t// Cannot use HTML for the connect icons because the icon receives all\n\t\t// mouse move events in IE, must use VML and SVG instead even if the\n\t\t// connect-icon appears behind the selection border and the selection\n\t\t// border consumes the events before the icon gets a chance\n\t\tvar bounds = new mxRectangle(0, 0, image.width, image.height);\n\t\tvar icon = new mxImageShape(bounds, image.src, null, null, 0);\n\t\ticon.preserveImageAspect = false;\n\n\t\tif (this.isMoveIconToFrontForState(state))\n\t\t{\n\t\t\ticon.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\t\ticon.init(this.graph.container);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ticon.dialect = (this.graph.dialect == mxConstants.DIALECT_SVG) ?\n\t\t\t\tmxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;\n\t\t\ticon.init(this.graph.getView().getOverlayPane());\n\n\t\t\t// Move the icon back in the overlay pane\n\t\t\tif (this.moveIconBack && icon.node.previousSibling != null)\n\t\t\t{\n\t\t\t\ticon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n\t\t\t}\n\t\t}\n\n\t\ticon.node.style.cursor = mxConstants.CURSOR_CONNECT;\n\n\t\t// Events transparency\n\t\tvar getState = mxUtils.bind(this, function()\n\t\t{\n\t\t\treturn (this.currentState != null) ? this.currentState : state;\n\t\t});\n\n\t\t// Updates the local icon before firing the mouse down event.\n\t\tvar mouseDown = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tif (!mxEvent.isConsumed(evt))\n\t\t\t{\n\t\t\t\tthis.icon = icon;\n\t\t\t\tthis.graph.fireMouseEvent(mxEvent.MOUSE_DOWN,\n\t\t\t\t\tnew mxMouseEvent(evt, getState()));\n\t\t\t}\n\t\t});\n\n\t\tmxEvent.redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n\n\t\ticons.push(icon);\n\t\tthis.redrawIcons(icons, this.iconState);\n\n\t\treturn icons;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: redrawIcons\n *\n * Redraws the given array of <mxImageShapes>.\n *\n * Parameters:\n *\n * icons - Optional array of <mxImageShapes> to be redrawn.\n */\nmxConnectionHandler.prototype.redrawIcons = function(icons, state)\n{\n\tif (icons != null && icons[0] != null && state != null)\n\t{\n\t\tvar pos = this.getIconPosition(icons[0], state);\n\t\ticons[0].bounds.x = pos.x;\n\t\ticons[0].bounds.y = pos.y;\n\t\ticons[0].redraw();\n\t}\n};\n\n/**\n * Function: redrawIcons\n *\n * Redraws the given array of <mxImageShapes>.\n *\n * Parameters:\n *\n * icons - Optional array of <mxImageShapes> to be redrawn.\n */\nmxConnectionHandler.prototype.getIconPosition = function(icon, state)\n{\n\tvar scale = this.graph.getView().scale;\n\tvar cx = state.getCenterX();\n\tvar cy = state.getCenterY();\n\n\tif (this.graph.isSwimlane(state.cell))\n\t{\n\t\tvar size = this.graph.getStartSize(state.cell);\n\n\t\tcx = (size.width != 0) ? state.x + size.width * scale / 2 : cx;\n\t\tcy = (size.height != 0) ? state.y + size.height * scale / 2 : cy;\n\n\t\tvar alpha = mxUtils.toRadians(mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0);\n\n\t\tif (alpha != 0)\n\t\t{\n\t\t\tvar cos = Math.cos(alpha);\n\t\t\tvar sin = Math.sin(alpha);\n\t\t\tvar ct = new mxPoint(state.getCenterX(), state.getCenterY());\n\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(cx, cy), cos, sin, ct);\n\t\t\tcx = pt.x;\n\t\t\tcy = pt.y;\n\t\t}\n\t}\n\n\treturn new mxPoint(cx - icon.bounds.width / 2,\n\t\t\tcy - icon.bounds.height / 2);\n};\n\n/**\n * Function: destroyIcons\n *\n * Destroys the connect icons and resets the respective state.\n */\nmxConnectionHandler.prototype.destroyIcons = function()\n{\n\tif (this.icons != null)\n\t{\n\t\tfor (var i = 0; i < this.icons.length; i++)\n\t\t{\n\t\t\tthis.icons[i].destroy();\n\t\t}\n\n\t\tthis.icons = null;\n\t\tthis.icon = null;\n\t\tthis.selectedIcon = null;\n\t\tthis.iconState = null;\n\t}\n};\n\n/**\n * Function: isStartEvent\n *\n * Returns true if the given mouse down event should start this handler. The\n * This implementation returns true if the event does not force marquee\n * selection, and the currentConstraint and currentFocus of the\n * <constraintHandler> are not null, or <previous> and <error> are not null and\n * <icons> is null or <icons> and <icon> are not null.\n */\nmxConnectionHandler.prototype.isStartEvent = function(me)\n{\n\treturn ((this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) ||\n\t\t(this.previous != null && this.error == null && (this.icons == null || (this.icons != null &&\n\t\tthis.icon != null))));\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by initiating a new connection.\n */\nmxConnectionHandler.prototype.mouseDown = function(sender, me)\n{\n\tthis.mouseDownCounter++;\n\n\tif (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() &&\n\t\t!this.isConnecting() && this.isStartEvent(me))\n\t{\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t{\n\t\t\tthis.sourceConstraint = this.constraintHandler.currentConstraint;\n\t\t\tthis.previous = this.constraintHandler.currentFocus;\n\t\t\tthis.first = this.constraintHandler.currentPoint.clone();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Stores the location of the initial mousedown\n\t\t\tthis.first = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t}\n\n\t\tthis.edgeState = this.createEdgeState(me);\n\t\tthis.mouseDownCounter = 1;\n\n\t\tif (this.waypointsEnabled && this.shape == null)\n\t\t{\n\t\t\tthis.waypoints = null;\n\t\t\tthis.shape = this.createShape();\n\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tthis.shape.apply(this.edgeState);\n\t\t\t}\n\t\t}\n\n\t\t// Stores the starting point in the geometry of the preview\n\t\tif (this.previous == null && this.edgeState != null)\n\t\t{\n\t\t\tvar pt = this.graph.getPointForEvent(me.getEvent());\n\t\t\tthis.edgeState.cell.geometry.setTerminalPoint(pt, true);\n\t\t}\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.START, 'state', this.previous));\n\n\t\tme.consume();\n\t}\n\n\tthis.selectedIcon = this.icon;\n\tthis.icon = null;\n};\n\n/**\n * Function: isImmediateConnectSource\n *\n * Returns true if a tap on the given source state should immediately start\n * connecting. This implementation returns true if the state is not movable\n * in the graph.\n */\nmxConnectionHandler.prototype.isImmediateConnectSource = function(state)\n{\n\treturn !this.graph.isCellMovable(state.cell);\n};\n\n/**\n * Function: createEdgeState\n *\n * Hook to return an <mxCellState> which may be used during the preview.\n * This implementation returns null.\n *\n * Use the following code to create a preview for an existing edge style:\n *\n * (code)\n * graph.connectionHandler.createEdgeState = function(me)\n * {\n *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\n *\n *   return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));\n * };\n * (end)\n */\nmxConnectionHandler.prototype.createEdgeState = function(me)\n{\n\treturn null;\n};\n\n/**\n * Function: isOutlineConnectEvent\n *\n * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n * or shift is pressed.\n */\nmxConnectionHandler.prototype.isOutlineConnectEvent = function(me)\n{\n\tvar offset = mxUtils.getOffset(this.graph.container);\n\tvar evt = me.getEvent();\n\n\tvar clientX = mxEvent.getClientX(evt);\n\tvar clientY = mxEvent.getClientY(evt);\n\n\tvar doc = document.documentElement;\n\tvar left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n\tvar top = (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);\n\n\tvar gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n\tvar gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n\n\treturn this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) &&\n\t\t(me.isSource(this.marker.highlight.shape) ||\n\t\t(mxEvent.isAltDown(me.getEvent()) && me.getState() != null) ||\n\t\tthis.marker.highlight.isHighlightAt(clientX, clientY) ||\n\t\t((gridX != clientX || gridY != clientY) && me.getState() == null &&\n\t\tthis.marker.highlight.isHighlightAt(gridX, gridY)));\n};\n\n/**\n * Function: updateCurrentState\n *\n * Updates the current state for a given mouse move event by using\n * the <marker>.\n */\nmxConnectionHandler.prototype.updateCurrentState = function(me, point)\n{\n\tthis.constraintHandler.update(me, this.first == null, false, (this.first == null ||\n\t\tme.isSource(this.marker.highlight.shape)) ? null : point);\n\n\tif (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null)\n\t{\n\t\t// Handles special case where grid is large and connection point is at actual point in which\n\t\t// case the outline is not followed as long as we're < gridSize / 2 away from that point\n\t\tif (this.marker.highlight != null && this.marker.highlight.state != null &&\n\t\t\tthis.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell)\n\t\t{\n\t\t\t// Direct repaint needed if cell already highlighted\n\t\t\tif (this.marker.highlight.shape.stroke != 'transparent')\n\t\t\t{\n\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n\t\t}\n\n\t\t// Updates validation state\n\t\tif (this.previous != null)\n\t\t{\n\t\t\tthis.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n\n\t\t\tif (this.error == null)\n\t\t\t{\n\t\t\t\tthis.currentState = this.constraintHandler.currentFocus;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.constraintHandler.reset();\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (this.graph.isIgnoreTerminalEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.marker.reset();\n\t\t\tthis.currentState = null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.process(me);\n\t\t\tthis.currentState = this.marker.getValidState();\n\n\t\t\tif (this.currentState != null && !this.isCellEnabled(this.currentState.cell))\n\t\t\t{\n\t\t\t\tthis.currentState = null;\n\t\t\t}\n\t\t}\n\n\t\tvar outline = this.isOutlineConnectEvent(me);\n\n\t\tif (this.currentState != null && outline)\n\t\t{\n\t\t\t// Handles special case where mouse is on outline away from actual end point\n\t\t\t// in which case the grid is ignored and mouse point is used instead\n\t\t\tif (me.isSource(this.marker.highlight.shape))\n\t\t\t{\n\t\t\t\tpoint = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\t}\n\n\t\t\tvar constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n\t\t\tthis.constraintHandler.setFocus(me, this.currentState, false);\n\t\t\tthis.constraintHandler.currentConstraint = constraint;\n\t\t\tthis.constraintHandler.currentPoint = point;\n\t\t}\n\n\t\tif (this.outlineConnect)\n\t\t{\n\t\t\tif (this.marker.highlight != null && this.marker.highlight.shape != null)\n\t\t\t{\n\t\t\t\tvar s = this.graph.view.scale;\n\n\t\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t\t\t{\n\t\t\t\t\tthis.marker.highlight.shape.stroke = mxConstants.OUTLINE_HIGHLIGHT_COLOR;\n\t\t\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t}\n\t\t\t\telse if (this.marker.hasValidState())\n\t\t\t\t{\n\t\t\t\t\t// Handles special case where actual end point of edge and current mouse point\n\t\t\t\t\t// are not equal (due to grid snapping) and there is no hit on shape or highlight\n\t\t\t\t\tif (this.marker.getValidState() != me.getState())\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\t\t\tthis.currentState = null;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.marker.highlight.shape.stroke = mxConstants.DEFAULT_VALID_COLOR;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isCellEnabled\n *\n * Returns true if the given cell does not allow new connections to be created.\n */\nmxConnectionHandler.prototype.isCellEnabled = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: convertWaypoint\n *\n * Converts the given point from screen coordinates to model coordinates.\n */\nmxConnectionHandler.prototype.convertWaypoint = function(point)\n{\n\tvar scale = this.graph.getView().getScale();\n\tvar tr = this.graph.getView().getTranslate();\n\n\tpoint.x = point.x / scale - tr.x;\n\tpoint.y = point.y / scale - tr.y;\n};\n\n/**\n * Function: snapToPreview\n *\n * Called to snap the given point to the current preview. This snaps to the\n * first point of the preview if alt is not pressed.\n */\nmxConnectionHandler.prototype.snapToPreview = function(me, point)\n{\n\tif (!mxEvent.isAltDown(me.getEvent()) && this.previous != null)\n\t{\n\t\tvar tol = this.graph.gridSize * this.graph.view.scale / 2;\n\t\tvar tmp = (this.sourceConstraint != null) ? this.first :\n\t\t\tnew mxPoint(this.previous.getCenterX(), this.previous.getCenterY());\n\n\t\tif (Math.abs(tmp.x - me.getGraphX()) < tol)\n\t\t{\n\t\t\tpoint.x = tmp.x;\n\t\t}\n\n\t\tif (Math.abs(tmp.y - me.getGraphY()) < tol)\n\t\t{\n\t\t\tpoint.y = tmp.y;\n\t\t}\n\t}\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by updating the preview edge or by highlighting\n * a possible source or target terminal.\n */\nmxConnectionHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (!me.isConsumed() && (this.ignoreMouseDown || this.first != null || !this.graph.isMouseDown))\n\t{\n\t\t// Handles special case when handler is disabled during highlight\n\t\tif (!this.isEnabled() && this.currentState != null)\n\t\t{\n\t\t\tthis.destroyIcons();\n\t\t\tthis.currentState = null;\n\t\t}\n\n\t\tvar view = this.graph.getView();\n\t\tvar scale = view.scale;\n\t\tvar tr = view.translate;\n\t\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\tthis.error = null;\n\n\t\tif (this.graph.isGridEnabledEvent(me.getEvent()))\n\t\t{\n\t\t\tpoint = new mxPoint((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale,\n\t\t\t\t(this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n\t\t}\n\n\t\tthis.snapToPreview(me, point);\n\t\tthis.currentPoint = point;\n\n\t\tif ((this.first != null || (this.isEnabled() && this.graph.isEnabled())) &&\n\t\t\t(this.shape != null || this.first == null ||\n\t\t\tMath.abs(me.getGraphX() - this.first.x) > this.graph.tolerance ||\n\t\t\tMath.abs(me.getGraphY() - this.first.y) > this.graph.tolerance))\n\t\t{\n\t\t\tthis.updateCurrentState(me, point);\n\t\t}\n\n\t\tif (this.first != null)\n\t\t{\n\t\t\tvar constraint = null;\n\t\t\tvar current = point;\n\n\t\t\t// Uses the current point from the constraint handler if available\n\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t\t{\n\t\t\t\tconstraint = this.constraintHandler.currentConstraint;\n\t\t\t\tcurrent = this.constraintHandler.currentPoint.clone();\n\t\t\t}\n\t\t\telse if (this.previous != null && !this.graph.isIgnoreTerminalEvent(me.getEvent()) &&\n\t\t\t\tmxEvent.isShiftDown(me.getEvent()))\n\t\t\t{\n\t\t\t\tif (Math.abs(this.previous.getCenterX() - point.x) <\n\t\t\t\t\tMath.abs(this.previous.getCenterY() - point.y))\n\t\t\t\t{\n\t\t\t\t\tpoint.x = this.previous.getCenterX();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpoint.y = this.previous.getCenterY();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar pt2 = this.first;\n\n\t\t\t// Moves the connect icon with the mouse\n\t\t\tif (this.selectedIcon != null)\n\t\t\t{\n\t\t\t\tvar w = this.selectedIcon.bounds.width;\n\t\t\t\tvar h = this.selectedIcon.bounds.height;\n\n\t\t\t\tif (this.currentState != null && this.targetConnectImage)\n\t\t\t\t{\n\t\t\t\t\tvar pos = this.getIconPosition(this.selectedIcon, this.currentState);\n\t\t\t\t\tthis.selectedIcon.bounds.x = pos.x;\n\t\t\t\t\tthis.selectedIcon.bounds.y = pos.y;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar bounds = new mxRectangle(me.getGraphX() + this.connectIconOffset.x,\n\t\t\t\t\t\tme.getGraphY() + this.connectIconOffset.y, w, h);\n\t\t\t\t\tthis.selectedIcon.bounds = bounds;\n\t\t\t\t}\n\n\t\t\t\tthis.selectedIcon.redraw();\n\t\t\t}\n\n\t\t\t// Uses edge state to compute the terminal points\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tthis.updateEdgeState(current, constraint);\n\t\t\t\tcurrent = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n\t\t\t\tpt2 = this.edgeState.absolutePoints[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (this.currentState != null)\n\t\t\t\t{\n\t\t\t\t\tif (this.constraintHandler.currentConstraint == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar tmp = this.getTargetPerimeterPoint(this.currentState, me);\n\n\t\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrent = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Computes the source perimeter point\n\t\t\t\tif (this.sourceConstraint == null && this.previous != null)\n\t\t\t\t{\n\t\t\t\t\tvar next = (this.waypoints != null && this.waypoints.length > 0) ?\n\t\t\t\t\t\t\tthis.waypoints[0] : current;\n\t\t\t\t\tvar tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n\n\t\t\t\t\tif (tmp != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt2 = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Makes sure the cell under the mousepointer can be detected\n\t\t\t// by moving the preview shape away from the mouse. This\n\t\t\t// makes sure the preview shape does not prevent the detection\n\t\t\t// of the cell under the mousepointer even for slow gestures.\n\t\t\tif (this.currentState == null && this.movePreviewAway)\n\t\t\t{\n\t\t\t\tvar tmp = pt2;\n\n\t\t\t\tif (this.edgeState != null && this.edgeState.absolutePoints.length >= 2)\n\t\t\t\t{\n\t\t\t\t\tvar tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n\n\t\t\t\t\tif (tmp2 != null)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = tmp2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar dx = current.x - tmp.x;\n\t\t\t\tvar dy = current.y - tmp.y;\n\n\t\t\t\tvar len = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tif (len == 0)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Stores old point to reuse when creating edge\n\t\t\t\tthis.originalPoint = current.clone();\n\t\t\t\tcurrent.x -= dx * 4 / len;\n\t\t\t\tcurrent.y -= dy * 4 / len;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.originalPoint = null;\n\t\t\t}\n\n\t\t\t// Creates the preview shape (lazy)\n\t\t\tif (this.shape == null)\n\t\t\t{\n\t\t\t\tvar dx = Math.abs(me.getGraphX() - this.first.x);\n\t\t\t\tvar dy = Math.abs(me.getGraphY() - this.first.y);\n\n\t\t\t\tif (dx > this.graph.tolerance || dy > this.graph.tolerance)\n\t\t\t\t{\n\t\t\t\t\tthis.shape = this.createShape();\n\n\t\t\t\t\tif (this.edgeState != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.shape.apply(this.edgeState);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Revalidates current connection\n\t\t\t\t\tthis.updateCurrentState(me, point);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Updates the points in the preview edge\n\t\t\tif (this.shape != null)\n\t\t\t{\n\t\t\t\tif (this.edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tthis.shape.points = this.edgeState.absolutePoints;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar pts = [pt2];\n\n\t\t\t\t\tif (this.waypoints != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpts = pts.concat(this.waypoints);\n\t\t\t\t\t}\n\n\t\t\t\t\tpts.push(current);\n\t\t\t\t\tthis.shape.points = pts;\n\t\t\t\t}\n\n\t\t\t\tthis.drawPreview();\n\t\t\t}\n\n\t\t\t// Makes sure endpoint of edge is visible during connect\n\t\t\tif (this.cursor != null)\n\t\t\t{\n\t\t\t\tthis.graph.container.style.cursor = this.cursor;\n\t\t\t}\n\n\t\t\tmxEvent.consume(me.getEvent());\n\t\t\tme.consume();\n\t\t}\n\t\telse if (!this.isEnabled() || !this.graph.isEnabled())\n\t\t{\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\t\telse if (this.previous != this.currentState && this.edgeState == null)\n\t\t{\n\t\t\tthis.destroyIcons();\n\n\t\t\t// Sets the cursor on the current shape\n\t\t\tif (this.currentState != null && this.error == null && this.constraintHandler.currentConstraint == null)\n\t\t\t{\n\t\t\t\tthis.icons = this.createIcons(this.currentState);\n\n\t\t\t\tif (this.icons == null)\n\t\t\t\t{\n\t\t\t\t\tthis.currentState.setCursor(mxConstants.CURSOR_CONNECT);\n\t\t\t\t\tme.consume();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.previous = this.currentState;\n\t\t}\n\t\telse if (this.previous == this.currentState && this.currentState != null && this.icons == null &&\n\t\t\t!this.graph.isMouseDown)\n\t\t{\n\t\t\t// Makes sure that no cursors are changed\n\t\t\tme.consume();\n\t\t}\n\n\t\tif (!this.graph.isMouseDown && this.currentState != null && this.icons != null)\n\t\t{\n\t\t\tvar hitsIcon = false;\n\t\t\tvar target = me.getSource();\n\n\t\t\tfor (var i = 0; i < this.icons.length && !hitsIcon; i++)\n\t\t\t{\n\t\t\t\thitsIcon = target == this.icons[i].node || target.parentNode == this.icons[i].node;\n\t\t\t}\n\n\t\t\tif (!hitsIcon)\n\t\t\t{\n\t\t\t\tthis.updateIcons(this.currentState, this.icons, me);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.constraintHandler.reset();\n\t}\n};\n\n/**\n * Function: updateEdgeState\n *\n * Updates <edgeState>.\n */\nmxConnectionHandler.prototype.updateEdgeState = function(current, constraint)\n{\n\t// TODO: Use generic method for writing constraint to style\n\tif (this.sourceConstraint != null && this.sourceConstraint.point != null)\n\t{\n\t\tthis.edgeState.style[mxConstants.STYLE_EXIT_X] = this.sourceConstraint.point.x;\n\t\tthis.edgeState.style[mxConstants.STYLE_EXIT_Y] = this.sourceConstraint.point.y;\n\t}\n\n\tif (constraint != null && constraint.point != null)\n\t{\n\t\tthis.edgeState.style[mxConstants.STYLE_ENTRY_X] = constraint.point.x;\n\t\tthis.edgeState.style[mxConstants.STYLE_ENTRY_Y] = constraint.point.y;\n\t}\n\telse\n\t{\n\t\tdelete this.edgeState.style[mxConstants.STYLE_ENTRY_X];\n\t\tdelete this.edgeState.style[mxConstants.STYLE_ENTRY_Y];\n\t}\n\n\tthis.edgeState.absolutePoints = [null, (this.currentState != null) ? null : current];\n\tthis.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n\n\tif (this.currentState != null)\n\t{\n\t\tif (constraint == null)\n\t\t{\n\t\t\tconstraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n\t\t}\n\n\t\tthis.edgeState.setAbsoluteTerminalPoint(null, false);\n\t\tthis.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n\t}\n\n\t// Scales and translates the waypoints to the model\n\tvar realPoints = null;\n\n\tif (this.waypoints != null)\n\t{\n\t\trealPoints = [];\n\n\t\tfor (var i = 0; i < this.waypoints.length; i++)\n\t\t{\n\t\t\tvar pt = this.waypoints[i].clone();\n\t\t\tthis.convertWaypoint(pt);\n\t\t\trealPoints[i] = pt;\n\t\t}\n\t}\n\n\tthis.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n\tthis.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n};\n\n/**\n * Function: getTargetPerimeterPoint\n *\n * Returns the perimeter point for the given target state.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the target cell state.\n * me - <mxMouseEvent> that represents the mouse move.\n */\nmxConnectionHandler.prototype.getTargetPerimeterPoint = function(state, me)\n{\n\tvar result = null;\n\tvar view = state.view;\n\tvar targetPerimeter = view.getPerimeterFunction(state);\n\n\tif (targetPerimeter != null)\n\t{\n\t\tvar next = (this.waypoints != null && this.waypoints.length > 0) ?\n\t\t\t\tthis.waypoints[this.waypoints.length - 1] :\n\t\t\t\tnew mxPoint(this.previous.getCenterX(), this.previous.getCenterY());\n\t\tvar tmp = targetPerimeter(view.getPerimeterBounds(state),\n\t\t\tthis.edgeState, next, false);\n\n\t\tif (tmp != null)\n\t\t{\n\t\t\tresult = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = new mxPoint(state.getCenterX(), state.getCenterY());\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: getSourcePerimeterPoint\n *\n * Hook to update the icon position(s) based on a mouseOver event. This is\n * an empty implementation.\n *\n * Parameters:\n *\n * state - <mxCellState> that represents the target cell state.\n * next - <mxPoint> that represents the next point along the previewed edge.\n * me - <mxMouseEvent> that represents the mouse move.\n */\nmxConnectionHandler.prototype.getSourcePerimeterPoint = function(state, next, me)\n{\n\tvar result = null;\n\tvar view = state.view;\n\tvar sourcePerimeter = view.getPerimeterFunction(state);\n\tvar c = new mxPoint(state.getCenterX(), state.getCenterY());\n\n\tif (sourcePerimeter != null)\n\t{\n\t\tvar theta = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0);\n\t\tvar rad = -theta * (Math.PI / 180);\n\n\t\tif (theta != 0)\n\t\t{\n\t\t\tnext = mxUtils.getRotatedPoint(new mxPoint(next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n\t\t}\n\n\t\tvar tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n\n\t\tif (tmp != null)\n\t\t{\n\t\t\tif (theta != 0)\n\t\t\t{\n\t\t\t\ttmp = mxUtils.getRotatedPoint(new mxPoint(tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n\t\t\t}\n\n\t\t\tresult = tmp;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = c;\n\t}\n\n\treturn result;\n};\n\n\n/**\n * Function: updateIcons\n *\n * Hook to update the icon position(s) based on a mouseOver event. This is\n * an empty implementation.\n *\n * Parameters:\n *\n * state - <mxCellState> under the mouse.\n * icons - Array of currently displayed icons.\n * me - <mxMouseEvent> that contains the mouse event.\n */\nmxConnectionHandler.prototype.updateIcons = function(state, icons, me)\n{\n\t// empty\n};\n\n/**\n * Function: isStopEvent\n *\n * Returns true if the given mouse up event should stop this handler. The\n * connection will be created if <error> is null. Note that this is only\n * called if <waypointsEnabled> is true. This implemtation returns true\n * if there is a cell state in the given event.\n */\nmxConnectionHandler.prototype.isStopEvent = function(me)\n{\n\treturn me.getState() != null;\n};\n\n/**\n * Function: addWaypoint\n *\n * Adds the waypoint for the given event to <waypoints>.\n */\nmxConnectionHandler.prototype.addWaypointForEvent = function(me)\n{\n\tvar point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());\n\tvar dx = Math.abs(point.x - this.first.x);\n\tvar dy = Math.abs(point.y - this.first.y);\n\tvar addPoint = this.waypoints != null || (this.mouseDownCounter > 1 &&\n\t\t\t(dx > this.graph.tolerance || dy > this.graph.tolerance));\n\n\tif (addPoint)\n\t{\n\t\tif (this.waypoints == null)\n\t\t{\n\t\t\tthis.waypoints = [];\n\t\t}\n\n\t\tvar scale = this.graph.view.scale;\n\t\tvar point = new mxPoint(this.graph.snap(me.getGraphX() / scale) * scale,\n\t\t\t\tthis.graph.snap(me.getGraphY() / scale) * scale);\n\t\tthis.waypoints.push(point);\n\t}\n};\n\n/**\n * Function: checkConstraints\n *\n * Returns true if the connection for the given constraints is valid. This\n * implementation returns true if the constraints are not pointing to the\n * same fixed connection point.\n */\nmxConnectionHandler.prototype.checkConstraints = function(c1, c2)\n{\n\treturn (c1 == null || c2 == null || c1.point == null || c2.point == null ||\n\t\t!c1.point.equals(c2.point) || c1.dx != c2.dx || c1.dy != c2.dy ||\n\t\tc1.perimeter != c2.perimeter);\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by inserting the new connection.\n */\nmxConnectionHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (!me.isConsumed() && this.isConnecting())\n\t{\n\t\tif (this.waypointsEnabled && !this.isStopEvent(me))\n\t\t{\n\t\t\tthis.addWaypointForEvent(me);\n\t\t\tme.consume();\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar c1 = this.sourceConstraint;\n\t\tvar c2 = this.constraintHandler.currentConstraint;\n\n\t\tvar source = (this.previous != null) ? this.previous.cell : null;\n\t\tvar target = null;\n\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t{\n\t\t\ttarget = this.constraintHandler.currentFocus.cell;\n\t\t}\n\n\t\tif (target == null && this.currentState != null)\n\t\t{\n\t\t\ttarget = this.currentState.cell;\n\t\t}\n\n\t\t// Inserts the edge if no validation error exists and if constraints differ\n\t\tif (this.error == null && (source == null || target == null ||\n\t\t\tsource != target || this.checkConstraints(c1, c2)))\n\t\t{\n\t\t\tthis.connect(source, target, me.getEvent(), me.getCell());\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Selects the source terminal for self-references\n\t\t\tif (this.previous != null && this.marker.validState != null &&\n\t\t\t\tthis.previous.cell == this.marker.validState.cell)\n\t\t\t{\n\t\t\t\tthis.graph.selectCellForEvent(this.marker.source, me.getEvent());\n\t\t\t}\n\n\t\t\t// Displays the error message if it is not an empty string,\n\t\t\t// for empty error messages, the event is silently dropped\n\t\t\tif (this.error != null && this.error.length > 0)\n\t\t\t{\n\t\t\t\tthis.graph.validationAlert(this.error);\n\t\t\t}\n\t\t}\n\n\t\t// Redraws the connect icons and resets the handler state\n\t\tthis.destroyIcons();\n\t\tme.consume();\n\t}\n\n\tif (this.first != null)\n\t{\n\t\tthis.reset();\n\t}\n};\n\n/**\n * Function: reset\n *\n * Resets the state of this handler.\n */\nmxConnectionHandler.prototype.reset = function()\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\n\t// Resets the cursor on the container\n\tif (this.cursor != null && this.graph.container != null)\n\t{\n\t\tthis.graph.container.style.cursor = '';\n\t}\n\n\tthis.destroyIcons();\n\tthis.marker.reset();\n\tthis.constraintHandler.reset();\n\tthis.originalPoint = null;\n\tthis.currentPoint = null;\n\tthis.edgeState = null;\n\tthis.previous = null;\n\tthis.error = null;\n\tthis.sourceConstraint = null;\n\tthis.mouseDownCounter = 0;\n\tthis.first = null;\n\n\tthis.fireEvent(new mxEventObject(mxEvent.RESET));\n};\n\n/**\n * Function: drawPreview\n *\n * Redraws the preview edge using the color and width returned by\n * <getEdgeColor> and <getEdgeWidth>.\n */\nmxConnectionHandler.prototype.drawPreview = function()\n{\n\tthis.updatePreview(this.error == null);\n\tthis.shape.redraw();\n};\n\n/**\n * Function: getEdgeColor\n *\n * Returns the color used to draw the preview edge. This returns green if\n * there is no edge validation error and red otherwise.\n *\n * Parameters:\n *\n * valid - Boolean indicating if the color for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.updatePreview = function(valid)\n{\n\tthis.shape.strokewidth = this.getEdgeWidth(valid);\n\tthis.shape.stroke = this.getEdgeColor(valid);\n};\n\n/**\n * Function: getEdgeColor\n *\n * Returns the color used to draw the preview edge. This returns green if\n * there is no edge validation error and red otherwise.\n *\n * Parameters:\n *\n * valid - Boolean indicating if the color for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.getEdgeColor = function(valid)\n{\n\treturn (valid) ? mxConstants.VALID_COLOR : mxConstants.INVALID_COLOR;\n};\n\n/**\n * Function: getEdgeWidth\n *\n * Returns the width used to draw the preview edge. This returns 3 if\n * there is no edge validation error and 1 otherwise.\n *\n * Parameters:\n *\n * valid - Boolean indicating if the width for a valid edge should be\n * returned.\n */\nmxConnectionHandler.prototype.getEdgeWidth = function(valid)\n{\n\treturn (valid) ? 3 : 1;\n};\n\n/**\n * Function: connect\n *\n * Connects the given source and target using a new edge. This\n * implementation uses <createEdge> to create the edge.\n *\n * Parameters:\n *\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * evt - Mousedown event of the connect gesture.\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\n * released.\n */\nmxConnectionHandler.prototype.connect = function(source, target, evt, dropTarget)\n{\n\tif (target != null || this.isCreateTarget(evt) || this.graph.allowDanglingEdges)\n\t{\n\t\t// Uses the common parent of source and target or\n\t\t// the default parent to insert the edge\n\t\tvar model = this.graph.getModel();\n\t\tvar terminalInserted = false;\n\t\tvar edge = null;\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (source != null && target == null && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt))\n\t\t\t{\n\t\t\t\ttarget = this.createTargetVertex(evt, source);\n\n\t\t\t\tif (target != null)\n\t\t\t\t{\n\t\t\t\t\tdropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n\t\t\t\t\tterminalInserted = true;\n\n\t\t\t\t\t// Disables edges as drop targets if the target cell was created\n\t\t\t\t\t// FIXME: Should not shift if vertex was aligned (same in Java)\n\t\t\t\t\tif (dropTarget == null || !this.graph.getModel().isEdge(dropTarget))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pstate = this.graph.getView().getState(dropTarget);\n\n\t\t\t\t\t\tif (pstate != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar tmp = model.getGeometry(target);\n\t\t\t\t\t\t\ttmp.x -= pstate.origin.x;\n\t\t\t\t\t\t\ttmp.y -= pstate.origin.y;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdropTarget = this.graph.getDefaultParent();\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.graph.addCell(target, dropTarget);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parent = this.graph.getDefaultParent();\n\n\t\t\tif (source != null && target != null &&\n\t\t\t\tmodel.getParent(source) == model.getParent(target) &&\n\t\t\t\tmodel.getParent(model.getParent(source)) != model.getRoot())\n\t\t\t{\n\t\t\t\tparent = model.getParent(source);\n\n\t\t\t\tif ((source.geometry != null && source.geometry.relative) &&\n\t\t\t\t\t(target.geometry != null && target.geometry.relative))\n\t\t\t\t{\n\t\t\t\t\tparent = model.getParent(parent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Uses the value of the preview edge state for inserting\n\t\t\t// the new edge into the graph\n\t\t\tvar value = null;\n\t\t\tvar style = null;\n\n\t\t\tif (this.edgeState != null)\n\t\t\t{\n\t\t\t\tvalue = this.edgeState.cell.value;\n\t\t\t\tstyle = this.edgeState.cell.style;\n\t\t\t}\n\n\t\t\tedge = this.insertEdge(parent, null, value, source, target, style);\n\n\t\t\tif (edge != null)\n\t\t\t{\n\t\t\t\t// Updates the connection constraints\n\t\t\t\tthis.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n\t\t\t\tthis.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n\n\t\t\t\t// Uses geometry of the preview edge state\n\t\t\t\tif (this.edgeState != null)\n\t\t\t\t{\n\t\t\t\t\tmodel.setGeometry(edge, this.edgeState.cell.geometry);\n\t\t\t\t}\n\n\t\t\t\tvar parent = model.getParent(source);\n\n\t\t\t\t// Inserts edge before source\n\t\t\t\tif (this.isInsertBefore(edge, source, target, evt, dropTarget))\n\t\t\t\t{\n\t\t\t\t\tvar index = null;\n\t\t\t\t\tvar tmp = source;\n\n\t\t\t\t\twhile (tmp.parent != null && tmp.geometry != null &&\n\t\t\t\t\t\ttmp.geometry.relative && tmp.parent != edge.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = this.graph.model.getParent(tmp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tmp != null && tmp.parent != null && tmp.parent == edge.parent)\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel.add(parent, edge, tmp.parent.getIndex(tmp));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Makes sure the edge has a non-null, relative geometry\n\t\t\t\tvar geo = model.getGeometry(edge);\n\n\t\t\t\tif (geo == null)\n\t\t\t\t{\n\t\t\t\t\tgeo = new mxGeometry();\n\t\t\t\t\tgeo.relative = true;\n\n\t\t\t\t\tmodel.setGeometry(edge, geo);\n\t\t\t\t}\n\n\t\t\t\t// Uses scaled waypoints in geometry\n\t\t\t\tif (this.waypoints != null && this.waypoints.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\tvar tr = this.graph.view.translate;\n\t\t\t\t\tgeo.points = [];\n\n\t\t\t\t\tfor (var i = 0; i < this.waypoints.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pt = this.waypoints[i];\n\t\t\t\t\t\tgeo.points.push(new mxPoint(pt.x / s - tr.x, pt.y / s - tr.y));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target == null)\n\t\t\t\t{\n\t\t\t\t\tvar t = this.graph.view.translate;\n\t\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\t\tvar pt = (this.originalPoint != null) ?\n\t\t\t\t\t\t\tnew mxPoint(this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) :\n\t\t\t\t\t\tnew mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n\t\t\t\t\tpt.x -= this.graph.panDx / this.graph.view.scale;\n\t\t\t\t\tpt.y -= this.graph.panDy / this.graph.view.scale;\n\t\t\t\t\tgeo.setTerminalPoint(pt, false);\n\t\t\t\t}\n\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.CONNECT, 'cell', edge, 'terminal', target,\n\t\t\t\t\t'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n\t\t\t}\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tmxLog.show();\n\t\t\tmxLog.debug(e.message);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\n\t\tif (this.select)\n\t\t{\n\t\t\tthis.selectCells(edge, (terminalInserted) ? target : null);\n\t\t}\n\t}\n};\n\n/**\n * Function: selectCells\n *\n * Selects the given edge after adding a new connection. The target argument\n * contains the target vertex if one has been inserted.\n */\nmxConnectionHandler.prototype.selectCells = function(edge, target)\n{\n\tthis.graph.setSelectionCell(edge);\n};\n\n/**\n * Function: insertEdge\n *\n * Creates, inserts and returns the new edge for the given parameters. This\n * implementation does only use <createEdge> if <factoryMethod> is defined,\n * otherwise <mxGraph.insertEdge> will be used.\n */\nmxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\n{\n\tif (this.factoryMethod == null)\n\t{\n\t\treturn this.graph.insertEdge(parent, id, value, source, target, style);\n\t}\n\telse\n\t{\n\t\tvar edge = this.createEdge(value, source, target, style);\n\t\tedge = this.graph.addEdge(edge, parent, source, target);\n\n\t\treturn edge;\n\t}\n};\n\n/**\n * Function: createTargetVertex\n *\n * Hook method for creating new vertices on the fly if no target was\n * under the mouse. This is only called if <createTarget> is true and\n * returns null.\n *\n * Parameters:\n *\n * evt - Mousedown event of the connect gesture.\n * source - <mxCell> that represents the source terminal.\n */\nmxConnectionHandler.prototype.createTargetVertex = function(evt, source)\n{\n\t// Uses the first non-relative source\n\tvar geo = this.graph.getCellGeometry(source);\n\n\twhile (geo != null && geo.relative)\n\t{\n\t\tsource = this.graph.getModel().getParent(source);\n\t\tgeo = this.graph.getCellGeometry(source);\n\t}\n\n\tvar clone = this.graph.cloneCell(source);\n\tvar geo = this.graph.getModel().getGeometry(clone);\n\n\tif (geo != null)\n\t{\n\t\tvar t = this.graph.view.translate;\n\t\tvar s = this.graph.view.scale;\n\t\tvar point = new mxPoint(this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n\t\tgeo.x = Math.round(point.x - geo.width / 2 - this.graph.panDx / s);\n\t\tgeo.y = Math.round(point.y - geo.height / 2 - this.graph.panDy / s);\n\n\t\t// Aligns with source if within certain tolerance\n\t\tvar tol = this.getAlignmentTolerance();\n\n\t\tif (tol > 0)\n\t\t{\n\t\t\tvar sourceState = this.graph.view.getState(source);\n\n\t\t\tif (sourceState != null)\n\t\t\t{\n\t\t\t\tvar x = sourceState.x / s - t.x;\n\t\t\t\tvar y = sourceState.y / s - t.y;\n\n\t\t\t\tif (Math.abs(x - geo.x) <= tol)\n\t\t\t\t{\n\t\t\t\t\tgeo.x = Math.round(x);\n\t\t\t\t}\n\n\t\t\t\tif (Math.abs(y - geo.y) <= tol)\n\t\t\t\t{\n\t\t\t\t\tgeo.y = Math.round(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn clone;\n};\n\n/**\n * Function: getAlignmentTolerance\n *\n * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\n */\nmxConnectionHandler.prototype.getAlignmentTolerance = function(evt)\n{\n\treturn (this.graph.isGridEnabled()) ? this.graph.gridSize / 2 : this.graph.tolerance;\n};\n\n/**\n * Function: createEdge\n *\n * Creates and returns a new edge using <factoryMethod> if one exists. If\n * no factory method is defined, then a new default edge is returned. The\n * source and target arguments are informal, the actual connection is\n * setup later by the caller of this function.\n *\n * Parameters:\n *\n * value - Value to be used for creating the edge.\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n * style - Optional style from the preview edge.\n */\nmxConnectionHandler.prototype.createEdge = function(value, source, target, style)\n{\n\tvar edge = null;\n\n\t// Creates a new edge using the factoryMethod\n\tif (this.factoryMethod != null)\n\t{\n\t\tedge = this.factoryMethod(source, target, style);\n\t}\n\n\tif (edge == null)\n\t{\n\t\tedge = new mxCell(value || '');\n\t\tedge.setEdge(true);\n\t\tedge.setStyle(style);\n\n\t\tvar geo = new mxGeometry();\n\t\tgeo.relative = true;\n\t\tedge.setGeometry(geo);\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes. This should be\n * called on all instances. It is called automatically for the built-in\n * instance created for each <mxGraph>.\n */\nmxConnectionHandler.prototype.destroy = function()\n{\n\tthis.graph.removeMouseListener(this);\n\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\n\tif (this.marker != null)\n\t{\n\t\tthis.marker.destroy();\n\t\tthis.marker = null;\n\t}\n\n\tif (this.constraintHandler != null)\n\t{\n\t\tthis.constraintHandler.destroy();\n\t\tthis.constraintHandler = null;\n\t}\n\n\tif (this.changeHandler != null)\n\t{\n\t\tthis.graph.getModel().removeListener(this.changeHandler);\n\t\tthis.graph.getView().removeListener(this.changeHandler);\n\t\tthis.changeHandler = null;\n\t}\n\n\tif (this.drillHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.drillHandler);\n\t\tthis.graph.getView().removeListener(this.drillHandler);\n\t\tthis.drillHandler = null;\n\t}\n\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n};\n\n__mxOutput.mxConnectionHandler = typeof mxConnectionHandler !== 'undefined' ? mxConnectionHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxConstraintHandler\n *\n * Handles constraints on connection targets. This class is in charge of\n * showing fixed points when the mouse is over a vertex and handles constraints\n * to establish new connections.\n *\n * Constructor: mxConstraintHandler\n *\n * Constructs an new constraint handler.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * factoryMethod - Optional function to create the edge. The function takes\n * the source and target <mxCell> as the first and second argument and\n * returns the <mxCell> that represents the new edge.\n */\nfunction mxConstraintHandler(graph)\n{\n\tthis.graph = graph;\n\n\t// Adds a graph model listener to update the current focus on changes\n\tthis.resetHandler = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tif (this.currentFocus != null && this.graph.view.getState(this.currentFocus.cell) == null)\n\t\t{\n\t\t\tthis.reset();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.redraw();\n\t\t}\n\t});\n\n\tthis.graph.model.addListener(mxEvent.CHANGE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.TRANSLATE, this.resetHandler);\n\tthis.graph.view.addListener(mxEvent.SCALE, this.resetHandler);\n\tthis.graph.addListener(mxEvent.ROOT, this.resetHandler);\n};\n\n/**\n * Variable: pointImage\n *\n * <mxImage> to be used as the image for fixed connection points.\n */\nmxConstraintHandler.prototype.pointImage = new mxImage(mxClient.imageBasePath + '/point.gif', 5, 5);\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxConstraintHandler.prototype.graph = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxConstraintHandler.prototype.enabled = true;\n\n/**\n * Variable: highlightColor\n *\n * Specifies the color for the highlight. Default is <mxConstants.DEFAULT_VALID_COLOR>.\n */\nmxConstraintHandler.prototype.highlightColor = mxConstants.DEFAULT_VALID_COLOR;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxConstraintHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n *\n * Parameters:\n *\n * enabled - Boolean that specifies the new enabled state.\n */\nmxConstraintHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: reset\n *\n * Resets the state of this handler.\n */\nmxConstraintHandler.prototype.reset = function()\n{\n\tif (this.focusIcons != null)\n\t{\n\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t{\n\t\t\tthis.focusIcons[i].destroy();\n\t\t}\n\n\t\tthis.focusIcons = null;\n\t}\n\n\tif (this.focusHighlight != null)\n\t{\n\t\tthis.focusHighlight.destroy();\n\t\tthis.focusHighlight = null;\n\t}\n\n\tthis.currentConstraint = null;\n\tthis.currentFocusArea = null;\n\tthis.currentPoint = null;\n\tthis.currentFocus = null;\n\tthis.focusPoints = null;\n};\n\n/**\n * Function: getTolerance\n *\n * Returns the tolerance to be used for intersecting connection points. This\n * implementation returns <mxGraph.tolerance>.\n *\n * Parameters:\n *\n * me - <mxMouseEvent> whose tolerance should be returned.\n */\nmxConstraintHandler.prototype.getTolerance = function(me)\n{\n\treturn this.graph.getTolerance();\n};\n\n/**\n * Function: getImageForConstraint\n *\n * Returns the tolerance to be used for intersecting connection points.\n */\nmxConstraintHandler.prototype.getImageForConstraint = function(state, constraint, point)\n{\n\treturn this.pointImage;\n};\n\n/**\n * Function: isEventIgnored\n *\n * Returns true if the given <mxMouseEvent> should be ignored in <update>. This\n * implementation always returns false.\n */\nmxConstraintHandler.prototype.isEventIgnored = function(me, source)\n{\n\treturn false;\n};\n\n/**\n * Function: isStateIgnored\n *\n * Returns true if the given state should be ignored. This always returns false.\n */\nmxConstraintHandler.prototype.isStateIgnored = function(state, source)\n{\n\treturn false;\n};\n\n/**\n * Function: destroyIcons\n *\n * Destroys the <focusIcons> if they exist.\n */\nmxConstraintHandler.prototype.destroyIcons = function()\n{\n\tif (this.focusIcons != null)\n\t{\n\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t{\n\t\t\tthis.focusIcons[i].destroy();\n\t\t}\n\n\t\tthis.focusIcons = null;\n\t\tthis.focusPoints = null;\n\t}\n};\n\n/**\n * Function: destroyFocusHighlight\n *\n * Destroys the <focusHighlight> if one exists.\n */\nmxConstraintHandler.prototype.destroyFocusHighlight = function()\n{\n\tif (this.focusHighlight != null)\n\t{\n\t\tthis.focusHighlight.destroy();\n\t\tthis.focusHighlight = null;\n\t}\n};\n\n/**\n * Function: isKeepFocusEvent\n *\n * Returns true if the current focused state should not be changed for the given event.\n * This returns true if shift and alt are pressed.\n */\nmxConstraintHandler.prototype.isKeepFocusEvent = function(me)\n{\n\treturn mxEvent.isShiftDown(me.getEvent());\n};\n\n/**\n * Function: getCellForEvent\n *\n * Returns the cell for the given event.\n */\nmxConstraintHandler.prototype.getCellForEvent = function(me, point)\n{\n\tvar cell = me.getCell();\n\n\t// Gets cell under actual point if different from event location\n\tif (cell == null && point != null && (me.getGraphX() != point.x || me.getGraphY() != point.y))\n\t{\n\t\tcell = this.graph.getCellAt(point.x, point.y);\n\t}\n\n\t// Uses connectable parent vertex if one exists\n\tif (cell != null && !this.graph.isCellConnectable(cell))\n\t{\n\t\tvar parent = this.graph.getModel().getParent(cell);\n\n\t\tif (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))\n\t\t{\n\t\t\tcell = parent;\n\t\t}\n\t}\n\n\treturn (this.graph.isCellLocked(cell)) ? null : cell;\n};\n\n/**\n * Function: update\n *\n * Updates the state of this handler based on the given <mxMouseEvent>.\n * Source is a boolean indicating if the cell is a source or target.\n */\nmxConstraintHandler.prototype.update = function(me, source, existingEdge, point)\n{\n\tif (this.isEnabled() && !this.isEventIgnored(me))\n\t{\n\t\t// Lazy installation of mouseleave handler\n\t\tif (this.mouseleaveHandler == null && this.graph.container != null)\n\t\t{\n\t\t\tthis.mouseleaveHandler = mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.reset();\n\t\t\t});\n\n\t\t\tmxEvent.addListener(this.graph.container, 'mouseleave', this.resetHandler);\n\t\t}\n\n\t\tvar tol = this.getTolerance(me);\n\t\tvar x = (point != null) ? point.x : me.getGraphX();\n\t\tvar y = (point != null) ? point.y : me.getGraphY();\n\t\tvar grid = new mxRectangle(x - tol, y - tol, 2 * tol, 2 * tol);\n\t\tvar mouse = new mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);\n\t\tvar state = this.graph.view.getState(this.getCellForEvent(me, point));\n\n\t\t// Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed\n\t\tif (!this.isKeepFocusEvent(me) && (this.currentFocusArea == null || this.currentFocus == null ||\n\t\t\t(state != null) || !this.graph.getModel().isVertex(this.currentFocus.cell) ||\n\t\t\t!mxUtils.intersects(this.currentFocusArea, mouse)) && (state != this.currentFocus))\n\t\t{\n\t\t\tthis.currentFocusArea = null;\n\t\t\tthis.currentFocus = null;\n\t\t\tthis.setFocus(me, state, source);\n\t\t}\n\n\t\tthis.currentConstraint = null;\n\t\tthis.currentPoint = null;\n\t\tvar minDistSq = null;\n\n\t\tif (this.focusIcons != null && this.constraints != null &&\n\t\t\t(state == null || this.currentFocus == state))\n\t\t{\n\t\t\tvar cx = mouse.getCenterX();\n\t\t\tvar cy = mouse.getCenterY();\n\n\t\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t\t{\n\t\t\t\tvar dx = cx - this.focusIcons[i].bounds.getCenterX();\n\t\t\t\tvar dy = cy - this.focusIcons[i].bounds.getCenterY();\n\t\t\t\tvar tmp = dx * dx + dy * dy;\n\n\t\t\t\tif ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || (point != null &&\n\t\t\t\t\tthis.intersects(this.focusIcons[i], grid, source, existingEdge))) &&\n\t\t\t\t\t(minDistSq == null || tmp < minDistSq))\n\t\t\t\t{\n\t\t\t\t\tthis.currentConstraint = this.constraints[i];\n\t\t\t\t\tthis.currentPoint = this.focusPoints[i];\n\t\t\t\t\tminDistSq = tmp;\n\n\t\t\t\t\tvar tmp = this.focusIcons[i].bounds.clone();\n\t\t\t\t\ttmp.grow(mxConstants.HIGHLIGHT_SIZE + 1);\n\t\t\t\t\ttmp.width -= 1;\n\t\t\t\t\ttmp.height -= 1;\n\n\t\t\t\t\tif (this.focusHighlight == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar hl = this.createHighlightShape();\n\t\t\t\t\t\thl.dialect = (this.graph.dialect == mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\t\t\tmxConstants.DIALECT_SVG : mxConstants.DIALECT_VML;\n\t\t\t\t\t\thl.pointerEvents = false;\n\n\t\t\t\t\t\thl.init(this.graph.getView().getOverlayPane());\n\t\t\t\t\t\tthis.focusHighlight = hl;\n\n\t\t\t\t\t\tvar getState = mxUtils.bind(this, function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn (this.currentFocus != null) ? this.currentFocus : state;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tmxEvent.redirectMouseEvents(hl.node, this.graph, getState);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.focusHighlight.bounds = tmp;\n\t\t\t\t\tthis.focusHighlight.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.currentConstraint == null)\n\t\t{\n\t\t\tthis.destroyFocusHighlight();\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.currentConstraint = null;\n\t\tthis.currentFocus = null;\n\t\tthis.currentPoint = null;\n\t}\n};\n\n/**\n * Function: redraw\n *\n * Transfers the focus to the given state as a source or target terminal. If\n * the handler is not enabled then the outline is painted, but the constraints\n * are ignored.\n */\nmxConstraintHandler.prototype.redraw = function()\n{\n\tif (this.currentFocus != null && this.constraints != null && this.focusIcons != null)\n\t{\n\t\tvar state = this.graph.view.getState(this.currentFocus.cell);\n\t\tthis.currentFocus = state;\n\t\tthis.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);\n\n\t\tfor (var i = 0; i < this.constraints.length; i++)\n\t\t{\n\t\t\tvar cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n\t\t\tvar img = this.getImageForConstraint(state, this.constraints[i], cp);\n\n\t\t\tvar bounds = new mxRectangle(Math.round(cp.x - img.width / 2),\n\t\t\t\tMath.round(cp.y - img.height / 2), img.width, img.height);\n\t\t\tthis.focusIcons[i].bounds = bounds;\n\t\t\tthis.focusIcons[i].redraw();\n\t\t\tthis.currentFocusArea.add(this.focusIcons[i].bounds);\n\t\t\tthis.focusPoints[i] = cp;\n\t\t}\n\t}\n};\n\n/**\n * Function: setFocus\n *\n * Transfers the focus to the given state as a source or target terminal. If\n * the handler is not enabled then the outline is painted, but the constraints\n * are ignored.\n */\nmxConstraintHandler.prototype.setFocus = function(me, state, source)\n{\n\tthis.constraints = (state != null && !this.isStateIgnored(state, source) &&\n\t\tthis.graph.isCellConnectable(state.cell)) ? ((this.isEnabled()) ?\n\t\t(this.graph.getAllConnectionConstraints(state, source) || []) : []) : null;\n\n\t// Only uses cells which have constraints\n\tif (this.constraints != null)\n\t{\n\t\tthis.currentFocus = state;\n\t\tthis.currentFocusArea = new mxRectangle(state.x, state.y, state.width, state.height);\n\n\t\tif (this.focusIcons != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.focusIcons.length; i++)\n\t\t\t{\n\t\t\t\tthis.focusIcons[i].destroy();\n\t\t\t}\n\n\t\t\tthis.focusIcons = null;\n\t\t\tthis.focusPoints = null;\n\t\t}\n\n\t\tthis.focusPoints = [];\n\t\tthis.focusIcons = [];\n\n\t\tfor (var i = 0; i < this.constraints.length; i++)\n\t\t{\n\t\t\tvar cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n\t\t\tvar img = this.getImageForConstraint(state, this.constraints[i], cp);\n\n\t\t\tvar src = img.src;\n\t\t\tvar bounds = new mxRectangle(Math.round(cp.x - img.width / 2),\n\t\t\t\tMath.round(cp.y - img.height / 2), img.width, img.height);\n\t\t\tvar icon = new mxImageShape(bounds, src);\n\t\t\ticon.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\t\t\ticon.preserveImageAspect = false;\n\t\t\ticon.init(this.graph.getView().getDecoratorPane());\n\n\t\t\t// Fixes lost event tracking for images in quirks / IE8 standards\n\t\t\tif (mxClient.IS_QUIRKS || document.documentMode == 8)\n\t\t\t{\n\t\t\t\tmxEvent.addListener(icon.node, 'dragstart', function(evt)\n\t\t\t\t{\n\t\t\t\t\tmxEvent.consume(evt);\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Move the icon behind all other overlays\n\t\t\tif (icon.node.previousSibling != null)\n\t\t\t{\n\t\t\t\ticon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n\t\t\t}\n\n\t\t\tvar getState = mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\treturn (this.currentFocus != null) ? this.currentFocus : state;\n\t\t\t});\n\n\t\t\ticon.redraw();\n\n\t\t\tmxEvent.redirectMouseEvents(icon.node, this.graph, getState);\n\t\t\tthis.currentFocusArea.add(icon.bounds);\n\t\t\tthis.focusIcons.push(icon);\n\t\t\tthis.focusPoints.push(cp);\n\t\t}\n\n\t\tthis.currentFocusArea.grow(this.getTolerance(me));\n\t}\n\telse\n\t{\n\t\tthis.destroyIcons();\n\t\tthis.destroyFocusHighlight();\n\t}\n};\n\n/**\n * Function: createHighlightShape\n *\n * Create the shape used to paint the highlight.\n *\n * Returns true if the given icon intersects the given point.\n */\nmxConstraintHandler.prototype.createHighlightShape = function()\n{\n\tvar hl = new mxRectangleShape(null, this.highlightColor, this.highlightColor, mxConstants.HIGHLIGHT_STROKEWIDTH);\n\thl.opacity = mxConstants.HIGHLIGHT_OPACITY;\n\n\treturn hl;\n};\n\n/**\n * Function: intersects\n *\n * Returns true if the given icon intersects the given rectangle.\n */\nmxConstraintHandler.prototype.intersects = function(icon, mouse, source, existingEdge)\n{\n\treturn mxUtils.intersects(icon.bounds, mouse);\n};\n\n/**\n * Function: destroy\n *\n * Destroy this handler.\n */\nmxConstraintHandler.prototype.destroy = function()\n{\n\tthis.reset();\n\n\tif (this.resetHandler != null)\n\t{\n\t\tthis.graph.model.removeListener(this.resetHandler);\n\t\tthis.graph.view.removeListener(this.resetHandler);\n\t\tthis.graph.removeListener(this.resetHandler);\n\t\tthis.resetHandler = null;\n\t}\n\n\tif (this.mouseleaveHandler != null && this.graph.container != null)\n\t{\n\t\tmxEvent.removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);\n\t\tthis.mouseleaveHandler = null;\n\t}\n};\n\n__mxOutput.mxConstraintHandler = typeof mxConstraintHandler !== 'undefined' ? mxConstraintHandler : undefined;\n\n/**\n * Copyright (c) 2006-2016, JGraph Ltd\n * Copyright (c) 2006-2016, Gaudenz Alder\n */\n/**\n * Class: mxRubberband\n *\n * Event handler that selects rectangular regions. This is not built-into\n * <mxGraph>. To enable rubberband selection in a graph, use the following code.\n *\n * Example:\n *\n * (code)\n * var rubberband = new mxRubberband(graph);\n * (end)\n *\n * Constructor: mxRubberband\n *\n * Constructs an event handler that selects rectangular regions in the graph\n * using rubberband selection.\n */\nfunction mxRubberband(graph)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.graph.addMouseListener(this);\n\n\t\t// Handles force rubberband event\n\t\tthis.forceRubberbandHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar evtName = evt.getProperty('eventName');\n\t\t\tvar me = evt.getProperty('event');\n\n\t\t\tif (evtName == mxEvent.MOUSE_DOWN && this.isForceRubberbandEvent(me))\n\t\t\t{\n\t\t\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\t\t\tvar origin = mxUtils.getScrollOrigin(this.graph.container);\n\t\t\t\torigin.x -= offset.x;\n\t\t\t\torigin.y -= offset.y;\n\t\t\t\tthis.start(me.getX() + origin.x, me.getY() + origin.y);\n\t\t\t\tme.consume(false);\n\t\t\t}\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.FIRE_MOUSE_EVENT, this.forceRubberbandHandler);\n\n\t\t// Repaints the marquee after autoscroll\n\t\tthis.panHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.repaint();\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.PAN, this.panHandler);\n\n\t\t// Does not show menu if any touch gestures take place after the trigger\n\t\tthis.gestureHandler = mxUtils.bind(this, function(sender, eo)\n\t\t{\n\t\t\tif (this.first != null)\n\t\t\t{\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t});\n\n\t\tthis.graph.addListener(mxEvent.GESTURE, this.gestureHandler);\n\n\t\t// Automatic deallocation of memory\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tmxEvent.addListener(window, 'unload',\n\t\t\t\tmxUtils.bind(this, function()\n\t\t\t\t{\n\t\t\t\t\tthis.destroy();\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Variable: defaultOpacity\n *\n * Specifies the default opacity to be used for the rubberband div. Default\n * is 20.\n */\nmxRubberband.prototype.defaultOpacity = 20;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxRubberband.prototype.enabled = true;\n\n/**\n * Variable: div\n *\n * Holds the DIV element which is currently visible.\n */\nmxRubberband.prototype.div = null;\n\n/**\n * Variable: sharedDiv\n *\n * Holds the DIV element which is used to display the rubberband.\n */\nmxRubberband.prototype.sharedDiv = null;\n\n/**\n * Variable: currentX\n *\n * Holds the value of the x argument in the last call to <update>.\n */\nmxRubberband.prototype.currentX = 0;\n\n/**\n * Variable: currentY\n *\n * Holds the value of the y argument in the last call to <update>.\n */\nmxRubberband.prototype.currentY = 0;\n\n/**\n * Variable: fadeOut\n *\n * Optional fade out effect. Default is false.\n */\nmxRubberband.prototype.fadeOut = false;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation returns\n * <enabled>.\n */\nmxRubberband.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation updates\n * <enabled>.\n */\nmxRubberband.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isForceRubberbandEvent\n *\n * Returns true if the given <mxMouseEvent> should start rubberband selection.\n * This implementation returns true if the alt key is pressed.\n */\nmxRubberband.prototype.isForceRubberbandEvent = function(me)\n{\n\treturn mxEvent.isAltDown(me.getEvent());\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by initiating a rubberband selection. By consuming the\n * event all subsequent events of the gesture are redirected to this\n * handler.\n */\nmxRubberband.prototype.mouseDown = function(sender, me)\n{\n\tif (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() &&\n\t\tme.getState() == null && !mxEvent.isMultiTouchEvent(me.getEvent()))\n\t{\n\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\tvar origin = mxUtils.getScrollOrigin(this.graph.container);\n\t\torigin.x -= offset.x;\n\t\torigin.y -= offset.y;\n\t\tthis.start(me.getX() + origin.x, me.getY() + origin.y);\n\n\t\t// Does not prevent the default for this event so that the\n\t\t// event processing chain is still executed even if we start\n\t\t// rubberbanding. This is required eg. in ExtJs to hide the\n\t\t// current context menu. In mouseMove we'll make sure we're\n\t\t// not selecting anything while we're rubberbanding.\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: start\n *\n * Sets the start point for the rubberband selection.\n */\nmxRubberband.prototype.start = function(x, y)\n{\n\tthis.first = new mxPoint(x, y);\n\n\tvar container = this.graph.container;\n\n\tfunction createMouseEvent(evt)\n\t{\n\t\tvar me = new mxMouseEvent(evt);\n\t\tvar pt = mxUtils.convertPoint(container, me.getX(), me.getY());\n\n\t\tme.graphX = pt.x;\n\t\tme.graphY = pt.y;\n\n\t\treturn me;\n\t};\n\n\tthis.dragHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.mouseMove(this.graph, createMouseEvent(evt));\n\t});\n\n\tthis.dropHandler = mxUtils.bind(this, function(evt)\n\t{\n\t\tthis.mouseUp(this.graph, createMouseEvent(evt));\n\t});\n\n\t// Workaround for rubberband stopping if the mouse leaves the container in Firefox\n\tif (mxClient.IS_FF)\n\t{\n\t\tmxEvent.addGestureListeners(document, null, this.dragHandler, this.dropHandler);\n\t}\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by updating therubberband selection.\n */\nmxRubberband.prototype.mouseMove = function(sender, me)\n{\n\tif (!me.isConsumed() && this.first != null)\n\t{\n\t\tvar origin = mxUtils.getScrollOrigin(this.graph.container);\n\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\torigin.x -= offset.x;\n\t\torigin.y -= offset.y;\n\t\tvar x = me.getX() + origin.x;\n\t\tvar y = me.getY() + origin.y;\n\t\tvar dx = this.first.x - x;\n\t\tvar dy = this.first.y - y;\n\t\tvar tol = this.graph.tolerance;\n\n\t\tif (this.div != null || Math.abs(dx) > tol ||  Math.abs(dy) > tol)\n\t\t{\n\t\t\tif (this.div == null)\n\t\t\t{\n\t\t\t\tthis.div = this.createShape();\n\t\t\t}\n\n\t\t\t// Clears selection while rubberbanding. This is required because\n\t\t\t// the event is not consumed in mouseDown.\n\t\t\tmxUtils.clearSelection();\n\n\t\t\tthis.update(x, y);\n\t\t\tme.consume();\n\t\t}\n\t}\n};\n\n/**\n * Function: createShape\n *\n * Creates the rubberband selection shape.\n */\nmxRubberband.prototype.createShape = function()\n{\n\tif (this.sharedDiv == null)\n\t{\n\t\tthis.sharedDiv = document.createElement('div');\n\t\tthis.sharedDiv.className = 'mxRubberband';\n\t\tmxUtils.setOpacity(this.sharedDiv, this.defaultOpacity);\n\t}\n\n\tthis.graph.container.appendChild(this.sharedDiv);\n\tvar result = this.sharedDiv;\n\n\tif (mxClient.IS_SVG && (!mxClient.IS_IE || document.documentMode >= 10) && this.fadeOut)\n\t{\n\t\tthis.sharedDiv = null;\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isActive\n *\n * Returns true if this handler is active.\n */\nmxRubberband.prototype.isActive = function(sender, me)\n{\n\treturn this.div != null && this.div.style.display != 'none';\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by selecting the region of the rubberband using\n * <mxGraph.selectRegion>.\n */\nmxRubberband.prototype.mouseUp = function(sender, me)\n{\n\tvar active = this.isActive();\n\tthis.reset();\n\n\tif (active)\n\t{\n\t\tthis.execute(me.getEvent());\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: execute\n *\n * Resets the state of this handler and selects the current region\n * for the given event.\n */\nmxRubberband.prototype.execute = function(evt)\n{\n\tvar rect = new mxRectangle(this.x, this.y, this.width, this.height);\n\tthis.graph.selectRegion(rect, evt);\n};\n\n/**\n * Function: reset\n *\n * Resets the state of the rubberband selection.\n */\nmxRubberband.prototype.reset = function()\n{\n\tif (this.div != null)\n\t{\n\t\tif (mxClient.IS_SVG && (!mxClient.IS_IE || document.documentMode >= 10) && this.fadeOut)\n\t\t{\n\t\t\tvar temp = this.div;\n\t\t\tmxUtils.setPrefixedStyle(temp.style, 'transition', 'all 0.2s linear');\n\t\t\ttemp.style.pointerEvents = 'none';\n\t\t\ttemp.style.opacity = 0;\n\n\t\t    window.setTimeout(function()\n\t\t    \t{\n\t\t    \t\ttemp.parentNode.removeChild(temp);\n\t\t    \t}, 200);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\t}\n\n\tmxEvent.removeGestureListeners(document, null, this.dragHandler, this.dropHandler);\n\tthis.dragHandler = null;\n\tthis.dropHandler = null;\n\n\tthis.currentX = 0;\n\tthis.currentY = 0;\n\tthis.first = null;\n\tthis.div = null;\n};\n\n/**\n * Function: update\n *\n * Sets <currentX> and <currentY> and calls <repaint>.\n */\nmxRubberband.prototype.update = function(x, y)\n{\n\tthis.currentX = x;\n\tthis.currentY = y;\n\n\tthis.repaint();\n};\n\n/**\n * Function: repaint\n *\n * Computes the bounding box and updates the style of the <div>.\n */\nmxRubberband.prototype.repaint = function()\n{\n\tif (this.div != null)\n\t{\n\t\tvar x = this.currentX - this.graph.panDx;\n\t\tvar y = this.currentY - this.graph.panDy;\n\n\t\tthis.x = Math.min(this.first.x, x);\n\t\tthis.y = Math.min(this.first.y, y);\n\t\tthis.width = Math.max(this.first.x, x) - this.x;\n\t\tthis.height =  Math.max(this.first.y, y) - this.y;\n\n\t\tvar dx = (mxClient.IS_VML) ? this.graph.panDx : 0;\n\t\tvar dy = (mxClient.IS_VML) ? this.graph.panDy : 0;\n\n\t\tthis.div.style.left = (this.x + dx) + 'px';\n\t\tthis.div.style.top = (this.y + dy) + 'px';\n\t\tthis.div.style.width = Math.max(1, this.width) + 'px';\n\t\tthis.div.style.height = Math.max(1, this.height) + 'px';\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes. This does\n * normally not need to be called, it is called automatically when the\n * window unloads.\n */\nmxRubberband.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\t\tthis.graph.removeMouseListener(this);\n\t\tthis.graph.removeListener(this.forceRubberbandHandler);\n\t\tthis.graph.removeListener(this.panHandler);\n\t\tthis.reset();\n\n\t\tif (this.sharedDiv != null)\n\t\t{\n\t\t\tthis.sharedDiv = null;\n\t\t}\n\t}\n};\n\n__mxOutput.mxRubberband = typeof mxRubberband !== 'undefined' ? mxRubberband : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxHandle\n *\n * Implements a single custom handle for vertices.\n *\n * Constructor: mxHandle\n *\n * Constructs a new handle for the given state.\n *\n * Parameters:\n *\n * state - <mxCellState> of the cell to be handled.\n */\nfunction mxHandle(state, cursor, image)\n{\n\tthis.graph = state.view.graph;\n\tthis.state = state;\n\tthis.cursor = (cursor != null) ? cursor : this.cursor;\n\tthis.image = (image != null) ? image : this.image;\n\tthis.init();\n};\n\n/**\n * Variable: cursor\n *\n * Specifies the cursor to be used for this handle. Default is 'default'.\n */\nmxHandle.prototype.cursor = 'default';\n\n/**\n * Variable: image\n *\n * Specifies the <mxImage> to be used to render the handle. Default is null.\n */\nmxHandle.prototype.image = null;\n\n/**\n * Variable: image\n *\n * Specifies the <mxImage> to be used to render the handle. Default is null.\n */\nmxHandle.prototype.ignoreGrid = false;\n\n/**\n * Function: getPosition\n *\n * Hook for subclassers to return the current position of the handle.\n */\nmxHandle.prototype.getPosition = function(bounds) { };\n\n/**\n * Function: setPosition\n *\n * Hooks for subclassers to update the style in the <state>.\n */\nmxHandle.prototype.setPosition = function(bounds, pt, me) { };\n\n/**\n * Function: execute\n *\n * Hook for subclassers to execute the handle.\n */\nmxHandle.prototype.execute = function() { };\n\n/**\n * Function: copyStyle\n *\n * Sets the cell style with the given name to the corresponding value in <state>.\n */\nmxHandle.prototype.copyStyle = function(key)\n{\n\tthis.graph.setCellStyles(key, this.state.style[key], [this.state.cell]);\n};\n\n/**\n * Function: processEvent\n *\n * Processes the given <mxMouseEvent> and invokes <setPosition>.\n */\nmxHandle.prototype.processEvent = function(me)\n{\n\tvar scale = this.graph.view.scale;\n\tvar tr = this.graph.view.translate;\n\tvar pt = new mxPoint(me.getGraphX() / scale - tr.x, me.getGraphY() / scale - tr.y);\n\n\t// Center shape on mouse cursor\n\tif (this.shape != null && this.shape.bounds != null)\n\t{\n\t\tpt.x -= this.shape.bounds.width / scale / 4;\n\t\tpt.y -= this.shape.bounds.height / scale / 4;\n\t}\n\n\t// Snaps to grid for the rotated position then applies the rotation for the direction after that\n\tvar alpha1 = -mxUtils.toRadians(this.getRotation());\n\tvar alpha2 = -mxUtils.toRadians(this.getTotalRotation()) - alpha1;\n\tpt = this.flipPoint(this.rotatePoint(this.snapPoint(this.rotatePoint(pt, alpha1),\n\t\t\tthis.ignoreGrid || !this.graph.isGridEnabledEvent(me.getEvent())), alpha2));\n\tthis.setPosition(this.state.getPaintBounds(), pt, me);\n\tthis.positionChanged();\n\tthis.redraw();\n};\n\n/**\n * Function: positionChanged\n *\n * Called after <setPosition> has been called in <processEvent>. This repaints\n * the state using <mxCellRenderer>.\n */\nmxHandle.prototype.positionChanged = function()\n{\n\tif (this.state.text != null)\n\t{\n\t\tthis.state.text.apply(this.state);\n\t}\n\n\tif (this.state.shape != null)\n\t{\n\t\tthis.state.shape.apply(this.state);\n\t}\n\n\tthis.graph.cellRenderer.redraw(this.state, true);\n};\n\n/**\n * Function: getRotation\n *\n * Returns the rotation defined in the style of the cell.\n */\nmxHandle.prototype.getRotation = function()\n{\n\tif (this.state.shape != null)\n\t{\n\t\treturn this.state.shape.getRotation();\n\t}\n\n\treturn 0;\n};\n\n/**\n * Function: getTotalRotation\n *\n * Returns the rotation from the style and the rotation from the direction of\n * the cell.\n */\nmxHandle.prototype.getTotalRotation = function()\n{\n\tif (this.state.shape != null)\n\t{\n\t\treturn this.state.shape.getShapeRotation();\n\t}\n\n\treturn 0;\n};\n\n/**\n * Function: init\n *\n * Creates and initializes the shapes required for this handle.\n */\nmxHandle.prototype.init = function()\n{\n\tvar html = this.isHtmlRequired();\n\n\tif (this.image != null)\n\t{\n\t\tthis.shape = new mxImageShape(new mxRectangle(0, 0, this.image.width, this.image.height), this.image.src);\n\t\tthis.shape.preserveImageAspect = false;\n\t}\n\telse\n\t{\n\t\tthis.shape = this.createShape(html);\n\t}\n\n\tthis.initShape(html);\n};\n\n/**\n * Function: createShape\n *\n * Creates and returns the shape for this handle.\n */\nmxHandle.prototype.createShape = function(html)\n{\n\tvar bounds = new mxRectangle(0, 0, mxConstants.HANDLE_SIZE, mxConstants.HANDLE_SIZE);\n\n\treturn new mxRectangleShape(bounds, mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n};\n\n/**\n * Function: initShape\n *\n * Initializes <shape> and sets its cursor.\n */\nmxHandle.prototype.initShape = function(html)\n{\n\tif (html && this.shape.isHtmlAllowed())\n\t{\n\t\tthis.shape.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tthis.shape.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\tthis.shape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\n\t\tif (this.cursor != null)\n\t\t{\n\t\t\tthis.shape.init(this.graph.getView().getOverlayPane());\n\t\t}\n\t}\n\n\tmxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n\tthis.shape.node.style.cursor = this.cursor;\n};\n\n/**\n * Function: redraw\n *\n * Renders the shape for this handle.\n */\nmxHandle.prototype.redraw = function()\n{\n\tif (this.shape != null && this.state.shape != null)\n\t{\n\t\tvar pt = this.getPosition(this.state.getPaintBounds());\n\n\t\tif (pt != null)\n\t\t{\n\t\t\tvar alpha = mxUtils.toRadians(this.getTotalRotation());\n\t\t\tpt = this.rotatePoint(this.flipPoint(pt), alpha);\n\n\t\t\tvar scale = this.graph.view.scale;\n\t\t\tvar tr = this.graph.view.translate;\n\t\t\tthis.shape.bounds.x = Math.floor((pt.x + tr.x) * scale - this.shape.bounds.width / 2);\n\t\t\tthis.shape.bounds.y = Math.floor((pt.y + tr.y) * scale - this.shape.bounds.height / 2);\n\n\t\t\t// Needed to force update of text bounds\n\t\t\tthis.shape.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: isHtmlRequired\n *\n * Returns true if this handle should be rendered in HTML. This returns true if\n * the text node is in the graph container.\n */\nmxHandle.prototype.isHtmlRequired = function()\n{\n\treturn this.state.text != null && this.state.text.node.parentNode == this.graph.container;\n};\n\n/**\n * Function: rotatePoint\n *\n * Rotates the point by the given angle.\n */\nmxHandle.prototype.rotatePoint = function(pt, alpha)\n{\n\tvar bounds = this.state.getCellBounds();\n\tvar cx = new mxPoint(bounds.getCenterX(), bounds.getCenterY());\n\tvar cos = Math.cos(alpha);\n\tvar sin = Math.sin(alpha);\n\n\treturn mxUtils.getRotatedPoint(pt, cos, sin, cx);\n};\n\n/**\n * Function: flipPoint\n *\n * Flips the given point vertically and/or horizontally.\n */\nmxHandle.prototype.flipPoint = function(pt)\n{\n\tif (this.state.shape != null)\n\t{\n\t\tvar bounds = this.state.getCellBounds();\n\n\t\tif (this.state.shape.flipH)\n\t\t{\n\t\t\tpt.x = 2 * bounds.x + bounds.width - pt.x;\n\t\t}\n\n\t\tif (this.state.shape.flipV)\n\t\t{\n\t\t\tpt.y = 2 * bounds.y + bounds.height - pt.y;\n\t\t}\n\t}\n\n\treturn pt;\n};\n\n/**\n * Function: snapPoint\n *\n * Snaps the given point to the grid if ignore is false. This modifies\n * the given point in-place and also returns it.\n */\nmxHandle.prototype.snapPoint = function(pt, ignore)\n{\n\tif (!ignore)\n\t{\n\t\tpt.x = this.graph.snap(pt.x);\n\t\tpt.y = this.graph.snap(pt.y);\n\t}\n\n\treturn pt;\n};\n\n/**\n * Function: setVisible\n *\n * Shows or hides this handle.\n */\nmxHandle.prototype.setVisible = function(visible)\n{\n\tif (this.shape != null && this.shape.node != null)\n\t{\n\t\tthis.shape.node.style.display = (visible) ? '' : 'none';\n\t}\n};\n\n/**\n * Function: reset\n *\n * Resets the state of this handle by setting its visibility to true.\n */\nmxHandle.prototype.reset = function()\n{\n\tthis.setVisible(true);\n\tthis.state.style = this.graph.getCellStyle(this.state.cell);\n\tthis.positionChanged();\n};\n\n/**\n * Function: destroy\n *\n * Destroys this handle.\n */\nmxHandle.prototype.destroy = function()\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n};\n\n__mxOutput.mxHandle = typeof mxHandle !== 'undefined' ? mxHandle : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxVertexHandler\n *\n * Event handler for resizing cells. This handler is automatically created in\n * <mxGraph.createHandler>.\n *\n * Constructor: mxVertexHandler\n *\n * Constructs an event handler that allows to resize vertices\n * and groups.\n *\n * Parameters:\n *\n * state - <mxCellState> of the cell to be resized.\n */\nfunction mxVertexHandler(state)\n{\n\tif (state != null)\n\t{\n\t\tthis.state = state;\n\t\tthis.init();\n\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tif (this.livePreview && this.index != null)\n\t\t\t{\n\t\t\t\t// Redraws the live preview\n\t\t\t\tthis.state.view.graph.cellRenderer.redraw(this.state, true);\n\n\t\t\t\t// Redraws connected edges\n\t\t\t\tthis.state.view.invalidate(this.state.cell);\n\t\t\t\tthis.state.invalid = false;\n\t\t\t\tthis.state.view.validate();\n\t\t\t}\n\n\t\t\tthis.reset();\n\t\t});\n\n\t\tthis.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxVertexHandler.prototype.graph = null;\n\n/**\n * Variable: state\n *\n * Reference to the <mxCellState> being modified.\n */\nmxVertexHandler.prototype.state = null;\n\n/**\n * Variable: singleSizer\n *\n * Specifies if only one sizer handle at the bottom, right corner should be\n * used. Default is false.\n */\nmxVertexHandler.prototype.singleSizer = false;\n\n/**\n * Variable: index\n *\n * Holds the index of the current handle.\n */\nmxVertexHandler.prototype.index = null;\n\n/**\n * Variable: allowHandleBoundsCheck\n *\n * Specifies if the bounds of handles should be used for hit-detection in IE or\n * if <tolerance> > 0. Default is true.\n */\nmxVertexHandler.prototype.allowHandleBoundsCheck = true;\n\n/**\n * Variable: handleImage\n *\n * Optional <mxImage> to be used as handles. Default is null.\n */\nmxVertexHandler.prototype.handleImage = null;\n\n/**\n * Variable: tolerance\n *\n * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n */\nmxVertexHandler.prototype.tolerance = 0;\n\n/**\n * Variable: rotationEnabled\n *\n * Specifies if a rotation handle should be visible. Default is false.\n */\nmxVertexHandler.prototype.rotationEnabled = false;\n\n/**\n * Variable: parentHighlightEnabled\n *\n * Specifies if the parent should be highlighted if a child cell is selected.\n * Default is false.\n */\nmxVertexHandler.prototype.parentHighlightEnabled = false;\n\n/**\n * Variable: rotationRaster\n *\n * Specifies if rotation steps should be \"rasterized\" depening on the distance\n * to the handle. Default is true.\n */\nmxVertexHandler.prototype.rotationRaster = true;\n\n/**\n * Variable: rotationCursor\n *\n * Specifies the cursor for the rotation handle. Default is 'crosshair'.\n */\nmxVertexHandler.prototype.rotationCursor = 'crosshair';\n\n/**\n * Variable: livePreview\n *\n * Specifies if resize should change the cell in-place. This is an experimental\n * feature for non-touch devices. Default is false.\n */\nmxVertexHandler.prototype.livePreview = false;\n\n/**\n * Variable: manageSizers\n *\n * Specifies if sizers should be hidden and spaced if the vertex is small.\n * Default is false.\n */\nmxVertexHandler.prototype.manageSizers = false;\n\n/**\n * Variable: constrainGroupByChildren\n *\n * Specifies if the size of groups should be constrained by the children.\n * Default is false.\n */\nmxVertexHandler.prototype.constrainGroupByChildren = false;\n\n/**\n * Variable: rotationHandleVSpacing\n *\n * Vertical spacing for rotation icon. Default is -16.\n */\nmxVertexHandler.prototype.rotationHandleVSpacing = -16;\n\n/**\n * Variable: horizontalOffset\n *\n * The horizontal offset for the handles. This is updated in <redrawHandles>\n * if <manageSizers> is true and the sizers are offset horizontally.\n */\nmxVertexHandler.prototype.horizontalOffset = 0;\n\n/**\n * Variable: verticalOffset\n *\n * The horizontal offset for the handles. This is updated in <redrawHandles>\n * if <manageSizers> is true and the sizers are offset vertically.\n */\nmxVertexHandler.prototype.verticalOffset = 0;\n\n/**\n * Function: init\n *\n * Initializes the shapes required for this vertex handler.\n */\nmxVertexHandler.prototype.init = function()\n{\n\tthis.graph = this.state.view.graph;\n\tthis.selectionBounds = this.getSelectionBounds(this.state);\n\tthis.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n\tthis.selectionBorder = this.createSelectionShape(this.bounds);\n\t// VML dialect required here for event transparency in IE\n\tthis.selectionBorder.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\tthis.selectionBorder.pointerEvents = false;\n\tthis.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\tthis.selectionBorder.init(this.graph.getView().getOverlayPane());\n\tmxEvent.redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);\n\n\tif (this.graph.isCellMovable(this.state.cell))\n\t{\n\t\tthis.selectionBorder.setCursor(mxConstants.CURSOR_MOVABLE_VERTEX);\n\t}\n\n\t// Adds the sizer handles\n\tif (mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells)\n\t{\n\t\tvar resizable = this.graph.isCellResizable(this.state.cell);\n\t\tthis.sizers = [];\n\n\t\tif (resizable || (this.graph.isLabelMovable(this.state.cell) &&\n\t\t\tthis.state.width >= 2 && this.state.height >= 2))\n\t\t{\n\t\t\tvar i = 0;\n\n\t\t\tif (resizable)\n\t\t\t{\n\t\t\t\tif (!this.singleSizer)\n\t\t\t\t{\n\t\t\t\t\tthis.sizers.push(this.createSizer('nw-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('n-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('ne-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('w-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('e-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('sw-resize', i++));\n\t\t\t\t\tthis.sizers.push(this.createSizer('s-resize', i++));\n\t\t\t\t}\n\n\t\t\t\tthis.sizers.push(this.createSizer('se-resize', i++));\n\t\t\t}\n\n\t\t\tvar geo = this.graph.model.getGeometry(this.state.cell);\n\n\t\t\tif (geo != null && !geo.relative && !this.graph.isSwimlane(this.state.cell) &&\n\t\t\t\tthis.graph.isLabelMovable(this.state.cell))\n\t\t\t{\n\t\t\t\t// Marks this as the label handle for getHandleForEvent\n\t\t\t\tthis.labelShape = this.createSizer(mxConstants.CURSOR_LABEL_HANDLE, mxEvent.LABEL_HANDLE, mxConstants.LABEL_HANDLE_SIZE, mxConstants.LABEL_HANDLE_FILLCOLOR);\n\t\t\t\tthis.sizers.push(this.labelShape);\n\t\t\t}\n\t\t}\n\t\telse if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) &&\n\t\t\tthis.state.width < 2 && this.state.height < 2)\n\t\t{\n\t\t\tthis.labelShape = this.createSizer(mxConstants.CURSOR_MOVABLE_VERTEX,\n\t\t\t\tmxEvent.LABEL_HANDLE, null, mxConstants.LABEL_HANDLE_FILLCOLOR);\n\t\t\tthis.sizers.push(this.labelShape);\n\t\t}\n\t}\n\n\t// Adds the rotation handler\n\tif (this.isRotationHandleVisible())\n\t{\n\t\tthis.rotationShape = this.createSizer(this.rotationCursor, mxEvent.ROTATION_HANDLE,\n\t\t\tmxConstants.HANDLE_SIZE + 3, mxConstants.HANDLE_FILLCOLOR);\n\t\tthis.sizers.push(this.rotationShape);\n\t}\n\n\tthis.customHandles = this.createCustomHandles();\n\tthis.redraw();\n\n\tif (this.constrainGroupByChildren)\n\t{\n\t\tthis.updateMinBounds();\n\t}\n};\n\n/**\n * Function: isRotationHandleVisible\n *\n * Returns true if the rotation handle should be showing.\n */\nmxVertexHandler.prototype.isRotationHandleVisible = function()\n{\n\treturn this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) &&\n\t\t(mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells) &&\n\t\tthis.state.width >= 2 && this.state.height >= 2;\n};\n\n/**\n * Function: isConstrainedEvent\n *\n * Returns true if the aspect ratio if the cell should be maintained.\n */\nmxVertexHandler.prototype.isConstrainedEvent = function(me)\n{\n\treturn mxEvent.isShiftDown(me.getEvent()) || this.state.style[mxConstants.STYLE_ASPECT] == 'fixed';\n};\n\n/**\n * Function: isCenteredEvent\n *\n * Returns true if the center of the vertex should be maintained during the resize.\n */\nmxVertexHandler.prototype.isCenteredEvent = function(state, me)\n{\n\treturn false;\n};\n\n/**\n * Function: createCustomHandles\n *\n * Returns an array of custom handles. This implementation returns null.\n */\nmxVertexHandler.prototype.createCustomHandles = function()\n{\n\treturn null;\n};\n\n/**\n * Function: updateMinBounds\n *\n * Initializes the shapes required for this vertex handler.\n */\nmxVertexHandler.prototype.updateMinBounds = function()\n{\n\tvar children = this.graph.getChildCells(this.state.cell);\n\n\tif (children.length > 0)\n\t{\n\t\tthis.minBounds = this.graph.view.getBounds(children);\n\n\t\tif (this.minBounds != null)\n\t\t{\n\t\t\tvar s = this.state.view.scale;\n\t\t\tvar t = this.state.view.translate;\n\n\t\t\tthis.minBounds.x -= this.state.x;\n\t\t\tthis.minBounds.y -= this.state.y;\n\t\t\tthis.minBounds.x /= s;\n\t\t\tthis.minBounds.y /= s;\n\t\t\tthis.minBounds.width /= s;\n\t\t\tthis.minBounds.height /= s;\n\t\t\tthis.x0 = this.state.x / s - t.x;\n\t\t\tthis.y0 = this.state.y / s - t.y;\n\t\t}\n\t}\n};\n\n/**\n * Function: getSelectionBounds\n *\n * Returns the mxRectangle that defines the bounds of the selection\n * border.\n */\nmxVertexHandler.prototype.getSelectionBounds = function(state)\n{\n\treturn new mxRectangle(Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));\n};\n\n/**\n * Function: createParentHighlightShape\n *\n * Creates the shape used to draw the selection border.\n */\nmxVertexHandler.prototype.createParentHighlightShape = function(bounds)\n{\n\treturn this.createSelectionShape(bounds);\n};\n\n/**\n * Function: createSelectionShape\n *\n * Creates the shape used to draw the selection border.\n */\nmxVertexHandler.prototype.createSelectionShape = function(bounds)\n{\n\tvar shape = new mxRectangleShape(bounds, null, this.getSelectionColor());\n\tshape.strokewidth = this.getSelectionStrokeWidth();\n\tshape.isDashed = this.isSelectionDashed();\n\n\treturn shape;\n};\n\n/**\n * Function: getSelectionColor\n *\n * Returns <mxConstants.VERTEX_SELECTION_COLOR>.\n */\nmxVertexHandler.prototype.getSelectionColor = function()\n{\n\treturn mxConstants.VERTEX_SELECTION_COLOR;\n};\n\n/**\n * Function: getSelectionStrokeWidth\n *\n * Returns <mxConstants.VERTEX_SELECTION_STROKEWIDTH>.\n */\nmxVertexHandler.prototype.getSelectionStrokeWidth = function()\n{\n\treturn mxConstants.VERTEX_SELECTION_STROKEWIDTH;\n};\n\n/**\n * Function: isSelectionDashed\n *\n * Returns <mxConstants.VERTEX_SELECTION_DASHED>.\n */\nmxVertexHandler.prototype.isSelectionDashed = function()\n{\n\treturn mxConstants.VERTEX_SELECTION_DASHED;\n};\n\n/**\n * Function: createSizer\n *\n * Creates a sizer handle for the specified cursor and index and returns\n * the new <mxRectangleShape> that represents the handle.\n */\nmxVertexHandler.prototype.createSizer = function(cursor, index, size, fillColor)\n{\n\tsize = size || mxConstants.HANDLE_SIZE;\n\n\tvar bounds = new mxRectangle(0, 0, size, size);\n\tvar sizer = this.createSizerShape(bounds, index, fillColor);\n\n\tif (sizer.isHtmlAllowed() && this.state.text != null && this.state.text.node.parentNode == this.graph.container)\n\t{\n\t\tsizer.bounds.height -= 1;\n\t\tsizer.bounds.width -= 1;\n\t\tsizer.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tsizer.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\tsizer.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\t\tsizer.init(this.graph.getView().getOverlayPane());\n\t}\n\n\tmxEvent.redirectMouseEvents(sizer.node, this.graph, this.state);\n\n\tif (this.graph.isEnabled())\n\t{\n\t\tsizer.setCursor(cursor);\n\t}\n\n\tif (!this.isSizerVisible(index))\n\t{\n\t\tsizer.visible = false;\n\t}\n\n\treturn sizer;\n};\n\n/**\n * Function: isSizerVisible\n *\n * Returns true if the sizer for the given index is visible.\n * This returns true for all given indices.\n */\nmxVertexHandler.prototype.isSizerVisible = function(index)\n{\n\treturn true;\n};\n\n/**\n * Function: createSizerShape\n *\n * Creates the shape used for the sizer handle for the specified bounds an\n * index. Only images and rectangles should be returned if support for HTML\n * labels with not foreign objects is required.\n */\nmxVertexHandler.prototype.createSizerShape = function(bounds, index, fillColor)\n{\n\tif (this.handleImage != null)\n\t{\n\t\tbounds = new mxRectangle(bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);\n\t\tvar shape = new mxImageShape(bounds, this.handleImage.src);\n\n\t\t// Allows HTML rendering of the images\n\t\tshape.preserveImageAspect = false;\n\n\t\treturn shape;\n\t}\n\telse if (index == mxEvent.ROTATION_HANDLE)\n\t{\n\t\treturn new mxEllipse(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n\telse\n\t{\n\t\treturn new mxRectangleShape(bounds, fillColor || mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n};\n\n/**\n * Function: createBounds\n *\n * Helper method to create an <mxRectangle> around the given centerpoint\n * with a width and height of 2*s or 6, if no s is given.\n */\nmxVertexHandler.prototype.moveSizerTo = function(shape, x, y)\n{\n\tif (shape != null)\n\t{\n\t\tshape.bounds.x = Math.floor(x - shape.bounds.width / 2);\n\t\tshape.bounds.y = Math.floor(y - shape.bounds.height / 2);\n\n\t\t// Fixes visible inactive handles in VML\n\t\tif (shape.node != null && shape.node.style.display != 'none')\n\t\t{\n\t\t\tshape.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: getHandleForEvent\n *\n * Returns the index of the handle for the given event. This returns the index\n * of the sizer from where the event originated or <mxEvent.LABEL_INDEX>.\n */\nmxVertexHandler.prototype.getHandleForEvent = function(me)\n{\n\t// Connection highlight may consume events before they reach sizer handle\n\tvar tol = (!mxEvent.isMouseEvent(me.getEvent())) ? this.tolerance : 1;\n\tvar hit = (this.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0)) ?\n\t\tnew mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n\n\tfunction checkShape(shape)\n\t{\n\t\treturn shape != null && (me.isSource(shape) || (hit != null && mxUtils.intersects(shape.bounds, hit) &&\n\t\t\tshape.node.style.display != 'none' && shape.node.style.visibility != 'hidden'));\n\t}\n\n\tif (this.customHandles != null && this.isCustomHandleEvent(me))\n\t{\n\t\t// Inverse loop order to match display order\n\t\tfor (var i = this.customHandles.length - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (checkShape(this.customHandles[i].shape))\n\t\t\t{\n\t\t\t\t// LATER: Return reference to active shape\n\t\t\t\treturn mxEvent.CUSTOM_HANDLE - i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (checkShape(this.rotationShape))\n\t{\n\t\treturn mxEvent.ROTATION_HANDLE;\n\t}\n\telse if (checkShape(this.labelShape))\n\t{\n\t\treturn mxEvent.LABEL_HANDLE;\n\t}\n\n\tif (this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tif (checkShape(this.sizers[i]))\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: isCustomHandleEvent\n *\n * Returns true if the given event allows custom handles to be changed. This\n * implementation returns true.\n */\nmxVertexHandler.prototype.isCustomHandleEvent = function(me)\n{\n\treturn true;\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event if a handle has been clicked. By consuming the\n * event all subsequent events of the gesture are redirected to this\n * handler.\n */\nmxVertexHandler.prototype.mouseDown = function(sender, me)\n{\n\tvar tol = (!mxEvent.isMouseEvent(me.getEvent())) ? this.tolerance : 0;\n\n\tif (!me.isConsumed() && this.graph.isEnabled() && (tol > 0 || me.getState() == this.state))\n\t{\n\t\tvar handle = this.getHandleForEvent(me);\n\n\t\tif (handle != null)\n\t\t{\n\t\t\tthis.start(me.getGraphX(), me.getGraphY(), handle);\n\t\t\tme.consume();\n\t\t}\n\t}\n};\n\n/**\n * Function: isLivePreviewBorder\n *\n * Called if <livePreview> is enabled to check if a border should be painted.\n * This implementation returns true if the shape is transparent.\n */\nmxVertexHandler.prototype.isLivePreviewBorder = function()\n{\n\treturn this.state.shape != null && this.state.shape.fill == null && this.state.shape.stroke == null;\n};\n\n/**\n * Function: start\n *\n * Starts the handling of the mouse gesture.\n */\nmxVertexHandler.prototype.start = function(x, y, index)\n{\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.inTolerance = true;\n\t\tthis.childOffsetX = 0;\n\t\tthis.childOffsetY = 0;\n\t\tthis.index = index;\n\t\tthis.startX = x;\n\t\tthis.startY = y;\n\n\t\t// Saves reference to parent state\n\t\tvar model = this.state.view.graph.model;\n\t\tvar parent = model.getParent(this.state.cell);\n\n\t\tif (this.state.view.currentRoot != parent && (model.isVertex(parent) || model.isEdge(parent)))\n\t\t{\n\t\t\tthis.parentState = this.state.view.graph.view.getState(parent);\n\t\t}\n\n\t\t// Creates a preview that can be on top of any HTML label\n\t\tthis.selectionBorder.node.style.display = (index == mxEvent.ROTATION_HANDLE) ? 'inline' : 'none';\n\n\t\t// Creates the border that represents the new bounds\n\t\tif (!this.livePreview || this.isLivePreviewBorder())\n\t\t{\n\t\t\tthis.preview = this.createSelectionShape(this.bounds);\n\n\t\t\tif (!(mxClient.IS_SVG && Number(this.state.style[mxConstants.STYLE_ROTATION] || '0') != 0) &&\n\t\t\t\tthis.state.text != null && this.state.text.node.parentNode == this.graph.container)\n\t\t\t{\n\t\t\t\tthis.preview.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\t\t\tthis.preview.init(this.graph.container);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.preview.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\t\t\t\tmxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\tthis.preview.init(this.graph.view.getOverlayPane());\n\t\t\t}\n\t\t}\n\n\t\t// Prepares the handles for live preview\n\t\tif (this.livePreview)\n\t\t{\n\t\t\tthis.hideSizers();\n\n\t\t\tif (index == mxEvent.ROTATION_HANDLE)\n\t\t\t{\n\t\t\t\tthis.rotationShape.node.style.display = '';\n\t\t\t}\n\t\t\telse if (index == mxEvent.LABEL_HANDLE)\n\t\t\t{\n\t\t\t\tthis.labelShape.node.style.display = '';\n\t\t\t}\n\t\t\telse if (this.sizers != null && this.sizers[index] != null)\n\t\t\t{\n\t\t\t\tthis.sizers[index].node.style.display = '';\n\t\t\t}\n\t\t\telse if (index <= mxEvent.CUSTOM_HANDLE && this.customHandles != null)\n\t\t\t{\n\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].setVisible(true);\n\t\t\t}\n\n\t\t\t// Gets the array of connected edge handlers for redrawing\n\t\t\tvar edges = this.graph.getEdges(this.state.cell);\n\t\t\tthis.edgeHandlers = [];\n\n\t\t\tfor (var i = 0; i < edges.length; i++)\n\t\t\t{\n\t\t\t\tvar handler = this.graph.selectionCellsHandler.getHandler(edges[i]);\n\n\t\t\t\tif (handler != null)\n\t\t\t\t{\n\t\t\t\t\tthis.edgeHandlers.push(handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: hideHandles\n *\n * Shortcut to <hideSizers>.\n */\nmxVertexHandler.prototype.setHandlesVisible = function(visible)\n{\n\tif (this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tthis.sizers[i].node.style.display = (visible) ? '' : 'none';\n\t\t}\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].setVisible(visible);\n\t\t}\n\t}\n};\n\n/**\n * Function: hideSizers\n *\n * Hides all sizers except.\n *\n * Starts the handling of the mouse gesture.\n */\nmxVertexHandler.prototype.hideSizers = function()\n{\n\tthis.setHandlesVisible(false);\n};\n\n/**\n * Function: checkTolerance\n *\n * Checks if the coordinates for the given event are within the\n * <mxGraph.tolerance>. If the event is a mouse event then the tolerance is\n * ignored.\n */\nmxVertexHandler.prototype.checkTolerance = function(me)\n{\n\tif (this.inTolerance && this.startX != null && this.startY != null)\n\t{\n\t\tif (mxEvent.isMouseEvent(me.getEvent()) ||\n\t\t\tMath.abs(me.getGraphX() - this.startX) > this.graph.tolerance ||\n\t\t\tMath.abs(me.getGraphY() - this.startY) > this.graph.tolerance)\n\t\t{\n\t\t\tthis.inTolerance = false;\n\t\t}\n\t}\n};\n\n/**\n * Function: updateHint\n *\n * Hook for subclassers do show details while the handler is active.\n */\nmxVertexHandler.prototype.updateHint = function(me) { };\n\n/**\n * Function: removeHint\n *\n * Hooks for subclassers to hide details when the handler gets inactive.\n */\nmxVertexHandler.prototype.removeHint = function() { };\n\n/**\n * Function: roundAngle\n *\n * Hook for rounding the angle. This uses Math.round.\n */\nmxVertexHandler.prototype.roundAngle = function(angle)\n{\n\treturn Math.round(angle * 10) / 10;\n};\n\n/**\n * Function: roundLength\n *\n * Hook for rounding the unscaled width or height. This uses Math.round.\n */\nmxVertexHandler.prototype.roundLength = function(length)\n{\n\treturn Math.round(length);\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by updating the preview.\n */\nmxVertexHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (!me.isConsumed() && this.index != null)\n\t{\n\t\t// Checks tolerance for ignoring single clicks\n\t\tthis.checkTolerance(me);\n\n\t\tif (!this.inTolerance)\n\t\t{\n\t\t\tif (this.index <= mxEvent.CUSTOM_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.customHandles != null)\n\t\t\t\t{\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].active = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.index == mxEvent.LABEL_HANDLE)\n\t\t\t{\n\t\t\t\tthis.moveLabel(me);\n\t\t\t}\n\t\t\telse if (this.index == mxEvent.ROTATION_HANDLE)\n\t\t\t{\n\t\t\t\tthis.rotateVertex(me);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.resizeVertex(me);\n\t\t\t}\n\n\t\t\tthis.updateHint(me);\n\t\t}\n\n\t\tme.consume();\n\t}\n\t// Workaround for disabling the connect highlight when over handle\n\telse if (!this.graph.isMouseDown && this.getHandleForEvent(me) != null)\n\t{\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: rotateVertex\n *\n * Rotates the vertex.\n */\nmxVertexHandler.prototype.moveLabel = function(me)\n{\n\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\tvar tr = this.graph.view.translate;\n\tvar scale = this.graph.view.scale;\n\n\tif (this.graph.isGridEnabledEvent(me.getEvent()))\n\t{\n\t\tpoint.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n\t\tpoint.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n\t}\n\n\tvar index = (this.rotationShape != null) ? this.sizers.length - 2 : this.sizers.length - 1;\n\tthis.moveSizerTo(this.sizers[index], point.x, point.y);\n};\n\n/**\n * Function: rotateVertex\n *\n * Rotates the vertex.\n */\nmxVertexHandler.prototype.rotateVertex = function(me)\n{\n\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\tvar dx = this.state.x + this.state.width / 2 - point.x;\n\tvar dy = this.state.y + this.state.height / 2 - point.y;\n\tthis.currentAlpha = (dx != 0) ? Math.atan(dy / dx) * 180 / Math.PI + 90 : ((dy < 0) ? 180 : 0);\n\n\tif (dx > 0)\n\t{\n\t\tthis.currentAlpha -= 180;\n\t}\n\n\t// Rotation raster\n\tif (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent()))\n\t{\n\t\tvar dx = point.x - this.state.getCenterX();\n\t\tvar dy = point.y - this.state.getCenterY();\n\t\tvar dist = Math.abs(Math.sqrt(dx * dx + dy * dy) - 20) * 3;\n\t\tvar raster = Math.max(1, 5 * Math.min(3, Math.max(0, Math.round(80 / Math.abs(dist)))));\n\n\t\tthis.currentAlpha = Math.round(this.currentAlpha / raster) * raster;\n\t}\n\telse\n\t{\n\t\tthis.currentAlpha = this.roundAngle(this.currentAlpha);\n\t}\n\n\tthis.selectionBorder.rotation = this.currentAlpha;\n\tthis.selectionBorder.redraw();\n\n\tif (this.livePreview)\n\t{\n\t\tthis.redrawHandles();\n\t}\n};\n\n/**\n * Function: rotateVertex\n *\n * Rotates the vertex.\n */\nmxVertexHandler.prototype.resizeVertex = function(me)\n{\n\tvar ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());\n\tvar alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\tvar tr = this.graph.view.translate;\n\tvar scale = this.graph.view.scale;\n\tvar cos = Math.cos(-alpha);\n\tvar sin = Math.sin(-alpha);\n\n\tvar dx = point.x - this.startX;\n\tvar dy = point.y - this.startY;\n\n\t// Rotates vector for mouse gesture\n\tvar tx = cos * dx - sin * dy;\n\tvar ty = sin * dx + cos * dy;\n\n\tdx = tx;\n\tdy = ty;\n\n\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\tthis.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index,\n\t\tthis.graph.isGridEnabledEvent(me.getEvent()), 1,\n\t\tnew mxPoint(0, 0), this.isConstrainedEvent(me),\n\t\tthis.isCenteredEvent(this.state, me));\n\n\t// Keeps vertex within maximum graph or parent bounds\n\tif (!geo.relative)\n\t{\n\t\tvar max = this.graph.getMaximumGraphBounds();\n\n\t\t// Handles child cells\n\t\tif (max != null && this.parentState != null)\n\t\t{\n\t\t\tmax = mxRectangle.fromRectangle(max);\n\n\t\t\tmax.x -= (this.parentState.x - tr.x * scale) / scale;\n\t\t\tmax.y -= (this.parentState.y - tr.y * scale) / scale;\n\t\t}\n\n\t\tif (this.graph.isConstrainChild(this.state.cell))\n\t\t{\n\t\t\tvar tmp = this.graph.getCellContainmentArea(this.state.cell);\n\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tvar overlap = this.graph.getOverlap(this.state.cell);\n\n\t\t\t\tif (overlap > 0)\n\t\t\t\t{\n\t\t\t\t\ttmp = mxRectangle.fromRectangle(tmp);\n\n\t\t\t\t\ttmp.x -= tmp.width * overlap;\n\t\t\t\t\ttmp.y -= tmp.height * overlap;\n\t\t\t\t\ttmp.width += 2 * tmp.width * overlap;\n\t\t\t\t\ttmp.height += 2 * tmp.height * overlap;\n\t\t\t\t}\n\n\t\t\t\tif (max == null)\n\t\t\t\t{\n\t\t\t\t\tmax = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmax = mxRectangle.fromRectangle(max);\n\t\t\t\t\tmax.intersect(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (max != null)\n\t\t{\n\t\t\tif (this.unscaledBounds.x < max.x)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.width -= max.x - this.unscaledBounds.x;\n\t\t\t\tthis.unscaledBounds.x = max.x;\n\t\t\t}\n\n\t\t\tif (this.unscaledBounds.y < max.y)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.height -= max.y - this.unscaledBounds.y;\n\t\t\t\tthis.unscaledBounds.y = max.y;\n\t\t\t}\n\n\t\t\tif (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.width -= this.unscaledBounds.x +\n\t\t\t\t\tthis.unscaledBounds.width - max.x - max.width;\n\t\t\t}\n\n\t\t\tif (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height)\n\t\t\t{\n\t\t\t\tthis.unscaledBounds.height -= this.unscaledBounds.y +\n\t\t\t\t\tthis.unscaledBounds.height - max.y - max.height;\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.bounds = new mxRectangle(((this.parentState != null) ? this.parentState.x : tr.x * scale) +\n\t\t(this.unscaledBounds.x) * scale, ((this.parentState != null) ? this.parentState.y : tr.y * scale) +\n\t\t(this.unscaledBounds.y) * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);\n\n\tif (geo.relative && this.parentState != null)\n\t{\n\t\tthis.bounds.x += this.state.x - this.parentState.x;\n\t\tthis.bounds.y += this.state.y - this.parentState.y;\n\t}\n\n\tcos = Math.cos(alpha);\n\tsin = Math.sin(alpha);\n\n\tvar c2 = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY());\n\n\tvar dx = c2.x - ct.x;\n\tvar dy = c2.y - ct.y;\n\n\tvar dx2 = cos * dx - sin * dy;\n\tvar dy2 = sin * dx + cos * dy;\n\n\tvar dx3 = dx2 - dx;\n\tvar dy3 = dy2 - dy;\n\n\tvar dx4 = this.bounds.x - this.state.x;\n\tvar dy4 = this.bounds.y - this.state.y;\n\n\tvar dx5 = cos * dx4 - sin * dy4;\n\tvar dy5 = sin * dx4 + cos * dy4;\n\n\tthis.bounds.x += dx3;\n\tthis.bounds.y += dy3;\n\n\t// Rounds unscaled bounds to int\n\tthis.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);\n\tthis.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);\n\tthis.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);\n\tthis.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);\n\n\t// Shifts the children according to parent offset\n\tif (!this.graph.isCellCollapsed(this.state.cell) && (dx3 != 0 || dy3 != 0))\n\t{\n\t\tthis.childOffsetX = this.state.x - this.bounds.x + dx5;\n\t\tthis.childOffsetY = this.state.y - this.bounds.y + dy5;\n\t}\n\telse\n\t{\n\t\tthis.childOffsetX = 0;\n\t\tthis.childOffsetY = 0;\n\t}\n\n\tif (this.livePreview)\n\t{\n\t\tthis.updateLivePreview(me);\n\t}\n\n\tif (this.preview != null)\n\t{\n\t\tthis.drawPreview();\n\t}\n};\n\n/**\n * Function: updateLivePreview\n *\n * Repaints the live preview.\n */\nmxVertexHandler.prototype.updateLivePreview = function(me)\n{\n\t// TODO: Apply child offset to children in live preview\n\tvar scale = this.graph.view.scale;\n\tvar tr = this.graph.view.translate;\n\n\t// Saves current state\n\tvar tempState = this.state.clone();\n\n\t// Temporarily changes size and origin\n\tthis.state.x = this.bounds.x;\n\tthis.state.y = this.bounds.y;\n\tthis.state.origin = new mxPoint(this.state.x / scale - tr.x, this.state.y / scale - tr.y);\n\tthis.state.width = this.bounds.width;\n\tthis.state.height = this.bounds.height;\n\n\t// Needed to force update of text bounds\n\tthis.state.unscaledWidth = null;\n\n\t// Redraws cell and handles\n\tvar off = this.state.absoluteOffset;\n\toff = new mxPoint(off.x, off.y);\n\n\t// Required to store and reset absolute offset for updating label position\n\tthis.state.absoluteOffset.x = 0;\n\tthis.state.absoluteOffset.y = 0;\n\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\n\tif (geo != null)\n\t{\n\t\tvar offset = geo.offset || this.EMPTY_POINT;\n\n\t\tif (offset != null && !geo.relative)\n\t\t{\n\t\t\tthis.state.absoluteOffset.x = this.state.view.scale * offset.x;\n\t\t\tthis.state.absoluteOffset.y = this.state.view.scale * offset.y;\n\t\t}\n\n\t\tthis.state.view.updateVertexLabelOffset(this.state);\n\t}\n\n\t// Draws the live preview\n\tthis.state.view.graph.cellRenderer.redraw(this.state, true);\n\n\t// Redraws connected edges TODO: Include child edges\n\tthis.state.view.invalidate(this.state.cell);\n\tthis.state.invalid = false;\n\tthis.state.view.validate();\n\tthis.redrawHandles();\n\n\t// Restores current state\n\tthis.state.setState(tempState);\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by applying the changes to the geometry.\n */\nmxVertexHandler.prototype.mouseUp = function(sender, me)\n{\n\tif (this.index != null && this.state != null)\n\t{\n\t\tvar point = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\tvar index = this.index;\n\t\tthis.index = null;\n\n\t\tthis.graph.getModel().beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tif (index <= mxEvent.CUSTOM_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.customHandles != null)\n\t\t\t\t{\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].active = false;\n\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].execute();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (index == mxEvent.ROTATION_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.currentAlpha != null)\n\t\t\t\t{\n\t\t\t\t\tvar delta = this.currentAlpha - (this.state.style[mxConstants.STYLE_ROTATION] || 0);\n\n\t\t\t\t\tif (delta != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.rotateCell(this.state.cell, delta);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.rotateClick();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());\n\t\t\t\tvar alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\t\tvar cos = Math.cos(-alpha);\n\t\t\t\tvar sin = Math.sin(-alpha);\n\n\t\t\t\tvar dx = point.x - this.startX;\n\t\t\t\tvar dy = point.y - this.startY;\n\n\t\t\t\t// Rotates vector for mouse gesture\n\t\t\t\tvar tx = cos * dx - sin * dy;\n\t\t\t\tvar ty = sin * dx + cos * dy;\n\n\t\t\t\tdx = tx;\n\t\t\t\tdy = ty;\n\n\t\t\t\tvar s = this.graph.view.scale;\n\t\t\t\tvar recurse = this.isRecursiveResize(this.state, me);\n\t\t\t\tthis.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s),\n\t\t\t\t\tindex, gridEnabled, this.isConstrainedEvent(me), recurse);\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.graph.getModel().endUpdate();\n\t\t}\n\n\t\tme.consume();\n\t\tthis.reset();\n\t}\n};\n\n/**\n * Function: rotateCell\n *\n * Rotates the given cell to the given rotation.\n */\nmxVertexHandler.prototype.isRecursiveResize = function(state, me)\n{\n\treturn this.graph.isRecursiveResize(this.state);\n};\n\n/**\n * Function: rotateClick\n *\n * Hook for subclassers to implement a single click on the rotation handle.\n * This code is executed as part of the model transaction. This implementation\n * is empty.\n */\nmxVertexHandler.prototype.rotateClick = function() { };\n\n/**\n * Function: rotateCell\n *\n * Rotates the given cell and its children by the given angle in degrees.\n *\n * Parameters:\n *\n * cell - <mxCell> to be rotated.\n * angle - Angle in degrees.\n */\nmxVertexHandler.prototype.rotateCell = function(cell, angle, parent)\n{\n\tif (angle != 0)\n\t{\n\t\tvar model = this.graph.getModel();\n\n\t\tif (model.isVertex(cell) || model.isEdge(cell))\n\t\t{\n\t\t\tif (!model.isEdge(cell))\n\t\t\t{\n\t\t\t\tvar state = this.graph.view.getState(cell);\n\t\t\t\tvar style = (state != null) ? state.style : this.graph.getCellStyle(cell);\n\n\t\t\t\tif (style != null)\n\t\t\t\t{\n\t\t\t\t\tvar total = (style[mxConstants.STYLE_ROTATION] || 0) + angle;\n\t\t\t\t\tthis.graph.setCellStyles(mxConstants.STYLE_ROTATION, total, [cell]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar geo = this.graph.getCellGeometry(cell);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar pgeo = this.graph.getCellGeometry(parent);\n\n\t\t\t\tif (pgeo != null && !model.isEdge(parent))\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\tgeo.rotate(angle, new mxPoint(pgeo.width / 2, pgeo.height / 2));\n\t\t\t\t\tmodel.setGeometry(cell, geo);\n\t\t\t\t}\n\n\t\t\t\tif ((model.isVertex(cell) && !geo.relative) || model.isEdge(cell))\n\t\t\t\t{\n\t\t\t\t\t// Recursive rotation\n\t\t\t\t\tvar childCount = model.getChildCount(cell);\n\n\t\t\t\t\tfor (var i = 0; i < childCount; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.rotateCell(model.getChildAt(cell, i), angle, cell);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: reset\n *\n * Resets the state of this handler.\n */\nmxVertexHandler.prototype.reset = function()\n{\n\tif (this.sizers != null && this.index != null && this.sizers[this.index] != null &&\n\t\tthis.sizers[this.index].node.style.display == 'none')\n\t{\n\t\tthis.sizers[this.index].node.style.display = '';\n\t}\n\n\tthis.currentAlpha = null;\n\tthis.inTolerance = null;\n\tthis.index = null;\n\n\t// TODO: Reset and redraw cell states for live preview\n\tif (this.preview != null)\n\t{\n\t\tthis.preview.destroy();\n\t\tthis.preview = null;\n\t}\n\n\tif (this.livePreview && this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tif (this.sizers[i] != null)\n\t\t\t{\n\t\t\t\tthis.sizers[i].node.style.display = '';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tif (this.customHandles[i].active)\n\t\t\t{\n\t\t\t\tthis.customHandles[i].active = false;\n\t\t\t\tthis.customHandles[i].reset();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.customHandles[i].setVisible(true);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Checks if handler has been destroyed\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.node.style.display = 'inline';\n\t\tthis.selectionBounds = this.getSelectionBounds(this.state);\n\t\tthis.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y,\n\t\t\tthis.selectionBounds.width, this.selectionBounds.height);\n\t\tthis.drawPreview();\n\t}\n\n\tthis.removeHint();\n\tthis.redrawHandles();\n\tthis.edgeHandlers = null;\n\tthis.unscaledBounds = null;\n};\n\n/**\n * Function: resizeCell\n *\n * Uses the given vector to change the bounds of the given cell\n * in the graph using <mxGraph.resizeCell>.\n */\nmxVertexHandler.prototype.resizeCell = function(cell, dx, dy, index, gridEnabled, constrained, recurse)\n{\n\tvar geo = this.graph.model.getGeometry(cell);\n\n\tif (geo != null)\n\t{\n\t\tif (index == mxEvent.LABEL_HANDLE)\n\t\t{\n\t\t\tvar scale = this.graph.view.scale;\n\t\t\tdx = Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale);\n\t\t\tdy = Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale);\n\n\t\t\tgeo = geo.clone();\n\n\t\t\tif (geo.offset == null)\n\t\t\t{\n\t\t\t\tgeo.offset = new mxPoint(dx, dy);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgeo.offset.x += dx;\n\t\t\t\tgeo.offset.y += dy;\n\t\t\t}\n\n\t\t\tthis.graph.model.setGeometry(cell, geo);\n\t\t}\n\t\telse if (this.unscaledBounds != null)\n\t\t{\n\t\t\tvar scale = this.graph.view.scale;\n\n\t\t\tif (this.childOffsetX != 0 || this.childOffsetY != 0)\n\t\t\t{\n\t\t\t\tthis.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));\n\t\t\t}\n\n\t\t\tthis.graph.resizeCell(cell, this.unscaledBounds, recurse);\n\t\t}\n\t}\n};\n\n/**\n * Function: moveChildren\n *\n * Moves the children of the given cell by the given vector.\n */\nmxVertexHandler.prototype.moveChildren = function(cell, dx, dy)\n{\n\tvar model = this.graph.getModel();\n\tvar childCount = model.getChildCount(cell);\n\n\tfor (var i = 0; i < childCount; i++)\n\t{\n\t\tvar child = model.getChildAt(cell, i);\n\t\tvar geo = this.graph.getCellGeometry(child);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.translate(dx, dy);\n\t\t\tmodel.setGeometry(child, geo);\n\t\t}\n\t}\n};\n/**\n * Function: union\n *\n * Returns the union of the given bounds and location for the specified\n * handle index.\n *\n * To override this to limit the size of vertex via a minWidth/-Height style,\n * the following code can be used.\n *\n * (code)\n * var vertexHandlerUnion = mxVertexHandler.prototype.union;\n * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\n * {\n *   var result = vertexHandlerUnion.apply(this, arguments);\n *\n *   result.width = Math.max(result.width, mxUtils.getNumber(this.state.style, 'minWidth', 0));\n *   result.height = Math.max(result.height, mxUtils.getNumber(this.state.style, 'minHeight', 0));\n *\n *   return result;\n * };\n * (end)\n *\n * The minWidth/-Height style can then be used as follows:\n *\n * (code)\n * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\n * (end)\n *\n * To override this to update the height for a wrapped text if the width of a vertex is\n * changed, the following can be used.\n *\n * (code)\n * var mxVertexHandlerUnion = mxVertexHandler.prototype.union;\n * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\n * {\n *   var result = mxVertexHandlerUnion.apply(this, arguments);\n *   var s = this.state;\n *\n *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\n *       s.text != null && s.style[mxConstants.STYLE_WHITE_SPACE] == 'wrap')\n *   {\n *     var label = this.graph.getLabel(s.cell);\n *     var fontSize = mxUtils.getNumber(s.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);\n *     var ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\n *\n *     result.height = mxUtils.getSizeForString(label, fontSize, s.style[mxConstants.STYLE_FONTFAMILY], ww).height;\n *   }\n *\n *   return result;\n * };\n * (end)\n */\nmxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered)\n{\n\tif (this.singleSizer)\n\t{\n\t\tvar x = bounds.x + bounds.width + dx;\n\t\tvar y = bounds.y + bounds.height + dy;\n\n\t\tif (gridEnabled)\n\t\t{\n\t\t\tx = this.graph.snap(x / scale) * scale;\n\t\t\ty = this.graph.snap(y / scale) * scale;\n\t\t}\n\n\t\tvar rect = new mxRectangle(bounds.x, bounds.y, 0, 0);\n\t\trect.add(new mxRectangle(x, y, 0, 0));\n\n\t\treturn rect;\n\t}\n\telse\n\t{\n\t\tvar w0 = bounds.width;\n\t\tvar h0 = bounds.height;\n\t\tvar left = bounds.x - tr.x * scale;\n\t\tvar right = left + w0;\n\t\tvar top = bounds.y - tr.y * scale;\n\t\tvar bottom = top + h0;\n\n\t\tvar cx = left + w0 / 2;\n\t\tvar cy = top + h0 / 2;\n\n\t\tif (index > 4 /* Bottom Row */)\n\t\t{\n\t\t\tbottom = bottom + dy;\n\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\tbottom = this.graph.snap(bottom / scale) * scale;\n\t\t\t}\n\t\t}\n\t\telse if (index < 3 /* Top Row */)\n\t\t{\n\t\t\ttop = top + dy;\n\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\ttop = this.graph.snap(top / scale) * scale;\n\t\t\t}\n\t\t}\n\n\t\tif (index == 0 || index == 3 || index == 5 /* Left */)\n\t\t{\n\t\t\tleft += dx;\n\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\tleft = this.graph.snap(left / scale) * scale;\n\t\t\t}\n\t\t}\n\t\telse if (index == 2 || index == 4 || index == 7 /* Right */)\n\t\t{\n\t\t\tright += dx;\n\n\t\t\tif (gridEnabled)\n\t\t\t{\n\t\t\t\tright = this.graph.snap(right / scale) * scale;\n\t\t\t}\n\t\t}\n\n\t\tvar width = right - left;\n\t\tvar height = bottom - top;\n\n\t\tif (constrained)\n\t\t{\n\t\t\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tvar aspect = geo.width / geo.height;\n\n\t\t\t\tif (index== 1 || index== 2 || index == 7 || index == 6)\n\t\t\t\t{\n\t\t\t\t\twidth = height * aspect;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\theight = width / aspect;\n\t\t\t\t}\n\n\t\t\t\tif (index == 0)\n\t\t\t\t{\n\t\t\t\t\tleft = right - width;\n\t\t\t\t\ttop = bottom - height;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (centered)\n\t\t{\n\t\t\twidth += (width - w0);\n\t\t\theight += (height - h0);\n\n\t\t\tvar cdx = cx - (left + width / 2);\n\t\t\tvar cdy = cy - (top + height / 2);\n\n\t\t\tleft += cdx;\n\t\t\ttop += cdy;\n\t\t\tright += cdx;\n\t\t\tbottom += cdy;\n\t\t}\n\n\t\t// Flips over left side\n\t\tif (width < 0)\n\t\t{\n\t\t\tleft += width;\n\t\t\twidth = Math.abs(width);\n\t\t}\n\n\t\t// Flips over top side\n\t\tif (height < 0)\n\t\t{\n\t\t\ttop += height;\n\t\t\theight = Math.abs(height);\n\t\t}\n\n\t\tvar result = new mxRectangle(left + tr.x * scale, top + tr.y * scale, width, height);\n\n\t\tif (this.minBounds != null)\n\t\t{\n\t\t\tresult.width = Math.max(result.width, this.minBounds.x * scale + this.minBounds.width * scale +\n\t\t\t\tMath.max(0, this.x0 * scale - result.x));\n\t\t\tresult.height = Math.max(result.height, this.minBounds.y * scale + this.minBounds.height * scale +\n\t\t\t\tMath.max(0, this.y0 * scale - result.y));\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\n/**\n * Function: redraw\n *\n * Redraws the handles and the preview.\n */\nmxVertexHandler.prototype.redraw = function()\n{\n\tthis.selectionBounds = this.getSelectionBounds(this.state);\n\tthis.bounds = new mxRectangle(this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n\n\tthis.redrawHandles();\n\tthis.drawPreview();\n};\n\n/**\n * Returns the padding to be used for drawing handles for the current <bounds>.\n */\nmxVertexHandler.prototype.getHandlePadding = function()\n{\n\t// KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n\tvar result = new mxPoint(0, 0);\n\tvar tol = this.tolerance;\n\n\tif (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null &&\n\t\t(this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol ||\n\t\tthis.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol))\n\t{\n\t\ttol /= 2;\n\n\t\tresult.x = this.sizers[0].bounds.width + tol;\n\t\tresult.y = this.sizers[0].bounds.height + tol;\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: redrawHandles\n *\n * Redraws the handles. To hide certain handles the following code can be used.\n *\n * (code)\n * mxVertexHandler.prototype.redrawHandles = function()\n * {\n *   mxVertexHandlerRedrawHandles.apply(this, arguments);\n *\n *   if (this.sizers != null && this.sizers.length > 7)\n *   {\n *     this.sizers[1].node.style.display = 'none';\n *     this.sizers[6].node.style.display = 'none';\n *   }\n * };\n * (end)\n */\nmxVertexHandler.prototype.redrawHandles = function()\n{\n\tvar tol = this.tolerance;\n\tthis.horizontalOffset = 0;\n\tthis.verticalOffset = 0;\n\tvar s = this.bounds;\n\n\tif (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null)\n\t{\n\t\tif (this.index == null && this.manageSizers && this.sizers.length >= 8)\n\t\t{\n\t\t\t// KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n\t\t\tvar padding = this.getHandlePadding();\n\t\t\tthis.horizontalOffset = padding.x;\n\t\t\tthis.verticalOffset = padding.y;\n\n\t\t\tif (this.horizontalOffset != 0 || this.verticalOffset != 0)\n\t\t\t{\n\t\t\t\ts = new mxRectangle(s.x, s.y, s.width, s.height);\n\n\t\t\t\ts.x -= this.horizontalOffset / 2;\n\t\t\t\ts.width += this.horizontalOffset;\n\t\t\t\ts.y -= this.verticalOffset / 2;\n\t\t\t\ts.height += this.verticalOffset;\n\t\t\t}\n\n\t\t\tif (this.sizers.length >= 8)\n\t\t\t{\n\t\t\t\tif ((s.width < 2 * this.sizers[0].bounds.width + 2 * tol) ||\n\t\t\t\t\t(s.height < 2 * this.sizers[0].bounds.height + 2 * tol))\n\t\t\t\t{\n\t\t\t\t\tthis.sizers[0].node.style.display = 'none';\n\t\t\t\t\tthis.sizers[2].node.style.display = 'none';\n\t\t\t\t\tthis.sizers[5].node.style.display = 'none';\n\t\t\t\t\tthis.sizers[7].node.style.display = 'none';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.sizers[0].node.style.display = '';\n\t\t\t\t\tthis.sizers[2].node.style.display = '';\n\t\t\t\t\tthis.sizers[5].node.style.display = '';\n\t\t\t\t\tthis.sizers[7].node.style.display = '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar r = s.x + s.width;\n\t\tvar b = s.y + s.height;\n\n\t\tif (this.singleSizer)\n\t\t{\n\t\t\tthis.moveSizerTo(this.sizers[0], r, b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar cx = s.x + s.width / 2;\n\t\t\tvar cy = s.y + s.height / 2;\n\n\t\t\tif (this.sizers.length >= 8)\n\t\t\t{\n\t\t\t\tvar crs = ['nw-resize', 'n-resize', 'ne-resize', 'e-resize', 'se-resize', 's-resize', 'sw-resize', 'w-resize'];\n\n\t\t\t\tvar alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\t\tvar cos = Math.cos(alpha);\n\t\t\t\tvar sin = Math.sin(alpha);\n\n\t\t\t\tvar da = Math.round(alpha * 4 / Math.PI);\n\n\t\t\t\tvar ct = new mxPoint(s.getCenterX(), s.getCenterY());\n\t\t\t\tvar pt = mxUtils.getRotatedPoint(new mxPoint(s.x, s.y), cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[0], pt.x, pt.y);\n\t\t\t\tthis.sizers[0].setCursor(crs[mxUtils.mod(0 + da, crs.length)]);\n\n\t\t\t\tpt.x = cx;\n\t\t\t\tpt.y = s.y;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[1], pt.x, pt.y);\n\t\t\t\tthis.sizers[1].setCursor(crs[mxUtils.mod(1 + da, crs.length)]);\n\n\t\t\t\tpt.x = r;\n\t\t\t\tpt.y = s.y;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[2], pt.x, pt.y);\n\t\t\t\tthis.sizers[2].setCursor(crs[mxUtils.mod(2 + da, crs.length)]);\n\n\t\t\t\tpt.x = s.x;\n\t\t\t\tpt.y = cy;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[3], pt.x, pt.y);\n\t\t\t\tthis.sizers[3].setCursor(crs[mxUtils.mod(7 + da, crs.length)]);\n\n\t\t\t\tpt.x = r;\n\t\t\t\tpt.y = cy;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[4], pt.x, pt.y);\n\t\t\t\tthis.sizers[4].setCursor(crs[mxUtils.mod(3 + da, crs.length)]);\n\n\t\t\t\tpt.x = s.x;\n\t\t\t\tpt.y = b;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[5], pt.x, pt.y);\n\t\t\t\tthis.sizers[5].setCursor(crs[mxUtils.mod(6 + da, crs.length)]);\n\n\t\t\t\tpt.x = cx;\n\t\t\t\tpt.y = b;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[6], pt.x, pt.y);\n\t\t\t\tthis.sizers[6].setCursor(crs[mxUtils.mod(5 + da, crs.length)]);\n\n\t\t\t\tpt.x = r;\n\t\t\t\tpt.y = b;\n\t\t\t\tpt = mxUtils.getRotatedPoint(pt, cos, sin, ct);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[7], pt.x, pt.y);\n\t\t\t\tthis.sizers[7].setCursor(crs[mxUtils.mod(4 + da, crs.length)]);\n\n\t\t\t\tthis.moveSizerTo(this.sizers[8], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n\t\t\t}\n\t\t\telse if (this.state.width >= 2 && this.state.height >= 2)\n\t\t\t{\n\t\t\t\tthis.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.moveSizerTo(this.sizers[0], this.state.x, this.state.y);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.rotationShape != null)\n\t{\n\t\tvar alpha = mxUtils.toRadians((this.currentAlpha != null) ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\tvar cos = Math.cos(alpha);\n\t\tvar sin = Math.sin(alpha);\n\n\t\tvar ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());\n\t\tvar pt = mxUtils.getRotatedPoint(this.getRotationHandlePosition(), cos, sin, ct);\n\n\t\tif (this.rotationShape.node != null)\n\t\t{\n\t\t\tthis.moveSizerTo(this.rotationShape, pt.x, pt.y);\n\n\t\t\t// Hides rotation handle during text editing\n\t\t\tthis.rotationShape.node.style.visibility = (this.state.view.graph.isEditing()) ? 'hidden' : '';\n\t\t}\n\t}\n\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t}\n\n\tif (this.edgeHandlers != null)\n\t{\n\t\tfor (var i = 0; i < this.edgeHandlers.length; i++)\n\t\t{\n\t\t\tthis.edgeHandlers[i].redraw();\n\t\t}\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tvar temp = this.customHandles[i].shape.node.style.display;\n\t\t\tthis.customHandles[i].redraw();\n\t\t\tthis.customHandles[i].shape.node.style.display = temp;\n\n\t\t\t// Hides custom handles during text editing\n\t\t\tthis.customHandles[i].shape.node.style.visibility = (this.graph.isEditing()) ? 'hidden' : '';\n\t\t}\n\t}\n\n\tthis.updateParentHighlight();\n};\n\n/**\n * Function: getRotationHandlePosition\n *\n * Returns an <mxPoint> that defines the rotation handle position.\n */\nmxVertexHandler.prototype.getRotationHandlePosition = function()\n{\n\treturn new mxPoint(this.bounds.x + this.bounds.width / 2, this.bounds.y + this.rotationHandleVSpacing)\n};\n\n/**\n * Function: updateParentHighlight\n *\n * Updates the highlight of the parent if <parentHighlightEnabled> is true.\n */\nmxVertexHandler.prototype.updateParentHighlight = function()\n{\n\t// If not destroyed\n\tif (this.selectionBorder != null)\n\t{\n\t\tif (this.parentHighlight != null)\n\t\t{\n\t\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\n\t\t\tif (this.graph.model.isVertex(parent))\n\t\t\t{\n\t\t\t\tvar pstate = this.graph.view.getState(parent);\n\t\t\t\tvar b = this.parentHighlight.bounds;\n\n\t\t\t\tif (pstate != null && (b.x != pstate.x || b.y != pstate.y ||\n\t\t\t\t\tb.width != pstate.width || b.height != pstate.height))\n\t\t\t\t{\n\t\t\t\t\tthis.parentHighlight.bounds = pstate;\n\t\t\t\t\tthis.parentHighlight.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.parentHighlight.destroy();\n\t\t\t\tthis.parentHighlight = null;\n\t\t\t}\n\t\t}\n\t\telse if (this.parentHighlightEnabled)\n\t\t{\n\t\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\n\t\t\tif (this.graph.model.isVertex(parent))\n\t\t\t{\n\t\t\t\tvar pstate = this.graph.view.getState(parent);\n\n\t\t\t\tif (pstate != null)\n\t\t\t\t{\n\t\t\t\t\tthis.parentHighlight = this.createParentHighlightShape(pstate);\n\t\t\t\t\t// VML dialect required here for event transparency in IE\n\t\t\t\t\tthis.parentHighlight.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\t\tthis.parentHighlight.pointerEvents = false;\n\t\t\t\t\tthis.parentHighlight.rotation = Number(pstate.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\t\t\tthis.parentHighlight.init(this.graph.getView().getOverlayPane());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: drawPreview\n *\n * Redraws the preview.\n */\nmxVertexHandler.prototype.drawPreview = function()\n{\n\tif (this.preview != null)\n\t{\n\t\tthis.preview.bounds = this.bounds;\n\n\t\tif (this.preview.node.parentNode == this.graph.container)\n\t\t{\n\t\t\tthis.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);\n\t\t\tthis.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);\n\t\t}\n\n\t\tthis.preview.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\tthis.preview.redraw();\n\t}\n\n\tthis.selectionBorder.bounds = this.bounds;\n\tthis.selectionBorder.redraw();\n\n\tif (this.parentHighlight != null)\n\t{\n\t\tthis.parentHighlight.redraw();\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxVertexHandler.prototype.destroy = function()\n{\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.state.view.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n\n\tif (this.preview != null)\n\t{\n\t\tthis.preview.destroy();\n\t\tthis.preview = null;\n\t}\n\n\tif (this.parentHighlight != null)\n\t{\n\t\tthis.parentHighlight.destroy();\n\t\tthis.parentHighlight = null;\n\t}\n\n\tif (this.selectionBorder != null)\n\t{\n\t\tthis.selectionBorder.destroy();\n\t\tthis.selectionBorder = null;\n\t}\n\n\tthis.labelShape = null;\n\tthis.removeHint();\n\n\tif (this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tthis.sizers[i].destroy();\n\t\t}\n\n\t\tthis.sizers = null;\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].destroy();\n\t\t}\n\n\t\tthis.customHandles = null;\n\t}\n};\n\n__mxOutput.mxVertexHandler = typeof mxVertexHandler !== 'undefined' ? mxVertexHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxEdgeHandler\n *\n * Graph event handler that reconnects edges and modifies control points and\n * the edge label location. Uses <mxTerminalMarker> for finding and\n * highlighting new source and target vertices. This handler is automatically\n * created in <mxGraph.createHandler> for each selected edge.\n *\n * To enable adding/removing control points, the following code can be used:\n *\n * (code)\n * mxEdgeHandler.prototype.addEnabled = true;\n * mxEdgeHandler.prototype.removeEnabled = true;\n * (end)\n *\n * Note: This experimental feature is not recommended for production use.\n *\n * Constructor: mxEdgeHandler\n *\n * Constructs an edge handler for the specified <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> of the cell to be handled.\n */\nfunction mxEdgeHandler(state)\n{\n\tif (state != null)\n\t{\n\t\tthis.state = state;\n\t\tthis.init();\n\n\t\t// Handles escape keystrokes\n\t\tthis.escapeHandler = mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar dirty = this.index != null;\n\t\t\tthis.reset();\n\n\t\t\tif (dirty)\n\t\t\t{\n\t\t\t\tthis.graph.cellRenderer.redraw(this.state, false, state.view.isRendering());\n\t\t\t}\n\t\t});\n\n\t\tthis.state.view.graph.addListener(mxEvent.ESCAPE, this.escapeHandler);\n\t}\n};\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxEdgeHandler.prototype.graph = null;\n\n/**\n * Variable: state\n *\n * Reference to the <mxCellState> being modified.\n */\nmxEdgeHandler.prototype.state = null;\n\n/**\n * Variable: marker\n *\n * Holds the <mxTerminalMarker> which is used for highlighting terminals.\n */\nmxEdgeHandler.prototype.marker = null;\n\n/**\n * Variable: constraintHandler\n *\n * Holds the <mxConstraintHandler> used for drawing and highlighting\n * constraints.\n */\nmxEdgeHandler.prototype.constraintHandler = null;\n\n/**\n * Variable: error\n *\n * Holds the current validation error while a connection is being changed.\n */\nmxEdgeHandler.prototype.error = null;\n\n/**\n * Variable: shape\n *\n * Holds the <mxShape> that represents the preview edge.\n */\nmxEdgeHandler.prototype.shape = null;\n\n/**\n * Variable: bends\n *\n * Holds the <mxShapes> that represent the points.\n */\nmxEdgeHandler.prototype.bends = null;\n\n/**\n * Variable: labelShape\n *\n * Holds the <mxShape> that represents the label position.\n */\nmxEdgeHandler.prototype.labelShape = null;\n\n/**\n * Variable: cloneEnabled\n *\n * Specifies if cloning by control-drag is enabled. Default is true.\n */\nmxEdgeHandler.prototype.cloneEnabled = true;\n\n/**\n * Variable: addEnabled\n *\n * Specifies if adding bends by shift-click is enabled. Default is false.\n * Note: This experimental feature is not recommended for production use.\n */\nmxEdgeHandler.prototype.addEnabled = false;\n\n/**\n * Variable: removeEnabled\n *\n * Specifies if removing bends by shift-click is enabled. Default is false.\n * Note: This experimental feature is not recommended for production use.\n */\nmxEdgeHandler.prototype.removeEnabled = false;\n\n/**\n * Variable: dblClickRemoveEnabled\n *\n * Specifies if removing bends by double click is enabled. Default is false.\n */\nmxEdgeHandler.prototype.dblClickRemoveEnabled = false;\n\n/**\n * Variable: mergeRemoveEnabled\n *\n * Specifies if removing bends by dropping them on other bends is enabled.\n * Default is false.\n */\nmxEdgeHandler.prototype.mergeRemoveEnabled = false;\n\n/**\n * Variable: straightRemoveEnabled\n *\n * Specifies if removing bends by creating straight segments should be enabled.\n * If enabled, this can be overridden by holding down the alt key while moving.\n * Default is false.\n */\nmxEdgeHandler.prototype.straightRemoveEnabled = false;\n\n/**\n * Variable: virtualBendsEnabled\n *\n * Specifies if virtual bends should be added in the center of each\n * segments. These bends can then be used to add new waypoints.\n * Default is false.\n */\nmxEdgeHandler.prototype.virtualBendsEnabled = false;\n\n/**\n * Variable: virtualBendOpacity\n *\n * Opacity to be used for virtual bends (see <virtualBendsEnabled>).\n * Default is 20.\n */\nmxEdgeHandler.prototype.virtualBendOpacity = 20;\n\n/**\n * Variable: parentHighlightEnabled\n *\n * Specifies if the parent should be highlighted if a child cell is selected.\n * Default is false.\n */\nmxEdgeHandler.prototype.parentHighlightEnabled = false;\n\n/**\n * Variable: preferHtml\n *\n * Specifies if bends should be added to the graph container. This is updated\n * in <init> based on whether the edge or one of its terminals has an HTML\n * label in the container.\n */\nmxEdgeHandler.prototype.preferHtml = false;\n\n/**\n * Variable: allowHandleBoundsCheck\n *\n * Specifies if the bounds of handles should be used for hit-detection in IE\n * Default is true.\n */\nmxEdgeHandler.prototype.allowHandleBoundsCheck = true;\n\n/**\n * Variable: snapToTerminals\n *\n * Specifies if waypoints should snap to the routing centers of terminals.\n * Default is false.\n */\nmxEdgeHandler.prototype.snapToTerminals = false;\n\n/**\n * Variable: handleImage\n *\n * Optional <mxImage> to be used as handles. Default is null.\n */\nmxEdgeHandler.prototype.handleImage = null;\n\n/**\n * Variable: tolerance\n *\n * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\n */\nmxEdgeHandler.prototype.tolerance = 0;\n\n/**\n * Variable: outlineConnect\n *\n * Specifies if connections to the outline of a highlighted target should be\n * enabled. This will allow to place the connection point along the outline of\n * the highlighted target. Default is false.\n */\nmxEdgeHandler.prototype.outlineConnect = false;\n\n/**\n * Variable: manageLabelHandle\n *\n * Specifies if the label handle should be moved if it intersects with another\n * handle. Uses <checkLabelHandle> for checking and moving. Default is false.\n */\nmxEdgeHandler.prototype.manageLabelHandle = false;\n\n/**\n * Function: init\n *\n * Initializes the shapes required for this edge handler.\n */\nmxEdgeHandler.prototype.init = function()\n{\n\tthis.graph = this.state.view.graph;\n\tthis.marker = this.createMarker();\n\tthis.constraintHandler = new mxConstraintHandler(this.graph);\n\n\t// Clones the original points from the cell\n\t// and makes sure at least one point exists\n\tthis.points = [];\n\n\t// Uses the absolute points of the state\n\t// for the initial configuration and preview\n\tthis.abspoints = this.getSelectionPoints(this.state);\n\tthis.shape = this.createSelectionShape(this.abspoints);\n\tthis.shape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\tthis.shape.init(this.graph.getView().getOverlayPane());\n\tthis.shape.pointerEvents = false;\n\tthis.shape.setCursor(mxConstants.CURSOR_MOVABLE_EDGE);\n\tmxEvent.redirectMouseEvents(this.shape.node, this.graph, this.state);\n\n\t// Updates preferHtml\n\tthis.preferHtml = this.state.text != null &&\n\t\tthis.state.text.node.parentNode == this.graph.container;\n\n\tif (!this.preferHtml)\n\t{\n\t\t// Checks source terminal\n\t\tvar sourceState = this.state.getVisibleTerminalState(true);\n\n\t\tif (sourceState != null)\n\t\t{\n\t\t\tthis.preferHtml = sourceState.text != null &&\n\t\t\t\tsourceState.text.node.parentNode == this.graph.container;\n\t\t}\n\n\t\tif (!this.preferHtml)\n\t\t{\n\t\t\t// Checks target terminal\n\t\t\tvar targetState = this.state.getVisibleTerminalState(false);\n\n\t\t\tif (targetState != null)\n\t\t\t{\n\t\t\t\tthis.preferHtml = targetState.text != null &&\n\t\t\t\ttargetState.text.node.parentNode == this.graph.container;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Adds highlight for parent group\n\tif (this.parentHighlightEnabled)\n\t{\n\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\n\t\tif (this.graph.model.isVertex(parent))\n\t\t{\n\t\t\tvar pstate = this.graph.view.getState(parent);\n\n\t\t\tif (pstate != null)\n\t\t\t{\n\t\t\t\tthis.parentHighlight = this.createParentHighlightShape(pstate);\n\t\t\t\t// VML dialect required here for event transparency in IE\n\t\t\t\tthis.parentHighlight.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\t\t\t\tthis.parentHighlight.pointerEvents = false;\n\t\t\t\tthis.parentHighlight.rotation = Number(pstate.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\t\tthis.parentHighlight.init(this.graph.getView().getOverlayPane());\n\t\t\t}\n\t\t}\n\t}\n\n\t// Creates bends for the non-routed absolute points\n\t// or bends that don't correspond to points\n\tif (this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells ||\n\t\tmxGraphHandler.prototype.maxCells <= 0)\n\t{\n\t\tthis.bends = this.createBends();\n\n\t\tif (this.isVirtualBendsEnabled())\n\t\t{\n\t\t\tthis.virtualBends = this.createVirtualBends();\n\t\t}\n\t}\n\n\t// Adds a rectangular handle for the label position\n\tthis.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n\tthis.labelShape = this.createLabelHandleShape();\n\tthis.initBend(this.labelShape);\n\tthis.labelShape.setCursor(mxConstants.CURSOR_LABEL_HANDLE);\n\n\tthis.customHandles = this.createCustomHandles();\n\n\tthis.redraw();\n};\n\n/**\n * Function: createCustomHandles\n *\n * Returns an array of custom handles. This implementation returns null.\n */\nmxEdgeHandler.prototype.createCustomHandles = function()\n{\n\treturn null;\n};\n\n/**\n * Function: isVirtualBendsEnabled\n *\n * Returns true if virtual bends should be added. This returns true if\n * <virtualBendsEnabled> is true and the current style allows and\n * renders custom waypoints.\n */\nmxEdgeHandler.prototype.isVirtualBendsEnabled = function(evt)\n{\n\treturn this.virtualBendsEnabled && (this.state.style[mxConstants.STYLE_EDGE] == null ||\n\t\t\tthis.state.style[mxConstants.STYLE_EDGE] == mxConstants.NONE ||\n\t\t\tthis.state.style[mxConstants.STYLE_NOEDGESTYLE] == 1)  &&\n\t\t\tmxUtils.getValue(this.state.style, mxConstants.STYLE_SHAPE, null) != 'arrow';\n};\n\n/**\n * Function: isAddPointEvent\n *\n * Returns true if the given event is a trigger to add a new point. This\n * implementation returns true if shift is pressed.\n */\nmxEdgeHandler.prototype.isAddPointEvent = function(evt)\n{\n\treturn mxEvent.isShiftDown(evt);\n};\n\n/**\n * Function: isRemovePointEvent\n *\n * Returns true if the given event is a trigger to remove a point. This\n * implementation returns true if shift is pressed.\n */\nmxEdgeHandler.prototype.isRemovePointEvent = function(evt)\n{\n\treturn mxEvent.isShiftDown(evt);\n};\n\n/**\n * Function: getSelectionPoints\n *\n * Returns the list of points that defines the selection stroke.\n */\nmxEdgeHandler.prototype.getSelectionPoints = function(state)\n{\n\treturn state.absolutePoints;\n};\n\n/**\n * Function: createSelectionShape\n *\n * Creates the shape used to draw the selection border.\n */\nmxEdgeHandler.prototype.createParentHighlightShape = function(bounds)\n{\n\tvar shape = new mxRectangleShape(bounds, null, this.getSelectionColor());\n\tshape.strokewidth = this.getSelectionStrokeWidth();\n\tshape.isDashed = this.isSelectionDashed();\n\n\treturn shape;\n};\n\n/**\n * Function: createSelectionShape\n *\n * Creates the shape used to draw the selection border.\n */\nmxEdgeHandler.prototype.createSelectionShape = function(points)\n{\n\tvar shape = new this.state.shape.constructor();\n\tshape.outline = true;\n\tshape.apply(this.state);\n\n\tshape.isDashed = this.isSelectionDashed();\n\tshape.stroke = this.getSelectionColor();\n\tshape.isShadow = false;\n\n\treturn shape;\n};\n\n/**\n * Function: getSelectionColor\n *\n * Returns <mxConstants.EDGE_SELECTION_COLOR>.\n */\nmxEdgeHandler.prototype.getSelectionColor = function()\n{\n\treturn mxConstants.EDGE_SELECTION_COLOR;\n};\n\n/**\n * Function: getSelectionStrokeWidth\n *\n * Returns <mxConstants.EDGE_SELECTION_STROKEWIDTH>.\n */\nmxEdgeHandler.prototype.getSelectionStrokeWidth = function()\n{\n\treturn mxConstants.EDGE_SELECTION_STROKEWIDTH;\n};\n\n/**\n * Function: isSelectionDashed\n *\n * Returns <mxConstants.EDGE_SELECTION_DASHED>.\n */\nmxEdgeHandler.prototype.isSelectionDashed = function()\n{\n\treturn mxConstants.EDGE_SELECTION_DASHED;\n};\n\n/**\n * Function: isConnectableCell\n *\n * Returns true if the given cell is connectable. This is a hook to\n * disable floating connections. This implementation returns true.\n */\nmxEdgeHandler.prototype.isConnectableCell = function(cell)\n{\n\treturn true;\n};\n\n/**\n * Function: getCellAt\n *\n * Creates and returns the <mxCellMarker> used in <marker>.\n */\nmxEdgeHandler.prototype.getCellAt = function(x, y)\n{\n\treturn (!this.outlineConnect) ? this.graph.getCellAt(x, y) : null;\n};\n\n/**\n * Function: createMarker\n *\n * Creates and returns the <mxCellMarker> used in <marker>.\n */\nmxEdgeHandler.prototype.createMarker = function()\n{\n\tvar marker = new mxCellMarker(this.graph);\n\tvar self = this; // closure\n\n\t// Only returns edges if they are connectable and never returns\n\t// the edge that is currently being modified\n\tmarker.getCell = function(me)\n\t{\n\t\tvar cell = mxCellMarker.prototype.getCell.apply(this, arguments);\n\n\t\t// Checks for cell at preview point (with grid)\n\t\tif ((cell == self.state.cell || cell == null) && self.currentPoint != null)\n\t\t{\n\t\t\tcell = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);\n\t\t}\n\n\t\t// Uses connectable parent vertex if one exists\n\t\tif (cell != null && !this.graph.isCellConnectable(cell))\n\t\t{\n\t\t\tvar parent = this.graph.getModel().getParent(cell);\n\n\t\t\tif (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))\n\t\t\t{\n\t\t\t\tcell = parent;\n\t\t\t}\n\t\t}\n\n\t\tvar model = self.graph.getModel();\n\n\t\tif ((this.graph.isSwimlane(cell) && self.currentPoint != null &&\n\t\t\tthis.graph.hitsSwimlaneContent(cell, self.currentPoint.x, self.currentPoint.y)) ||\n\t\t\t(!self.isConnectableCell(cell)) || (cell == self.state.cell ||\n\t\t\t(cell != null && !self.graph.connectableEdges && model.isEdge(cell))) ||\n\t\t\tmodel.isAncestor(self.state.cell, cell))\n\t\t{\n\t\t\tcell = null;\n\t\t}\n\n\t\tif (!this.graph.isCellConnectable(cell))\n\t\t{\n\t\t\tcell = null;\n\t\t}\n\n\t\treturn cell;\n\t};\n\n\t// Sets the highlight color according to validateConnection\n\tmarker.isValidState = function(state)\n\t{\n\t\tvar model = self.graph.getModel();\n\t\tvar other = self.graph.view.getTerminalPort(state,\n\t\t\tself.graph.view.getState(model.getTerminal(self.state.cell,\n\t\t\t!self.isSource)), !self.isSource);\n\t\tvar otherCell = (other != null) ? other.cell : null;\n\t\tvar source = (self.isSource) ? state.cell : otherCell;\n\t\tvar target = (self.isSource) ? otherCell : state.cell;\n\n\t\t// Updates the error message of the handler\n\t\tself.error = self.validateConnection(source, target);\n\n\t\treturn self.error == null;\n\t};\n\n\treturn marker;\n};\n\n/**\n * Function: validateConnection\n *\n * Returns the error message or an empty string if the connection for the\n * given source, target pair is not valid. Otherwise it returns null. This\n * implementation uses <mxGraph.getEdgeValidationError>.\n *\n * Parameters:\n *\n * source - <mxCell> that represents the source terminal.\n * target - <mxCell> that represents the target terminal.\n */\nmxEdgeHandler.prototype.validateConnection = function(source, target)\n{\n\treturn this.graph.getEdgeValidationError(this.state.cell, source, target);\n};\n\n/**\n * Function: createBends\n *\n * Creates and returns the bends used for modifying the edge. This is\n * typically an array of <mxRectangleShapes>.\n */\n mxEdgeHandler.prototype.createBends = function()\n {\n\tvar cell = this.state.cell;\n\tvar bends = [];\n\n\tfor (var i = 0; i < this.abspoints.length; i++)\n\t{\n\t\tif (this.isHandleVisible(i))\n\t\t{\n\t\t\tvar source = i == 0;\n\t\t\tvar target = i == this.abspoints.length - 1;\n\t\t\tvar terminal = source || target;\n\n\t\t\tif (terminal || this.graph.isCellBendable(cell))\n\t\t\t{\n\t\t\t\t(mxUtils.bind(this, function(index)\n\t\t\t\t{\n\t\t\t\t\tvar bend = this.createHandleShape(index);\n\t\t\t\t\tthis.initBend(bend, mxUtils.bind(this, mxUtils.bind(this, function()\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.dblClickRemoveEnabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.removePoint(this.state, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t})));\n\n\t\t\t\t\tif (this.isHandleEnabled(i))\n\t\t\t\t\t{\n\t\t\t\t\t\tbend.setCursor((terminal) ? mxConstants.CURSOR_TERMINAL_HANDLE : mxConstants.CURSOR_BEND_HANDLE);\n\t\t\t\t\t}\n\n\t\t\t\t\tbends.push(bend);\n\n\t\t\t\t\tif (!terminal)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.points.push(new mxPoint(0,0));\n\t\t\t\t\t\tbend.node.style.visibility = 'hidden';\n\t\t\t\t\t}\n\t\t\t\t}))(i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bends;\n};\n\n/**\n * Function: createVirtualBends\n *\n * Creates and returns the bends used for modifying the edge. This is\n * typically an array of <mxRectangleShapes>.\n */\n mxEdgeHandler.prototype.createVirtualBends = function()\n {\n\tvar cell = this.state.cell;\n\tvar last = this.abspoints[0];\n\tvar bends = [];\n\n\tif (this.graph.isCellBendable(cell))\n\t{\n\t\tfor (var i = 1; i < this.abspoints.length; i++)\n\t\t{\n\t\t\t(mxUtils.bind(this, function(bend)\n\t\t\t{\n\t\t\t\tthis.initBend(bend);\n\t\t\t\tbend.setCursor(mxConstants.CURSOR_VIRTUAL_BEND_HANDLE);\n\t\t\t\tbends.push(bend);\n\t\t\t}))(this.createHandleShape());\n\t\t}\n\t}\n\n\treturn bends;\n};\n\n/**\n * Function: isHandleEnabled\n *\n * Creates the shape used to display the given bend.\n */\nmxEdgeHandler.prototype.isHandleEnabled = function(index)\n{\n\treturn true;\n};\n\n/**\n * Function: isHandleVisible\n *\n * Returns true if the handle at the given index is visible.\n */\nmxEdgeHandler.prototype.isHandleVisible = function(index)\n{\n\tvar source = this.state.getVisibleTerminalState(true);\n\tvar target = this.state.getVisibleTerminalState(false);\n\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\tvar edgeStyle = (geo != null) ? this.graph.view.getEdgeStyle(this.state, geo.points, source, target) : null;\n\n\treturn edgeStyle != mxEdgeStyle.EntityRelation || index == 0 || index == this.abspoints.length - 1;\n};\n\n/**\n * Function: createHandleShape\n *\n * Creates the shape used to display the given bend. Note that the index may be\n * null for special cases, such as when called from\n * <mxElbowEdgeHandler.createVirtualBend>. Only images and rectangles should be\n * returned if support for HTML labels with not foreign objects is required.\n * Index if null for virtual handles.\n */\nmxEdgeHandler.prototype.createHandleShape = function(index)\n{\n\tif (this.handleImage != null)\n\t{\n\t\tvar shape = new mxImageShape(new mxRectangle(0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);\n\n\t\t// Allows HTML rendering of the images\n\t\tshape.preserveImageAspect = false;\n\n\t\treturn shape;\n\t}\n\telse\n\t{\n\t\tvar s = mxConstants.HANDLE_SIZE;\n\n\t\tif (this.preferHtml)\n\t\t{\n\t\t\ts -= 1;\n\t\t}\n\n\t\treturn new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n};\n\n/**\n * Function: createLabelHandleShape\n *\n * Creates the shape used to display the the label handle.\n */\nmxEdgeHandler.prototype.createLabelHandleShape = function()\n{\n\tif (this.labelHandleImage != null)\n\t{\n\t\tvar shape = new mxImageShape(new mxRectangle(0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);\n\n\t\t// Allows HTML rendering of the images\n\t\tshape.preserveImageAspect = false;\n\n\t\treturn shape;\n\t}\n\telse\n\t{\n\t\tvar s = mxConstants.LABEL_HANDLE_SIZE;\n\t\treturn new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.LABEL_HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);\n\t}\n};\n\n/**\n * Function: initBend\n *\n * Helper method to initialize the given bend.\n *\n * Parameters:\n *\n * bend - <mxShape> that represents the bend to be initialized.\n */\nmxEdgeHandler.prototype.initBend = function(bend, dblClick)\n{\n\tif (this.preferHtml)\n\t{\n\t\tbend.dialect = mxConstants.DIALECT_STRICTHTML;\n\t\tbend.init(this.graph.container);\n\t}\n\telse\n\t{\n\t\tbend.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ?\n\t\t\tmxConstants.DIALECT_MIXEDHTML : mxConstants.DIALECT_SVG;\n\t\tbend.init(this.graph.getView().getOverlayPane());\n\t}\n\n\tmxEvent.redirectMouseEvents(bend.node, this.graph, this.state,\n\t\t\tnull, null, null, dblClick);\n\n\t// Fixes lost event tracking for images in quirks / IE8 standards\n\tif (mxClient.IS_QUIRKS || document.documentMode == 8)\n\t{\n\t\tmxEvent.addListener(bend.node, 'dragstart', function(evt)\n\t\t{\n\t\t\tmxEvent.consume(evt);\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\tif (mxClient.IS_TOUCH)\n\t{\n\t\tbend.node.setAttribute('pointer-events', 'none');\n\t}\n};\n\n/**\n * Function: getHandleForEvent\n *\n * Returns the index of the handle for the given event.\n */\nmxEdgeHandler.prototype.getHandleForEvent = function(me)\n{\n\t// Connection highlight may consume events before they reach sizer handle\n\tvar tol = (!mxEvent.isMouseEvent(me.getEvent())) ? this.tolerance : 1;\n\tvar hit = (this.allowHandleBoundsCheck && (mxClient.IS_IE || tol > 0)) ?\n\t\tnew mxRectangle(me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n\tvar minDistSq = null;\n\tvar result = null;\n\n\tfunction checkShape(shape)\n\t{\n\t\tif (shape != null && shape.node.style.display != 'none' && shape.node.style.visibility != 'hidden' &&\n\t\t\t(me.isSource(shape) || (hit != null && mxUtils.intersects(shape.bounds, hit))))\n\t\t{\n\t\t\tvar dx = me.getGraphX() - shape.bounds.getCenterX();\n\t\t\tvar dy = me.getGraphY() - shape.bounds.getCenterY();\n\t\t\tvar tmp = dx * dx + dy * dy;\n\n\t\t\tif (minDistSq == null || tmp <= minDistSq)\n\t\t\t{\n\t\t\t\tminDistSq = tmp;\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tif (this.customHandles != null && this.isCustomHandleEvent(me))\n\t{\n\t\t// Inverse loop order to match display order\n\t\tfor (var i = this.customHandles.length - 1; i >= 0; i--)\n\t\t{\n\t\t\tif (checkShape(this.customHandles[i].shape))\n\t\t\t{\n\t\t\t\t// LATER: Return reference to active shape\n\t\t\t\treturn mxEvent.CUSTOM_HANDLE - i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (me.isSource(this.state.text) || checkShape(this.labelShape))\n\t{\n\t\tresult = mxEvent.LABEL_HANDLE;\n\t}\n\n\tif (this.bends != null)\n\t{\n\t\tfor (var i = 0; i < this.bends.length; i++)\n\t\t{\n\t\t\tif (checkShape(this.bends[i]))\n\t\t\t{\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.virtualBends != null && this.isAddVirtualBendEvent(me))\n\t{\n\t\tfor (var i = 0; i < this.virtualBends.length; i++)\n\t\t{\n\t\t\tif (checkShape(this.virtualBends[i]))\n\t\t\t{\n\t\t\t\tresult = mxEvent.VIRTUAL_HANDLE - i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Function: isAddVirtualBendEvent\n *\n * Returns true if the given event allows virtual bends to be added. This\n * implementation returns true.\n */\nmxEdgeHandler.prototype.isAddVirtualBendEvent = function(me)\n{\n\treturn true;\n};\n\n/**\n * Function: isCustomHandleEvent\n *\n * Returns true if the given event allows custom handles to be changed. This\n * implementation returns true.\n */\nmxEdgeHandler.prototype.isCustomHandleEvent = function(me)\n{\n\treturn true;\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by checking if a special element of the handler\n * was clicked, in which case the index parameter is non-null. The\n * indices may be one of <LABEL_HANDLE> or the number of the respective\n * control point. The source and target points are used for reconnecting\n * the edge.\n */\nmxEdgeHandler.prototype.mouseDown = function(sender, me)\n{\n\tvar handle = this.getHandleForEvent(me);\n\n\tif (this.bends != null && this.bends[handle] != null)\n\t{\n\t\tvar b = this.bends[handle].bounds;\n\t\tthis.snapPoint = new mxPoint(b.getCenterX(), b.getCenterY());\n\t}\n\n\tif (this.addEnabled && handle == null && this.isAddPointEvent(me.getEvent()))\n\t{\n\t\tthis.addPoint(this.state, me.getEvent());\n\t\tme.consume();\n\t}\n\telse if (handle != null && !me.isConsumed() && this.graph.isEnabled())\n\t{\n\t\tif (this.removeEnabled && this.isRemovePointEvent(me.getEvent()))\n\t\t{\n\t\t\tthis.removePoint(this.state, handle);\n\t\t}\n\t\telse if (handle != mxEvent.LABEL_HANDLE || this.graph.isLabelMovable(me.getCell()))\n\t\t{\n\t\t\tif (handle <= mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tmxUtils.setOpacity(this.virtualBends[mxEvent.VIRTUAL_HANDLE - handle].node, 100);\n\t\t\t}\n\n\t\t\tthis.start(me.getX(), me.getY(), handle);\n\t\t}\n\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: start\n *\n * Starts the handling of the mouse gesture.\n */\nmxEdgeHandler.prototype.start = function(x, y, index)\n{\n\tthis.startX = x;\n\tthis.startY = y;\n\n\tthis.isSource = (this.bends == null) ? false : index == 0;\n\tthis.isTarget = (this.bends == null) ? false : index == this.bends.length - 1;\n\tthis.isLabel = index == mxEvent.LABEL_HANDLE;\n\n\tif (this.isSource || this.isTarget)\n\t{\n\t\tvar cell = this.state.cell;\n\t\tvar terminal = this.graph.model.getTerminal(cell, this.isSource);\n\n\t\tif ((terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource)) ||\n\t\t\t(terminal != null && this.graph.isCellDisconnectable(cell, terminal, this.isSource)))\n\t\t{\n\t\t\tthis.index = index;\n\t\t}\n\t}\n\telse\n\t{\n\t\tthis.index = index;\n\t}\n\n\t// Hides other custom handles\n\tif (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE)\n\t{\n\t\tif (this.customHandles != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t\t{\n\t\t\t\tif (i != mxEvent.CUSTOM_HANDLE - this.index)\n\t\t\t\t{\n\t\t\t\t\tthis.customHandles[i].setVisible(false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: clonePreviewState\n *\n * Returns a clone of the current preview state for the given point and terminal.\n */\nmxEdgeHandler.prototype.clonePreviewState = function(point, terminal)\n{\n\treturn this.state.clone();\n};\n\n/**\n * Function: getSnapToTerminalTolerance\n *\n * Returns the tolerance for the guides. Default value is\n * gridSize * scale / 2.\n */\nmxEdgeHandler.prototype.getSnapToTerminalTolerance = function()\n{\n\treturn this.graph.gridSize * this.graph.view.scale / 2;\n};\n\n/**\n * Function: updateHint\n *\n * Hook for subclassers do show details while the handler is active.\n */\nmxEdgeHandler.prototype.updateHint = function(me, point) { };\n\n/**\n * Function: removeHint\n *\n * Hooks for subclassers to hide details when the handler gets inactive.\n */\nmxEdgeHandler.prototype.removeHint = function() { };\n\n/**\n * Function: roundLength\n *\n * Hook for rounding the unscaled width or height. This uses Math.round.\n */\nmxEdgeHandler.prototype.roundLength = function(length)\n{\n\treturn Math.round(length);\n};\n\n/**\n * Function: isSnapToTerminalsEvent\n *\n * Returns true if <snapToTerminals> is true and if alt is not pressed.\n */\nmxEdgeHandler.prototype.isSnapToTerminalsEvent = function(me)\n{\n\treturn this.snapToTerminals && !mxEvent.isAltDown(me.getEvent());\n};\n\n/**\n * Function: getPointForEvent\n *\n * Returns the point for the given event.\n */\nmxEdgeHandler.prototype.getPointForEvent = function(me)\n{\n\tvar view = this.graph.getView();\n\tvar scale = view.scale;\n\tvar point = new mxPoint(this.roundLength(me.getGraphX() / scale) * scale,\n\t\tthis.roundLength(me.getGraphY() / scale) * scale);\n\n\tvar tt = this.getSnapToTerminalTolerance();\n\tvar overrideX = false;\n\tvar overrideY = false;\n\n\tif (tt > 0 && this.isSnapToTerminalsEvent(me))\n\t{\n\t\tfunction snapToPoint(pt)\n\t\t{\n\t\t\tif (pt != null)\n\t\t\t{\n\t\t\t\tvar x = pt.x;\n\n\t\t\t\tif (Math.abs(point.x - x) < tt)\n\t\t\t\t{\n\t\t\t\t\tpoint.x = x;\n\t\t\t\t\toverrideX = true;\n\t\t\t\t}\n\n\t\t\t\tvar y = pt.y;\n\n\t\t\t\tif (Math.abs(point.y - y) < tt)\n\t\t\t\t{\n\t\t\t\t\tpoint.y = y;\n\t\t\t\t\toverrideY = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Temporary function\n\t\tfunction snapToTerminal(terminal)\n\t\t{\n\t\t\tif (terminal != null)\n\t\t\t{\n\t\t\t\tsnapToPoint.call(this, new mxPoint(view.getRoutingCenterX(terminal),\n\t\t\t\t\t\tview.getRoutingCenterY(terminal)));\n\t\t\t}\n\t\t};\n\n\t\tsnapToTerminal.call(this, this.state.getVisibleTerminalState(true));\n\t\tsnapToTerminal.call(this, this.state.getVisibleTerminalState(false));\n\n\t\tif (this.state.absolutePoints != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.state.absolutePoints.length; i++)\n\t\t\t{\n\t\t\t\tsnapToPoint.call(this, this.state.absolutePoints[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.graph.isGridEnabledEvent(me.getEvent()))\n\t{\n\t\tvar tr = view.translate;\n\n\t\tif (!overrideX)\n\t\t{\n\t\t\tpoint.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n\t\t}\n\n\t\tif (!overrideY)\n\t\t{\n\t\t\tpoint.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n\t\t}\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: getPreviewTerminalState\n *\n * Updates the given preview state taking into account the state of the constraint handler.\n */\nmxEdgeHandler.prototype.getPreviewTerminalState = function(me)\n{\n\tthis.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);\n\n\tif (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null)\n\t{\n\t\t// Handles special case where grid is large and connection point is at actual point in which\n\t\t// case the outline is not followed as long as we're < gridSize / 2 away from that point\n\t\tif (this.marker.highlight != null && this.marker.highlight.state != null &&\n\t\t\tthis.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell)\n\t\t{\n\t\t\t// Direct repaint needed if cell already highlighted\n\t\t\tif (this.marker.highlight.shape.stroke != 'transparent')\n\t\t\t{\n\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n\t\t}\n\n\t\tvar model = this.graph.getModel();\n\t\tvar other = this.graph.view.getTerminalPort(this.state,\n\t\t\t\tthis.graph.view.getState(model.getTerminal(this.state.cell,\n\t\t\t!this.isSource)), !this.isSource);\n\t\tvar otherCell = (other != null) ? other.cell : null;\n\t\tvar source = (this.isSource) ? this.constraintHandler.currentFocus.cell : otherCell;\n\t\tvar target = (this.isSource) ? otherCell : this.constraintHandler.currentFocus.cell;\n\n\t\t// Updates the error message of the handler\n\t\tthis.error = this.validateConnection(source, target);\n\t\tvar result = null;\n\n\t\tif (this.error == null)\n\t\t{\n\t\t\tresult = this.constraintHandler.currentFocus;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.constraintHandler.reset();\n\t\t}\n\n\t\treturn result;\n\t}\n\telse if (!this.graph.isIgnoreTerminalEvent(me.getEvent()))\n\t{\n\t\tthis.marker.process(me);\n\t\tvar state = this.marker.getValidState();\n\n\t\tif (state != null && this.graph.isCellLocked(state.cell))\n\t\t{\n\t\t\tthis.marker.reset();\n\t\t}\n\n\t\treturn this.marker.getValidState();\n\t}\n\telse\n\t{\n\t\tthis.marker.reset();\n\n\t\treturn null;\n\t}\n};\n\n/**\n * Function: getPreviewPoints\n *\n * Updates the given preview state taking into account the state of the constraint handler.\n *\n * Parameters:\n *\n * pt - <mxPoint> that contains the current pointer position.\n * me - Optional <mxMouseEvent> that contains the current event.\n */\nmxEdgeHandler.prototype.getPreviewPoints = function(pt, me)\n{\n\tvar geometry = this.graph.getCellGeometry(this.state.cell);\n\tvar points = (geometry.points != null) ? geometry.points.slice() : null;\n\tvar point = new mxPoint(pt.x, pt.y);\n\tvar result = null;\n\n\tif (!this.isSource && !this.isTarget)\n\t{\n\t\tthis.convertPoint(point, false);\n\n\t\tif (points == null)\n\t\t{\n\t\t\tpoints = [point];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Adds point from virtual bend\n\t\t\tif (this.index <= mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tpoints.splice(mxEvent.VIRTUAL_HANDLE - this.index, 0, point);\n\t\t\t}\n\n\t\t\t// Removes point if dragged on terminal point\n\t\t\tif (!this.isSource && !this.isTarget)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < this.bends.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i != this.index)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar bend = this.bends[i];\n\n\t\t\t\t\t\tif (bend != null && mxUtils.contains(bend.bounds, pt.x, pt.y))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (this.index <= mxEvent.VIRTUAL_HANDLE)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpoints.splice(mxEvent.VIRTUAL_HANDLE - this.index, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpoints.splice(this.index - 1, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tresult = points;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Removes point if user tries to straighten a segment\n\t\t\t\tif (result == null && this.straightRemoveEnabled && (me == null || !mxEvent.isAltDown(me.getEvent())))\n\t\t\t\t{\n\t\t\t\t\tvar tol = this.graph.tolerance * this.graph.tolerance;\n\t\t\t\t\tvar abs = this.state.absolutePoints.slice();\n\t\t\t\t\tabs[this.index] = pt;\n\n\t\t\t\t\t// Handes special case where removing waypoint affects tolerance (flickering)\n\t\t\t\t\tvar src = this.state.getVisibleTerminalState(true);\n\n\t\t\t\t\tif (src != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar c = this.graph.getConnectionConstraint(this.state, src, true);\n\n\t\t\t\t\t\t// Checks if point is not fixed\n\t\t\t\t\t\tif (c == null || this.graph.getConnectionPoint(src, c) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tabs[0] = new mxPoint(src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar trg = this.state.getVisibleTerminalState(false);\n\n\t\t\t\t\tif (trg != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar c = this.graph.getConnectionConstraint(this.state, trg, false);\n\n\t\t\t\t\t\t// Checks if point is not fixed\n\t\t\t\t\t\tif (c == null || this.graph.getConnectionPoint(trg, c) == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tabs[abs.length - 1] = new mxPoint(trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction checkRemove(idx, tmp)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (idx > 0 && idx < abs.length - 1 &&\n\t\t\t\t\t\t\tmxUtils.ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y,\n\t\t\t\t\t\t\t\tabs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpoints.splice(idx - 1, 1);\n\t\t\t\t\t\t\tresult = points;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// LATER: Check if other points can be removed if a segment is made straight\n\t\t\t\t\tcheckRemove(this.index, pt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Updates existing point\n\t\t\tif (result == null && this.index > mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tpoints[this.index - 1] = point;\n\t\t\t}\n\t\t}\n\t}\n\telse if (this.graph.resetEdgesOnConnect)\n\t{\n\t\tpoints = null;\n\t}\n\n\treturn (result != null) ? result : points;\n};\n\n/**\n * Function: isOutlineConnectEvent\n *\n * Returns true if <outlineConnect> is true and the source of the event is the outline shape\n * or shift is pressed.\n */\nmxEdgeHandler.prototype.isOutlineConnectEvent = function(me)\n{\n\tvar offset = mxUtils.getOffset(this.graph.container);\n\tvar evt = me.getEvent();\n\n\tvar clientX = mxEvent.getClientX(evt);\n\tvar clientY = mxEvent.getClientY(evt);\n\n\tvar doc = document.documentElement;\n\tvar left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n\tvar top = (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);\n\n\tvar gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n\tvar gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n\n\treturn this.outlineConnect && !mxEvent.isShiftDown(me.getEvent()) &&\n\t\t(me.isSource(this.marker.highlight.shape) ||\n\t\t(mxEvent.isAltDown(me.getEvent()) && me.getState() != null) ||\n\t\tthis.marker.highlight.isHighlightAt(clientX, clientY) ||\n\t\t((gridX != clientX || gridY != clientY) && me.getState() == null &&\n\t\tthis.marker.highlight.isHighlightAt(gridX, gridY)));\n};\n\n/**\n * Function: updatePreviewState\n *\n * Updates the given preview state taking into account the state of the constraint handler.\n */\nmxEdgeHandler.prototype.updatePreviewState = function(edge, point, terminalState, me, outline)\n{\n\t// Computes the points for the edge style and terminals\n\tvar sourceState = (this.isSource) ? terminalState : this.state.getVisibleTerminalState(true);\n\tvar targetState = (this.isTarget) ? terminalState : this.state.getVisibleTerminalState(false);\n\n\tvar sourceConstraint = this.graph.getConnectionConstraint(edge, sourceState, true);\n\tvar targetConstraint = this.graph.getConnectionConstraint(edge, targetState, false);\n\n\tvar constraint = this.constraintHandler.currentConstraint;\n\n\tif (constraint == null && outline)\n\t{\n\t\tif (terminalState != null)\n\t\t{\n\t\t\t// Handles special case where mouse is on outline away from actual end point\n\t\t\t// in which case the grid is ignored and mouse point is used instead\n\t\t\tif (me.isSource(this.marker.highlight.shape))\n\t\t\t{\n\t\t\t\tpoint = new mxPoint(me.getGraphX(), me.getGraphY());\n\t\t\t}\n\n\t\t\tconstraint = this.graph.getOutlineConstraint(point, terminalState, me);\n\t\t\tthis.constraintHandler.setFocus(me, terminalState, this.isSource);\n\t\t\tthis.constraintHandler.currentConstraint = constraint;\n\t\t\tthis.constraintHandler.currentPoint = point;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconstraint = new mxConnectionConstraint();\n\t\t}\n\t}\n\n\tif (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null)\n\t{\n\t\tvar s = this.graph.view.scale;\n\n\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t{\n\t\t\tthis.marker.highlight.shape.stroke = (outline) ? mxConstants.OUTLINE_HIGHLIGHT_COLOR : 'transparent';\n\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\tthis.marker.highlight.repaint();\n\t\t}\n\t\telse if (this.marker.hasValidState())\n\t\t{\n\t\t\tthis.marker.highlight.shape.stroke = (this.marker.getValidState() == me.getState()) ?\n\t\t\t\tmxConstants.DEFAULT_VALID_COLOR : 'transparent';\n\t\t\tthis.marker.highlight.shape.strokewidth = mxConstants.HIGHLIGHT_STROKEWIDTH / s / s;\n\t\t\tthis.marker.highlight.repaint();\n\t\t}\n\t}\n\n\tif (this.isSource)\n\t{\n\t\tsourceConstraint = constraint;\n\t}\n\telse if (this.isTarget)\n\t{\n\t\ttargetConstraint = constraint;\n\t}\n\n\tif (this.isSource || this.isTarget)\n\t{\n\t\tif (constraint != null && constraint.point != null)\n\t\t{\n\t\t\tedge.style[(this.isSource) ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X] = constraint.point.x;\n\t\t\tedge.style[(this.isSource) ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y] = constraint.point.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdelete edge.style[(this.isSource) ? mxConstants.STYLE_EXIT_X : mxConstants.STYLE_ENTRY_X];\n\t\t\tdelete edge.style[(this.isSource) ? mxConstants.STYLE_EXIT_Y : mxConstants.STYLE_ENTRY_Y];\n\t\t}\n\t}\n\n\tedge.setVisibleTerminalState(sourceState, true);\n\tedge.setVisibleTerminalState(targetState, false);\n\n\tif (!this.isSource || sourceState != null)\n\t{\n\t\tedge.view.updateFixedTerminalPoint(edge, sourceState, true, sourceConstraint);\n\t}\n\n\tif (!this.isTarget || targetState != null)\n\t{\n\t\tedge.view.updateFixedTerminalPoint(edge, targetState, false, targetConstraint);\n\t}\n\n\tif ((this.isSource || this.isTarget) && terminalState == null)\n\t{\n\t\tedge.setAbsoluteTerminalPoint(point, this.isSource);\n\n\t\tif (this.marker.getMarkedState() == null)\n\t\t{\n\t\t\tthis.error = (this.graph.allowDanglingEdges) ? null : '';\n\t\t}\n\t}\n\n\tedge.view.updatePoints(edge, this.points, sourceState, targetState);\n\tedge.view.updateFloatingTerminalPoints(edge, sourceState, targetState);\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by updating the preview.\n */\nmxEdgeHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (this.index != null && this.marker != null)\n\t{\n\t\tthis.currentPoint = this.getPointForEvent(me);\n\t\tthis.error = null;\n\n\t\t// Uses the current point from the constraint handler if available\n\t\tif (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && mxEvent.isShiftDown(me.getEvent()) && this.snapPoint != null)\n\t\t{\n\t\t\tif (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y))\n\t\t\t{\n\t\t\t\tthis.currentPoint.x = this.snapPoint.x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.currentPoint.y = this.snapPoint.y;\n\t\t\t}\n\t\t}\n\n\t\tif (this.index <= mxEvent.CUSTOM_HANDLE && this.index > mxEvent.VIRTUAL_HANDLE)\n\t\t{\n\t\t\tif (this.customHandles != null)\n\t\t\t{\n\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - this.index].processEvent(me);\n\t\t\t}\n\t\t}\n\t\telse if (this.isLabel)\n\t\t{\n\t\t\tthis.label.x = this.currentPoint.x;\n\t\t\tthis.label.y = this.currentPoint.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.points = this.getPreviewPoints(this.currentPoint, me);\n\t\t\tvar terminalState = (this.isSource || this.isTarget) ? this.getPreviewTerminalState(me) : null;\n\n\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\tthis.constraintHandler.currentFocus != null &&\n\t\t\t\tthis.constraintHandler.currentPoint != null)\n\t\t\t{\n\t\t\t\tthis.currentPoint = this.constraintHandler.currentPoint.clone();\n\t\t\t}\n\t\t\telse if (this.outlineConnect)\n\t\t\t{\n\t\t\t\t// Need to check outline before cloning terminal state\n\t\t\t\tvar outline = (this.isSource || this.isTarget) ? this.isOutlineConnectEvent(me) : false\n\n\t\t\t\tif (outline)\n\t\t\t\t{\n\t\t\t\t\tterminalState = this.marker.highlight.state;\n\t\t\t\t}\n\t\t\t\telse if (terminalState != null && terminalState != me.getState() && this.marker.highlight.shape != null)\n\t\t\t\t{\n\t\t\t\t\tthis.marker.highlight.shape.stroke = 'transparent';\n\t\t\t\t\tthis.marker.highlight.repaint();\n\t\t\t\t\tterminalState = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (terminalState != null && this.graph.isCellLocked(terminalState.cell))\n\t\t\t{\n\t\t\t\tterminalState = null;\n\t\t\t\tthis.marker.reset();\n\t\t\t}\n\n\t\t\tvar clone = this.clonePreviewState(this.currentPoint, (terminalState != null) ? terminalState.cell : null);\n\t\t\tthis.updatePreviewState(clone, this.currentPoint, terminalState, me, outline);\n\n\t\t\t// Sets the color of the preview to valid or invalid, updates the\n\t\t\t// points of the preview and redraws\n\t\t\tvar color = (this.error == null) ? this.marker.validColor : this.marker.invalidColor;\n\t\t\tthis.setPreviewColor(color);\n\t\t\tthis.abspoints = clone.absolutePoints;\n\t\t\tthis.active = true;\n\t\t}\n\n\t\t// This should go before calling isOutlineConnectEvent above. As a workaround\n\t\t// we add an offset of gridSize to the hint to avoid problem with hit detection\n\t\t// in highlight.isHighlightAt (which uses comonentFromPoint)\n\t\tthis.updateHint(me, this.currentPoint);\n\t\tthis.drawPreview();\n\t\tmxEvent.consume(me.getEvent());\n\t\tme.consume();\n\t}\n\t// Workaround for disabling the connect highlight when over handle\n\telse if (mxClient.IS_IE && this.getHandleForEvent(me) != null)\n\t{\n\t\tme.consume(false);\n\t}\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event to applying the previewed changes on the edge by\n * using <moveLabel>, <connect> or <changePoints>.\n */\nmxEdgeHandler.prototype.mouseUp = function(sender, me)\n{\n\t// Workaround for wrong event source in Webkit\n\tif (this.index != null && this.marker != null)\n\t{\n\t\tvar edge = this.state.cell;\n\t\tvar index = this.index;\n\t\tthis.index = null;\n\n\t\t// Ignores event if mouse has not been moved\n\t\tif (me.getX() != this.startX || me.getY() != this.startY)\n\t\t{\n\t\t\tvar clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) &&\n\t\t\t\tthis.cloneEnabled && this.graph.isCellsCloneable();\n\n\t\t\t// Displays the reason for not carriying out the change\n\t\t\t// if there is an error message with non-zero length\n\t\t\tif (this.error != null)\n\t\t\t{\n\t\t\t\tif (this.error.length > 0)\n\t\t\t\t{\n\t\t\t\t\tthis.graph.validationAlert(this.error);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (index <= mxEvent.CUSTOM_HANDLE && index > mxEvent.VIRTUAL_HANDLE)\n\t\t\t{\n\t\t\t\tif (this.customHandles != null)\n\t\t\t\t{\n\t\t\t\t\tvar model = this.graph.getModel();\n\n\t\t\t\t\tmodel.beginUpdate();\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.customHandles[mxEvent.CUSTOM_HANDLE - index].execute();\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel.endUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.isLabel)\n\t\t\t{\n\t\t\t\tthis.moveLabel(this.state, this.label.x, this.label.y);\n\t\t\t}\n\t\t\telse if (this.isSource || this.isTarget)\n\t\t\t{\n\t\t\t\tvar terminal = null;\n\n\t\t\t\tif (this.constraintHandler.currentConstraint != null &&\n\t\t\t\t\tthis.constraintHandler.currentFocus != null)\n\t\t\t\t{\n\t\t\t\t\tterminal = this.constraintHandler.currentFocus.cell;\n\t\t\t\t}\n\n\t\t\t\tif (terminal == null && this.marker.hasValidState() && this.marker.highlight != null &&\n\t\t\t\t\tthis.marker.highlight.shape != null &&\n\t\t\t\t\tthis.marker.highlight.shape.stroke != 'transparent' &&\n\t\t\t\t\tthis.marker.highlight.shape.stroke != 'white')\n\t\t\t\t{\n\t\t\t\t\tterminal = this.marker.validState.cell;\n\t\t\t\t}\n\n\t\t\t\tif (terminal != null)\n\t\t\t\t{\n\t\t\t\t\tvar model = this.graph.getModel();\n\t\t\t\t\tvar parent = model.getParent(edge);\n\n\t\t\t\t\tmodel.beginUpdate();\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t// Clones and adds the cell\n\t\t\t\t\t\tif (clone)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar geo = model.getGeometry(edge);\n\t\t\t\t\t\t\tvar clone = this.graph.cloneCell(edge);\n\t\t\t\t\t\t\tmodel.add(parent, clone, model.getChildCount(parent));\n\n\t\t\t\t\t\t\tif (geo != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgeo = geo.clone();\n\t\t\t\t\t\t\t\tmodel.setGeometry(clone, geo);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar other = model.getTerminal(edge, !this.isSource);\n\t\t\t\t\t\t\tthis.graph.connectCell(clone, other, !this.isSource);\n\n\t\t\t\t\t\t\tedge = clone;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedge = this.connect(edge, terminal, this.isSource, clone, me);\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tmodel.endUpdate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (this.graph.isAllowDanglingEdges())\n\t\t\t\t{\n\t\t\t\t\tvar pt = this.abspoints[(this.isSource) ? 0 : this.abspoints.length - 1];\n\t\t\t\t\tpt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);\n\t\t\t\t\tpt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);\n\n\t\t\t\t\tvar pstate = this.graph.getView().getState(\n\t\t\t\t\t\t\tthis.graph.getModel().getParent(edge));\n\n\t\t\t\t\tif (pstate != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpt.x -= pstate.origin.x;\n\t\t\t\t\t\tpt.y -= pstate.origin.y;\n\t\t\t\t\t}\n\n\t\t\t\t\tpt.x -= this.graph.panDx / this.graph.view.scale;\n\t\t\t\t\tpt.y -= this.graph.panDy / this.graph.view.scale;\n\n\t\t\t\t\t// Destroys and recreates this handler\n\t\t\t\t\tedge = this.changeTerminalPoint(edge, pt, this.isSource, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (this.active)\n\t\t\t{\n\t\t\t\tedge = this.changePoints(edge, this.points, clone);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.graph.getView().invalidate(this.state.cell);\n\t\t\t\tthis.graph.getView().validate(this.state.cell);\n\t\t\t}\n\t\t}\n\n\t\t// Resets the preview color the state of the handler if this\n\t\t// handler has not been recreated\n\t\tif (this.marker != null)\n\t\t{\n\t\t\tthis.reset();\n\n\t\t\t// Updates the selection if the edge has been cloned\n\t\t\tif (edge != this.state.cell)\n\t\t\t{\n\t\t\t\tthis.graph.setSelectionCell(edge);\n\t\t\t}\n\t\t}\n\n\t\tme.consume();\n\t}\n};\n\n/**\n * Function: reset\n *\n * Resets the state of this handler.\n */\nmxEdgeHandler.prototype.reset = function()\n{\n\tif (this.active)\n\t{\n\t\tthis.refresh();\n\t}\n\n\tthis.error = null;\n\tthis.index = null;\n\tthis.label = null;\n\tthis.points = null;\n\tthis.snapPoint = null;\n\tthis.isLabel = false;\n\tthis.isSource = false;\n\tthis.isTarget = false;\n\tthis.active = false;\n\n\tif (this.livePreview && this.sizers != null)\n\t{\n\t\tfor (var i = 0; i < this.sizers.length; i++)\n\t\t{\n\t\t\tif (this.sizers[i] != null)\n\t\t\t{\n\t\t\t\tthis.sizers[i].node.style.display = '';\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.marker != null)\n\t{\n\t\tthis.marker.reset();\n\t}\n\n\tif (this.constraintHandler != null)\n\t{\n\t\tthis.constraintHandler.reset();\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].reset();\n\t\t}\n\t}\n\n\tthis.setPreviewColor(mxConstants.EDGE_SELECTION_COLOR);\n\tthis.removeHint();\n\tthis.redraw();\n};\n\n/**\n * Function: setPreviewColor\n *\n * Sets the color of the preview to the given value.\n */\nmxEdgeHandler.prototype.setPreviewColor = function(color)\n{\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.stroke = color;\n\t}\n};\n\n\n/**\n * Function: convertPoint\n *\n * Converts the given point in-place from screen to unscaled, untranslated\n * graph coordinates and applies the grid. Returns the given, modified\n * point instance.\n *\n * Parameters:\n *\n * point - <mxPoint> to be converted.\n * gridEnabled - Boolean that specifies if the grid should be applied.\n */\nmxEdgeHandler.prototype.convertPoint = function(point, gridEnabled)\n{\n\tvar scale = this.graph.getView().getScale();\n\tvar tr = this.graph.getView().getTranslate();\n\n\tif (gridEnabled)\n\t{\n\t\tpoint.x = this.graph.snap(point.x);\n\t\tpoint.y = this.graph.snap(point.y);\n\t}\n\n\tpoint.x = Math.round(point.x / scale - tr.x);\n\tpoint.y = Math.round(point.y / scale - tr.y);\n\n\tvar pstate = this.graph.getView().getState(\n\t\tthis.graph.getModel().getParent(this.state.cell));\n\n\tif (pstate != null)\n\t{\n\t\tpoint.x -= pstate.origin.x;\n\t\tpoint.y -= pstate.origin.y;\n\t}\n\n\treturn point;\n};\n\n/**\n * Function: moveLabel\n *\n * Changes the coordinates for the label of the given edge.\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge.\n * x - Integer that specifies the x-coordinate of the new location.\n * y - Integer that specifies the y-coordinate of the new location.\n */\nmxEdgeHandler.prototype.moveLabel = function(edgeState, x, y)\n{\n\tvar model = this.graph.getModel();\n\tvar geometry = model.getGeometry(edgeState.cell);\n\n\tif (geometry != null)\n\t{\n\t\tvar scale = this.graph.getView().scale;\n\t\tgeometry = geometry.clone();\n\n\t\tif (geometry.relative)\n\t\t{\n\t\t\t// Resets the relative location stored inside the geometry\n\t\t\tvar pt = this.graph.getView().getRelativePoint(edgeState, x, y);\n\t\t\tgeometry.x = Math.round(pt.x * 10000) / 10000;\n\t\t\tgeometry.y = Math.round(pt.y);\n\n\t\t\t// Resets the offset inside the geometry to find the offset\n\t\t\t// from the resulting point\n\t\t\tgeometry.offset = new mxPoint(0, 0);\n\t\t\tvar pt = this.graph.view.getPoint(edgeState, geometry);\n\t\t\tgeometry.offset = new mxPoint(Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar points = edgeState.absolutePoints;\n\t\t\tvar p0 = points[0];\n\t\t\tvar pe = points[points.length - 1];\n\n\t\t\tif (p0 != null && pe != null)\n\t\t\t{\n\t\t\t\tvar cx = p0.x + (pe.x - p0.x) / 2;\n\t\t\t\tvar cy = p0.y + (pe.y - p0.y) / 2;\n\n\t\t\t\tgeometry.offset = new mxPoint(Math.round((x - cx) / scale), Math.round((y - cy) / scale));\n\t\t\t\tgeometry.x = 0;\n\t\t\t\tgeometry.y = 0;\n\t\t\t}\n\t\t}\n\n\t\tmodel.setGeometry(edgeState.cell, geometry);\n\t}\n};\n\n/**\n * Function: connect\n *\n * Changes the terminal or terminal point of the given edge in the graph\n * model.\n *\n * Parameters:\n *\n * edge - <mxCell> that represents the edge to be reconnected.\n * terminal - <mxCell> that represents the new terminal.\n * isSource - Boolean indicating if the new terminal is the source or\n * target terminal.\n * isClone - Boolean indicating if the new connection should be a clone of\n * the old edge.\n * me - <mxMouseEvent> that contains the mouse up event.\n */\nmxEdgeHandler.prototype.connect = function(edge, terminal, isSource, isClone, me)\n{\n\tvar model = this.graph.getModel();\n\tvar parent = model.getParent(edge);\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tvar constraint = this.constraintHandler.currentConstraint;\n\n\t\tif (constraint == null)\n\t\t{\n\t\t\tconstraint = new mxConnectionConstraint();\n\t\t}\n\n\t\tthis.graph.connectCell(edge, terminal, isSource, constraint);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: changeTerminalPoint\n *\n * Changes the terminal point of the given edge.\n */\nmxEdgeHandler.prototype.changeTerminalPoint = function(edge, point, isSource, clone)\n{\n\tvar model = this.graph.getModel();\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tif (clone)\n\t\t{\n\t\t\tvar parent = model.getParent(edge);\n\t\t\tvar terminal = model.getTerminal(edge, !isSource);\n\t\t\tedge = this.graph.cloneCell(edge);\n\t\t\tmodel.add(parent, edge, model.getChildCount(parent));\n\t\t\tmodel.setTerminal(edge, terminal, !isSource);\n\t\t}\n\n\t\tvar geo = model.getGeometry(edge);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.setTerminalPoint(point, isSource);\n\t\t\tmodel.setGeometry(edge, geo);\n\t\t\tthis.graph.connectCell(edge, null, isSource, new mxConnectionConstraint());\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: changePoints\n *\n * Changes the control points of the given edge in the graph model.\n */\nmxEdgeHandler.prototype.changePoints = function(edge, points, clone)\n{\n\tvar model = this.graph.getModel();\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tif (clone)\n\t\t{\n\t\t\tvar parent = model.getParent(edge);\n\t\t\tvar source = model.getTerminal(edge, true);\n\t\t\tvar target = model.getTerminal(edge, false);\n\t\t\tedge = this.graph.cloneCell(edge);\n\t\t\tmodel.add(parent, edge, model.getChildCount(parent));\n\t\t\tmodel.setTerminal(edge, source, true);\n\t\t\tmodel.setTerminal(edge, target, false);\n\t\t}\n\n\t\tvar geo = model.getGeometry(edge);\n\n\t\tif (geo != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.points = points;\n\n\t\t\tmodel.setGeometry(edge, geo);\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: addPoint\n *\n * Adds a control point for the given state and event.\n */\nmxEdgeHandler.prototype.addPoint = function(state, evt)\n{\n\tvar pt = mxUtils.convertPoint(this.graph.container, mxEvent.getClientX(evt),\n\t\t\tmxEvent.getClientY(evt));\n\tvar gridEnabled = this.graph.isGridEnabledEvent(evt);\n\tthis.convertPoint(pt, gridEnabled);\n\tthis.addPointAt(state, pt.x, pt.y);\n\tmxEvent.consume(evt);\n};\n\n/**\n * Function: addPointAt\n *\n * Adds a control point at the given point.\n */\nmxEdgeHandler.prototype.addPointAt = function(state, x, y)\n{\n\tvar geo = this.graph.getCellGeometry(state.cell);\n\tvar pt = new mxPoint(x, y);\n\n\tif (geo != null)\n\t{\n\t\tgeo = geo.clone();\n\t\tvar t = this.graph.view.translate;\n\t\tvar s = this.graph.view.scale;\n\t\tvar offset = new mxPoint(t.x * s, t.y * s);\n\n\t\tvar parent = this.graph.model.getParent(this.state.cell);\n\n\t\tif (this.graph.model.isVertex(parent))\n\t\t{\n\t\t\tvar pState = this.graph.view.getState(parent);\n\t\t\toffset = new mxPoint(pState.x, pState.y);\n\t\t}\n\n\t\tvar index = mxUtils.findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);\n\n\t\tif (geo.points == null)\n\t\t{\n\t\t\tgeo.points = [pt];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgeo.points.splice(index, 0, pt);\n\t\t}\n\n\t\tthis.graph.getModel().setGeometry(state.cell, geo);\n\t\tthis.refresh();\n\t\tthis.redraw();\n\t}\n};\n\n/**\n * Function: removePoint\n *\n * Removes the control point at the given index from the given state.\n */\nmxEdgeHandler.prototype.removePoint = function(state, index)\n{\n\tif (index > 0 && index < this.abspoints.length - 1)\n\t{\n\t\tvar geo = this.graph.getCellGeometry(this.state.cell);\n\n\t\tif (geo != null && geo.points != null)\n\t\t{\n\t\t\tgeo = geo.clone();\n\t\t\tgeo.points.splice(index - 1, 1);\n\t\t\tthis.graph.getModel().setGeometry(state.cell, geo);\n\t\t\tthis.refresh();\n\t\t\tthis.redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: getHandleFillColor\n *\n * Returns the fillcolor for the handle at the given index.\n */\nmxEdgeHandler.prototype.getHandleFillColor = function(index)\n{\n\tvar isSource = index == 0;\n\tvar cell = this.state.cell;\n\tvar terminal = this.graph.getModel().getTerminal(cell, isSource);\n\tvar color = mxConstants.HANDLE_FILLCOLOR;\n\n\tif ((terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource)) ||\n\t\t(terminal == null && !this.graph.isTerminalPointMovable(cell, isSource)))\n\t{\n\t\tcolor = mxConstants.LOCKED_HANDLE_FILLCOLOR;\n\t}\n\telse if (terminal != null && this.graph.isCellDisconnectable(cell, terminal, isSource))\n\t{\n\t\tcolor = mxConstants.CONNECT_HANDLE_FILLCOLOR;\n\t}\n\n\treturn color;\n};\n\n/**\n * Function: redraw\n *\n * Redraws the preview, and the bends- and label control points.\n */\nmxEdgeHandler.prototype.redraw = function()\n{\n\tthis.abspoints = this.state.absolutePoints.slice();\n\tthis.redrawHandles();\n\n\tvar g = this.graph.getModel().getGeometry(this.state.cell);\n\tvar pts = g.points;\n\n\tif (this.bends != null && this.bends.length > 0)\n\t{\n\t\tif (pts != null)\n\t\t{\n\t\t\tif (this.points == null)\n\t\t\t{\n\t\t\t\tthis.points = [];\n\t\t\t}\n\n\t\t\tfor (var i = 1; i < this.bends.length - 1; i++)\n\t\t\t{\n\t\t\t\tif (this.bends[i] != null && this.abspoints[i] != null)\n\t\t\t\t{\n\t\t\t\t\tthis.points[i - 1] = pts[i - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.drawPreview();\n};\n\n/**\n * Function: redrawHandles\n *\n * Redraws the handles.\n */\nmxEdgeHandler.prototype.redrawHandles = function()\n{\n\tvar cell = this.state.cell;\n\n\t// Updates the handle for the label position\n\tvar b = this.labelShape.bounds;\n\tthis.label = new mxPoint(this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n\tthis.labelShape.bounds = new mxRectangle(Math.round(this.label.x - b.width / 2),\n\t\tMath.round(this.label.y - b.height / 2), b.width, b.height);\n\n\t// Shows or hides the label handle depending on the label\n\tvar lab = this.graph.getLabel(cell);\n\tthis.labelShape.visible = (lab != null && lab.length > 0 && this.graph.isLabelMovable(cell));\n\n\tif (this.bends != null && this.bends.length > 0)\n\t{\n\t\tvar n = this.abspoints.length - 1;\n\n\t\tvar p0 = this.abspoints[0];\n\t\tvar x0 = p0.x;\n\t\tvar y0 = p0.y;\n\n\t\tb = this.bends[0].bounds;\n\t\tthis.bends[0].bounds = new mxRectangle(Math.floor(x0 - b.width / 2),\n\t\t\t\tMath.floor(y0 - b.height / 2), b.width, b.height);\n\t\tthis.bends[0].fill = this.getHandleFillColor(0);\n\t\tthis.bends[0].redraw();\n\n\t\tif (this.manageLabelHandle)\n\t\t{\n\t\t\tthis.checkLabelHandle(this.bends[0].bounds);\n\t\t}\n\n\t\tvar pe = this.abspoints[n];\n\t\tvar xn = pe.x;\n\t\tvar yn = pe.y;\n\n\t\tvar bn = this.bends.length - 1;\n\t\tb = this.bends[bn].bounds;\n\t\tthis.bends[bn].bounds = new mxRectangle(Math.floor(xn - b.width / 2),\n\t\t\t\tMath.floor(yn - b.height / 2), b.width, b.height);\n\t\tthis.bends[bn].fill = this.getHandleFillColor(bn);\n\t\tthis.bends[bn].redraw();\n\n\t\tif (this.manageLabelHandle)\n\t\t{\n\t\t\tthis.checkLabelHandle(this.bends[bn].bounds);\n\t\t}\n\n\t\tthis.redrawInnerBends(p0, pe);\n\t}\n\n\tif (this.abspoints != null && this.virtualBends != null && this.virtualBends.length > 0)\n\t{\n\t\tvar last = this.abspoints[0];\n\n\t\tfor (var i = 0; i < this.virtualBends.length; i++)\n\t\t{\n\t\t\tif (this.virtualBends[i] != null && this.abspoints[i + 1] != null)\n\t\t\t{\n\t\t\t\tvar pt = this.abspoints[i + 1];\n\t\t\t\tvar b = this.virtualBends[i];\n\t\t\t\tvar x = last.x + (pt.x - last.x) / 2;\n\t\t\t\tvar y = last.y + (pt.y - last.y) / 2;\n\t\t\t\tb.bounds = new mxRectangle(Math.floor(x - b.bounds.width / 2),\n\t\t\t\t\t\tMath.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);\n\t\t\t\tb.redraw();\n\t\t\t\tmxUtils.setOpacity(b.node, this.virtualBendOpacity);\n\t\t\t\tlast = pt;\n\n\t\t\t\tif (this.manageLabelHandle)\n\t\t\t\t{\n\t\t\t\t\tthis.checkLabelHandle(b.bounds);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (this.labelShape != null)\n\t{\n\t\tthis.labelShape.redraw();\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].redraw();\n\t\t}\n\t}\n};\n\n/**\n * Function: hideHandles\n *\n * Shortcut to <hideSizers>.\n */\nmxEdgeHandler.prototype.setHandlesVisible = function(visible)\n{\n\tif (this.bends != null)\n\t{\n\t\tfor (var i = 0; i < this.bends.length; i++)\n\t\t{\n\t\t\tthis.bends[i].node.style.display = (visible) ? '' : 'none';\n\t\t}\n\t}\n\n\tif (this.virtualBends != null)\n\t{\n\t\tfor (var i = 0; i < this.virtualBends.length; i++)\n\t\t{\n\t\t\tthis.virtualBends[i].node.style.display = (visible) ? '' : 'none';\n\t\t}\n\t}\n\n\tif (this.labelShape != null)\n\t{\n\t\tthis.labelShape.node.style.display = (visible) ? '' : 'none';\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tfor (var i = 0; i < this.customHandles.length; i++)\n\t\t{\n\t\t\tthis.customHandles[i].setVisible(visible);\n\t\t}\n\t}\n};\n\n/**\n * Function: redrawInnerBends\n *\n * Updates and redraws the inner bends.\n *\n * Parameters:\n *\n * p0 - <mxPoint> that represents the location of the first point.\n * pe - <mxPoint> that represents the location of the last point.\n */\nmxEdgeHandler.prototype.redrawInnerBends = function(p0, pe)\n{\n\tfor (var i = 1; i < this.bends.length - 1; i++)\n\t{\n\t\tif (this.bends[i] != null)\n\t\t{\n\t\t\tif (this.abspoints[i] != null)\n\t\t\t{\n\t\t\t\tvar x = this.abspoints[i].x;\n\t\t\t\tvar y = this.abspoints[i].y;\n\n\t\t\t\tvar b = this.bends[i].bounds;\n\t\t\t\tthis.bends[i].node.style.visibility = 'visible';\n\t\t\t\tthis.bends[i].bounds = new mxRectangle(Math.round(x - b.width / 2),\n\t\t\t\t\t\tMath.round(y - b.height / 2), b.width, b.height);\n\n\t\t\t\tif (this.manageLabelHandle)\n\t\t\t\t{\n\t\t\t\t\tthis.checkLabelHandle(this.bends[i].bounds);\n\t\t\t\t}\n\t\t\t\telse if (this.handleImage == null && this.labelShape.visible && mxUtils.intersects(this.bends[i].bounds, this.labelShape.bounds))\n\t\t\t\t{\n\t\t\t\t\tw = mxConstants.HANDLE_SIZE + 3;\n\t\t\t\t\th = mxConstants.HANDLE_SIZE + 3;\n\t\t\t\t\tthis.bends[i].bounds = new mxRectangle(Math.round(x - w / 2), Math.round(y - h / 2), w, h);\n\t\t\t\t}\n\n\t\t\t\tthis.bends[i].redraw();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.bends[i].destroy();\n\t\t\t\tthis.bends[i] = null;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: checkLabelHandle\n *\n * Checks if the label handle intersects the given bounds and moves it if it\n * intersects.\n */\nmxEdgeHandler.prototype.checkLabelHandle = function(b)\n{\n\tif (this.labelShape != null)\n\t{\n\t\tvar b2 = this.labelShape.bounds;\n\n\t\tif (mxUtils.intersects(b, b2))\n\t\t{\n\t\t\tif (b.getCenterY() < b2.getCenterY())\n\t\t\t{\n\t\t\t\tb2.y = b.y + b.height;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tb2.y = b.y - b2.height;\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: drawPreview\n *\n * Redraws the preview.\n */\nmxEdgeHandler.prototype.drawPreview = function()\n{\n\tif (this.isLabel)\n\t{\n\t\tvar b = this.labelShape.bounds;\n\t\tvar bounds = new mxRectangle(Math.round(this.label.x - b.width / 2),\n\t\t\t\tMath.round(this.label.y - b.height / 2), b.width, b.height);\n\t\tthis.labelShape.bounds = bounds;\n\t\tthis.labelShape.redraw();\n\t}\n\telse if (this.shape != null)\n\t{\n\t\tthis.shape.apply(this.state);\n\t\tthis.shape.points = this.abspoints;\n\t\tthis.shape.scale = this.state.view.scale;\n\t\tthis.shape.isDashed = this.isSelectionDashed();\n\t\tthis.shape.stroke = this.getSelectionColor();\n\t\tthis.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;\n\t\tthis.shape.isShadow = false;\n\t\tthis.shape.redraw();\n\t}\n\n\tif (this.parentHighlight != null)\n\t{\n\t\tthis.parentHighlight.redraw();\n\t}\n};\n\n/**\n * Function: refresh\n *\n * Refreshes the bends of this handler.\n */\nmxEdgeHandler.prototype.refresh = function()\n{\n\tthis.abspoints = this.getSelectionPoints(this.state);\n\tthis.points = [];\n\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.points = this.abspoints;\n\t}\n\n\tif (this.bends != null)\n\t{\n\t\tthis.destroyBends(this.bends);\n\t\tthis.bends = this.createBends();\n\t}\n\n\tif (this.virtualBends != null)\n\t{\n\t\tthis.destroyBends(this.virtualBends);\n\t\tthis.virtualBends = this.createVirtualBends();\n\t}\n\n\tif (this.customHandles != null)\n\t{\n\t\tthis.destroyBends(this.customHandles);\n\t\tthis.customHandles = this.createCustomHandles();\n\t}\n\n\t// Puts label node on top of bends\n\tif (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null)\n\t{\n\t\tthis.labelShape.node.parentNode.appendChild(this.labelShape.node);\n\t}\n};\n\n/**\n * Function: destroyBends\n *\n * Destroys all elements in <bends>.\n */\nmxEdgeHandler.prototype.destroyBends = function(bends)\n{\n\tif (bends != null)\n\t{\n\t\tfor (var i = 0; i < bends.length; i++)\n\t\t{\n\t\t\tif (bends[i] != null)\n\t\t\t{\n\t\t\t\tbends[i].destroy();\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes. This does\n * normally not need to be called as handlers are destroyed automatically\n * when the corresponding cell is deselected.\n */\nmxEdgeHandler.prototype.destroy = function()\n{\n\tif (this.escapeHandler != null)\n\t{\n\t\tthis.state.view.graph.removeListener(this.escapeHandler);\n\t\tthis.escapeHandler = null;\n\t}\n\n\tif (this.marker != null)\n\t{\n\t\tthis.marker.destroy();\n\t\tthis.marker = null;\n\t}\n\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n\n\tif (this.parentHighlight != null)\n\t{\n\t\tthis.parentHighlight.destroy();\n\t\tthis.parentHighlight = null;\n\t}\n\n\tif (this.labelShape != null)\n\t{\n\t\tthis.labelShape.destroy();\n\t\tthis.labelShape = null;\n\t}\n\n\tif (this.constraintHandler != null)\n\t{\n\t\tthis.constraintHandler.destroy();\n\t\tthis.constraintHandler = null;\n\t}\n\n\tthis.destroyBends(this.virtualBends);\n\tthis.virtualBends = null;\n\n\tthis.destroyBends(this.customHandles);\n\tthis.customHandles = null;\n\n\tthis.destroyBends(this.bends);\n\tthis.bends = null;\n\n\tthis.removeHint();\n};\n\n__mxOutput.mxEdgeHandler = typeof mxEdgeHandler !== 'undefined' ? mxEdgeHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxElbowEdgeHandler\n *\n * Graph event handler that reconnects edges and modifies control points and\n * the edge label location. Uses <mxTerminalMarker> for finding and\n * highlighting new source and target vertices. This handler is automatically\n * created in <mxGraph.createHandler>. It extends <mxEdgeHandler>.\n *\n * Constructor: mxEdgeHandler\n *\n * Constructs an edge handler for the specified <mxCellState>.\n *\n * Parameters:\n *\n * state - <mxCellState> of the cell to be modified.\n */\nfunction mxElbowEdgeHandler(state)\n{\n\tmxEdgeHandler.call(this, state);\n};\n\n/**\n * Extends mxEdgeHandler.\n */\nmxUtils.extend(mxElbowEdgeHandler, mxEdgeHandler);\n\n/**\n * Specifies if a double click on the middle handle should call\n * <mxGraph.flipEdge>. Default is true.\n */\nmxElbowEdgeHandler.prototype.flipEnabled = true;\n\n/**\n * Variable: doubleClickOrientationResource\n *\n * Specifies the resource key for the tooltip to be displayed on the single\n * control point for routed edges. If the resource for this key does not\n * exist then the value is used as the error message. Default is\n * 'doubleClickOrientation'.\n */\nmxElbowEdgeHandler.prototype.doubleClickOrientationResource =\n\t(mxClient.language != 'none') ? 'doubleClickOrientation' : '';\n\n/**\n * Function: createBends\n *\n * Overrides <mxEdgeHandler.createBends> to create custom bends.\n */\n mxElbowEdgeHandler.prototype.createBends = function()\n {\n\tvar bends = [];\n\n\t// Source\n\tvar bend = this.createHandleShape(0);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\n\t// Virtual\n\tbends.push(this.createVirtualBend(mxUtils.bind(this, function(evt)\n\t{\n\t\tif (!mxEvent.isConsumed(evt) && this.flipEnabled)\n\t\t{\n\t\t\tthis.graph.flipEdge(this.state.cell, evt);\n\t\t\tmxEvent.consume(evt);\n\t\t}\n\t})));\n\tthis.points.push(new mxPoint(0,0));\n\n\t// Target\n\tbend = this.createHandleShape(2);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\n\treturn bends;\n };\n\n/**\n * Function: createVirtualBend\n *\n * Creates a virtual bend that supports double clicking and calls\n * <mxGraph.flipEdge>.\n */\nmxElbowEdgeHandler.prototype.createVirtualBend = function(dblClickHandler)\n{\n\tvar bend = this.createHandleShape();\n\tthis.initBend(bend, dblClickHandler);\n\n\tbend.setCursor(this.getCursorForBend());\n\n\tif (!this.graph.isCellBendable(this.state.cell))\n\t{\n\t\tbend.node.style.display = 'none';\n\t}\n\n\treturn bend;\n};\n\n/**\n * Function: getCursorForBend\n *\n * Returns the cursor to be used for the bend.\n */\nmxElbowEdgeHandler.prototype.getCursorForBend = function()\n{\n\treturn (this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.TopToBottom ||\n\t\tthis.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_TOPTOBOTTOM ||\n\t\t((this.state.style[mxConstants.STYLE_EDGE] == mxEdgeStyle.ElbowConnector ||\n\t\tthis.state.style[mxConstants.STYLE_EDGE] == mxConstants.EDGESTYLE_ELBOW)&&\n\t\tthis.state.style[mxConstants.STYLE_ELBOW] == mxConstants.ELBOW_VERTICAL)) ?\n\t\t'row-resize' : 'col-resize';\n};\n\n/**\n * Function: getTooltipForNode\n *\n * Returns the tooltip for the given node.\n */\nmxElbowEdgeHandler.prototype.getTooltipForNode = function(node)\n{\n\tvar tip = null;\n\n\tif (this.bends != null && this.bends[1] != null && (node == this.bends[1].node ||\n\t\tnode.parentNode == this.bends[1].node))\n\t{\n\t\ttip = this.doubleClickOrientationResource;\n\t\ttip = mxResources.get(tip) || tip; // translate\n\t}\n\n\treturn tip;\n};\n\n/**\n * Function: convertPoint\n *\n * Converts the given point in-place from screen to unscaled, untranslated\n * graph coordinates and applies the grid.\n *\n * Parameters:\n *\n * point - <mxPoint> to be converted.\n * gridEnabled - Boolean that specifies if the grid should be applied.\n */\nmxElbowEdgeHandler.prototype.convertPoint = function(point, gridEnabled)\n{\n\tvar scale = this.graph.getView().getScale();\n\tvar tr = this.graph.getView().getTranslate();\n\tvar origin = this.state.origin;\n\n\tif (gridEnabled)\n\t{\n\t\tpoint.x = this.graph.snap(point.x);\n\t\tpoint.y = this.graph.snap(point.y);\n\t}\n\n\tpoint.x = Math.round(point.x / scale - tr.x - origin.x);\n\tpoint.y = Math.round(point.y / scale - tr.y - origin.y);\n\n\treturn point;\n};\n\n/**\n * Function: redrawInnerBends\n *\n * Updates and redraws the inner bends.\n *\n * Parameters:\n *\n * p0 - <mxPoint> that represents the location of the first point.\n * pe - <mxPoint> that represents the location of the last point.\n */\nmxElbowEdgeHandler.prototype.redrawInnerBends = function(p0, pe)\n{\n\tvar g = this.graph.getModel().getGeometry(this.state.cell);\n\tvar pts = this.state.absolutePoints;\n\tvar pt = null;\n\n\t// Keeps the virtual bend on the edge shape\n\tif (pts.length > 1)\n\t{\n\t\tp0 = pts[1];\n\t\tpe = pts[pts.length - 2];\n\t}\n\telse if (g.points != null && g.points.length > 0)\n\t{\n\t\tpt = pts[0];\n\t}\n\n\tif (pt == null)\n\t{\n\t\tpt = new mxPoint(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n\t}\n\telse\n\t{\n\t\tpt = new mxPoint(this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x),\n\t\t\t\tthis.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y));\n\t}\n\n\t// Makes handle slightly bigger if the yellow  label handle\n\t// exists and intersects this green handle\n\tvar b = this.bends[1].bounds;\n\tvar w = b.width;\n\tvar h = b.height;\n\tvar bounds = new mxRectangle(Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);\n\n\tif (this.manageLabelHandle)\n\t{\n\t\tthis.checkLabelHandle(bounds);\n\t}\n\telse if (this.handleImage == null && this.labelShape.visible && mxUtils.intersects(bounds, this.labelShape.bounds))\n\t{\n\t\tw = mxConstants.HANDLE_SIZE + 3;\n\t\th = mxConstants.HANDLE_SIZE + 3;\n\t\tbounds = new mxRectangle(Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);\n\t}\n\n\tthis.bends[1].bounds = bounds;\n\tthis.bends[1].redraw();\n\n\tif (this.manageLabelHandle)\n\t{\n\t\tthis.checkLabelHandle(this.bends[1].bounds);\n\t}\n};\n\n__mxOutput.mxElbowEdgeHandler = typeof mxElbowEdgeHandler !== 'undefined' ? mxElbowEdgeHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nfunction mxEdgeSegmentHandler(state)\n{\n\tmxEdgeHandler.call(this, state);\n};\n\n/**\n * Extends mxEdgeHandler.\n */\nmxUtils.extend(mxEdgeSegmentHandler, mxElbowEdgeHandler);\n\n/**\n * Function: getCurrentPoints\n *\n * Returns the current absolute points.\n */\nmxEdgeSegmentHandler.prototype.getCurrentPoints = function()\n{\n\tvar pts = this.state.absolutePoints;\n\n\tif (pts != null)\n\t{\n\t\t// Special case for straight edges where we add a virtual middle handle for moving the edge\n\t\tvar tol = Math.max(1, this.graph.view.scale);\n\n\t\tif (pts.length == 2 || (pts.length == 3 &&\n\t\t\t(Math.abs(pts[0].x - pts[1].x) < tol && Math.abs(pts[1].x - pts[2].x) < tol ||\n\t\t\tMath.abs(pts[0].y - pts[1].y) < tol && Math.abs(pts[1].y - pts[2].y) < tol)))\n\t\t{\n\t\t\tvar cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n\t\t\tvar cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n\n\t\t\tpts = [pts[0], new mxPoint(cx, cy), new mxPoint(cx, cy), pts[pts.length - 1]];\n\t\t}\n\t}\n\n\treturn pts;\n};\n\n/**\n * Function: getPreviewPoints\n *\n * Updates the given preview state taking into account the state of the constraint handler.\n */\nmxEdgeSegmentHandler.prototype.getPreviewPoints = function(point)\n{\n\tif (this.isSource || this.isTarget)\n\t{\n\t\treturn mxElbowEdgeHandler.prototype.getPreviewPoints.apply(this, arguments);\n\t}\n\telse\n\t{\n\t\tvar pts = this.getCurrentPoints();\n\t\tvar last = this.convertPoint(pts[0].clone(), false);\n\t\tpoint = this.convertPoint(point.clone(), false);\n\t\tvar result = [];\n\n\t\tfor (var i = 1; i < pts.length; i++)\n\t\t{\n\t\t\tvar pt = this.convertPoint(pts[i].clone(), false);\n\n\t\t\tif (i == this.index)\n\t\t\t{\n\t\t\t\tif (Math.round(last.x - pt.x) == 0)\n\t\t \t\t{\n\t\t\t\t\tlast.x = point.x;\n\t\t\t\t\tpt.x = point.x;\n\t\t \t\t}\n\n\t\t\t\tif (Math.round(last.y - pt.y) == 0)\n\t\t \t\t{\n\t\t \t\t\tlast.y = point.y;\n\t\t \t\t\tpt.y = point.y;\n\t\t \t\t}\n\t\t\t}\n\n\t\t\tif (i < pts.length - 1)\n\t\t\t{\n\t\t\t\tresult.push(pt);\n\t\t\t}\n\n\t\t\tlast = pt;\n\t\t}\n\n\t\t// Replaces single point that intersects with source or target\n\t\tif (result.length == 1)\n\t\t{\n\t\t\tvar source = this.state.getVisibleTerminalState(true);\n\t\t\tvar target = this.state.getVisibleTerminalState(false);\n\t\t\tvar scale = this.state.view.getScale();\n\t\t\tvar tr = this.state.view.getTranslate();\n\n\t\t\tvar x = result[0].x * scale + tr.x;\n\t\t\tvar y = result[0].y * scale + tr.y;\n\n\t\t\tif ((source != null && mxUtils.contains(source, x, y)) ||\n\t\t\t\t(target != null && mxUtils.contains(target, x, y)))\n\t\t\t{\n\t\t\t\tresult = [point, point];\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\n/**\n * Function: updatePreviewState\n *\n * Overridden to perform optimization of the edge style result.\n */\nmxEdgeSegmentHandler.prototype.updatePreviewState = function(edge, point, terminalState, me)\n{\n\tmxEdgeHandler.prototype.updatePreviewState.apply(this, arguments);\n\n\t// Checks and corrects preview by running edge style again\n\tif (!this.isSource && !this.isTarget)\n\t{\n\t\tpoint = this.convertPoint(point.clone(), false);\n\t\tvar pts = edge.absolutePoints;\n\t\tvar pt0 = pts[0];\n\t\tvar pt1 = pts[1];\n\n\t\tvar result = [];\n\n\t\tfor (var i = 2; i < pts.length; i++)\n\t\t{\n\t\t\tvar pt2 = pts[i];\n\n\t\t\t// Merges adjacent segments only if more than 2 to allow for straight edges\n\t\t\tif ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) &&\n\t\t\t\t(Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0))\n\t\t\t{\n\t\t\t\tresult.push(this.convertPoint(pt1.clone(), false));\n\t\t\t}\n\n\t\t\tpt0 = pt1;\n\t\t\tpt1 = pt2;\n\t\t}\n\n\t\tvar source = this.state.getVisibleTerminalState(true);\n\t\tvar target = this.state.getVisibleTerminalState(false);\n\t\tvar rpts = this.state.absolutePoints;\n\n\t\t// A straight line is represented by 3 handles\n\t\tif (result.length == 0 && (Math.round(pts[0].x - pts[pts.length - 1].x) == 0 ||\n\t\t\tMath.round(pts[0].y - pts[pts.length - 1].y) == 0))\n\t\t{\n\t\t\tresult = [point, point];\n\t\t}\n\t\t// Handles special case of transitions from straight vertical to routed\n\t\telse if (pts.length == 5 && result.length == 2 && source != null && target != null &&\n\t\t\t\trpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) == 0)\n\t\t{\n\t\t\tvar view = this.graph.getView();\n\t\t\tvar scale = view.getScale();\n\t\t\tvar tr = view.getTranslate();\n\n\t\t\tvar y0 = view.getRoutingCenterY(source) / scale - tr.y;\n\n\t\t\t// Use fixed connection point y-coordinate if one exists\n\t\t\tvar sc = this.graph.getConnectionConstraint(edge, source, true);\n\n\t\t\tif (sc != null)\n\t\t\t{\n\t\t\t\tvar pt = this.graph.getConnectionPoint(source, sc);\n\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tthis.convertPoint(pt, false);\n\t\t\t\t\ty0 = pt.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ye = view.getRoutingCenterY(target) / scale - tr.y;\n\n\t\t\t// Use fixed connection point y-coordinate if one exists\n\t\t\tvar tc = this.graph.getConnectionConstraint(edge, target, false);\n\n\t\t\tif (tc)\n\t\t\t{\n\t\t\t\tvar pt = this.graph.getConnectionPoint(target, tc);\n\n\t\t\t\tif (pt != null)\n\t\t\t\t{\n\t\t\t\t\tthis.convertPoint(pt, false);\n\t\t\t\t\tye = pt.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult = [new mxPoint(point.x, y0), new mxPoint(point.x, ye)];\n\t\t}\n\n\t\tthis.points = result;\n\n\t\t// LATER: Check if points and result are different\n\t\tedge.view.updateFixedTerminalPoints(edge, source, target);\n\t\tedge.view.updatePoints(edge, this.points, source, target);\n\t\tedge.view.updateFloatingTerminalPoints(edge, source, target);\n\t}\n};\n\n/**\n * Overriden to merge edge segments.\n */\nmxEdgeSegmentHandler.prototype.connect = function(edge, terminal, isSource, isClone, me)\n{\n\tvar model = this.graph.getModel();\n\tvar geo = model.getGeometry(edge);\n\tvar result = null;\n\n\t// Merges adjacent edge segments\n\tif (geo != null && geo.points != null && geo.points.length > 0)\n\t{\n\t\tvar pts = this.abspoints;\n\t\tvar pt0 = pts[0];\n\t\tvar pt1 = pts[1];\n\t\tresult = [];\n\n\t\tfor (var i = 2; i < pts.length; i++)\n\t\t{\n\t\t\tvar pt2 = pts[i];\n\n\t\t\t// Merges adjacent segments only if more than 2 to allow for straight edges\n\t\t\tif ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) &&\n\t\t\t\t(Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0))\n\t\t\t{\n\t\t\t\tresult.push(this.convertPoint(pt1.clone(), false));\n\t\t\t}\n\n\t\t\tpt0 = pt1;\n\t\t\tpt1 = pt2;\n\t\t}\n\t}\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tif (result != null)\n\t\t{\n\t\t\tvar geo = model.getGeometry(edge);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tgeo = geo.clone();\n\t\t\t\tgeo.points = result;\n\n\t\t\t\tmodel.setGeometry(edge, geo);\n\t\t\t}\n\t\t}\n\n\t\tedge = mxEdgeHandler.prototype.connect.apply(this, arguments);\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\n\treturn edge;\n};\n\n/**\n * Function: getTooltipForNode\n *\n * Returns no tooltips.\n */\nmxEdgeSegmentHandler.prototype.getTooltipForNode = function(node)\n{\n\treturn null;\n};\n\n/**\n * Function: createBends\n *\n * Adds custom bends for the center of each segment.\n */\nmxEdgeSegmentHandler.prototype.start = function(x, y, index)\n{\n\tmxEdgeHandler.prototype.start.apply(this, arguments);\n\n\tif (this.bends != null && this.bends[index] != null &&\n\t\t!this.isSource && !this.isTarget)\n\t{\n\t\tmxUtils.setOpacity(this.bends[index].node, 100);\n\t}\n};\n\n/**\n * Function: createBends\n *\n * Adds custom bends for the center of each segment.\n */\nmxEdgeSegmentHandler.prototype.createBends = function()\n{\n\tvar bends = [];\n\n\t// Source\n\tvar bend = this.createHandleShape(0);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\n\tvar pts = this.getCurrentPoints();\n\n\t// Waypoints (segment handles)\n\tif (this.graph.isCellBendable(this.state.cell))\n\t{\n\t\tif (this.points == null)\n\t\t{\n\t\t\tthis.points = [];\n\t\t}\n\n\t\tfor (var i = 0; i < pts.length - 1; i++)\n\t\t{\n\t\t\tbend = this.createVirtualBend();\n\t\t\tbends.push(bend);\n\t\t\tvar horizontal = Math.round(pts[i].x - pts[i + 1].x) == 0;\n\n\t\t\t// Special case where dy is 0 as well\n\t\t\tif (Math.round(pts[i].y - pts[i + 1].y) == 0 && i < pts.length - 2)\n\t\t\t{\n\t\t\t\thorizontal = Math.round(pts[i].x - pts[i + 2].x) == 0;\n\t\t\t}\n\n\t\t\tbend.setCursor((horizontal) ? 'col-resize' : 'row-resize');\n\t\t\tthis.points.push(new mxPoint(0,0));\n\t\t}\n\t}\n\n\t// Target\n\tvar bend = this.createHandleShape(pts.length);\n\tthis.initBend(bend);\n\tbend.setCursor(mxConstants.CURSOR_TERMINAL_HANDLE);\n\tbends.push(bend);\n\n\treturn bends;\n};\n\n/**\n * Function: redraw\n *\n * Overridden to invoke <refresh> before the redraw.\n */\nmxEdgeSegmentHandler.prototype.redraw = function()\n{\n\tthis.refresh();\n\tmxEdgeHandler.prototype.redraw.apply(this, arguments);\n};\n\n/**\n * Function: redrawInnerBends\n *\n * Updates the position of the custom bends.\n */\nmxEdgeSegmentHandler.prototype.redrawInnerBends = function(p0, pe)\n{\n\tif (this.graph.isCellBendable(this.state.cell))\n\t{\n\t\tvar pts = this.getCurrentPoints();\n\n\t\tif (pts != null && pts.length > 1)\n\t\t{\n\t\t\tvar straight = false;\n\n\t\t\t// Puts handle in the center of straight edges\n\t\t\tif (pts.length == 4 && Math.round(pts[1].x - pts[2].x) == 0 && Math.round(pts[1].y - pts[2].y) == 0)\n\t\t\t{\n\t\t\t\tstraight = true;\n\n\t\t\t\tif (Math.round(pts[0].y - pts[pts.length - 1].y) == 0)\n\t\t\t\t{\n\t\t\t\t\tvar cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n\t\t\t\t\tpts[1] = new mxPoint(cx, pts[1].y);\n\t\t\t\t\tpts[2] = new mxPoint(cx, pts[2].y);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n\t\t\t\t\tpts[1] = new mxPoint(pts[1].x, cy);\n\t\t\t\t\tpts[2] = new mxPoint(pts[2].x, cy);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < pts.length - 1; i++)\n\t\t\t{\n\t\t\t\tif (this.bends[i + 1] != null)\n\t\t\t\t{\n\t\t \t\t\tvar p0 = pts[i];\n\t \t\t\t\tvar pe = pts[i + 1];\n\t\t\t \t\tvar pt = new mxPoint(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n\t\t\t \t\tvar b = this.bends[i + 1].bounds;\n\t\t\t \t\tthis.bends[i + 1].bounds = new mxRectangle(Math.floor(pt.x - b.width / 2),\n\t\t\t \t\t\t\tMath.floor(pt.y - b.height / 2), b.width, b.height);\n\t\t\t\t \tthis.bends[i + 1].redraw();\n\n\t\t\t\t \tif (this.manageLabelHandle)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.checkLabelHandle(this.bends[i + 1].bounds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (straight)\n\t\t\t{\n\t\t\t\tmxUtils.setOpacity(this.bends[1].node, this.virtualBendOpacity);\n\t\t\t\tmxUtils.setOpacity(this.bends[3].node, this.virtualBendOpacity);\n\t\t\t}\n\t\t}\n\t}\n};\n\n__mxOutput.mxEdgeSegmentHandler = typeof mxEdgeSegmentHandler !== 'undefined' ? mxEdgeSegmentHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxKeyHandler\n *\n * Event handler that listens to keystroke events. This is not a singleton,\n * however, it is normally only required once if the target is the document\n * element (default).\n *\n * This handler installs a key event listener in the topmost DOM node and\n * processes all events that originate from descandants of <mxGraph.container>\n * or from the topmost DOM node. The latter means that all unhandled keystrokes\n * are handled by this object regardless of the focused state of the <graph>.\n *\n * Example:\n *\n * The following example creates a key handler that listens to the delete key\n * (46) and deletes the selection cells if the graph is enabled.\n *\n * (code)\n * var keyHandler = new mxKeyHandler(graph);\n * keyHandler.bindKey(46, function(evt)\n * {\n *   if (graph.isEnabled())\n *   {\n *     graph.removeCells();\n *   }\n * });\n * (end)\n *\n * Keycodes:\n *\n * See http://tinyurl.com/yp8jgl or http://tinyurl.com/229yqw for a list of\n * keycodes or install a key event listener into the document element and print\n * the key codes of the respective events to the console.\n *\n * To support the Command key and the Control key on the Mac, the following\n * code can be used.\n *\n * (code)\n * keyHandler.getFunction = function(evt)\n * {\n *   if (evt != null)\n *   {\n *     return (mxEvent.isControlDown(evt) || (mxClient.IS_MAC && evt.metaKey)) ? this.controlKeys[evt.keyCode] : this.normalKeys[evt.keyCode];\n *   }\n *\n *   return null;\n * };\n * (end)\n *\n * Constructor: mxKeyHandler\n *\n * Constructs an event handler that executes functions bound to specific\n * keystrokes.\n *\n * Parameters:\n *\n * graph - Reference to the associated <mxGraph>.\n * target - Optional reference to the event target. If null, the document\n * element is used as the event target, that is, the object where the key\n * event listener is installed.\n */\nfunction mxKeyHandler(graph, target)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.target = target || document.documentElement;\n\n\t\t// Creates the arrays to map from keycodes to functions\n\t\tthis.normalKeys = [];\n\t\tthis.shiftKeys = [];\n\t\tthis.controlKeys = [];\n\t\tthis.controlShiftKeys = [];\n\n\t\tthis.keydownHandler = mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.keyDown(evt);\n\t\t});\n\n\t\t// Installs the keystroke listener in the target\n\t\tmxEvent.addListener(this.target, 'keydown', this.keydownHandler);\n\n\t\t// Automatically deallocates memory in IE\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tmxEvent.addListener(window, 'unload',\n\t\t\t\tmxUtils.bind(this, function()\n\t\t\t\t{\n\t\t\t\t\tthis.destroy();\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Variable: graph\n *\n * Reference to the <mxGraph> associated with this handler.\n */\nmxKeyHandler.prototype.graph = null;\n\n/**\n * Variable: target\n *\n * Reference to the target DOM, that is, the DOM node where the key event\n * listeners are installed.\n */\nmxKeyHandler.prototype.target = null;\n\n/**\n * Variable: normalKeys\n *\n * Maps from keycodes to functions for non-pressed control keys.\n */\nmxKeyHandler.prototype.normalKeys = null;\n\n/**\n * Variable: shiftKeys\n *\n * Maps from keycodes to functions for pressed shift keys.\n */\nmxKeyHandler.prototype.shiftKeys = null;\n\n/**\n * Variable: controlKeys\n *\n * Maps from keycodes to functions for pressed control keys.\n */\nmxKeyHandler.prototype.controlKeys = null;\n\n/**\n * Variable: controlShiftKeys\n *\n * Maps from keycodes to functions for pressed control and shift keys.\n */\nmxKeyHandler.prototype.controlShiftKeys = null;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxKeyHandler.prototype.enabled = true;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation returns\n * <enabled>.\n */\nmxKeyHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling by updating <enabled>.\n *\n * Parameters:\n *\n * enabled - Boolean that specifies the new enabled state.\n */\nmxKeyHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: bindKey\n *\n * Binds the specified keycode to the given function. This binding is used\n * if the control key is not pressed.\n *\n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindKey = function(code, funct)\n{\n\tthis.normalKeys[code] = funct;\n};\n\n/**\n * Function: bindShiftKey\n *\n * Binds the specified keycode to the given function. This binding is used\n * if the shift key is pressed.\n *\n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindShiftKey = function(code, funct)\n{\n\tthis.shiftKeys[code] = funct;\n};\n\n/**\n * Function: bindControlKey\n *\n * Binds the specified keycode to the given function. This binding is used\n * if the control key is pressed.\n *\n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindControlKey = function(code, funct)\n{\n\tthis.controlKeys[code] = funct;\n};\n\n/**\n * Function: bindControlShiftKey\n *\n * Binds the specified keycode to the given function. This binding is used\n * if the control and shift key are pressed.\n *\n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * funct - JavaScript function that takes the key event as an argument.\n */\nmxKeyHandler.prototype.bindControlShiftKey = function(code, funct)\n{\n\tthis.controlShiftKeys[code] = funct;\n};\n\n/**\n * Function: isControlDown\n *\n * Returns true if the control key is pressed. This uses <mxEvent.isControlDown>.\n *\n * Parameters:\n *\n * evt - Key event whose control key pressed state should be returned.\n */\nmxKeyHandler.prototype.isControlDown = function(evt)\n{\n\treturn mxEvent.isControlDown(evt);\n};\n\n/**\n * Function: getFunction\n *\n * Returns the function associated with the given key event or null if no\n * function is associated with the given event.\n *\n * Parameters:\n *\n * evt - Key event whose associated function should be returned.\n */\nmxKeyHandler.prototype.getFunction = function(evt)\n{\n\tif (evt != null && !mxEvent.isAltDown(evt))\n\t{\n\t\tif (this.isControlDown(evt))\n\t\t{\n\t\t\tif (mxEvent.isShiftDown(evt))\n\t\t\t{\n\t\t\t\treturn this.controlShiftKeys[evt.keyCode];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.controlKeys[evt.keyCode];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxEvent.isShiftDown(evt))\n\t\t\t{\n\t\t\t\treturn this.shiftKeys[evt.keyCode];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn this.normalKeys[evt.keyCode];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: isGraphEvent\n *\n * Returns true if the event should be processed by this handler, that is,\n * if the event source is either the target, one of its direct children, a\n * descendant of the <mxGraph.container>, or the <mxGraph.cellEditor> of the\n * <graph>.\n *\n * Parameters:\n *\n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.isGraphEvent = function(evt)\n{\n\tvar source = mxEvent.getSource(evt);\n\n\t// Accepts events from the target object or\n\t// in-place editing inside graph\n\tif ((source == this.target || source.parentNode == this.target) ||\n\t\t(this.graph.cellEditor != null && this.graph.cellEditor.isEventSource(evt)))\n\t{\n\t\treturn true;\n\t}\n\n\t// Accepts events from inside the container\n\treturn mxUtils.isAncestorNode(this.graph.container, source);\n};\n\n/**\n * Function: keyDown\n *\n * Handles the event by invoking the function bound to the respective keystroke\n * if <isEnabledForEvent> returns true for the given event and if\n * <isEventIgnored> returns false, except for escape for which\n * <isEventIgnored> is not invoked.\n *\n * Parameters:\n *\n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.keyDown = function(evt)\n{\n\tif (this.isEnabledForEvent(evt))\n\t{\n\t\t// Cancels the editing if escape is pressed\n\t\tif (evt.keyCode == 27 /* Escape */)\n\t\t{\n\t\t\tthis.escape(evt);\n\t\t}\n\n\t\t// Invokes the function for the keystroke\n\t\telse if (!this.isEventIgnored(evt))\n\t\t{\n\t\t\tvar boundFunction = this.getFunction(evt);\n\n\t\t\tif (boundFunction != null)\n\t\t\t{\n\t\t\t\tboundFunction(evt);\n\t\t\t\tmxEvent.consume(evt);\n\t\t\t}\n\t\t}\n\t}\n};\n\n/**\n * Function: isEnabledForEvent\n *\n * Returns true if the given event should be handled. <isEventIgnored> is\n * called later if the event is not an escape key stroke, in which case\n * <escape> is called. This implementation returns true if <isEnabled>\n * returns true for both, this handler and <graph>, if the event is not\n * consumed and if <isGraphEvent> returns true.\n *\n * Parameters:\n *\n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.isEnabledForEvent = function(evt)\n{\n\treturn (this.graph.isEnabled() && !mxEvent.isConsumed(evt) &&\n\t\tthis.isGraphEvent(evt) && this.isEnabled());\n};\n\n/**\n * Function: isEventIgnored\n *\n * Returns true if the given keystroke should be ignored. This returns\n * graph.isEditing().\n *\n * Parameters:\n *\n * evt - Key event that represents the keystroke.\n */\nmxKeyHandler.prototype.isEventIgnored = function(evt)\n{\n\treturn this.graph.isEditing();\n};\n\n/**\n * Function: escape\n *\n * Hook to process ESCAPE keystrokes. This implementation invokes\n * <mxGraph.stopEditing> to cancel the current editing, connecting\n * and/or other ongoing modifications.\n *\n * Parameters:\n *\n * evt - Key event that represents the keystroke. Possible keycode in this\n * case is 27 (ESCAPE).\n */\nmxKeyHandler.prototype.escape = function(evt)\n{\n\tif (this.graph.isEscapeEnabled())\n\t{\n\t\tthis.graph.escape(evt);\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its references into the DOM. This does\n * normally not need to be called, it is called automatically when the\n * window unloads (in IE).\n */\nmxKeyHandler.prototype.destroy = function()\n{\n\tif (this.target != null && this.keydownHandler != null)\n\t{\n\t\tmxEvent.removeListener(this.target, 'keydown', this.keydownHandler);\n\t\tthis.keydownHandler = null;\n\t}\n\n\tthis.target = null;\n};\n\n__mxOutput.mxKeyHandler = typeof mxKeyHandler !== 'undefined' ? mxKeyHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxTooltipHandler\n *\n * Graph event handler that displays tooltips. <mxGraph.getTooltip> is used to\n * get the tooltip for a cell or handle. This handler is built-into\n * <mxGraph.tooltipHandler> and enabled using <mxGraph.setTooltips>.\n *\n * Example:\n *\n * (code>\n * new mxTooltipHandler(graph);\n * (end)\n *\n * Constructor: mxTooltipHandler\n *\n * Constructs an event handler that displays tooltips with the specified\n * delay (in milliseconds). If no delay is specified then a default delay\n * of 500 ms (0.5 sec) is used.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * delay - Optional delay in milliseconds.\n */\nfunction mxTooltipHandler(graph, delay)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.delay = delay || 500;\n\t\tthis.graph.addMouseListener(this);\n\t}\n};\n\n/**\n * Variable: zIndex\n *\n * Specifies the zIndex for the tooltip and its shadow. Default is 10005.\n */\nmxTooltipHandler.prototype.zIndex = 10005;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxTooltipHandler.prototype.graph = null;\n\n/**\n * Variable: delay\n *\n * Delay to show the tooltip in milliseconds. Default is 500.\n */\nmxTooltipHandler.prototype.delay = null;\n\n/**\n * Variable: ignoreTouchEvents\n *\n * Specifies if touch and pen events should be ignored. Default is true.\n */\nmxTooltipHandler.prototype.ignoreTouchEvents = true;\n\n/**\n * Variable: hideOnHover\n *\n * Specifies if the tooltip should be hidden if the mouse is moved over the\n * current cell. Default is false.\n */\nmxTooltipHandler.prototype.hideOnHover = false;\n\n/**\n * Variable: destroyed\n *\n * True if this handler was destroyed using <destroy>.\n */\nmxTooltipHandler.prototype.destroyed = false;\n\n/**\n * Variable: enabled\n *\n * Specifies if events are handled. Default is true.\n */\nmxTooltipHandler.prototype.enabled = true;\n\n/**\n * Function: isEnabled\n *\n * Returns true if events are handled. This implementation\n * returns <enabled>.\n */\nmxTooltipHandler.prototype.isEnabled = function()\n{\n\treturn this.enabled;\n};\n\n/**\n * Function: setEnabled\n *\n * Enables or disables event handling. This implementation\n * updates <enabled>.\n */\nmxTooltipHandler.prototype.setEnabled = function(enabled)\n{\n\tthis.enabled = enabled;\n};\n\n/**\n * Function: isHideOnHover\n *\n * Returns <hideOnHover>.\n */\nmxTooltipHandler.prototype.isHideOnHover = function()\n{\n\treturn this.hideOnHover;\n};\n\n/**\n * Function: setHideOnHover\n *\n * Sets <hideOnHover>.\n */\nmxTooltipHandler.prototype.setHideOnHover = function(value)\n{\n\tthis.hideOnHover = value;\n};\n\n/**\n * Function: init\n *\n * Initializes the DOM nodes required for this tooltip handler.\n */\nmxTooltipHandler.prototype.init = function()\n{\n\tif (document.body != null)\n\t{\n\t\tthis.div = document.createElement('div');\n\t\tthis.div.className = 'mxTooltip';\n\t\tthis.div.style.visibility = 'hidden';\n\n\t\tdocument.body.appendChild(this.div);\n\n\t\tmxEvent.addGestureListeners(this.div, mxUtils.bind(this, function(evt)\n\t\t{\n\t\t\tthis.hideTooltip();\n\t\t}));\n\t}\n};\n\n/**\n * Function: getStateForEvent\n *\n * Returns the <mxCellState> to be used for showing a tooltip for this event.\n */\nmxTooltipHandler.prototype.getStateForEvent = function(me)\n{\n\treturn me.getState();\n};\n\n/**\n * Function: mouseDown\n *\n * Handles the event by initiating a rubberband selection. By consuming the\n * event all subsequent events of the gesture are redirected to this\n * handler.\n */\nmxTooltipHandler.prototype.mouseDown = function(sender, me)\n{\n\tthis.reset(me, false);\n\tthis.hideTooltip();\n};\n\n/**\n * Function: mouseMove\n *\n * Handles the event by updating the rubberband selection.\n */\nmxTooltipHandler.prototype.mouseMove = function(sender, me)\n{\n\tif (me.getX() != this.lastX || me.getY() != this.lastY)\n\t{\n\t\tthis.reset(me, true);\n\t\tvar state = this.getStateForEvent(me);\n\n\t\tif (this.isHideOnHover() || state != this.state || (me.getSource() != this.node &&\n\t\t\t(!this.stateSource || (state != null && this.stateSource ==\n\t\t\t(me.isSource(state.shape) || !me.isSource(state.text))))))\n\t\t{\n\t\t\tthis.hideTooltip();\n\t\t}\n\t}\n\n\tthis.lastX = me.getX();\n\tthis.lastY = me.getY();\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by resetting the tooltip timer or hiding the existing\n * tooltip.\n */\nmxTooltipHandler.prototype.mouseUp = function(sender, me)\n{\n\tthis.reset(me, true);\n\tthis.hideTooltip();\n};\n\n\n/**\n * Function: resetTimer\n *\n * Resets the timer.\n */\nmxTooltipHandler.prototype.resetTimer = function()\n{\n\tif (this.thread != null)\n\t{\n\t\twindow.clearTimeout(this.thread);\n\t\tthis.thread = null;\n\t}\n};\n\n/**\n * Function: reset\n *\n * Resets and/or restarts the timer to trigger the display of the tooltip.\n */\nmxTooltipHandler.prototype.reset = function(me, restart, state)\n{\n\tif (!this.ignoreTouchEvents || mxEvent.isMouseEvent(me.getEvent()))\n\t{\n\t\tthis.resetTimer();\n\t\tstate = (state != null) ? state : this.getStateForEvent(me);\n\n\t\tif (restart && this.isEnabled() && state != null && (this.div == null ||\n\t\t\tthis.div.style.visibility == 'hidden'))\n\t\t{\n\t\t\tvar node = me.getSource();\n\t\t\tvar x = me.getX();\n\t\t\tvar y = me.getY();\n\t\t\tvar stateSource = me.isSource(state.shape) || me.isSource(state.text);\n\n\t\t\tthis.thread = window.setTimeout(mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tif (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown)\n\t\t\t\t{\n\t\t\t\t\t// Uses information from inside event cause using the event at\n\t\t\t\t\t// this (delayed) point in time is not possible in IE as it no\n\t\t\t\t\t// longer contains the required information (member not found)\n\t\t\t\t\tvar tip = this.graph.getTooltip(state, node, x, y);\n\t\t\t\t\tthis.show(tip, x, y);\n\t\t\t\t\tthis.state = state;\n\t\t\t\t\tthis.node = node;\n\t\t\t\t\tthis.stateSource = stateSource;\n\t\t\t\t}\n\t\t\t}), this.delay);\n\t\t}\n\t}\n};\n\n/**\n * Function: hide\n *\n * Hides the tooltip and resets the timer.\n */\nmxTooltipHandler.prototype.hide = function()\n{\n\tthis.resetTimer();\n\tthis.hideTooltip();\n};\n\n/**\n * Function: hideTooltip\n *\n * Hides the tooltip.\n */\nmxTooltipHandler.prototype.hideTooltip = function()\n{\n\tif (this.div != null)\n\t{\n\t\tthis.div.style.visibility = 'hidden';\n\t\tthis.div.innerHTML = '';\n\t}\n};\n\n/**\n * Function: show\n *\n * Shows the tooltip for the specified cell and optional index at the\n * specified location (with a vertical offset of 10 pixels).\n */\nmxTooltipHandler.prototype.show = function(tip, x, y)\n{\n\tif (!this.destroyed && tip != null && tip.length > 0)\n\t{\n\t\t// Initializes the DOM nodes if required\n\t\tif (this.div == null)\n\t\t{\n\t\t\tthis.init();\n\t\t}\n\n\t\tvar origin = mxUtils.getScrollOrigin();\n\n\t\tthis.div.style.zIndex = this.zIndex;\n\t\tthis.div.style.left = (x + origin.x) + 'px';\n\t\tthis.div.style.top = (y + mxConstants.TOOLTIP_VERTICAL_OFFSET +\n\t\t\torigin.y) + 'px';\n\n\t\tif (!mxUtils.isNode(tip))\n\t\t{\n\t\t\tthis.div.innerHTML = tip.replace(/\\n/g, '<br>');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.div.innerHTML = '';\n\t\t\tthis.div.appendChild(tip);\n\t\t}\n\n\t\tthis.div.style.visibility = '';\n\t\tmxUtils.fit(this.div);\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxTooltipHandler.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.graph.removeMouseListener(this);\n\t\tmxEvent.release(this.div);\n\n\t\tif (this.div != null && this.div.parentNode != null)\n\t\t{\n\t\t\tthis.div.parentNode.removeChild(this.div);\n\t\t}\n\n\t\tthis.destroyed = true;\n\t\tthis.div = null;\n\t}\n};\n\n__mxOutput.mxTooltipHandler = typeof mxTooltipHandler !== 'undefined' ? mxTooltipHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellTracker\n *\n * Event handler that highlights cells. Inherits from <mxCellMarker>.\n *\n * Example:\n *\n * (code)\n * new mxCellTracker(graph, '#00FF00');\n * (end)\n *\n * For detecting dragEnter, dragOver and dragLeave on cells, the following\n * code can be used:\n *\n * (code)\n * graph.addMouseListener(\n * {\n *   cell: null,\n *   mouseDown: function(sender, me) { },\n *   mouseMove: function(sender, me)\n *   {\n *     var tmp = me.getCell();\n *\n *     if (tmp != this.cell)\n *     {\n *       if (this.cell != null)\n *       {\n *         this.dragLeave(me.getEvent(), this.cell);\n *       }\n *\n *       this.cell = tmp;\n *\n *       if (this.cell != null)\n *       {\n *         this.dragEnter(me.getEvent(), this.cell);\n *       }\n *     }\n *\n *     if (this.cell != null)\n *     {\n *       this.dragOver(me.getEvent(), this.cell);\n *     }\n *   },\n *   mouseUp: function(sender, me) { },\n *   dragEnter: function(evt, cell)\n *   {\n *     mxLog.debug('dragEnter', cell.value);\n *   },\n *   dragOver: function(evt, cell)\n *   {\n *     mxLog.debug('dragOver', cell.value);\n *   },\n *   dragLeave: function(evt, cell)\n *   {\n *     mxLog.debug('dragLeave', cell.value);\n *   }\n * });\n * (end)\n *\n * Constructor: mxCellTracker\n *\n * Constructs an event handler that highlights cells.\n *\n * Parameters:\n *\n * graph - Reference to the enclosing <mxGraph>.\n * color - Color of the highlight. Default is blue.\n * funct - Optional JavaScript function that is used to override\n * <mxCellMarker.getCell>.\n */\nfunction mxCellTracker(graph, color, funct)\n{\n\tmxCellMarker.call(this, graph, color);\n\n\tthis.graph.addMouseListener(this);\n\n\tif (funct != null)\n\t{\n\t\tthis.getCell = funct;\n\t}\n\n\t// Automatic deallocation of memory\n\tif (mxClient.IS_IE)\n\t{\n\t\tmxEvent.addListener(window, 'unload', mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.destroy();\n\t\t}));\n\t}\n};\n\n/**\n * Extends mxCellMarker.\n */\nmxUtils.extend(mxCellTracker, mxCellMarker);\n\n/**\n * Function: mouseDown\n *\n * Ignores the event. The event is not consumed.\n */\nmxCellTracker.prototype.mouseDown = function(sender, me) { };\n\n/**\n * Function: mouseMove\n *\n * Handles the event by highlighting the cell under the mousepointer if it\n * is over the hotspot region of the cell.\n */\nmxCellTracker.prototype.mouseMove = function(sender, me)\n{\n\tif (this.isEnabled())\n\t{\n\t\tthis.process(me);\n\t}\n};\n\n/**\n * Function: mouseUp\n *\n * Handles the event by reseting the highlight.\n */\nmxCellTracker.prototype.mouseUp = function(sender, me) { };\n\n/**\n * Function: destroy\n *\n * Destroys the object and all its resources and DOM nodes. This doesn't\n * normally need to be called. It is called automatically when the window\n * unloads.\n */\nmxCellTracker.prototype.destroy = function()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\n\t\tthis.graph.removeMouseListener(this);\n\t\tmxCellMarker.prototype.destroy.apply(this);\n\t}\n};\n\n__mxOutput.mxCellTracker = typeof mxCellTracker !== 'undefined' ? mxCellTracker : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCellHighlight\n *\n * A helper class to highlight cells. Here is an example for a given cell.\n *\n * (code)\n * var highlight = new mxCellHighlight(graph, '#ff0000', 2);\n * highlight.highlight(graph.view.getState(cell)));\n * (end)\n *\n * Constructor: mxCellHighlight\n *\n * Constructs a cell highlight.\n */\nfunction mxCellHighlight(graph, highlightColor, strokeWidth, dashed)\n{\n\tif (graph != null)\n\t{\n\t\tthis.graph = graph;\n\t\tthis.highlightColor = (highlightColor != null) ? highlightColor : mxConstants.DEFAULT_VALID_COLOR;\n\t\tthis.strokeWidth = (strokeWidth != null) ? strokeWidth : mxConstants.HIGHLIGHT_STROKEWIDTH;\n\t\tthis.dashed = (dashed != null) ? dashed : false;\n\t\tthis.opacity = mxConstants.HIGHLIGHT_OPACITY;\n\n\t\t// Updates the marker if the graph changes\n\t\tthis.repaintHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\t// Updates reference to state\n\t\t\tif (this.state != null)\n\t\t\t{\n\t\t\t\tvar tmp = this.graph.view.getState(this.state.cell);\n\n\t\t\t\tif (tmp == null)\n\t\t\t\t{\n\t\t\t\t\tthis.hide();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.state = tmp;\n\t\t\t\t\tthis.repaint();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.graph.getView().addListener(mxEvent.SCALE, this.repaintHandler);\n\t\tthis.graph.getView().addListener(mxEvent.TRANSLATE, this.repaintHandler);\n\t\tthis.graph.getView().addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);\n\t\tthis.graph.getModel().addListener(mxEvent.CHANGE, this.repaintHandler);\n\n\t\t// Hides the marker if the current root changes\n\t\tthis.resetHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.hide();\n\t\t});\n\n\t\tthis.graph.getView().addListener(mxEvent.DOWN, this.resetHandler);\n\t\tthis.graph.getView().addListener(mxEvent.UP, this.resetHandler);\n\t}\n};\n\n/**\n * Variable: keepOnTop\n *\n * Specifies if the highlights should appear on top of everything\n * else in the overlay pane. Default is false.\n */\nmxCellHighlight.prototype.keepOnTop = false;\n\n/**\n * Variable: graph\n *\n * Reference to the enclosing <mxGraph>.\n */\nmxCellHighlight.prototype.graph = true;\n\n/**\n * Variable: state\n *\n * Reference to the <mxCellState>.\n */\nmxCellHighlight.prototype.state = null;\n\n/**\n * Variable: spacing\n *\n * Specifies the spacing between the highlight for vertices and the vertex.\n * Default is 2.\n */\nmxCellHighlight.prototype.spacing = 2;\n\n/**\n * Variable: resetHandler\n *\n * Holds the handler that automatically invokes reset if the highlight\n * should be hidden.\n */\nmxCellHighlight.prototype.resetHandler = null;\n\n/**\n * Function: setHighlightColor\n *\n * Sets the color of the rectangle used to highlight drop targets.\n *\n * Parameters:\n *\n * color - String that represents the new highlight color.\n */\nmxCellHighlight.prototype.setHighlightColor = function(color)\n{\n\tthis.highlightColor = color;\n\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.stroke = color;\n\t}\n};\n\n/**\n * Function: drawHighlight\n *\n * Creates and returns the highlight shape for the given state.\n */\nmxCellHighlight.prototype.drawHighlight = function()\n{\n\tthis.shape = this.createShape();\n\tthis.repaint();\n\n\tif (!this.keepOnTop && this.shape.node.parentNode.firstChild != this.shape.node)\n\t{\n\t\tthis.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);\n\t}\n};\n\n/**\n * Function: createShape\n *\n * Creates and returns the highlight shape for the given state.\n */\nmxCellHighlight.prototype.createShape = function()\n{\n\tvar shape = this.graph.cellRenderer.createShape(this.state);\n\n\tshape.svgStrokeTolerance = this.graph.tolerance;\n\tshape.points = this.state.absolutePoints;\n\tshape.apply(this.state);\n\tshape.stroke = this.highlightColor;\n\tshape.opacity = this.opacity;\n\tshape.isDashed = this.dashed;\n\tshape.isShadow = false;\n\n\tshape.dialect = (this.graph.dialect != mxConstants.DIALECT_SVG) ? mxConstants.DIALECT_VML : mxConstants.DIALECT_SVG;\n\tshape.init(this.graph.getView().getOverlayPane());\n\tmxEvent.redirectMouseEvents(shape.node, this.graph, this.state);\n\n\tif (this.graph.dialect != mxConstants.DIALECT_SVG)\n\t{\n\t\tshape.pointerEvents = false;\n\t}\n\telse\n\t{\n\t\tshape.svgPointerEvents = 'stroke';\n\t}\n\n\treturn shape;\n};\n\n/**\n * Function: repaint\n *\n * Updates the highlight after a change of the model or view.\n */\nmxCellHighlight.prototype.getStrokeWidth = function(state)\n{\n\treturn this.strokeWidth;\n};\n\n/**\n * Function: repaint\n *\n * Updates the highlight after a change of the model or view.\n */\nmxCellHighlight.prototype.repaint = function()\n{\n\tif (this.state != null && this.shape != null)\n\t{\n\t\tthis.shape.scale = this.state.view.scale;\n\n\t\tif (this.graph.model.isEdge(this.state.cell))\n\t\t{\n\t\t\tthis.shape.strokewidth = this.getStrokeWidth();\n\t\t\tthis.shape.points = this.state.absolutePoints;\n\t\t\tthis.shape.outline = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.shape.bounds = new mxRectangle(this.state.x - this.spacing, this.state.y - this.spacing,\n\t\t\t\t\tthis.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);\n\t\t\tthis.shape.rotation = Number(this.state.style[mxConstants.STYLE_ROTATION] || '0');\n\t\t\tthis.shape.strokewidth = this.getStrokeWidth() / this.state.view.scale;\n\t\t\tthis.shape.outline = true;\n\t\t}\n\n\t\t// Uses cursor from shape in highlight\n\t\tif (this.state.shape != null)\n\t\t{\n\t\t\tthis.shape.setCursor(this.state.shape.getCursor());\n\t\t}\n\n\t\t// Workaround for event transparency in VML with transparent color\n\t\t// is to use a non-transparent color with near zero opacity\n\t\tif (mxClient.IS_QUIRKS || document.documentMode == 8)\n\t\t{\n\t\t\tif (this.shape.stroke == 'transparent')\n\t\t\t{\n\t\t\t\t// KNOWN: Quirks mode does not seem to catch events if\n\t\t\t\t// we do not force an update of the DOM via a change such\n\t\t\t\t// as mxLog.debug. Since IE6 is EOL we do not add a fix.\n\t\t\t\tthis.shape.stroke = 'white';\n\t\t\t\tthis.shape.opacity = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.shape.opacity = this.opacity;\n\t\t\t}\n\t\t}\n\n\t\tthis.shape.redraw();\n\t}\n};\n\n/**\n * Function: hide\n *\n * Resets the state of the cell marker.\n */\nmxCellHighlight.prototype.hide = function()\n{\n\tthis.highlight(null);\n};\n\n/**\n * Function: mark\n *\n * Marks the <markedState> and fires a <mark> event.\n */\nmxCellHighlight.prototype.highlight = function(state)\n{\n\tif (this.state != state)\n\t{\n\t\tif (this.shape != null)\n\t\t{\n\t\t\tthis.shape.destroy();\n\t\t\tthis.shape = null;\n\t\t}\n\n\t\tthis.state = state;\n\n\t\tif (this.state != null)\n\t\t{\n\t\t\tthis.drawHighlight();\n\t\t}\n\t}\n};\n\n/**\n * Function: isHighlightAt\n *\n * Returns true if this highlight is at the given position.\n */\nmxCellHighlight.prototype.isHighlightAt = function(x, y)\n{\n\tvar hit = false;\n\n\t// Quirks mode is currently not supported as it used a different coordinate system\n\tif (this.shape != null && document.elementFromPoint != null && !mxClient.IS_QUIRKS)\n\t{\n\t\tvar elt = document.elementFromPoint(x, y);\n\n\t\twhile (elt != null)\n\t\t{\n\t\t\tif (elt == this.shape.node)\n\t\t\t{\n\t\t\t\thit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telt = elt.parentNode;\n\t\t}\n\t}\n\n\treturn hit;\n};\n\n/**\n * Function: destroy\n *\n * Destroys the handler and all its resources and DOM nodes.\n */\nmxCellHighlight.prototype.destroy = function()\n{\n\tthis.graph.getView().removeListener(this.resetHandler);\n\tthis.graph.getView().removeListener(this.repaintHandler);\n\tthis.graph.getModel().removeListener(this.repaintHandler);\n\n\tif (this.shape != null)\n\t{\n\t\tthis.shape.destroy();\n\t\tthis.shape = null;\n\t}\n};\n\n__mxOutput.mxCellHighlight = typeof mxCellHighlight !== 'undefined' ? mxCellHighlight : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultKeyHandler\n *\n * Binds keycodes to actionnames in an editor. This aggregates an internal\n * <handler> and extends the implementation of <mxKeyHandler.escape> to not\n * only cancel the editing, but also hide the properties dialog and fire an\n * <mxEditor.escape> event via <editor>. An instance of this class is created\n * by <mxEditor> and stored in <mxEditor.keyHandler>.\n *\n * Example:\n *\n * Bind the delete key to the delete action in an existing editor.\n *\n * (code)\n * var keyHandler = new mxDefaultKeyHandler(editor);\n * keyHandler.bindAction(46, 'delete');\n * (end)\n *\n * Codec:\n *\n * This class uses the <mxDefaultKeyHandlerCodec> to read configuration\n * data into an existing instance. See <mxDefaultKeyHandlerCodec> for a\n * description of the configuration format.\n *\n * Keycodes:\n *\n * See <mxKeyHandler>.\n *\n * An <mxEvent.ESCAPE> event is fired via the editor if the escape key is\n * pressed.\n *\n * Constructor: mxDefaultKeyHandler\n *\n * Constructs a new default key handler for the <mxEditor.graph> in the\n * given <mxEditor>. (The editor may be null if a prototypical instance for\n * a <mxDefaultKeyHandlerCodec> is created.)\n *\n * Parameters:\n *\n * editor - Reference to the enclosing <mxEditor>.\n */\nfunction mxDefaultKeyHandler(editor)\n{\n\tif (editor != null)\n\t{\n\t\tthis.editor = editor;\n\t\tthis.handler = new mxKeyHandler(editor.graph);\n\n\t\t// Extends the escape function of the internal key\n\t\t// handle to hide the properties dialog and fire\n\t\t// the escape event via the editor instance\n\t\tvar old = this.handler.escape;\n\n\t\tthis.handler.escape = function(evt)\n\t\t{\n\t\t\told.apply(this, arguments);\n\t\t\teditor.hideProperties();\n\t\t\teditor.fireEvent(new mxEventObject(mxEvent.ESCAPE, 'event', evt));\n\t\t};\n\t}\n};\n\n/**\n * Variable: editor\n *\n * Reference to the enclosing <mxEditor>.\n */\nmxDefaultKeyHandler.prototype.editor = null;\n\n/**\n * Variable: handler\n *\n * Holds the <mxKeyHandler> for key event handling.\n */\nmxDefaultKeyHandler.prototype.handler = null;\n\n/**\n * Function: bindAction\n *\n * Binds the specified keycode to the given action in <editor>. The\n * optional control flag specifies if the control key must be pressed\n * to trigger the action.\n *\n * Parameters:\n *\n * code - Integer that specifies the keycode.\n * action - Name of the action to execute in <editor>.\n * control - Optional boolean that specifies if control must be pressed.\n * Default is false.\n */\nmxDefaultKeyHandler.prototype.bindAction = function (code, action, control)\n{\n\tvar keyHandler = mxUtils.bind(this, function()\n\t{\n\t\tthis.editor.execute(action);\n\t});\n\n\t// Binds the function to control-down keycode\n\tif (control)\n\t{\n\t\tthis.handler.bindControlKey(code, keyHandler);\n\t}\n\n\t// Binds the function to the normal keycode\n\telse\n\t{\n\t\tthis.handler.bindKey(code, keyHandler);\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the <handler> associated with this object. This does normally\n * not need to be called, the <handler> is destroyed automatically when the\n * window unloads (in IE) by <mxEditor>.\n */\nmxDefaultKeyHandler.prototype.destroy = function ()\n{\n\tthis.handler.destroy();\n\tthis.handler = null;\n};\n\n__mxOutput.mxDefaultKeyHandler = typeof mxDefaultKeyHandler !== 'undefined' ? mxDefaultKeyHandler : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultPopupMenu\n *\n * Creates popupmenus for mouse events. This object holds an XML node\n * which is a description of the popup menu to be created. In\n * <createMenu>, the configuration is applied to the context and\n * the resulting menu items are added to the menu dynamically. See\n * <createMenu> for a description of the configuration format.\n *\n * This class does not create the DOM nodes required for the popup menu, it\n * only parses an XML description to invoke the respective methods on an\n * <mxPopupMenu> each time the menu is displayed.\n *\n * Codec:\n *\n * This class uses the <mxDefaultPopupMenuCodec> to read configuration\n * data into an existing instance, however, the actual parsing is done\n * by this class during program execution, so the format is described\n * below.\n *\n * Constructor: mxDefaultPopupMenu\n *\n * Constructs a new popupmenu-factory based on given configuration.\n *\n * Paramaters:\n *\n * config - XML node that contains the configuration data.\n */\nfunction mxDefaultPopupMenu(config)\n{\n\tthis.config = config;\n};\n\n/**\n * Variable: imageBasePath\n *\n * Base path for all icon attributes in the config. Default is null.\n */\nmxDefaultPopupMenu.prototype.imageBasePath = null;\n\n/**\n * Variable: config\n *\n * XML node used as the description of new menu items. This node is\n * used in <createMenu> to dynamically create the menu items if their\n * respective conditions evaluate to true for the given arguments.\n */\nmxDefaultPopupMenu.prototype.config = null;\n\n/**\n * Function: createMenu\n *\n * This function is called from <mxEditor> to add items to the\n * given menu based on <config>. The config is a sequence of\n * the following nodes and attributes.\n *\n * Child Nodes:\n *\n * add - Adds a new menu item. See below for attributes.\n * separator - Adds a separator. No attributes.\n * condition - Adds a custom condition. Name attribute.\n *\n * The add-node may have a child node that defines a function to be invoked\n * before the action is executed (or instead of an action to be executed).\n *\n * Attributes:\n *\n * as - Resource key for the label (needs entry in property file).\n * action - Name of the action to execute in enclosing editor.\n * icon - Optional icon (relative/absolute URL).\n * iconCls - Optional CSS class for the icon.\n * if - Optional name of condition that must be true (see below).\n * enabled-if - Optional name of condition that specifies if the menu item\n * should be enabled.\n * name - Name of custom condition. Only for condition nodes.\n *\n * Conditions:\n *\n * nocell - No cell under the mouse.\n * ncells - More than one cell selected.\n * notRoot - Drilling position is other than home.\n * cell - Cell under the mouse.\n * notEmpty - Exactly one cell with children under mouse.\n * expandable - Exactly one expandable cell under mouse.\n * collapsable - Exactly one collapsable cell under mouse.\n * validRoot - Exactly one cell which is a possible root under mouse.\n * swimlane - Exactly one cell which is a swimlane under mouse.\n *\n * Example:\n *\n * To add a new item for a given action to the popupmenu:\n *\n * (code)\n * <mxDefaultPopupMenu as=\"popupHandler\">\n *   <add as=\"delete\" action=\"delete\" icon=\"images/delete.gif\" if=\"cell\"/>\n * </mxDefaultPopupMenu>\n * (end)\n *\n * To add a new item for a custom function:\n *\n * (code)\n * <mxDefaultPopupMenu as=\"popupHandler\">\n *   <add as=\"action1\"><![CDATA[\n *\t\tfunction (editor, cell, evt)\n *\t\t{\n *\t\t\teditor.execute('action1', cell, 'myArg');\n *\t\t}\n *   ]]></add>\n * </mxDefaultPopupMenu>\n * (end)\n *\n * The above example invokes action1 with an additional third argument via\n * the editor instance. The third argument is passed to the function that\n * defines action1. If the add-node has no action-attribute, then only the\n * function defined in the text content is executed, otherwise first the\n * function and then the action defined in the action-attribute is\n * executed. The function in the text content has 3 arguments, namely the\n * <mxEditor> instance, the <mxCell> instance under the mouse, and the\n * native mouse event.\n *\n * Custom Conditions:\n *\n * To add a new condition for popupmenu items:\n *\n * (code)\n * <condition name=\"condition1\"><![CDATA[\n *   function (editor, cell, evt)\n *   {\n *     return cell != null;\n *   }\n * ]]></condition>\n * (end)\n *\n * The new condition can then be used in any item as follows:\n *\n * (code)\n * <add as=\"action1\" action=\"action1\" icon=\"action1.gif\" if=\"condition1\"/>\n * (end)\n *\n * The order in which the items and conditions appear is not significant as\n * all connditions are evaluated before any items are created.\n *\n * Parameters:\n *\n * editor - Enclosing <mxEditor> instance.\n * menu - <mxPopupMenu> that is used for adding items and separators.\n * cell - Optional <mxCell> which is under the mousepointer.\n * evt - Optional mouse event which triggered the menu.\n */\nmxDefaultPopupMenu.prototype.createMenu = function(editor, menu, cell, evt)\n{\n\tif (this.config != null)\n\t{\n\t\tvar conditions = this.createConditions(editor, cell, evt);\n\t\tvar item = this.config.firstChild;\n\n\t\tthis.addItems(editor, menu, cell, evt, conditions, item, null);\n\t}\n};\n\n/**\n * Function: addItems\n *\n * Recursively adds the given items and all of its children into the given menu.\n *\n * Parameters:\n *\n * editor - Enclosing <mxEditor> instance.\n * menu - <mxPopupMenu> that is used for adding items and separators.\n * cell - Optional <mxCell> which is under the mousepointer.\n * evt - Optional mouse event which triggered the menu.\n * conditions - Array of names boolean conditions.\n * item - XML node that represents the current menu item.\n * parent - DOM node that represents the parent menu item.\n */\nmxDefaultPopupMenu.prototype.addItems = function(editor, menu, cell, evt, conditions, item, parent)\n{\n\tvar addSeparator = false;\n\n\twhile (item != null)\n\t{\n\t\tif (item.nodeName == 'add')\n\t\t{\n\t\t\tvar condition = item.getAttribute('if');\n\n\t\t\tif (condition == null || conditions[condition])\n\t\t\t{\n\t\t\t\tvar as = item.getAttribute('as');\n\t\t\t\tas = mxResources.get(as) || as;\n\t\t\t\tvar funct = mxUtils.eval(mxUtils.getTextContent(item));\n\t\t\t\tvar action = item.getAttribute('action');\n\t\t\t\tvar icon = item.getAttribute('icon');\n\t\t\t\tvar iconCls = item.getAttribute('iconCls');\n\t\t\t\tvar enabledCond = item.getAttribute('enabled-if');\n\t\t\t\tvar enabled = enabledCond == null || conditions[enabledCond];\n\n\t\t\t\tif (addSeparator)\n\t\t\t\t{\n\t\t\t\t\tmenu.addSeparator(parent);\n\t\t\t\t\taddSeparator = false;\n\t\t\t\t}\n\n\t\t\t\tif (icon != null && this.imageBasePath)\n\t\t\t\t{\n\t\t\t\t\ticon = this.imageBasePath + icon;\n\t\t\t\t}\n\n\t\t\t\tvar row = this.addAction(menu, editor, as, icon, funct, action, cell, parent, iconCls, enabled);\n\t\t\t\tthis.addItems(editor, menu, cell, evt, conditions, item.firstChild, row);\n\t\t\t}\n\t\t}\n\t\telse if (item.nodeName == 'separator')\n\t\t{\n\t\t\taddSeparator = true;\n\t\t}\n\n\t\titem = item.nextSibling;\n\t}\n};\n\n/**\n * Function: addAction\n *\n * Helper method to bind an action to a new menu item.\n *\n * Parameters:\n *\n * menu - <mxPopupMenu> that is used for adding items and separators.\n * editor - Enclosing <mxEditor> instance.\n * lab - String that represents the label of the menu item.\n * icon - Optional URL that represents the icon of the menu item.\n * action - Optional name of the action to execute in the given editor.\n * funct - Optional function to execute before the optional action. The\n * function takes an <mxEditor>, the <mxCell> under the mouse and the\n * mouse event that triggered the call.\n * cell - Optional <mxCell> to use as an argument for the action.\n * parent - DOM node that represents the parent menu item.\n * iconCls - Optional CSS class for the menu icon.\n * enabled - Optional boolean that specifies if the menu item is enabled.\n * Default is true.\n */\nmxDefaultPopupMenu.prototype.addAction = function(menu, editor, lab, icon, funct, action, cell, parent, iconCls, enabled)\n{\n\tvar clickHandler = function(evt)\n\t{\n\t\tif (typeof(funct) == 'function')\n\t\t{\n\t\t\tfunct.call(editor, editor, cell, evt);\n\t\t}\n\n\t\tif (action != null)\n\t\t{\n\t\t\teditor.execute(action, cell, evt);\n\t\t}\n\t};\n\n\treturn menu.addItem(lab, icon, clickHandler, parent, iconCls, enabled);\n};\n\n/**\n * Function: createConditions\n *\n * Evaluates the default conditions for the given context.\n */\nmxDefaultPopupMenu.prototype.createConditions = function(editor, cell, evt)\n{\n\t// Creates array with conditions\n\tvar model = editor.graph.getModel();\n\tvar childCount = model.getChildCount(cell);\n\n\t// Adds some frequently used conditions\n\tvar conditions = [];\n\tconditions['nocell'] = cell == null;\n\tconditions['ncells'] = editor.graph.getSelectionCount() > 1;\n\tconditions['notRoot'] = model.getRoot() !=\n\t\tmodel.getParent(editor.graph.getDefaultParent());\n\tconditions['cell'] = cell != null;\n\n\tvar isCell = cell != null && editor.graph.getSelectionCount() == 1;\n\tconditions['nonEmpty'] = isCell && childCount > 0;\n\tconditions['expandable'] = isCell && editor.graph.isCellFoldable(cell, false);\n\tconditions['collapsable'] = isCell && editor.graph.isCellFoldable(cell, true);\n\tconditions['validRoot'] = isCell && editor.graph.isValidRoot(cell);\n\tconditions['emptyValidRoot'] = conditions['validRoot'] && childCount == 0;\n\tconditions['swimlane'] = isCell && editor.graph.isSwimlane(cell);\n\n\t// Evaluates dynamic conditions from config file\n\tvar condNodes = this.config.getElementsByTagName('condition');\n\n\tfor (var i=0; i<condNodes.length; i++)\n\t{\n\t\tvar funct = mxUtils.eval(mxUtils.getTextContent(condNodes[i]));\n\t\tvar name = condNodes[i].getAttribute('name');\n\n\t\tif (name != null && typeof(funct) == 'function')\n\t\t{\n\t\t\tconditions[name] = funct(editor, cell, evt);\n\t\t}\n\t}\n\n\treturn conditions;\n};\n\n__mxOutput.mxDefaultPopupMenu = typeof mxDefaultPopupMenu !== 'undefined' ? mxDefaultPopupMenu : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultToolbar\n *\n * Toolbar for the editor. This modifies the state of the graph\n * or inserts new cells upon mouse clicks.\n *\n * Example:\n *\n * Create a toolbar with a button to copy the selection into the clipboard,\n * and a combo box with one action to paste the selection from the clipboard\n * into the graph.\n *\n * (code)\n * var toolbar = new mxDefaultToolbar(container, editor);\n * toolbar.addItem('Copy', null, 'copy');\n *\n * var combo = toolbar.addActionCombo('More actions...');\n * toolbar.addActionOption(combo, 'Paste', 'paste');\n * (end)\n *\n * Codec:\n *\n * This class uses the <mxDefaultToolbarCodec> to read configuration\n * data into an existing instance. See <mxDefaultToolbarCodec> for a\n * description of the configuration format.\n *\n * Constructor: mxDefaultToolbar\n *\n * Constructs a new toolbar for the given container and editor. The\n * container and editor may be null if a prototypical instance for a\n * <mxDefaultKeyHandlerCodec> is created.\n *\n * Parameters:\n *\n * container - DOM node that contains the toolbar.\n * editor - Reference to the enclosing <mxEditor>.\n */\nfunction mxDefaultToolbar(container, editor)\n{\n\tthis.editor = editor;\n\n\tif (container != null && editor != null)\n\t{\n\t\tthis.init(container);\n\t}\n};\n\n/**\n * Variable: editor\n *\n * Reference to the enclosing <mxEditor>.\n */\nmxDefaultToolbar.prototype.editor = null;\n\n/**\n * Variable: toolbar\n *\n * Holds the internal <mxToolbar>.\n */\nmxDefaultToolbar.prototype.toolbar = null;\n\n/**\n * Variable: resetHandler\n *\n * Reference to the function used to reset the <toolbar>.\n */\nmxDefaultToolbar.prototype.resetHandler = null;\n\n/**\n * Variable: spacing\n *\n * Defines the spacing between existing and new vertices in\n * gridSize units when a new vertex is dropped on an existing\n * cell. Default is 4 (40 pixels).\n */\nmxDefaultToolbar.prototype.spacing = 4;\n\n/**\n * Variable: connectOnDrop\n *\n * Specifies if elements should be connected if new cells are dropped onto\n * connectable elements. Default is false.\n */\nmxDefaultToolbar.prototype.connectOnDrop = false;\n\n/**\n * Variable: init\n *\n * Constructs the <toolbar> for the given container and installs a listener\n * that updates the <mxEditor.insertFunction> on <editor> if an item is\n * selected in the toolbar. This assumes that <editor> is not null.\n *\n * Parameters:\n *\n * container - DOM node that contains the toolbar.\n */\nmxDefaultToolbar.prototype.init = function(container)\n{\n\tif (container != null)\n\t{\n\t\tthis.toolbar = new mxToolbar(container);\n\n\t\t// Installs the insert function in the editor if an item is\n\t\t// selected in the toolbar\n\t\tthis.toolbar.addListener(mxEvent.SELECT, mxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar funct = evt.getProperty('function');\n\n\t\t\tif (funct != null)\n\t\t\t{\n\t\t\t\tthis.editor.insertFunction = mxUtils.bind(this, function()\n\t\t\t\t{\n\t\t\t\t\tfunct.apply(this, arguments);\n\t\t\t\t\tthis.toolbar.resetMode();\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.editor.insertFunction = null;\n\t\t\t}\n\t\t}));\n\n\t\t// Resets the selected tool after a doubleclick or escape keystroke\n\t\tthis.resetHandler = mxUtils.bind(this, function()\n\t\t{\n\t\t\tif (this.toolbar != null)\n\t\t\t{\n\t\t\t\tthis.toolbar.resetMode(true);\n\t\t\t}\n\t\t});\n\n\t\tthis.editor.graph.addListener(mxEvent.DOUBLE_CLICK, this.resetHandler);\n\t\tthis.editor.addListener(mxEvent.ESCAPE, this.resetHandler);\n\t}\n};\n\n/**\n * Function: addItem\n *\n * Adds a new item that executes the given action in <editor>. The title,\n * icon and pressedIcon are used to display the toolbar item.\n *\n * Parameters:\n *\n * title - String that represents the title (tooltip) for the item.\n * icon - URL of the icon to be used for displaying the item.\n * action - Name of the action to execute when the item is clicked.\n * pressed - Optional URL of the icon for the pressed state.\n */\nmxDefaultToolbar.prototype.addItem = function(title, icon, action, pressed)\n{\n\tvar clickHandler = mxUtils.bind(this, function()\n\t{\n\t\tif (action != null && action.length > 0)\n\t\t{\n\t\t\tthis.editor.execute(action);\n\t\t}\n\t});\n\n\treturn this.toolbar.addItem(title, icon, clickHandler, pressed);\n};\n\n/**\n * Function: addSeparator\n *\n * Adds a vertical separator using the optional icon.\n *\n * Parameters:\n *\n * icon - Optional URL of the icon that represents the vertical separator.\n * Default is <mxClient.imageBasePath> + '/separator.gif'.\n */\nmxDefaultToolbar.prototype.addSeparator = function(icon)\n{\n\ticon = icon || mxClient.imageBasePath + '/separator.gif';\n\tthis.toolbar.addSeparator(icon);\n};\n\n/**\n * Function: addCombo\n *\n * Helper method to invoke <mxToolbar.addCombo> on <toolbar> and return the\n * resulting DOM node.\n */\nmxDefaultToolbar.prototype.addCombo = function()\n{\n\treturn this.toolbar.addCombo();\n};\n\n/**\n * Function: addActionCombo\n *\n * Helper method to invoke <mxToolbar.addActionCombo> on <toolbar> using\n * the given title and return the resulting DOM node.\n *\n * Parameters:\n *\n * title - String that represents the title of the combo.\n */\nmxDefaultToolbar.prototype.addActionCombo = function(title)\n{\n\treturn this.toolbar.addActionCombo(title);\n};\n\n/**\n * Function: addActionOption\n *\n * Binds the given action to a option with the specified label in the\n * given combo. Combo is an object returned from an earlier call to\n * <addCombo> or <addActionCombo>.\n *\n * Parameters:\n *\n * combo - DOM node that represents the combo box.\n * title - String that represents the title of the combo.\n * action - Name of the action to execute in <editor>.\n */\nmxDefaultToolbar.prototype.addActionOption = function(combo, title, action)\n{\n\tvar clickHandler = mxUtils.bind(this, function()\n\t{\n\t\tthis.editor.execute(action);\n\t});\n\n\tthis.addOption(combo, title, clickHandler);\n};\n\n/**\n * Function: addOption\n *\n * Helper method to invoke <mxToolbar.addOption> on <toolbar> and return\n * the resulting DOM node that represents the option.\n *\n * Parameters:\n *\n * combo - DOM node that represents the combo box.\n * title - String that represents the title of the combo.\n * value - Object that represents the value of the option.\n */\nmxDefaultToolbar.prototype.addOption = function(combo, title, value)\n{\n\treturn this.toolbar.addOption(combo, title, value);\n};\n\n/**\n * Function: addMode\n *\n * Creates an item for selecting the given mode in the <editor>'s graph.\n * Supported modenames are select, connect and pan.\n *\n * Parameters:\n *\n * title - String that represents the title of the item.\n * icon - URL of the icon that represents the item.\n * mode - String that represents the mode name to be used in\n * <mxEditor.setMode>.\n * pressed - Optional URL of the icon that represents the pressed state.\n * funct - Optional JavaScript function that takes the <mxEditor> as the\n * first and only argument that is executed after the mode has been\n * selected.\n */\nmxDefaultToolbar.prototype.addMode = function(title, icon, mode, pressed, funct)\n{\n\tvar clickHandler = mxUtils.bind(this, function()\n\t{\n\t\tthis.editor.setMode(mode);\n\n\t\tif (funct != null)\n\t\t{\n\t\t\tfunct(this.editor);\n\t\t}\n\t});\n\n\treturn this.toolbar.addSwitchMode(title, icon, clickHandler, pressed);\n};\n\n/**\n * Function: addPrototype\n *\n * Creates an item for inserting a clone of the specified prototype cell into\n * the <editor>'s graph. The ptype may either be a cell or a function that\n * returns a cell.\n *\n * Parameters:\n *\n * title - String that represents the title of the item.\n * icon - URL of the icon that represents the item.\n * ptype - Function or object that represents the prototype cell. If ptype\n * is a function then it is invoked with no arguments to create new\n * instances.\n * pressed - Optional URL of the icon that represents the pressed state.\n * insert - Optional JavaScript function that handles an insert of the new\n * cell. This function takes the <mxEditor>, new cell to be inserted, mouse\n * event and optional <mxCell> under the mouse pointer as arguments.\n * toggle - Optional boolean that specifies if the item can be toggled.\n * Default is true.\n */\nmxDefaultToolbar.prototype.addPrototype = function(title, icon, ptype, pressed, insert, toggle)\n{\n\t// Creates a wrapper function that is in charge of constructing\n\t// the new cell instance to be inserted into the graph\n\tvar factory = mxUtils.bind(this, function()\n\t{\n\t\tif (typeof(ptype) == 'function')\n\t\t{\n\t\t\treturn ptype();\n\t\t}\n\t\telse if (ptype != null)\n\t\t{\n\t\t\treturn this.editor.graph.cloneCell(ptype);\n\t\t}\n\n\t\treturn null;\n\t});\n\n\t// Defines the function for a click event on the graph\n\t// after this item has been selected in the toolbar\n\tvar clickHandler = mxUtils.bind(this, function(evt, cell)\n\t{\n\t\tif (typeof(insert) == 'function')\n\t\t{\n\t\t\tinsert(this.editor, factory(), evt, cell);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.drop(factory(), evt, cell);\n\t\t}\n\n\t\tthis.toolbar.resetMode();\n\t\tmxEvent.consume(evt);\n\t});\n\n\tvar img = this.toolbar.addMode(title, icon, clickHandler, pressed, null, toggle);\n\n\t// Creates a wrapper function that calls the click handler without\n\t// the graph argument\n\tvar dropHandler = function(graph, evt, cell)\n\t{\n\t\tclickHandler(evt, cell);\n\t};\n\n\tthis.installDropHandler(img, dropHandler);\n\n\treturn img;\n};\n\n/**\n * Function: drop\n *\n * Handles a drop from a toolbar item to the graph. The given vertex\n * represents the new cell to be inserted. This invokes <insert> or\n * <connect> depending on the given target cell.\n *\n * Parameters:\n *\n * vertex - <mxCell> to be inserted.\n * evt - Mouse event that represents the drop.\n * target - Optional <mxCell> that represents the drop target.\n */\nmxDefaultToolbar.prototype.drop = function(vertex, evt, target)\n{\n\tvar graph = this.editor.graph;\n\tvar model = graph.getModel();\n\n\tif (target == null ||\n\t\tmodel.isEdge(target) ||\n\t\t!this.connectOnDrop ||\n\t\t!graph.isCellConnectable(target))\n\t{\n\t\twhile (target != null &&\n\t\t\t!graph.isValidDropTarget(target, [vertex], evt))\n\t\t{\n\t\t\ttarget = model.getParent(target);\n\t\t}\n\n\t\tthis.insert(vertex, evt, target);\n\t}\n\telse\n\t{\n\t\tthis.connect(vertex, evt, target);\n\t}\n};\n\n/**\n * Function: insert\n *\n * Handles a drop by inserting the given vertex into the given parent cell\n * or the default parent if no parent is specified.\n *\n * Parameters:\n *\n * vertex - <mxCell> to be inserted.\n * evt - Mouse event that represents the drop.\n * parent - Optional <mxCell> that represents the parent.\n */\nmxDefaultToolbar.prototype.insert = function(vertex, evt, target)\n{\n\tvar graph = this.editor.graph;\n\n\tif (graph.canImportCell(vertex))\n\t{\n\t\tvar x = mxEvent.getClientX(evt);\n\t\tvar y = mxEvent.getClientY(evt);\n\t\tvar pt = mxUtils.convertPoint(graph.container, x, y);\n\n\t\t// Splits the target edge or inserts into target group\n\t\tif (graph.isSplitEnabled() &&\n\t\t\tgraph.isSplitTarget(target, [vertex], evt))\n\t\t{\n\t\t\treturn graph.splitEdge(target, [vertex], null, pt.x, pt.y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.editor.addVertex(target, vertex, pt.x, pt.y);\n\t\t}\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: connect\n *\n * Handles a drop by connecting the given vertex to the given source cell.\n *\n * vertex - <mxCell> to be inserted.\n * evt - Mouse event that represents the drop.\n * source - Optional <mxCell> that represents the source terminal.\n */\nmxDefaultToolbar.prototype.connect = function(vertex, evt, source)\n{\n\tvar graph = this.editor.graph;\n\tvar model = graph.getModel();\n\n\tif (source != null &&\n\t\tgraph.isCellConnectable(vertex) &&\n\t\tgraph.isEdgeValid(null, source, vertex))\n\t{\n\t\tvar edge = null;\n\n\t\tmodel.beginUpdate();\n\t\ttry\n\t\t{\n\t\t\tvar geo = model.getGeometry(source);\n\t\t\tvar g = model.getGeometry(vertex).clone();\n\n\t\t\t// Moves the vertex away from the drop target that will\n\t\t\t// be used as the source for the new connection\n\t\t\tg.x = geo.x + (geo.width - g.width) / 2;\n\t\t\tg.y = geo.y + (geo.height - g.height) / 2;\n\n\t\t\tvar step = this.spacing * graph.gridSize;\n\t\t\tvar dist = model.getDirectedEdgeCount(source, true) * 20;\n\n\t\t\tif (this.editor.horizontalFlow)\n\t\t\t{\n\t\t\t\tg.x += (g.width + geo.width) / 2 + step + dist;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tg.y += (g.height + geo.height) / 2 + step + dist;\n\t\t\t}\n\n\t\t\tvertex.setGeometry(g);\n\n\t\t\t// Fires two add-events with the code below - should be fixed\n\t\t\t// to only fire one add event for both inserts\n\t\t\tvar parent = model.getParent(source);\n\t\t\tgraph.addCell(vertex, parent);\n\t\t\tgraph.constrainChild(vertex);\n\n\t\t\t// Creates the edge using the editor instance and calls\n\t\t\t// the second function that fires an add event\n\t\t\tedge = this.editor.createEdge(source, vertex);\n\n\t\t\tif (model.getGeometry(edge) == null)\n\t\t\t{\n\t\t\t\tvar edgeGeometry = new mxGeometry();\n\t\t\t\tedgeGeometry.relative = true;\n\n\t\t\t\tmodel.setGeometry(edge, edgeGeometry);\n\t\t\t}\n\n\t\t\tgraph.addEdge(edge, parent, source, vertex);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tmodel.endUpdate();\n\t\t}\n\n\t\tgraph.setSelectionCells([vertex, edge]);\n\t\tgraph.scrollCellToVisible(vertex);\n\t}\n};\n\n/**\n * Function: installDropHandler\n *\n * Makes the given img draggable using the given function for handling a\n * drop event.\n *\n * Parameters:\n *\n * img - DOM node that represents the image.\n * dropHandler - Function that handles a drop of the image.\n */\nmxDefaultToolbar.prototype.installDropHandler = function (img, dropHandler)\n{\n\tvar sprite = document.createElement('img');\n\tsprite.setAttribute('src', img.getAttribute('src'));\n\n\t// Handles delayed loading of the images\n\tvar loader = mxUtils.bind(this, function(evt)\n\t{\n\t\t// Preview uses the image node with double size. Later this can be\n\t\t// changed to use a separate preview and guides, but for this the\n\t\t// dropHandler must use the additional x- and y-arguments and the\n\t\t// dragsource which makeDraggable returns much be configured to\n\t\t// use guides via mxDragSource.isGuidesEnabled.\n\t\tsprite.style.width = (2 * img.offsetWidth) + 'px';\n\t\tsprite.style.height = (2 * img.offsetHeight) + 'px';\n\n\t\tmxUtils.makeDraggable(img, this.editor.graph, dropHandler,\n\t\t\tsprite);\n\t\tmxEvent.removeListener(sprite, 'load', loader);\n\t});\n\n\tif (mxClient.IS_IE)\n\t{\n\t\tloader();\n\t}\n\telse\n\t{\n\t\tmxEvent.addListener(sprite, 'load', loader);\n\t}\n};\n\n/**\n * Function: destroy\n *\n * Destroys the <toolbar> associated with this object and removes all\n * installed listeners. This does normally not need to be called, the\n * <toolbar> is destroyed automatically when the window unloads (in IE) by\n * <mxEditor>.\n */\nmxDefaultToolbar.prototype.destroy = function ()\n{\n\tif (this.resetHandler != null)\n\t{\n\t\tthis.editor.graph.removeListener('dblclick', this.resetHandler);\n\t\tthis.editor.removeListener('escape', this.resetHandler);\n\t\tthis.resetHandler = null;\n\t}\n\n\tif (this.toolbar != null)\n\t{\n\t\tthis.toolbar.destroy();\n\t\tthis.toolbar = null;\n\t}\n};\n\n__mxOutput.mxDefaultToolbar = typeof mxDefaultToolbar !== 'undefined' ? mxDefaultToolbar : undefined;\n\n/**\n * Copyright (c) 2006-2019, JGraph Ltd\n * Copyright (c) 2006-2019, draw.io AG\n */\n/**\n * Class: mxEditor\n *\n * Extends <mxEventSource> to implement a application wrapper for a graph that\n * adds <actions>, I/O using <mxCodec>, auto-layout using <mxLayoutManager>,\n * command history using <undoManager>, and standard dialogs and widgets, eg.\n * properties, help, outline, toolbar, and popupmenu. It also adds <templates>\n * to be used as cells in toolbars, auto-validation using the <validation>\n * flag, attribute cycling using <cycleAttributeValues>, higher-level events\n * such as <root>, and backend integration using <urlPost> and <urlImage>.\n *\n * Actions:\n *\n * Actions are functions stored in the <actions> array under their names. The\n * functions take the <mxEditor> as the first, and an optional <mxCell> as the\n * second argument and are invoked using <execute>. Any additional arguments\n * passed to execute are passed on to the action as-is.\n *\n * A list of built-in actions is available in the <addActions> description.\n *\n * Read/write Diagrams:\n *\n * To read a diagram from an XML string, for example from a textfield within the\n * page, the following code is used:\n *\n * (code)\n * var doc = mxUtils.parseXML(xmlString);\n * var node = doc.documentElement;\n * editor.readGraphModel(node);\n * (end)\n *\n * For reading a diagram from a remote location, use the <open> method.\n *\n * To save diagrams in XML on a server, you can set the <urlPost> variable.\n * This variable will be used in <getUrlPost> to construct a URL for the post\n * request that is issued in the <save> method. The post request contains the\n * XML representation of the diagram as returned by <writeGraphModel> in the\n * xml parameter.\n *\n * On the server side, the post request is processed using standard\n * technologies such as Java Servlets, CGI, .NET or ASP.\n *\n * Here are some examples of processing a post request in various languages.\n *\n * - Java: URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\")\n *\n * Note that the linefeeds should only be replaced if the XML is\n * processed in Java, for example when creating an image, but not\n * if the XML is passed back to the client-side.\n *\n * - .NET: HttpUtility.UrlDecode(context.Request.Params[\"xml\"])\n * - PHP: urldecode($_POST[\"xml\"])\n *\n * Creating images:\n *\n * A backend (Java, PHP or C#) is required for creating images. The\n * distribution contains an example for each backend (ImageHandler.java,\n * ImageHandler.cs and graph.php). More information about using a backend\n * to create images can be found in the readme.html files. Note that the\n * preview is implemented using VML/SVG in the browser and does not require\n * a backend. The backend is only required to creates images (bitmaps).\n *\n * Special characters:\n *\n * Note There are five characters that should always appear in XML content as\n * escapes, so that they do not interact with the syntax of the markup. These\n * are part of the language for all documents based on XML and for HTML.\n *\n * - &lt; (<)\n * - &gt; (>)\n * - &amp; (&)\n * - &quot; (\")\n * - &apos; (')\n *\n * Although it is part of the XML language, &apos; is not defined in HTML.\n * For this reason the XHTML specification recommends instead the use of\n * &#39; if text may be passed to a HTML user agent.\n *\n * If you are having problems with special characters on the server-side then\n * you may want to try the <escapePostData> flag.\n *\n * For converting decimal escape sequences inside strings, a user has provided\n * us with the following function:\n *\n * (code)\n * function html2js(text)\n * {\n *   var entitySearch = /&#[0-9]+;/;\n *   var entity;\n *\n *   while (entity = entitySearch.exec(text))\n *   {\n *     var charCode = entity[0].substring(2, entity[0].length -1);\n *     text = text.substring(0, entity.index)\n *            + String.fromCharCode(charCode)\n *            + text.substring(entity.index + entity[0].length);\n *   }\n *\n *   return text;\n * }\n * (end)\n *\n * Otherwise try using hex escape sequences and the built-in unescape function\n * for converting such strings.\n *\n * Local Files:\n *\n * For saving and opening local files, no standardized method exists that\n * works across all browsers. The recommended way of dealing with local files\n * is to create a backend that streams the XML data back to the browser (echo)\n * as an attachment so that a Save-dialog is displayed on the client-side and\n * the file can be saved to the local disk.\n *\n * For example, in PHP the code that does this looks as follows.\n *\n * (code)\n * $xml = stripslashes($_POST[\"xml\"]);\n * header(\"Content-Disposition: attachment; filename=\\\"diagram.xml\\\"\");\n * echo($xml);\n * (end)\n *\n * To open a local file, the file should be uploaded via a form in the browser\n * and then opened from the server in the editor.\n *\n * Cell Properties:\n *\n * The properties displayed in the properties dialog are the attributes and\n * values of the cell's user object, which is an XML node. The XML node is\n * defined in the templates section of the config file.\n *\n * The templates are stored in <mxEditor.templates> and contain cells which\n * are cloned at insertion time to create new vertices by use of drag and\n * drop from the toolbar. Each entry in the toolbar for adding a new vertex\n * must refer to an existing template.\n *\n * In the following example, the task node is a business object and only the\n * mxCell node and its mxGeometry child contain graph information:\n *\n * (code)\n * <Task label=\"Task\" description=\"\">\n *   <mxCell vertex=\"true\">\n *     <mxGeometry as=\"geometry\" width=\"72\" height=\"32\"/>\n *   </mxCell>\n * </Task>\n * (end)\n *\n * The idea is that the XML representation is inverse from the in-memory\n * representation: The outer XML node is the user object and the inner node is\n * the cell. This means the user object of the cell is the Task node with no\n * children for the above example:\n *\n * (code)\n * <Task label=\"Task\" description=\"\"/>\n * (end)\n *\n * The Task node can have any tag name, attributes and child nodes. The\n * <mxCodec> will use the XML hierarchy as the user object, while removing the\n * \"known annotations\", such as the mxCell node. At save-time the cell data\n * will be \"merged\" back into the user object. The user object is only modified\n * via the properties dialog during the lifecycle of the cell.\n *\n * In the default implementation of <createProperties>, the user object's\n * attributes are put into a form for editing. Attributes are changed using\n * the <mxCellAttributeChange> action in the model. The dialog can be replaced\n * by overriding the <createProperties> hook or by replacing the showProperties\n * action in <actions>. Alternatively, the entry in the config file's popupmenu\n * section can be modified to invoke a different action.\n *\n * If you want to displey the properties dialog on a doubleclick, you can set\n * <mxEditor.dblClickAction> to showProperties as follows:\n *\n * (code)\n * editor.dblClickAction = 'showProperties';\n * (end)\n *\n * Popupmenu and Toolbar:\n *\n * The toolbar and popupmenu are typically configured using the respective\n * sections in the config file, that is, the popupmenu is defined as follows:\n *\n * (code)\n * <mxEditor>\n *   <mxDefaultPopupMenu as=\"popupHandler\">\n * \t\t<add as=\"cut\" action=\"cut\" icon=\"images/cut.gif\"/>\n *      ...\n * (end)\n *\n * New entries can be added to the toolbar by inserting an add-node into the\n * above configuration. Existing entries may be removed and changed by\n * modifying or removing the respective entries in the configuration.\n * The configuration is read by the <mxDefaultPopupMenuCodec>, the format of the\n * configuration is explained in <mxDefaultPopupMenu.decode>.\n *\n * The toolbar is defined in the mxDefaultToolbar section. Items can be added\n * and removed in this section.\n *\n * (code)\n * <mxEditor>\n *   <mxDefaultToolbar>\n *     <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\n *     <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"/>\n *     ...\n * (end)\n *\n * The format of the configuration is described in\n * <mxDefaultToolbarCodec.decode>.\n *\n * Ids:\n *\n * For the IDs, there is an implicit behaviour in <mxCodec>: It moves the Id\n * from the cell to the user object at encoding time and vice versa at decoding\n * time. For example, if the Task node from above has an id attribute, then\n * the <mxCell.id> of the corresponding cell will have this value. If there\n * is no Id collision in the model, then the cell may be retrieved using this\n * Id with the <mxGraphModel.getCell> function. If there is a collision, a new\n * Id will be created for the cell using <mxGraphModel.createId>. At encoding\n * time, this new Id will replace the value previously stored under the id\n * attribute in the Task node.\n *\n * See <mxEditorCodec>, <mxDefaultToolbarCodec> and <mxDefaultPopupMenuCodec>\n * for information about configuring the editor and user interface.\n *\n * Programmatically inserting cells:\n *\n * For inserting a new cell, say, by clicking a button in the document,\n * the following code can be used. This requires an reference to the editor.\n *\n * (code)\n * var userObject = new Object();\n * var parent = editor.graph.getDefaultParent();\n * var model = editor.graph.model;\n * model.beginUpdate();\n * try\n * {\n *   editor.graph.insertVertex(parent, null, userObject, 20, 20, 80, 30);\n * }\n * finally\n * {\n *   model.endUpdate();\n * }\n * (end)\n *\n * If a template cell from the config file should be inserted, then a clone\n * of the template can be created as follows. The clone is then inserted using\n * the add function instead of addVertex.\n *\n * (code)\n * var template = editor.templates['task'];\n * var clone = editor.graph.model.cloneCell(template);\n * (end)\n *\n * Resources:\n *\n * resources/editor - Language resources for mxEditor\n *\n * Callback: onInit\n *\n * Called from within the constructor. In the callback,\n * \"this\" refers to the editor instance.\n *\n * Cookie: mxgraph=seen\n *\n * Set when the editor is started. Never expires. Use\n * <resetFirstTime> to reset this cookie. This cookie\n * only exists if <onInit> is implemented.\n *\n * Event: mxEvent.OPEN\n *\n * Fires after a file was opened in <open>. The <code>filename</code> property\n * contains the filename that was used. The same value is also available in\n * <filename>.\n *\n * Event: mxEvent.SAVE\n *\n * Fires after the current file was saved in <save>. The <code>url</code>\n * property contains the URL that was used for saving.\n *\n * Event: mxEvent.POST\n *\n * Fires if a successful response was received in <postDiagram>. The\n * <code>request</code> property contains the <mxXmlRequest>, the\n * <code>url</code> and <code>data</code> properties contain the URL and the\n * data that were used in the post request.\n *\n * Event: mxEvent.ROOT\n *\n * Fires when the current root has changed, or when the title of the current\n * root has changed. This event has no properties.\n *\n * Event: mxEvent.BEFORE_ADD_VERTEX\n *\n * Fires before a vertex is added in <addVertex>. The <code>vertex</code>\n * property contains the new vertex and the <code>parent</code> property\n * contains its parent.\n *\n * Event: mxEvent.ADD_VERTEX\n *\n * Fires between begin- and endUpdate in <addVertex>. The <code>vertex</code>\n * property contains the vertex that is being inserted.\n *\n * Event: mxEvent.AFTER_ADD_VERTEX\n *\n * Fires after a vertex was inserted and selected in <addVertex>. The\n * <code>vertex</code> property contains the new vertex.\n *\n * Example:\n *\n * For starting an in-place edit after a new vertex has been added to the\n * graph, the following code can be used.\n *\n * (code)\n * editor.addListener(mxEvent.AFTER_ADD_VERTEX, function(sender, evt)\n * {\n *   var vertex = evt.getProperty('vertex');\n *\n *   if (editor.graph.isCellEditable(vertex))\n *   {\n *   \teditor.graph.startEditingAtCell(vertex);\n *   }\n * });\n * (end)\n *\n * Event: mxEvent.ESCAPE\n *\n * Fires when the escape key is pressed. The <code>event</code> property\n * contains the key event.\n *\n * Constructor: mxEditor\n *\n * Constructs a new editor. This function invokes the <onInit> callback\n * upon completion.\n *\n * Example:\n *\n * (code)\n * var config = mxUtils.load('config/diagrameditor.xml').getDocumentElement();\n * var editor = new mxEditor(config);\n * (end)\n *\n * Parameters:\n *\n * config - Optional XML node that contains the configuration.\n */\nfunction mxEditor(config)\n{\n\tthis.actions = [];\n\tthis.addActions();\n\n\t// Executes the following only if a document has been instanciated.\n\t// That is, don't execute when the editorcodec is setup.\n\tif (document.body != null)\n\t{\n\t\t// Defines instance fields\n\t\tthis.cycleAttributeValues = [];\n\t\tthis.popupHandler = new mxDefaultPopupMenu();\n\t\tthis.undoManager = new mxUndoManager();\n\n\t\t// Creates the graph and toolbar without the containers\n\t\tthis.graph = this.createGraph();\n\t\tthis.toolbar = this.createToolbar();\n\n\t\t// Creates the global keyhandler (requires graph instance)\n\t\tthis.keyHandler = new mxDefaultKeyHandler(this);\n\n\t\t// Configures the editor using the URI\n\t\t// which was passed to the ctor\n\t\tthis.configure(config);\n\n\t\t// Assigns the swimlaneIndicatorColorAttribute on the graph\n\t\tthis.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;\n\n\t\t// Checks if the <onInit> hook has been set\n\t\tif (this.onInit != null)\n\t\t{\n\t\t\t// Invokes the <onInit> hook\n\t\t\tthis.onInit();\n\t\t}\n\n\t\t// Automatic deallocation of memory\n\t\tif (mxClient.IS_IE)\n\t\t{\n\t\t\tmxEvent.addListener(window, 'unload', mxUtils.bind(this, function()\n\t\t\t{\n\t\t\t\tthis.destroy();\n\t\t\t}));\n\t\t}\n\t}\n};\n\n/**\n * Installs the required language resources at class\n * loading time.\n */\nif (mxLoadResources)\n{\n\tmxResources.add(mxClient.basePath + '/resources/editor');\n}\nelse\n{\n\tmxClient.defaultBundles.push(mxClient.basePath + '/resources/editor');\n}\n\n/**\n * Extends mxEventSource.\n */\nmxEditor.prototype = new mxEventSource();\nmxEditor.prototype.constructor = mxEditor;\n\n/**\n * Group: Controls and Handlers\n */\n\n/**\n * Variable: askZoomResource\n *\n * Specifies the resource key for the zoom dialog. If the resource for this\n * key does not exist then the value is used as the error message. Default\n * is 'askZoom'.\n */\nmxEditor.prototype.askZoomResource = (mxClient.language != 'none') ? 'askZoom' : '';\n\n/**\n * Variable: lastSavedResource\n *\n * Specifies the resource key for the last saved info. If the resource for\n * this key does not exist then the value is used as the error message.\n * Default is 'lastSaved'.\n */\nmxEditor.prototype.lastSavedResource = (mxClient.language != 'none') ? 'lastSaved' : '';\n\n/**\n * Variable: currentFileResource\n *\n * Specifies the resource key for the current file info. If the resource for\n * this key does not exist then the value is used as the error message.\n * Default is 'lastSaved'.\n */\nmxEditor.prototype.currentFileResource = (mxClient.language != 'none') ? 'currentFile' : '';\n\n/**\n * Variable: propertiesResource\n *\n * Specifies the resource key for the properties window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'properties'.\n */\nmxEditor.prototype.propertiesResource = (mxClient.language != 'none') ? 'properties' : '';\n\n/**\n * Variable: tasksResource\n *\n * Specifies the resource key for the tasks window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'tasks'.\n */\nmxEditor.prototype.tasksResource = (mxClient.language != 'none') ? 'tasks' : '';\n\n/**\n * Variable: helpResource\n *\n * Specifies the resource key for the help window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'help'.\n */\nmxEditor.prototype.helpResource = (mxClient.language != 'none') ? 'help' : '';\n\n/**\n * Variable: outlineResource\n *\n * Specifies the resource key for the outline window title. If the\n * resource for this key does not exist then the value is used as the\n * error message. Default is 'outline'.\n */\nmxEditor.prototype.outlineResource = (mxClient.language != 'none') ? 'outline' : '';\n\n/**\n * Variable: outline\n *\n * Reference to the <mxWindow> that contains the outline. The <mxOutline>\n * is stored in outline.outline.\n */\nmxEditor.prototype.outline = null;\n\n/**\n * Variable: graph\n *\n * Holds a <mxGraph> for displaying the diagram. The graph\n * is created in <setGraphContainer>.\n */\nmxEditor.prototype.graph = null;\n\n/**\n * Variable: graphRenderHint\n *\n * Holds the render hint used for creating the\n * graph in <setGraphContainer>. See <mxGraph>.\n * Default is null.\n */\nmxEditor.prototype.graphRenderHint = null;\n\n/**\n * Variable: toolbar\n *\n * Holds a <mxDefaultToolbar> for displaying the toolbar. The\n * toolbar is created in <setToolbarContainer>.\n */\nmxEditor.prototype.toolbar = null;\n\n/**\n * Variable: status\n *\n * DOM container that holds the statusbar. Default is null.\n * Use <setStatusContainer> to set this value.\n */\nmxEditor.prototype.status = null;\n\n/**\n * Variable: popupHandler\n *\n * Holds a <mxDefaultPopupMenu> for displaying\n * popupmenus.\n */\nmxEditor.prototype.popupHandler = null;\n\n/**\n * Variable: undoManager\n *\n * Holds an <mxUndoManager> for the command history.\n */\nmxEditor.prototype.undoManager = null;\n\n/**\n * Variable: keyHandler\n *\n * Holds a <mxDefaultKeyHandler> for handling keyboard events.\n * The handler is created in <setGraphContainer>.\n */\nmxEditor.prototype.keyHandler = null;\n\n/**\n * Group: Actions and Options\n */\n\n/**\n * Variable: actions\n *\n * Maps from actionnames to actions, which are functions taking\n * the editor and the cell as arguments. Use <addAction>\n * to add or replace an action and <execute> to execute an action\n * by name, passing the cell to be operated upon as the second\n * argument.\n */\nmxEditor.prototype.actions = null;\n\n/**\n * Variable: dblClickAction\n *\n * Specifies the name of the action to be executed\n * when a cell is double clicked. Default is edit.\n *\n * To handle a singleclick, use the following code.\n *\n * (code)\n * editor.graph.addListener(mxEvent.CLICK, function(sender, evt)\n * {\n *   var e = evt.getProperty('event');\n *   var cell = evt.getProperty('cell');\n *\n *   if (cell != null && !e.isConsumed())\n *   {\n *     // Do something useful with cell...\n *     e.consume();\n *   }\n * });\n * (end)\n */\nmxEditor.prototype.dblClickAction = 'edit';\n\n/**\n * Variable: swimlaneRequired\n *\n * Specifies if new cells must be inserted\n * into an existing swimlane. Otherwise, cells\n * that are not swimlanes can be inserted as\n * top-level cells. Default is false.\n */\nmxEditor.prototype.swimlaneRequired = false;\n\n/**\n * Variable: disableContextMenu\n *\n * Specifies if the context menu should be disabled in the graph container.\n * Default is true.\n */\nmxEditor.prototype.disableContextMenu = true;\n\n/**\n * Group: Templates\n */\n\n/**\n * Variable: insertFunction\n *\n * Specifies the function to be used for inserting new\n * cells into the graph. This is assigned from the\n * <mxDefaultToolbar> if a vertex-tool is clicked.\n */\nmxEditor.prototype.insertFunction = null;\n\n/**\n * Variable: forcedInserting\n *\n * Specifies if a new cell should be inserted on a single\n * click even using <insertFunction> if there is a cell\n * under the mousepointer, otherwise the cell under the\n * mousepointer is selected. Default is false.\n */\nmxEditor.prototype.forcedInserting = false;\n\n/**\n * Variable: templates\n *\n * Maps from names to protoype cells to be used\n * in the toolbar for inserting new cells into\n * the diagram.\n */\nmxEditor.prototype.templates = null;\n\n/**\n * Variable: defaultEdge\n *\n * Prototype edge cell that is used for creating\n * new edges.\n */\nmxEditor.prototype.defaultEdge = null;\n\n/**\n * Variable: defaultEdgeStyle\n *\n * Specifies the edge style to be returned in <getEdgeStyle>.\n * Default is null.\n */\nmxEditor.prototype.defaultEdgeStyle = null;\n\n/**\n * Variable: defaultGroup\n *\n * Prototype group cell that is used for creating\n * new groups.\n */\nmxEditor.prototype.defaultGroup = null;\n\n/**\n * Variable: groupBorderSize\n *\n * Default size for the border of new groups. If null,\n * then then <mxGraph.gridSize> is used. Default is\n * null.\n */\nmxEditor.prototype.groupBorderSize = null;\n\n/**\n * Group: Backend Integration\n */\n\n/**\n * Variable: filename\n *\n * Contains the URL of the last opened file as a string.\n * Default is null.\n */\nmxEditor.prototype.filename = null;\n\n/**\n * Variable: lineFeed\n *\n * Character to be used for encoding linefeeds in <save>. Default is '&#xa;'.\n */\nmxEditor.prototype.linefeed = '&#xa;';\n\n/**\n * Variable: postParameterName\n *\n * Specifies if the name of the post parameter that contains the diagram\n * data in a post request to the server. Default is xml.\n */\nmxEditor.prototype.postParameterName = 'xml';\n\n/**\n * Variable: escapePostData\n *\n * Specifies if the data in the post request for saving a diagram\n * should be converted using encodeURIComponent. Default is true.\n */\nmxEditor.prototype.escapePostData = true;\n\n/**\n * Variable: urlPost\n *\n * Specifies the URL to be used for posting the diagram\n * to a backend in <save>.\n */\nmxEditor.prototype.urlPost = null;\n\n/**\n * Variable: urlImage\n *\n * Specifies the URL to be used for creating a bitmap of\n * the graph in the image action.\n */\nmxEditor.prototype.urlImage = null;\n\n/**\n * Group: Autolayout\n */\n\n/**\n * Variable: horizontalFlow\n *\n * Specifies the direction of the flow\n * in the diagram. This is used in the\n * layout algorithms. Default is false,\n * ie. vertical flow.\n */\nmxEditor.prototype.horizontalFlow = false;\n\n/**\n * Variable: layoutDiagram\n *\n * Specifies if the top-level elements in the\n * diagram should be layed out using a vertical\n * or horizontal stack depending on the setting\n * of <horizontalFlow>. The spacing between the\n * swimlanes is specified by <swimlaneSpacing>.\n * Default is false.\n *\n * If the top-level elements are swimlanes, then\n * the intra-swimlane layout is activated by\n * the <layoutSwimlanes> switch.\n */\nmxEditor.prototype.layoutDiagram = false;\n\n/**\n * Variable: swimlaneSpacing\n *\n * Specifies the spacing between swimlanes if\n * automatic layout is turned on in\n * <layoutDiagram>. Default is 0.\n */\nmxEditor.prototype.swimlaneSpacing = 0;\n\n/**\n * Variable: maintainSwimlanes\n *\n * Specifies if the swimlanes should be kept at the same\n * width or height depending on the setting of\n * <horizontalFlow>.  Default is false.\n *\n * For horizontal flows, all swimlanes\n * have the same height and for vertical flows, all swimlanes\n * have the same width. Furthermore, the swimlanes are\n * automatically \"stacked\" if <layoutDiagram> is true.\n */\nmxEditor.prototype.maintainSwimlanes = false;\n\n/**\n * Variable: layoutSwimlanes\n *\n * Specifies if the children of swimlanes should\n * be layed out, either vertically or horizontally\n * depending on <horizontalFlow>.\n * Default is false.\n */\nmxEditor.prototype.layoutSwimlanes = false;\n\n/**\n * Group: Attribute Cycling\n */\n\n/**\n * Variable: cycleAttributeValues\n *\n * Specifies the attribute values to be cycled when\n * inserting new swimlanes. Default is an empty\n * array.\n */\nmxEditor.prototype.cycleAttributeValues = null;\n\n/**\n * Variable: cycleAttributeIndex\n *\n * Index of the last consumed attribute index. If a new\n * swimlane is inserted, then the <cycleAttributeValues>\n * at this index will be used as the value for\n * <cycleAttributeName>. Default is 0.\n */\nmxEditor.prototype.cycleAttributeIndex = 0;\n\n/**\n * Variable: cycleAttributeName\n *\n * Name of the attribute to be assigned a <cycleAttributeValues>\n * when inserting new swimlanes. Default is fillColor.\n */\nmxEditor.prototype.cycleAttributeName = 'fillColor';\n\n/**\n * Group: Windows\n */\n\n/**\n * Variable: tasks\n *\n * Holds the <mxWindow> created in <showTasks>.\n */\nmxEditor.prototype.tasks = null;\n\n/**\n * Variable: tasksWindowImage\n *\n * Icon for the tasks window.\n */\nmxEditor.prototype.tasksWindowImage = null;\n\n/**\n * Variable: tasksTop\n *\n * Specifies the top coordinate of the tasks window in pixels.\n * Default is 20.\n */\nmxEditor.prototype.tasksTop = 20;\n\n/**\n * Variable: help\n *\n * Holds the <mxWindow> created in <showHelp>.\n */\nmxEditor.prototype.help = null;\n\n/**\n * Variable: helpWindowImage\n *\n * Icon for the help window.\n */\nmxEditor.prototype.helpWindowImage = null;\n\n/**\n * Variable: urlHelp\n *\n * Specifies the URL to be used for the contents of the\n * Online Help window. This is usually specified in the\n * resources file under urlHelp for language-specific\n * online help support.\n */\nmxEditor.prototype.urlHelp = null;\n\n/**\n * Variable: helpWidth\n *\n * Specifies the width of the help window in pixels.\n * Default is 300.\n */\nmxEditor.prototype.helpWidth = 300;\n\n/**\n * Variable: helpHeight\n *\n * Specifies the height of the help window in pixels.\n * Default is 260.\n */\nmxEditor.prototype.helpHeight = 260;\n\n/**\n * Variable: propertiesWidth\n *\n * Specifies the width of the properties window in pixels.\n * Default is 240.\n */\nmxEditor.prototype.propertiesWidth = 240;\n\n/**\n * Variable: propertiesHeight\n *\n * Specifies the height of the properties window in pixels.\n * If no height is specified then the window will be automatically\n * sized to fit its contents. Default is null.\n */\nmxEditor.prototype.propertiesHeight = null;\n\n/**\n * Variable: movePropertiesDialog\n *\n * Specifies if the properties dialog should be automatically\n * moved near the cell it is displayed for, otherwise the\n * dialog is not moved. This value is only taken into\n * account if the dialog is already visible. Default is false.\n */\nmxEditor.prototype.movePropertiesDialog = false;\n\n/**\n * Variable: validating\n *\n * Specifies if <mxGraph.validateGraph> should automatically be invoked after\n * each change. Default is false.\n */\nmxEditor.prototype.validating = false;\n\n/**\n * Variable: modified\n *\n * True if the graph has been modified since it was last saved.\n */\nmxEditor.prototype.modified = false;\n\n/**\n * Function: isModified\n *\n * Returns <modified>.\n */\nmxEditor.prototype.isModified = function ()\n{\n\treturn this.modified;\n};\n\n/**\n * Function: setModified\n *\n * Sets <modified> to the specified boolean value.\n */\nmxEditor.prototype.setModified = function (value)\n{\n\tthis.modified = value;\n};\n\n/**\n * Function: addActions\n *\n * Adds the built-in actions to the editor instance.\n *\n * save - Saves the graph using <urlPost>.\n * print - Shows the graph in a new print preview window.\n * show - Shows the graph in a new window.\n * exportImage - Shows the graph as a bitmap image using <getUrlImage>.\n * refresh - Refreshes the graph's display.\n * cut - Copies the current selection into the clipboard\n * and removes it from the graph.\n * copy - Copies the current selection into the clipboard.\n * paste - Pastes the clipboard into the graph.\n * delete - Removes the current selection from the graph.\n * group - Puts the current selection into a new group.\n * ungroup - Removes the selected groups and selects the children.\n * undo - Undoes the last change on the graph model.\n * redo - Redoes the last change on the graph model.\n * zoom - Sets the zoom via a dialog.\n * zoomIn - Zooms into the graph.\n * zoomOut - Zooms out of the graph\n * actualSize - Resets the scale and translation on the graph.\n * fit - Changes the scale so that the graph fits into the window.\n * showProperties - Shows the properties dialog.\n * selectAll - Selects all cells.\n * selectNone - Clears the selection.\n * selectVertices - Selects all vertices.\n * selectEdges = Selects all edges.\n * edit - Starts editing the current selection cell.\n * enterGroup - Drills down into the current selection cell.\n * exitGroup - Moves up in the drilling hierachy\n * home - Moves to the topmost parent in the drilling hierarchy\n * selectPrevious - Selects the previous cell.\n * selectNext - Selects the next cell.\n * selectParent - Selects the parent of the selection cell.\n * selectChild - Selects the first child of the selection cell.\n * collapse - Collapses the currently selected cells.\n * expand - Expands the currently selected cells.\n * bold - Toggle bold text style.\n * italic - Toggle italic text style.\n * underline - Toggle underline text style.\n * alignCellsLeft - Aligns the selection cells at the left.\n * alignCellsCenter - Aligns the selection cells in the center.\n * alignCellsRight - Aligns the selection cells at the right.\n * alignCellsTop - Aligns the selection cells at the top.\n * alignCellsMiddle - Aligns the selection cells in the middle.\n * alignCellsBottom - Aligns the selection cells at the bottom.\n * alignFontLeft - Sets the horizontal text alignment to left.\n * alignFontCenter - Sets the horizontal text alignment to center.\n * alignFontRight - Sets the horizontal text alignment to right.\n * alignFontTop - Sets the vertical text alignment to top.\n * alignFontMiddle - Sets the vertical text alignment to middle.\n * alignFontBottom - Sets the vertical text alignment to bottom.\n * toggleTasks - Shows or hides the tasks window.\n * toggleHelp - Shows or hides the help window.\n * toggleOutline - Shows or hides the outline window.\n * toggleConsole - Shows or hides the console window.\n */\nmxEditor.prototype.addActions = function ()\n{\n\tthis.addAction('save', function(editor)\n\t{\n\t\teditor.save();\n\t});\n\n\tthis.addAction('print', function(editor)\n\t{\n\t\tvar preview = new mxPrintPreview(editor.graph, 1);\n\t\tpreview.open();\n\t});\n\n\tthis.addAction('show', function(editor)\n\t{\n\t\tmxUtils.show(editor.graph, null, 10, 10);\n\t});\n\n\tthis.addAction('exportImage', function(editor)\n\t{\n\t\tvar url = editor.getUrlImage();\n\n\t\tif (url == null || mxClient.IS_LOCAL)\n\t\t{\n\t\t\teditor.execute('show');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar node = mxUtils.getViewXml(editor.graph, 1);\n\t\t\tvar xml = mxUtils.getXml(node, '\\n');\n\n\t\t\tmxUtils.submit(url, editor.postParameterName + '=' +\n\t\t\t\tencodeURIComponent(xml), document, '_blank');\n\t\t}\n\t});\n\n\tthis.addAction('refresh', function(editor)\n\t{\n\t\teditor.graph.refresh();\n\t});\n\n\tthis.addAction('cut', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tmxClipboard.cut(editor.graph);\n\t\t}\n\t});\n\n\tthis.addAction('copy', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tmxClipboard.copy(editor.graph);\n\t\t}\n\t});\n\n\tthis.addAction('paste', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tmxClipboard.paste(editor.graph);\n\t\t}\n\t});\n\n\tthis.addAction('delete', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.removeCells();\n\t\t}\n\t});\n\n\tthis.addAction('group', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setSelectionCell(editor.groupCells());\n\t\t}\n\t});\n\n\tthis.addAction('ungroup', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setSelectionCells(editor.graph.ungroupCells());\n\t\t}\n\t});\n\n\tthis.addAction('removeFromParent', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.removeCellsFromParent();\n\t\t}\n\t});\n\n\tthis.addAction('undo', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.undo();\n\t\t}\n\t});\n\n\tthis.addAction('redo', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.redo();\n\t\t}\n\t});\n\n\tthis.addAction('zoomIn', function(editor)\n\t{\n\t\teditor.graph.zoomIn();\n\t});\n\n\tthis.addAction('zoomOut', function(editor)\n\t{\n\t\teditor.graph.zoomOut();\n\t});\n\n\tthis.addAction('actualSize', function(editor)\n\t{\n\t\teditor.graph.zoomActual();\n\t});\n\n\tthis.addAction('fit', function(editor)\n\t{\n\t\teditor.graph.fit();\n\t});\n\n\tthis.addAction('showProperties', function(editor, cell)\n\t{\n\t\teditor.showProperties(cell);\n\t});\n\n\tthis.addAction('selectAll', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectAll();\n\t\t}\n\t});\n\n\tthis.addAction('selectNone', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.clearSelection();\n\t\t}\n\t});\n\n\tthis.addAction('selectVertices', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectVertices();\n\t\t}\n\t});\n\n\tthis.addAction('selectEdges', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectEdges();\n\t\t}\n\t});\n\n\tthis.addAction('edit', function(editor, cell)\n\t{\n\t\tif (editor.graph.isEnabled() &&\n\t\t\teditor.graph.isCellEditable(cell))\n\t\t{\n\t\t\teditor.graph.startEditingAtCell(cell);\n\t\t}\n\t});\n\n\tthis.addAction('toBack', function(editor, cell)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.orderCells(true);\n\t\t}\n\t});\n\n\tthis.addAction('toFront', function(editor, cell)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.orderCells(false);\n\t\t}\n\t});\n\n\tthis.addAction('enterGroup', function(editor, cell)\n\t{\n\t\teditor.graph.enterGroup(cell);\n\t});\n\n\tthis.addAction('exitGroup', function(editor)\n\t{\n\t\teditor.graph.exitGroup();\n\t});\n\n\tthis.addAction('home', function(editor)\n\t{\n\t\teditor.graph.home();\n\t});\n\n\tthis.addAction('selectPrevious', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectPreviousCell();\n\t\t}\n\t});\n\n\tthis.addAction('selectNext', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectNextCell();\n\t\t}\n\t});\n\n\tthis.addAction('selectParent', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectParentCell();\n\t\t}\n\t});\n\n\tthis.addAction('selectChild', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.selectChildCell();\n\t\t}\n\t});\n\n\tthis.addAction('collapse', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.foldCells(true);\n\t\t}\n\t});\n\n\tthis.addAction('collapseAll', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tvar cells = editor.graph.getChildVertices();\n\t\t\teditor.graph.foldCells(true, false, cells);\n\t\t}\n\t});\n\n\tthis.addAction('expand', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.foldCells(false);\n\t\t}\n\t});\n\n\tthis.addAction('expandAll', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\tvar cells = editor.graph.getChildVertices();\n\t\t\teditor.graph.foldCells(false, false, cells);\n\t\t}\n\t});\n\n\tthis.addAction('bold', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.toggleCellStyleFlags(\n\t\t\t\tmxConstants.STYLE_FONTSTYLE,\n\t\t\t\tmxConstants.FONT_BOLD);\n\t\t}\n\t});\n\n\tthis.addAction('italic', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.toggleCellStyleFlags(\n\t\t\t\tmxConstants.STYLE_FONTSTYLE,\n\t\t\t\tmxConstants.FONT_ITALIC);\n\t\t}\n\t});\n\n\tthis.addAction('underline', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.toggleCellStyleFlags(\n\t\t\t\tmxConstants.STYLE_FONTSTYLE,\n\t\t\t\tmxConstants.FONT_UNDERLINE);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsLeft', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_LEFT);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsCenter', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_CENTER);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsRight', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_RIGHT);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsTop', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_TOP);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsMiddle', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_MIDDLE);\n\t\t}\n\t});\n\n\tthis.addAction('alignCellsBottom', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.alignCells(mxConstants.ALIGN_BOTTOM);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontLeft', function(editor)\n\t{\n\n\t\teditor.graph.setCellStyles(\n\t\t\tmxConstants.STYLE_ALIGN,\n\t\t\tmxConstants.ALIGN_LEFT);\n\t});\n\n\tthis.addAction('alignFontCenter', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_ALIGN,\n\t\t\t\tmxConstants.ALIGN_CENTER);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontRight', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_ALIGN,\n\t\t\t\tmxConstants.ALIGN_RIGHT);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontTop', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_VERTICAL_ALIGN,\n\t\t\t\tmxConstants.ALIGN_TOP);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontMiddle', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_VERTICAL_ALIGN,\n\t\t\t\tmxConstants.ALIGN_MIDDLE);\n\t\t}\n\t});\n\n\tthis.addAction('alignFontBottom', function(editor)\n\t{\n\t\tif (editor.graph.isEnabled())\n\t\t{\n\t\t\teditor.graph.setCellStyles(\n\t\t\t\tmxConstants.STYLE_VERTICAL_ALIGN,\n\t\t\t\tmxConstants.ALIGN_BOTTOM);\n\t\t}\n\t});\n\n\tthis.addAction('zoom', function(editor)\n\t{\n\t\tvar current = editor.graph.getView().scale*100;\n\t\tvar scale = parseFloat(mxUtils.prompt(\n\t\t\tmxResources.get(editor.askZoomResource) ||\n\t\t\teditor.askZoomResource,\n\t\t\tcurrent))/100;\n\n\t\tif (!isNaN(scale))\n\t\t{\n\t\t\teditor.graph.getView().setScale(scale);\n\t\t}\n\t});\n\n\tthis.addAction('toggleTasks', function(editor)\n\t{\n\t\tif (editor.tasks != null)\n\t\t{\n\t\t\teditor.tasks.setVisible(!editor.tasks.isVisible());\n\t\t}\n\t\telse\n\t\t{\n\t\t\teditor.showTasks();\n\t\t}\n\t});\n\n\tthis.addAction('toggleHelp', function(editor)\n\t{\n\t\tif (editor.help != null)\n\t\t{\n\t\t\teditor.help.setVisible(!editor.help.isVisible());\n\t\t}\n\t\telse\n\t\t{\n\t\t\teditor.showHelp();\n\t\t}\n\t});\n\n\tthis.addAction('toggleOutline', function(editor)\n\t{\n\t\tif (editor.outline == null)\n\t\t{\n\t\t\teditor.showOutline();\n\t\t}\n\t\telse\n\t\t{\n\t\t\teditor.outline.setVisible(!editor.outline.isVisible());\n\t\t}\n\t});\n\n\tthis.addAction('toggleConsole', function(editor)\n\t{\n\t\tmxLog.setVisible(!mxLog.isVisible());\n\t});\n};\n\n/**\n * Function: configure\n *\n * Configures the editor using the specified node. To load the\n * configuration from a given URL the following code can be used to obtain\n * the XML node.\n *\n * (code)\n * var node = mxUtils.load(url).getDocumentElement();\n * (end)\n *\n * Parameters:\n *\n * node - XML node that contains the configuration.\n */\nmxEditor.prototype.configure = function (node)\n{\n\tif (node != null)\n\t{\n\t\t// Creates a decoder for the XML data\n\t\t// and uses it to configure the editor\n\t\tvar dec = new mxCodec(node.ownerDocument);\n\t\tdec.decode(node, this);\n\n\t\t// Resets the counters, modified state and\n\t\t// command history\n\t\tthis.resetHistory();\n\t}\n};\n\n/**\n * Function: resetFirstTime\n *\n * Resets the cookie that is used to remember if the editor has already\n * been used.\n */\nmxEditor.prototype.resetFirstTime = function ()\n{\n\tdocument.cookie =\n\t\t'mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/';\n};\n\n/**\n * Function: resetHistory\n *\n * Resets the command history, modified state and counters.\n */\nmxEditor.prototype.resetHistory = function ()\n{\n\tthis.lastSnapshot = new Date().getTime();\n\tthis.undoManager.clear();\n\tthis.ignoredChanges = 0;\n\tthis.setModified(false);\n};\n\n/**\n * Function: addAction\n *\n * Binds the specified actionname to the specified function.\n *\n * Parameters:\n *\n * actionname - String that specifies the name of the action\n * to be added.\n * funct - Function that implements the new action. The first\n * argument of the function is the editor it is used\n * with, the second argument is the cell it operates\n * upon.\n *\n * Example:\n * (code)\n * editor.addAction('test', function(editor, cell)\n * {\n * \t\tmxUtils.alert(\"test \"+cell);\n * });\n * (end)\n */\nmxEditor.prototype.addAction = function (actionname, funct)\n{\n\tthis.actions[actionname] = funct;\n};\n\n/**\n * Function: execute\n *\n * Executes the function with the given name in <actions> passing the\n * editor instance and given cell as the first and second argument. All\n * additional arguments are passed to the action as well. This method\n * contains a try-catch block and displays an error message if an action\n * causes an exception. The exception is re-thrown after the error\n * message was displayed.\n *\n * Example:\n *\n * (code)\n * editor.execute(\"showProperties\", cell);\n * (end)\n */\nmxEditor.prototype.execute = function (actionname, cell, evt)\n{\n\tvar action = this.actions[actionname];\n\n\tif (action != null)\n\t{\n\t\ttry\n\t\t{\n\t\t\t// Creates the array of arguments by replacing the actionname\n\t\t\t// with the editor instance in the args of this function\n\t\t\tvar args = arguments;\n\t\t\targs[0] = this;\n\n\t\t\t// Invokes the function on the editor using the args\n\t\t\taction.apply(this, args);\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tmxUtils.error('Cannot execute ' + actionname +\n\t\t\t\t': ' + e.message, 280, true);\n\n\t\t\tthrow e;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmxUtils.error('Cannot find action '+actionname, 280, true);\n\t}\n};\n\n/**\n * Function: addTemplate\n *\n * Adds the specified template under the given name in <templates>.\n */\nmxEditor.prototype.addTemplate = function (name, template)\n{\n\tthis.templates[name] = template;\n};\n\n/**\n * Function: getTemplate\n *\n * Returns the template for the given name.\n */\nmxEditor.prototype.getTemplate = function (name)\n{\n\treturn this.templates[name];\n};\n\n/**\n * Function: createGraph\n *\n * Creates the <graph> for the editor. The graph is created with no\n * container and is initialized from <setGraphContainer>.\n */\nmxEditor.prototype.createGraph = function ()\n{\n\tvar graph = new mxGraph(null, null, this.graphRenderHint);\n\n\t// Enables rubberband, tooltips, panning\n\tgraph.setTooltips(true);\n\tgraph.setPanning(true);\n\n\t// Overrides the dblclick method on the graph to\n\t// invoke the dblClickAction for a cell and reset\n\t// the selection tool in the toolbar\n\tthis.installDblClickHandler(graph);\n\n\t// Installs the command history\n\tthis.installUndoHandler(graph);\n\n\t// Installs the handlers for the root event\n\tthis.installDrillHandler(graph);\n\n\t// Installs the handler for validation\n\tthis.installChangeHandler(graph);\n\n\t// Installs the handler for calling the\n\t// insert function and consume the\n\t// event if an insert function is defined\n\tthis.installInsertHandler(graph);\n\n\t// Redirects the function for creating the\n\t// popupmenu items\n\tgraph.popupMenuHandler.factoryMethod =\n\t\tmxUtils.bind(this, function(menu, cell, evt)\n\t\t{\n\t\t\treturn this.createPopupMenu(menu, cell, evt);\n\t\t});\n\n\t// Redirects the function for creating\n\t// new connections in the diagram\n\tgraph.connectionHandler.factoryMethod =\n\t\tmxUtils.bind(this, function(source, target)\n\t\t{\n\t\t\treturn this.createEdge(source, target);\n\t\t});\n\n\t// Maintains swimlanes and installs autolayout\n\tthis.createSwimlaneManager(graph);\n\tthis.createLayoutManager(graph);\n\n\treturn graph;\n};\n\n/**\n * Function: createSwimlaneManager\n *\n * Sets the graph's container using <mxGraph.init>.\n */\nmxEditor.prototype.createSwimlaneManager = function (graph)\n{\n\tvar swimlaneMgr = new mxSwimlaneManager(graph, false);\n\n\tswimlaneMgr.isHorizontal = mxUtils.bind(this, function()\n\t{\n\t\treturn this.horizontalFlow;\n\t});\n\n\tswimlaneMgr.isEnabled = mxUtils.bind(this, function()\n\t{\n\t\treturn this.maintainSwimlanes;\n\t});\n\n\treturn swimlaneMgr;\n};\n\n/**\n * Function: createLayoutManager\n *\n * Creates a layout manager for the swimlane and diagram layouts, that\n * is, the locally defined inter- and intraswimlane layouts.\n */\nmxEditor.prototype.createLayoutManager = function (graph)\n{\n\tvar layoutMgr = new mxLayoutManager(graph);\n\n\tvar self = this; // closure\n\tlayoutMgr.getLayout = function(cell)\n\t{\n\t\tvar layout = null;\n\t\tvar model = self.graph.getModel();\n\n\t\tif (model.getParent(cell) != null)\n\t\t{\n\t\t\t// Executes the swimlane layout if a child of\n\t\t\t// a swimlane has been changed. The layout is\n\t\t\t// lazy created in createSwimlaneLayout.\n\t\t\tif (self.layoutSwimlanes &&\n\t\t\t\tgraph.isSwimlane(cell))\n\t\t\t{\n\t\t\t\tif (self.swimlaneLayout == null)\n\t\t\t\t{\n\t\t\t\t\tself.swimlaneLayout = self.createSwimlaneLayout();\n\t\t\t\t}\n\n\t\t\t\tlayout = self.swimlaneLayout;\n\t\t\t}\n\n\t\t\t// Executes the diagram layout if the modified\n\t\t\t// cell is a top-level cell. The layout is\n\t\t\t// lazy created in createDiagramLayout.\n\t\t\telse if (self.layoutDiagram &&\n\t\t\t\t(graph.isValidRoot(cell) ||\n\t\t\t\tmodel.getParent(model.getParent(cell)) == null))\n\t\t\t{\n\t\t\t\tif (self.diagramLayout == null)\n\t\t\t\t{\n\t\t\t\t\tself.diagramLayout = self.createDiagramLayout();\n\t\t\t\t}\n\n\t\t\t\tlayout = self.diagramLayout;\n\t\t\t}\n\t\t}\n\n\t\treturn layout;\n\t};\n\n\treturn layoutMgr;\n};\n\n/**\n * Function: setGraphContainer\n *\n * Sets the graph's container using <mxGraph.init>.\n */\nmxEditor.prototype.setGraphContainer = function (container)\n{\n\tif (this.graph.container == null)\n\t{\n\t\t// Creates the graph instance inside the given container and render hint\n\t\t//this.graph = new mxGraph(container, null, this.graphRenderHint);\n\t\tthis.graph.init(container);\n\n\t\t// Install rubberband selection as the last\n\t\t// action handler in the chain\n\t\tthis.rubberband = new mxRubberband(this.graph);\n\n\t\t// Disables the context menu\n\t\tif (this.disableContextMenu)\n\t\t{\n\t\t\tmxEvent.disableContextMenu(container);\n\t\t}\n\n\t\t// Workaround for stylesheet directives in IE\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tnew mxDivResizer(container);\n\t\t}\n\t}\n};\n\n/**\n * Function: installDblClickHandler\n *\n * Overrides <mxGraph.dblClick> to invoke <dblClickAction>\n * on a cell and reset the selection tool in the toolbar.\n */\nmxEditor.prototype.installDblClickHandler = function (graph)\n{\n\t// Installs a listener for double click events\n\tgraph.addListener(mxEvent.DOUBLE_CLICK,\n\t\tmxUtils.bind(this, function(sender, evt)\n\t\t{\n\t\t\tvar cell = evt.getProperty('cell');\n\n\t\t\tif (cell != null &&\n\t\t\t\tgraph.isEnabled() &&\n\t\t\t\tthis.dblClickAction != null)\n\t\t\t{\n\t\t\t\tthis.execute(this.dblClickAction, cell);\n\t\t\t\tevt.consume();\n\t\t\t}\n\t\t})\n\t);\n};\n\n/**\n * Function: installUndoHandler\n *\n * Adds the <undoManager> to the graph model and the view.\n */\nmxEditor.prototype.installUndoHandler = function (graph)\n{\n\tvar listener = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\tvar edit = evt.getProperty('edit');\n\t\tthis.undoManager.undoableEditHappened(edit);\n\t});\n\n\tgraph.getModel().addListener(mxEvent.UNDO, listener);\n\tgraph.getView().addListener(mxEvent.UNDO, listener);\n\n\t// Keeps the selection state in sync\n\tvar undoHandler = function(sender, evt)\n\t{\n\t\tvar changes = evt.getProperty('edit').changes;\n\t\tgraph.setSelectionCells(graph.getSelectionCellsForChanges(changes));\n\t};\n\n\tthis.undoManager.addListener(mxEvent.UNDO, undoHandler);\n\tthis.undoManager.addListener(mxEvent.REDO, undoHandler);\n};\n\n/**\n * Function: installDrillHandler\n *\n * Installs listeners for dispatching the <root> event.\n */\nmxEditor.prototype.installDrillHandler = function (graph)\n{\n\tvar listener = mxUtils.bind(this, function(sender)\n\t{\n\t\tthis.fireEvent(new mxEventObject(mxEvent.ROOT));\n\t});\n\n\tgraph.getView().addListener(mxEvent.DOWN, listener);\n\tgraph.getView().addListener(mxEvent.UP, listener);\n};\n\n/**\n * Function: installChangeHandler\n *\n * Installs the listeners required to automatically validate\n * the graph. On each change of the root, this implementation\n * fires a <root> event.\n */\nmxEditor.prototype.installChangeHandler = function (graph)\n{\n\tvar listener = mxUtils.bind(this, function(sender, evt)\n\t{\n\t\t// Updates the modified state\n\t\tthis.setModified(true);\n\n\t\t// Automatically validates the graph\n\t\t// after each change\n\t\tif (this.validating == true)\n\t\t{\n\t\t\tgraph.validateGraph();\n\t\t}\n\n\t\t// Checks if the root has been changed\n\t\tvar changes = evt.getProperty('edit').changes;\n\n\t\tfor (var i = 0; i < changes.length; i++)\n\t\t{\n\t\t\tvar change = changes[i];\n\n\t\t\tif (change instanceof mxRootChange ||\n\t\t\t\t(change instanceof mxValueChange &&\n\t\t\t\tchange.cell == this.graph.model.root) ||\n\t\t\t\t(change instanceof mxCellAttributeChange &&\n\t\t\t\tchange.cell == this.graph.model.root))\n\t\t\t{\n\t\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ROOT));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n\n\tgraph.getModel().addListener(mxEvent.CHANGE, listener);\n};\n\n/**\n * Function: installInsertHandler\n *\n * Installs the handler for invoking <insertFunction> if\n * one is defined.\n */\nmxEditor.prototype.installInsertHandler = function (graph)\n{\n\tvar self = this; // closure\n\tvar insertHandler =\n\t{\n\t\tmouseDown: function(sender, me)\n\t\t{\n\t\t\tif (self.insertFunction != null &&\n\t\t\t\t!me.isPopupTrigger() &&\n\t\t\t\t(self.forcedInserting ||\n\t\t\t\tme.getState() == null))\n\t\t\t{\n\t\t\t\tself.graph.clearSelection();\n\t\t\t\tself.insertFunction(me.getEvent(), me.getCell());\n\n\t\t\t\t// Consumes the rest of the events\n\t\t\t\t// for this gesture (down, move, up)\n\t\t\t\tthis.isActive = true;\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t},\n\n\t\tmouseMove: function(sender, me)\n\t\t{\n\t\t\tif (this.isActive)\n\t\t\t{\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t},\n\n\t\tmouseUp: function(sender, me)\n\t\t{\n\t\t\tif (this.isActive)\n\t\t\t{\n\t\t\t\tthis.isActive = false;\n\t\t\t\tme.consume();\n\t\t\t}\n\t\t}\n\t};\n\n\tgraph.addMouseListener(insertHandler);\n};\n\n/**\n * Function: createDiagramLayout\n *\n * Creates the layout instance used to layout the\n * swimlanes in the diagram.\n */\nmxEditor.prototype.createDiagramLayout = function ()\n{\n\tvar gs = this.graph.gridSize;\n\tvar layout = new mxStackLayout(this.graph, !this.horizontalFlow,\n\t\t this.swimlaneSpacing, 2*gs, 2*gs);\n\n\t// Overrides isIgnored to only take into account swimlanes\n\tlayout.isVertexIgnored = function(cell)\n\t{\n\t\treturn !layout.graph.isSwimlane(cell);\n\t};\n\n\treturn layout;\n};\n\n/**\n * Function: createSwimlaneLayout\n *\n * Creates the layout instance used to layout the\n * children of each swimlane.\n */\nmxEditor.prototype.createSwimlaneLayout = function ()\n{\n\treturn new mxCompactTreeLayout(this.graph, this.horizontalFlow);\n};\n\n/**\n * Function: createToolbar\n *\n * Creates the <toolbar> with no container.\n */\nmxEditor.prototype.createToolbar = function ()\n{\n\treturn new mxDefaultToolbar(null, this);\n};\n\n/**\n * Function: setToolbarContainer\n *\n * Initializes the toolbar for the given container.\n */\nmxEditor.prototype.setToolbarContainer = function (container)\n{\n\tthis.toolbar.init(container);\n\n\t// Workaround for stylesheet directives in IE\n\tif (mxClient.IS_QUIRKS)\n\t{\n\t\tnew mxDivResizer(container);\n\t}\n};\n\n/**\n * Function: setStatusContainer\n *\n * Creates the <status> using the specified container.\n *\n * This implementation adds listeners in the editor to\n * display the last saved time and the current filename\n * in the status bar.\n *\n * Parameters:\n *\n * container - DOM node that will contain the statusbar.\n */\nmxEditor.prototype.setStatusContainer = function (container)\n{\n\tif (this.status == null)\n\t{\n\t\tthis.status = container;\n\n\t\t// Prints the last saved time in the status bar\n\t\t// when files are saved\n\t\tthis.addListener(mxEvent.SAVE, mxUtils.bind(this, function()\n\t\t{\n\t\t\tvar tstamp = new Date().toLocaleString();\n\t\t\tthis.setStatus((mxResources.get(this.lastSavedResource) ||\n\t\t\t\tthis.lastSavedResource)+': '+tstamp);\n\t\t}));\n\n\t\t// Updates the statusbar to display the filename\n\t\t// when new files are opened\n\t\tthis.addListener(mxEvent.OPEN, mxUtils.bind(this, function()\n\t\t{\n\t\t\tthis.setStatus((mxResources.get(this.currentFileResource) ||\n\t\t\t\tthis.currentFileResource)+': '+this.filename);\n\t\t}));\n\n\t\t// Workaround for stylesheet directives in IE\n\t\tif (mxClient.IS_QUIRKS)\n\t\t{\n\t\t\tnew mxDivResizer(container);\n\t\t}\n\t}\n};\n\n/**\n * Function: setStatus\n *\n * Display the specified message in the status bar.\n *\n * Parameters:\n *\n * message - String the specified the message to\n * be displayed.\n */\nmxEditor.prototype.setStatus = function (message)\n{\n\tif (this.status != null && message != null)\n\t{\n\t\tthis.status.innerHTML = message;\n\t}\n};\n\n/**\n * Function: setTitleContainer\n *\n * Creates a listener to update the inner HTML of the\n * specified DOM node with the value of <getTitle>.\n *\n * Parameters:\n *\n * container - DOM node that will contain the title.\n */\nmxEditor.prototype.setTitleContainer = function (container)\n{\n\tthis.addListener(mxEvent.ROOT, mxUtils.bind(this, function(sender)\n\t{\n\t\tcontainer.innerHTML = this.getTitle();\n\t}));\n\n\t// Workaround for stylesheet directives in IE\n\tif (mxClient.IS_QUIRKS)\n\t{\n\t\tnew mxDivResizer(container);\n\t}\n};\n\n/**\n * Function: treeLayout\n *\n * Executes a vertical or horizontal compact tree layout\n * using the specified cell as an argument. The cell may\n * either be a group or the root of a tree.\n *\n * Parameters:\n *\n * cell - <mxCell> to use in the compact tree layout.\n * horizontal - Optional boolean to specify the tree's\n * orientation. Default is true.\n */\nmxEditor.prototype.treeLayout = function (cell, horizontal)\n{\n\tif (cell != null)\n\t{\n\t\tvar layout = new mxCompactTreeLayout(this.graph, horizontal);\n\t\tlayout.execute(cell);\n\t}\n};\n\n/**\n * Function: getTitle\n *\n * Returns the string value for the current root of the\n * diagram.\n */\nmxEditor.prototype.getTitle = function ()\n{\n\tvar title = '';\n\tvar graph = this.graph;\n\tvar cell = graph.getCurrentRoot();\n\n\twhile (cell != null &&\n\t\t   graph.getModel().getParent(\n\t\t\t\tgraph.getModel().getParent(cell)) != null)\n\t{\n\t\t// Append each label of a valid root\n\t\tif (graph.isValidRoot(cell))\n\t\t{\n\t\t\ttitle = ' > ' +\n\t\t\tgraph.convertValueToString(cell) + title;\n\t\t}\n\n\t\tcell = graph.getModel().getParent(cell);\n\t}\n\n\tvar prefix = this.getRootTitle();\n\n\treturn prefix + title;\n};\n\n/**\n * Function: getRootTitle\n *\n * Returns the string value of the root cell in\n * <mxGraph.model>.\n */\nmxEditor.prototype.getRootTitle = function ()\n{\n\tvar root = this.graph.getModel().getRoot();\n\treturn this.graph.convertValueToString(root);\n};\n\n/**\n * Function: undo\n *\n * Undo the last change in <graph>.\n */\nmxEditor.prototype.undo = function ()\n{\n\tthis.undoManager.undo();\n};\n\n/**\n * Function: redo\n *\n * Redo the last change in <graph>.\n */\nmxEditor.prototype.redo = function ()\n{\n\tthis.undoManager.redo();\n};\n\n/**\n * Function: groupCells\n *\n * Invokes <createGroup> to create a new group cell and the invokes\n * <mxGraph.groupCells>, using the grid size of the graph as the spacing\n * in the group's content area.\n */\nmxEditor.prototype.groupCells = function ()\n{\n\tvar border = (this.groupBorderSize != null) ?\n\t\tthis.groupBorderSize :\n\t\tthis.graph.gridSize;\n\treturn this.graph.groupCells(this.createGroup(), border);\n};\n\n/**\n * Function: createGroup\n *\n * Creates and returns a clone of <defaultGroup> to be used\n * as a new group cell in <group>.\n */\nmxEditor.prototype.createGroup = function ()\n{\n\tvar model = this.graph.getModel();\n\n\treturn model.cloneCell(this.defaultGroup);\n};\n\n/**\n * Function: open\n *\n * Opens the specified file synchronously and parses it using\n * <readGraphModel>. It updates <filename> and fires an <open>-event after\n * the file has been opened. Exceptions should be handled as follows:\n *\n * (code)\n * try\n * {\n *   editor.open(filename);\n * }\n * catch (e)\n * {\n *   mxUtils.error('Cannot open ' + filename +\n *     ': ' + e.message, 280, true);\n * }\n * (end)\n *\n * Parameters:\n *\n * filename - URL of the file to be opened.\n */\nmxEditor.prototype.open = function (filename)\n{\n\tif (filename != null)\n\t{\n\t\tvar xml = mxUtils.load(filename).getXml();\n\t\tthis.readGraphModel(xml.documentElement);\n\t\tthis.filename = filename;\n\n\t\tthis.fireEvent(new mxEventObject(mxEvent.OPEN, 'filename', filename));\n\t}\n};\n\n/**\n * Function: readGraphModel\n *\n * Reads the specified XML node into the existing graph model and resets\n * the command history and modified state.\n */\nmxEditor.prototype.readGraphModel = function (node)\n{\n\tvar dec = new mxCodec(node.ownerDocument);\n\tdec.decode(node, this.graph.getModel());\n\tthis.resetHistory();\n};\n\n/**\n * Function: save\n *\n * Posts the string returned by <writeGraphModel> to the given URL or the\n * URL returned by <getUrlPost>. The actual posting is carried out by\n * <postDiagram>. If the URL is null then the resulting XML will be\n * displayed using <mxUtils.popup>. Exceptions should be handled as\n * follows:\n *\n * (code)\n * try\n * {\n *   editor.save();\n * }\n * catch (e)\n * {\n *   mxUtils.error('Cannot save : ' + e.message, 280, true);\n * }\n * (end)\n */\nmxEditor.prototype.save = function (url, linefeed)\n{\n\t// Gets the URL to post the data to\n\turl = url || this.getUrlPost();\n\n\t// Posts the data if the URL is not empty\n\tif (url != null && url.length > 0)\n\t{\n\t\tvar data = this.writeGraphModel(linefeed);\n\t\tthis.postDiagram(url, data);\n\n\t\t// Resets the modified flag\n\t\tthis.setModified(false);\n\t}\n\n\t// Dispatches a save event\n\tthis.fireEvent(new mxEventObject(mxEvent.SAVE, 'url', url));\n};\n\n/**\n * Function: postDiagram\n *\n * Hook for subclassers to override the posting of a diagram\n * represented by the given node to the given URL. This fires\n * an asynchronous <post> event if the diagram has been posted.\n *\n * Example:\n *\n * To replace the diagram with the diagram in the response, use the\n * following code.\n *\n * (code)\n * editor.addListener(mxEvent.POST, function(sender, evt)\n * {\n *   // Process response (replace diagram)\n *   var req = evt.getProperty('request');\n *   var root = req.getDocumentElement();\n *   editor.graph.readGraphModel(root)\n * });\n * (end)\n */\nmxEditor.prototype.postDiagram = function (url, data)\n{\n\tif (this.escapePostData)\n\t{\n\t\tdata = encodeURIComponent(data);\n\t}\n\n\tmxUtils.post(url, this.postParameterName+'='+data,\n\t\tmxUtils.bind(this, function(req)\n\t\t{\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.POST,\n\t\t\t\t'request', req, 'url', url, 'data', data));\n\t\t})\n\t);\n};\n\n/**\n * Function: writeGraphModel\n *\n * Hook to create the string representation of the diagram. The default\n * implementation uses an <mxCodec> to encode the graph model as\n * follows:\n *\n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(this.graph.getModel());\n * return mxUtils.getXml(node, this.linefeed);\n * (end)\n *\n * Parameters:\n *\n * linefeed - Optional character to be used as the linefeed. Default is\n * <linefeed>.\n */\nmxEditor.prototype.writeGraphModel = function (linefeed)\n{\n\tlinefeed = (linefeed != null) ? linefeed : this.linefeed;\n\tvar enc = new mxCodec();\n\tvar node = enc.encode(this.graph.getModel());\n\n\treturn mxUtils.getXml(node, linefeed);\n};\n\n/**\n * Function: getUrlPost\n *\n * Returns the URL to post the diagram to. This is used\n * in <save>. The default implementation returns <urlPost>,\n * adding <code>?draft=true</code>.\n */\nmxEditor.prototype.getUrlPost = function ()\n{\n\treturn this.urlPost;\n};\n\n/**\n * Function: getUrlImage\n *\n * Returns the URL to create the image with. This is typically\n * the URL of a backend which accepts an XML representation\n * of a graph view to create an image. The function is used\n * in the image action to create an image. This implementation\n * returns <urlImage>.\n */\nmxEditor.prototype.getUrlImage = function ()\n{\n\treturn this.urlImage;\n};\n\n/**\n * Function: swapStyles\n *\n * Swaps the styles for the given names in the graph's\n * stylesheet and refreshes the graph.\n */\nmxEditor.prototype.swapStyles = function (first, second)\n{\n\tvar style = this.graph.getStylesheet().styles[second];\n\tthis.graph.getView().getStylesheet().putCellStyle(\n\t\tsecond, this.graph.getStylesheet().styles[first]);\n\tthis.graph.getStylesheet().putCellStyle(first, style);\n\tthis.graph.refresh();\n};\n\n/**\n * Function: showProperties\n *\n * Creates and shows the properties dialog for the given\n * cell. The content area of the dialog is created using\n * <createProperties>.\n */\nmxEditor.prototype.showProperties = function (cell)\n{\n\tcell = cell || this.graph.getSelectionCell();\n\n\t// Uses the root node for the properties dialog\n\t// if not cell was passed in and no cell is\n\t// selected\n\tif (cell == null)\n\t{\n\t\tcell = this.graph.getCurrentRoot();\n\n\t\tif (cell == null)\n\t\t{\n\t\t\tcell = this.graph.getModel().getRoot();\n\t\t}\n\t}\n\n\tif (cell != null)\n\t{\n\t\t// Makes sure there is no in-place editor in the\n\t\t// graph and computes the location of the dialog\n\t\tthis.graph.stopEditing(true);\n\n\t\tvar offset = mxUtils.getOffset(this.graph.container);\n\t\tvar x = offset.x+10;\n\t\tvar y = offset.y;\n\n\t\t// Avoids moving the dialog if it is alredy open\n\t\tif (this.properties != null && !this.movePropertiesDialog)\n\t\t{\n\t\t\tx = this.properties.getX();\n\t\t\ty = this.properties.getY();\n\t\t}\n\n\t\t// Places the dialog near the cell for which it\n\t\t// displays the properties\n\t\telse\n\t\t{\n\t\t\tvar bounds = this.graph.getCellBounds(cell);\n\n\t\t\tif (bounds != null)\n\t\t\t{\n\t\t\t\tx += bounds.x+Math.min(200, bounds.width);\n\t\t\t\ty += bounds.y;\n\t\t\t}\n\t\t}\n\n\t\t// Hides the existing properties dialog and creates a new one with the\n\t\t// contents created in the hook method\n\t\tthis.hideProperties();\n\t\tvar node = this.createProperties(cell);\n\n\t\tif (node != null)\n\t\t{\n\t\t\t// Displays the contents in a window and stores a reference to the\n\t\t\t// window for later hiding of the window\n\t\t\tthis.properties = new mxWindow(mxResources.get(this.propertiesResource) ||\n\t\t\t\tthis.propertiesResource, node, x, y, this.propertiesWidth, this.propertiesHeight, false);\n\t\t\tthis.properties.setVisible(true);\n\t\t}\n\t}\n};\n\n/**\n * Function: isPropertiesVisible\n *\n * Returns true if the properties dialog is currently visible.\n */\nmxEditor.prototype.isPropertiesVisible = function ()\n{\n\treturn this.properties != null;\n};\n\n/**\n * Function: createProperties\n *\n * Creates and returns the DOM node that represents the contents\n * of the properties dialog for the given cell. This implementation\n * works for user objects that are XML nodes and display all the\n * node attributes in a form.\n */\nmxEditor.prototype.createProperties = function (cell)\n{\n\tvar model = this.graph.getModel();\n\tvar value = model.getValue(cell);\n\n\tif (mxUtils.isNode(value))\n\t{\n\t\t// Creates a form for the user object inside\n\t\t// the cell\n\t\tvar form = new mxForm('properties');\n\n\t\t// Adds a readonly field for the cell id\n\t\tvar id = form.addText('ID', cell.getId());\n\t\tid.setAttribute('readonly', 'true');\n\n\t\tvar geo = null;\n\t\tvar yField = null;\n\t\tvar xField = null;\n\t\tvar widthField = null;\n\t\tvar heightField = null;\n\n\t\t// Adds fields for the location and size\n\t\tif (model.isVertex(cell))\n\t\t{\n\t\t\tgeo = model.getGeometry(cell);\n\n\t\t\tif (geo != null)\n\t\t\t{\n\t\t\t\tyField = form.addText('top', geo.y);\n\t\t\t\txField = form.addText('left', geo.x);\n\t\t\t\twidthField = form.addText('width', geo.width);\n\t\t\t\theightField = form.addText('height', geo.height);\n\t\t\t}\n\t\t}\n\n\t\t// Adds a field for the cell style\n\t\tvar tmp = model.getStyle(cell);\n\t\tvar style = form.addText('Style', tmp || '');\n\n\t\t// Creates textareas for each attribute of the\n\t\t// user object within the cell\n\t\tvar attrs = value.attributes;\n\t\tvar texts = [];\n\n\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t{\n\t\t\t// Creates a textarea with more lines for\n\t\t\t// the cell label\n\t\t\tvar val = attrs[i].value;\n\t\t\ttexts[i] = form.addTextarea(attrs[i].nodeName, val,\n\t\t\t\t(attrs[i].nodeName == 'label') ? 4 : 2);\n\t\t}\n\n\t\t// Adds an OK and Cancel button to the dialog\n\t\t// contents and implements the respective\n\t\t// actions below\n\n\t\t// Defines the function to be executed when the\n\t\t// OK button is pressed in the dialog\n\t\tvar okFunction = mxUtils.bind(this, function()\n\t\t{\n\t\t\t// Hides the dialog\n\t\t\tthis.hideProperties();\n\n\t\t\t// Supports undo for the changes on the underlying\n\t\t\t// XML structure / XML node attribute changes.\n\t\t\tmodel.beginUpdate();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (geo != null)\n\t\t\t\t{\n\t\t\t\t\tgeo = geo.clone();\n\n\t\t\t\t\tgeo.x = parseFloat(xField.value);\n\t\t\t\t\tgeo.y = parseFloat(yField.value);\n\t\t\t\t\tgeo.width = parseFloat(widthField.value);\n\t\t\t\t\tgeo.height = parseFloat(heightField.value);\n\n\t\t\t\t\tmodel.setGeometry(cell, geo);\n\t\t\t\t}\n\n\t\t\t\t// Applies the style\n\t\t\t\tif (style.value.length > 0)\n\t\t\t\t{\n\t\t\t\t\tmodel.setStyle(cell, style.value);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmodel.setStyle(cell, null);\n\t\t\t\t}\n\n\t\t\t\t// Creates an undoable change for each\n\t\t\t\t// attribute and executes it using the\n\t\t\t\t// model, which will also make the change\n\t\t\t\t// part of the current transaction\n\t\t\t\tfor (var i=0; i<attrs.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar edit = new mxCellAttributeChange(\n\t\t\t\t\t\tcell, attrs[i].nodeName,\n\t\t\t\t\t\ttexts[i].value);\n\t\t\t\t\tmodel.execute(edit);\n\t\t\t\t}\n\n\t\t\t\t// Checks if the graph wants cells to\n\t\t\t\t// be automatically sized and updates\n\t\t\t\t// the size as an undoable step if\n\t\t\t\t// the feature is enabled\n\t\t\t\tif (this.graph.isAutoSizeCell(cell))\n\t\t\t\t{\n\t\t\t\t\tthis.graph.updateCellSize(cell);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmodel.endUpdate();\n\t\t\t}\n\t\t});\n\n\t\t// Defines the function to be executed when the\n\t\t// Cancel button is pressed in the dialog\n\t\tvar cancelFunction = mxUtils.bind(this, function()\n\t\t{\n\t\t\t// Hides the dialog\n\t\t\tthis.hideProperties();\n\t\t});\n\n\t\tform.addButtons(okFunction, cancelFunction);\n\n\t\treturn form.table;\n\t}\n\n\treturn null;\n};\n\n/**\n * Function: hideProperties\n *\n * Hides the properties dialog.\n */\nmxEditor.prototype.hideProperties = function ()\n{\n\tif (this.properties != null)\n\t{\n\t\tthis.properties.destroy();\n\t\tthis.properties = null;\n\t}\n};\n\n/**\n * Function: showTasks\n *\n * Shows the tasks window. The tasks window is created using <createTasks>. The\n * default width of the window is 200 pixels, the y-coordinate of the location\n * can be specifies in <tasksTop> and the x-coordinate is right aligned with a\n * 20 pixel offset from the right border. To change the location of the tasks\n * window, the following code can be used:\n *\n * (code)\n * var oldShowTasks = mxEditor.prototype.showTasks;\n * mxEditor.prototype.showTasks = function()\n * {\n *   oldShowTasks.apply(this, arguments); // \"supercall\"\n *\n *   if (this.tasks != null)\n *   {\n *     this.tasks.setLocation(10, 10);\n *   }\n * };\n * (end)\n */\nmxEditor.prototype.showTasks = function ()\n{\n\tif (this.tasks == null)\n\t{\n\t\tvar div = document.createElement('div');\n\t\tdiv.style.padding = '4px';\n\t\tdiv.style.paddingLeft = '20px';\n\t\tvar w = document.body.clientWidth;\n\t\tvar wnd = new mxWindow(\n\t\t\tmxResources.get(this.tasksResource) ||\n\t\t\tthis.tasksResource,\n\t\t\tdiv, w - 220, this.tasksTop, 200);\n\t\twnd.setClosable(true);\n\t\twnd.destroyOnClose = false;\n\n\t\t// Installs a function to update the contents\n\t\t// of the tasks window on every change of the\n\t\t// model, selection or root.\n\t\tvar funct = mxUtils.bind(this, function(sender)\n\t\t{\n\t\t\tmxEvent.release(div);\n\t\t\tdiv.innerHTML = '';\n\t\t\tthis.createTasks(div);\n\t\t});\n\n\t\tthis.graph.getModel().addListener(mxEvent.CHANGE, funct);\n\t\tthis.graph.getSelectionModel().addListener(mxEvent.CHANGE, funct);\n\t\tthis.graph.addListener(mxEvent.ROOT, funct);\n\n\t\t// Assigns the icon to the tasks window\n\t\tif (this.tasksWindowImage != null)\n\t\t{\n\t\t\twnd.setImage(this.tasksWindowImage);\n\t\t}\n\n\t\tthis.tasks = wnd;\n\t\tthis.createTasks(div);\n\t}\n\n\tthis.tasks.setVisible(true);\n};\n\n/**\n * Function: refreshTasks\n *\n * Updates the contents of the tasks window using <createTasks>.\n */\nmxEditor.prototype.refreshTasks = function (div)\n{\n\tif (this.tasks != null)\n\t{\n\t\tvar div = this.tasks.content;\n\t\tmxEvent.release(div);\n\t\tdiv.innerHTML = '';\n\t\tthis.createTasks(div);\n\t}\n};\n\n/**\n * Function: createTasks\n *\n * Updates the contents of the given DOM node to\n * display the tasks associated with the current\n * editor state. This is invoked whenever there\n * is a possible change of state in the editor.\n * Default implementation is empty.\n */\nmxEditor.prototype.createTasks = function (div)\n{\n\t// override\n};\n\n/**\n * Function: showHelp\n *\n * Shows the help window. If the help window does not exist\n * then it is created using an iframe pointing to the resource\n * for the <code>urlHelp</code> key or <urlHelp> if the resource\n * is undefined.\n */\nmxEditor.prototype.showHelp = function (tasks)\n{\n\tif (this.help == null)\n\t{\n\t\tvar frame = document.createElement('iframe');\n\t\tframe.setAttribute('src', mxResources.get('urlHelp') || this.urlHelp);\n\t\tframe.setAttribute('height', '100%');\n\t\tframe.setAttribute('width', '100%');\n\t\tframe.setAttribute('frameBorder', '0');\n\t\tframe.style.backgroundColor = 'white';\n\n\t\tvar w = document.body.clientWidth;\n\t\tvar h = (document.body.clientHeight || document.documentElement.clientHeight);\n\n\t\tvar wnd = new mxWindow(mxResources.get(this.helpResource) || this.helpResource,\n\t\t\tframe, (w-this.helpWidth)/2, (h-this.helpHeight)/3, this.helpWidth, this.helpHeight);\n\t\twnd.setMaximizable(true);\n\t\twnd.setClosable(true);\n\t\twnd.destroyOnClose = false;\n\t\twnd.setResizable(true);\n\n\t\t// Assigns the icon to the help window\n\t\tif (this.helpWindowImage != null)\n\t\t{\n\t\t\twnd.setImage(this.helpWindowImage);\n\t\t}\n\n\t\t// Workaround for ignored iframe height 100% in FF\n\t\tif (mxClient.IS_NS)\n\t\t{\n\t\t\tvar handler = function(sender)\n\t\t\t{\n\t\t\t\tvar h = wnd.div.offsetHeight;\n\t\t\t\tframe.setAttribute('height', (h-26)+'px');\n\t\t\t};\n\n\t\t\twnd.addListener(mxEvent.RESIZE_END, handler);\n\t\t\twnd.addListener(mxEvent.MAXIMIZE, handler);\n\t\t\twnd.addListener(mxEvent.NORMALIZE, handler);\n\t\t\twnd.addListener(mxEvent.SHOW, handler);\n\t\t}\n\n\t\tthis.help = wnd;\n\t}\n\n\tthis.help.setVisible(true);\n};\n\n/**\n * Function: showOutline\n *\n * Shows the outline window. If the window does not exist, then it is\n * created using an <mxOutline>.\n */\nmxEditor.prototype.showOutline = function ()\n{\n\tvar create = this.outline == null;\n\n\tif (create)\n\t{\n\t\tvar div = document.createElement('div');\n\n\t\tdiv.style.overflow = 'hidden';\n\t\tdiv.style.position = 'relative';\n\t\tdiv.style.width = '100%';\n\t\tdiv.style.height = '100%';\n\t\tdiv.style.background = 'white';\n\t\tdiv.style.cursor = 'move';\n\n\t\tif (document.documentMode == 8)\n\t\t{\n\t\t\tdiv.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n\t\t}\n\n\t\tvar wnd = new mxWindow(\n\t\t\tmxResources.get(this.outlineResource) ||\n\t\t\tthis.outlineResource,\n\t\t\tdiv, 600, 480, 200, 200, false);\n\n\t\t// Creates the outline in the specified div\n\t\t// and links it to the existing graph\n\t\tvar outline = new mxOutline(this.graph, div);\n\t\twnd.setClosable(true);\n\t\twnd.setResizable(true);\n\t\twnd.destroyOnClose = false;\n\n\t\twnd.addListener(mxEvent.RESIZE_END, function()\n\t\t{\n\t\t\toutline.update();\n\t\t});\n\n\t\tthis.outline = wnd;\n\t\tthis.outline.outline = outline;\n\t}\n\n\t// Finally shows the outline\n\tthis.outline.setVisible(true);\n\tthis.outline.outline.update(true);\n};\n\n/**\n * Function: setMode\n *\n * Puts the graph into the specified mode. The following modenames are\n * supported:\n *\n * select - Selects using the left mouse button, new connections\n * are disabled.\n * connect - Selects using the left mouse button or creates new\n * connections if mouse over cell hotspot. See <mxConnectionHandler>.\n * pan - Pans using the left mouse button, new connections are disabled.\n */\nmxEditor.prototype.setMode = function(modename)\n{\n\tif (modename == 'select')\n\t{\n\t\tthis.graph.panningHandler.useLeftButtonForPanning = false;\n\t\tthis.graph.setConnectable(false);\n\t}\n\telse if (modename == 'connect')\n\t{\n\t\tthis.graph.panningHandler.useLeftButtonForPanning = false;\n\t\tthis.graph.setConnectable(true);\n\t}\n\telse if (modename == 'pan')\n\t{\n\t\tthis.graph.panningHandler.useLeftButtonForPanning = true;\n\t\tthis.graph.setConnectable(false);\n\t}\n};\n\n/**\n * Function: createPopupMenu\n *\n * Uses <popupHandler> to create the menu in the graph's\n * panning handler. The redirection is setup in\n * <setToolbarContainer>.\n */\nmxEditor.prototype.createPopupMenu = function (menu, cell, evt)\n{\n\tthis.popupHandler.createMenu(this, menu, cell, evt);\n};\n\n/**\n * Function: createEdge\n *\n * Uses <defaultEdge> as the prototype for creating new edges\n * in the connection handler of the graph. The style of the\n * edge will be overridden with the value returned by\n * <getEdgeStyle>.\n */\nmxEditor.prototype.createEdge = function (source, target)\n{\n\t// Clones the defaultedge prototype\n\tvar e = null;\n\n\tif (this.defaultEdge != null)\n\t{\n\t\tvar model = this.graph.getModel();\n\t\te = model.cloneCell(this.defaultEdge);\n\t}\n\telse\n\t{\n\t\te = new mxCell('');\n\t\te.setEdge(true);\n\n\t\tvar geo = new mxGeometry();\n\t\tgeo.relative = true;\n\t\te.setGeometry(geo);\n\t}\n\n\t// Overrides the edge style\n\tvar style = this.getEdgeStyle();\n\n\tif (style != null)\n\t{\n\t\te.setStyle(style);\n\t}\n\n\treturn e;\n};\n\n/**\n * Function: getEdgeStyle\n *\n * Returns a string identifying the style of new edges.\n * The function is used in <createEdge> when new edges\n * are created in the graph.\n */\nmxEditor.prototype.getEdgeStyle = function ()\n{\n\treturn this.defaultEdgeStyle;\n};\n\n/**\n * Function: consumeCycleAttribute\n *\n * Returns the next attribute in <cycleAttributeValues>\n * or null, if not attribute should be used in the\n * specified cell.\n */\nmxEditor.prototype.consumeCycleAttribute = function (cell)\n{\n\treturn (this.cycleAttributeValues != null &&\n\t\tthis.cycleAttributeValues.length > 0 &&\n\t\tthis.graph.isSwimlane(cell)) ?\n\t\tthis.cycleAttributeValues[this.cycleAttributeIndex++ %\n\t\t\tthis.cycleAttributeValues.length] : null;\n};\n\n/**\n * Function: cycleAttribute\n *\n * Uses the returned value from <consumeCycleAttribute>\n * as the value for the <cycleAttributeName> key in\n * the given cell's style.\n */\nmxEditor.prototype.cycleAttribute = function (cell)\n{\n\tif (this.cycleAttributeName != null)\n\t{\n\t\tvar value = this.consumeCycleAttribute(cell);\n\n\t\tif (value != null)\n\t\t{\n\t\t\tcell.setStyle(cell.getStyle()+';'+\n\t\t\t\tthis.cycleAttributeName+'='+value);\n\t\t}\n\t}\n};\n\n/**\n * Function: addVertex\n *\n * Adds the given vertex as a child of parent at the specified\n * x and y coordinate and fires an <addVertex> event.\n */\nmxEditor.prototype.addVertex = function (parent, vertex, x, y)\n{\n\tvar model = this.graph.getModel();\n\n\twhile (parent != null && !this.graph.isValidDropTarget(parent))\n\t{\n\t\tparent = model.getParent(parent);\n\t}\n\n\tparent = (parent != null) ? parent : this.graph.getSwimlaneAt(x, y);\n\tvar scale = this.graph.getView().scale;\n\n\tvar geo = model.getGeometry(vertex);\n\tvar pgeo = model.getGeometry(parent);\n\n\tif (this.graph.isSwimlane(vertex) &&\n\t\t!this.graph.swimlaneNesting)\n\t{\n\t\tparent = null;\n\t}\n\telse if (parent == null && this.swimlaneRequired)\n\t{\n\t\treturn null;\n\t}\n\telse if (parent != null && pgeo != null)\n\t{\n\t\t// Keeps vertex inside parent\n\t\tvar state = this.graph.getView().getState(parent);\n\n\t\tif (state != null)\n\t\t{\n\t\t\tx -= state.origin.x * scale;\n\t\t\ty -= state.origin.y * scale;\n\n\t\t\tif (this.graph.isConstrainedMoving)\n\t\t\t{\n\t\t\t\tvar width = geo.width;\n\t\t\t\tvar height = geo.height;\n\t\t\t\tvar tmp = state.x+state.width;\n\n\t\t\t\tif (x+width > tmp)\n\t\t\t\t{\n\t\t\t\t\tx -= x+width - tmp;\n\t\t\t\t}\n\n\t\t\t\ttmp = state.y+state.height;\n\n\t\t\t\tif (y+height > tmp)\n\t\t\t\t{\n\t\t\t\t\ty -= y+height - tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (pgeo != null)\n\t\t{\n\t\t\tx -= pgeo.x*scale;\n\t\t\ty -= pgeo.y*scale;\n\t\t}\n\t}\n\n\tgeo = geo.clone();\n\tgeo.x = this.graph.snap(x / scale -\n\t\tthis.graph.getView().translate.x -\n\t\tthis.graph.gridSize/2);\n\tgeo.y = this.graph.snap(y / scale -\n\t\tthis.graph.getView().translate.y -\n\t\tthis.graph.gridSize/2);\n\tvertex.setGeometry(geo);\n\n\tif (parent == null)\n\t{\n\t\tparent = this.graph.getDefaultParent();\n\t}\n\n\tthis.cycleAttribute(vertex);\n\tthis.fireEvent(new mxEventObject(mxEvent.BEFORE_ADD_VERTEX,\n\t\t\t'vertex', vertex, 'parent', parent));\n\n\tmodel.beginUpdate();\n\ttry\n\t{\n\t\tvertex = this.graph.addCell(vertex, parent);\n\n\t\tif (vertex != null)\n\t\t{\n\t\t\tthis.graph.constrainChild(vertex);\n\n\t\t\tthis.fireEvent(new mxEventObject(mxEvent.ADD_VERTEX, 'vertex', vertex));\n\t\t}\n\t}\n\tfinally\n\t{\n\t\tmodel.endUpdate();\n\t}\n\n\tif (vertex != null)\n\t{\n\t\tthis.graph.setSelectionCell(vertex);\n\t\tthis.graph.scrollCellToVisible(vertex);\n\t\tthis.fireEvent(new mxEventObject(mxEvent.AFTER_ADD_VERTEX, 'vertex', vertex));\n\t}\n\n\treturn vertex;\n};\n\n/**\n * Function: destroy\n *\n * Removes the editor and all its associated resources. This does not\n * normally need to be called, it is called automatically when the window\n * unloads.\n */\nmxEditor.prototype.destroy = function ()\n{\n\tif (!this.destroyed)\n\t{\n\t\tthis.destroyed = true;\n\n\t\tif (this.tasks != null)\n\t\t{\n\t\t\tthis.tasks.destroy();\n\t\t}\n\n\t\tif (this.outline != null)\n\t\t{\n\t\t\tthis.outline.destroy();\n\t\t}\n\n\t\tif (this.properties != null)\n\t\t{\n\t\t\tthis.properties.destroy();\n\t\t}\n\n\t\tif (this.keyHandler != null)\n\t\t{\n\t\t\tthis.keyHandler.destroy();\n\t\t}\n\n\t\tif (this.rubberband != null)\n\t\t{\n\t\t\tthis.rubberband.destroy();\n\t\t}\n\n\t\tif (this.toolbar != null)\n\t\t{\n\t\t\tthis.toolbar.destroy();\n\t\t}\n\n\t\tif (this.graph != null)\n\t\t{\n\t\t\tthis.graph.destroy();\n\t\t}\n\n\t\tthis.status = null;\n\t\tthis.templates = null;\n\t}\n};\n\n__mxOutput.mxEditor = typeof mxEditor !== 'undefined' ? mxEditor : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nvar mxCodecRegistry =\n{\n\t/**\n\t * Class: mxCodecRegistry\n\t *\n\t * Singleton class that acts as a global registry for codecs.\n\t *\n\t * Adding an <mxCodec>:\n\t *\n\t * 1. Define a default codec with a new instance of the\n\t * object to be handled.\n\t *\n\t * (code)\n\t * var codec = new mxObjectCodec(new mxGraphModel());\n\t * (end)\n\t *\n\t * 2. Define the functions required for encoding and decoding\n\t * objects.\n\t *\n\t * (code)\n\t * codec.encode = function(enc, obj) { ... }\n\t * codec.decode = function(dec, node, into) { ... }\n\t * (end)\n\t *\n\t * 3. Register the codec in the <mxCodecRegistry>.\n\t *\n\t * (code)\n\t * mxCodecRegistry.register(codec);\n\t * (end)\n\t *\n\t * <mxObjectCodec.decode> may be used to either create a new\n\t * instance of an object or to configure an existing instance,\n\t * in which case the into argument points to the existing\n\t * object. In this case, we say the codec \"configures\" the\n\t * object.\n\t *\n\t * Variable: codecs\n\t *\n\t * Maps from constructor names to codecs.\n\t */\n\tcodecs: [],\n\n\t/**\n\t * Variable: aliases\n\t *\n\t * Maps from classnames to codecnames.\n\t */\n\taliases: [],\n\n\t/**\n\t * Function: register\n\t *\n\t * Registers a new codec and associates the name of the template\n\t * constructor in the codec with the codec object.\n\t *\n\t * Parameters:\n\t *\n\t * codec - <mxObjectCodec> to be registered.\n\t */\n\tregister: function(codec)\n\t{\n\t\tif (codec != null)\n\t\t{\n\t\t\tvar name = codec.getName();\n\t\t\tmxCodecRegistry.codecs[name] = codec;\n\n\t\t\tvar classname = mxUtils.getFunctionName(codec.template.constructor);\n\n\t\t\tif (classname != name)\n\t\t\t{\n\t\t\t\tmxCodecRegistry.addAlias(classname, name);\n\t\t\t}\n\t\t}\n\n\t\treturn codec;\n\t},\n\n\t/**\n\t * Function: addAlias\n\t *\n\t * Adds an alias for mapping a classname to a codecname.\n\t */\n\taddAlias: function(classname, codecname)\n\t{\n\t\tmxCodecRegistry.aliases[classname] = codecname;\n\t},\n\n\t/**\n\t * Function: getCodec\n\t *\n\t * Returns a codec that handles objects that are constructed\n\t * using the given constructor.\n\t *\n\t * Parameters:\n\t *\n\t * ctor - JavaScript constructor function.\n\t */\n\tgetCodec: function(ctor)\n\t{\n\t\tvar codec = null;\n\n\t\tif (ctor != null)\n\t\t{\n\t\t\tvar name = mxUtils.getFunctionName(ctor);\n\t\t\tvar tmp = mxCodecRegistry.aliases[name];\n\n\t\t\tif (tmp != null)\n\t\t\t{\n\t\t\t\tname = tmp;\n\t\t\t}\n\n\t\t\tcodec = mxCodecRegistry.codecs[name];\n\n\t\t\t// Registers a new default codec for the given constructor\n\t\t\t// if no codec has been previously defined.\n\t\t\tif (codec == null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tcodec = new mxObjectCodec(new ctor());\n\t\t\t\t\tmxCodecRegistry.register(codec);\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn codec;\n\t}\n\n};\n\n__mxOutput.mxCodecRegistry = typeof mxCodecRegistry !== 'undefined' ? mxCodecRegistry : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxCodec\n *\n * XML codec for JavaScript object graphs. See <mxObjectCodec> for a\n * description of the general encoding/decoding scheme. This class uses the\n * codecs registered in <mxCodecRegistry> for encoding/decoding each object.\n *\n * References:\n *\n * In order to resolve references, especially forward references, the mxCodec\n * constructor must be given the document that contains the referenced\n * elements.\n *\n * Examples:\n *\n * The following code is used to encode a graph model.\n *\n * (code)\n * var encoder = new mxCodec();\n * var result = encoder.encode(graph.getModel());\n * var xml = mxUtils.getXml(result);\n * (end)\n *\n * Example:\n *\n * Using the code below, an XML document is decoded into an existing model. The\n * document may be obtained using one of the functions in mxUtils for loading\n * an XML file, eg. <mxUtils.get>, or using <mxUtils.parseXml> for parsing an\n * XML string.\n *\n * (code)\n * var doc = mxUtils.parseXml(xmlString);\n * var codec = new mxCodec(doc);\n * codec.decode(doc.documentElement, graph.getModel());\n * (end)\n *\n * Example:\n *\n * This example demonstrates parsing a list of isolated cells into an existing\n * graph model. Note that the cells do not have a parent reference so they can\n * be added anywhere in the cell hierarchy after parsing.\n *\n * (code)\n * var xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';\n * var doc = mxUtils.parseXml(xml);\n * var codec = new mxCodec(doc);\n * var elt = doc.documentElement.firstChild;\n * var cells = [];\n *\n * while (elt != null)\n * {\n *   cells.push(codec.decode(elt));\n *   elt = elt.nextSibling;\n * }\n *\n * graph.addCells(cells);\n * (end)\n *\n * Example:\n *\n * Using the following code, the selection cells of a graph are encoded and the\n * output is displayed in a dialog box.\n *\n * (code)\n * var enc = new mxCodec();\n * var cells = graph.getSelectionCells();\n * mxUtils.alert(mxUtils.getPrettyXml(enc.encode(cells)));\n * (end)\n *\n * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\n * must be passed to <mxUtils.getXml> as the second argument.\n *\n * Debugging:\n *\n * For debugging I/O you can use the following code to get the sequence of\n * encoded objects:\n *\n * (code)\n * var oldEncode = mxCodec.prototype.encode;\n * mxCodec.prototype.encode = function(obj)\n * {\n *   mxLog.show();\n *   mxLog.debug('mxCodec.encode: obj='+mxUtils.getFunctionName(obj.constructor));\n *\n *   return oldEncode.apply(this, arguments);\n * };\n * (end)\n *\n * Note that the I/O system adds object codecs for new object automatically. For\n * decoding those objects, the constructor should be written as follows:\n *\n * (code)\n * var MyObj = function(name)\n * {\n *   // ...\n * };\n * (end)\n *\n * Constructor: mxCodec\n *\n * Constructs an XML encoder/decoder for the specified\n * owner document.\n *\n * Parameters:\n *\n * document - Optional XML document that contains the data.\n * If no document is specified then a new document is created\n * using <mxUtils.createXmlDocument>.\n */\nfunction mxCodec(document)\n{\n\tthis.document = document || mxUtils.createXmlDocument();\n\tthis.objects = [];\n};\n\n/**\n * Variable: document\n *\n * The owner document of the codec.\n */\nmxCodec.prototype.document = null;\n\n/**\n * Variable: objects\n *\n * Maps from IDs to objects.\n */\nmxCodec.prototype.objects = null;\n\n/**\n * Variable: elements\n *\n * Lookup table for resolving IDs to elements.\n */\nmxCodec.prototype.elements = null;\n\n/**\n * Variable: encodeDefaults\n *\n * Specifies if default values should be encoded. Default is false.\n */\nmxCodec.prototype.encodeDefaults = false;\n\n\n/**\n * Function: putObject\n *\n * Assoiates the given object with the given ID and returns the given object.\n *\n * Parameters\n *\n * id - ID for the object to be associated with.\n * obj - Object to be associated with the ID.\n */\nmxCodec.prototype.putObject = function(id, obj)\n{\n\tthis.objects[id] = obj;\n\n\treturn obj;\n};\n\n/**\n * Function: getObject\n *\n * Returns the decoded object for the element with the specified ID in\n * <document>. If the object is not known then <lookup> is used to find an\n * object. If no object is found, then the element with the respective ID\n * from the document is parsed using <decode>.\n */\nmxCodec.prototype.getObject = function(id)\n{\n\tvar obj = null;\n\n\tif (id != null)\n\t{\n\t\tobj = this.objects[id];\n\n\t\tif (obj == null)\n\t\t{\n\t\t\tobj = this.lookup(id);\n\n\t\t\tif (obj == null)\n\t\t\t{\n\t\t\t\tvar node = this.getElementById(id);\n\n\t\t\t\tif (node != null)\n\t\t\t\t{\n\t\t\t\t\tobj = this.decode(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n};\n\n/**\n * Function: lookup\n *\n * Hook for subclassers to implement a custom lookup mechanism for cell IDs.\n * This implementation always returns null.\n *\n * Example:\n *\n * (code)\n * var codec = new mxCodec();\n * codec.lookup = function(id)\n * {\n *   return model.getCell(id);\n * };\n * (end)\n *\n * Parameters:\n *\n * id - ID of the object to be returned.\n */\nmxCodec.prototype.lookup = function(id)\n{\n\treturn null;\n};\n\n/**\n * Function: getElementById\n *\n * Returns the element with the given ID from <document>.\n *\n * Parameters:\n *\n * id - String that contains the ID.\n */\nmxCodec.prototype.getElementById = function(id)\n{\n\tthis.updateElements();\n\n\treturn this.elements[id];\n};\n\n/**\n * Function: updateElements\n *\n * Returns the element with the given ID from <document>.\n *\n * Parameters:\n *\n * id - String that contains the ID.\n */\nmxCodec.prototype.updateElements = function()\n{\n\tif (this.elements == null)\n\t{\n\t\tthis.elements = new Object();\n\n\t\tif (this.document.documentElement != null)\n\t\t{\n\t\t\tthis.addElement(this.document.documentElement);\n\t\t}\n\t}\n};\n\n/**\n * Function: addElement\n *\n * Adds the given element to <elements> if it has an ID.\n */\nmxCodec.prototype.addElement = function(node)\n{\n\tif (node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tvar id = node.getAttribute('id');\n\n\t\tif (id != null)\n\t\t{\n\t\t\tif (this.elements[id] == null)\n\t\t\t{\n\t\t\t\tthis.elements[id] = node;\n\t\t\t}\n\t\t\telse if (this.elements[id] != node)\n\t\t\t{\n\t\t\t\tthrow new Error(id + ': Duplicate ID');\n\t\t\t}\n\t\t}\n\t}\n\n\tnode = node.firstChild;\n\n\twhile (node != null)\n\t{\n\t\tthis.addElement(node);\n\t\tnode = node.nextSibling;\n\t}\n};\n\n/**\n * Function: getId\n *\n * Returns the ID of the specified object. This implementation\n * calls <reference> first and if that returns null handles\n * the object as an <mxCell> by returning their IDs using\n * <mxCell.getId>. If no ID exists for the given cell, then\n * an on-the-fly ID is generated using <mxCellPath.create>.\n *\n * Parameters:\n *\n * obj - Object to return the ID for.\n */\nmxCodec.prototype.getId = function(obj)\n{\n\tvar id = null;\n\n\tif (obj != null)\n\t{\n\t\tid = this.reference(obj);\n\n\t\tif (id == null && obj instanceof mxCell)\n\t\t{\n\t\t\tid = obj.getId();\n\n\t\t\tif (id == null)\n\t\t\t{\n\t\t\t\t// Uses an on-the-fly Id\n\t\t\t\tid = mxCellPath.create(obj);\n\n\t\t\t\tif (id.length == 0)\n\t\t\t\t{\n\t\t\t\t\tid = 'root';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn id;\n};\n\n/**\n * Function: reference\n *\n * Hook for subclassers to implement a custom method\n * for retrieving IDs from objects. This implementation\n * always returns null.\n *\n * Example:\n *\n * (code)\n * var codec = new mxCodec();\n * codec.reference = function(obj)\n * {\n *   return obj.getCustomId();\n * };\n * (end)\n *\n * Parameters:\n *\n * obj - Object whose ID should be returned.\n */\nmxCodec.prototype.reference = function(obj)\n{\n\treturn null;\n};\n\n/**\n * Function: encode\n *\n * Encodes the specified object and returns the resulting\n * XML node.\n *\n * Parameters:\n *\n * obj - Object to be encoded.\n */\nmxCodec.prototype.encode = function(obj)\n{\n\tvar node = null;\n\n\tif (obj != null && obj.constructor != null)\n\t{\n\t\tvar enc = mxCodecRegistry.getCodec(obj.constructor);\n\n\t\tif (enc != null)\n\t\t{\n\t\t\tnode = enc.encode(this, obj);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mxUtils.isNode(obj))\n\t\t\t{\n\t\t\t\tnode = mxUtils.importNode(this.document, obj, true);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t    \t\tmxLog.warn('mxCodec.encode: No codec for ' + mxUtils.getFunctionName(obj.constructor));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node;\n};\n\n/**\n * Function: decode\n *\n * Decodes the given XML node. The optional \"into\"\n * argument specifies an existing object to be\n * used. If no object is given, then a new instance\n * is created using the constructor from the codec.\n *\n * The function returns the passed in object or\n * the new instance if no object was given.\n *\n * Parameters:\n *\n * node - XML node to be decoded.\n * into - Optional object to be decodec into.\n */\nmxCodec.prototype.decode = function(node, into)\n{\n\tthis.updateElements();\n\tvar obj = null;\n\n\tif (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\tvar ctor = null;\n\n\t\ttry\n\t\t{\n\t\t\tctor = window[node.nodeName];\n\t\t}\n\t\tcatch (err)\n\t\t{\n\t\t\t// ignore\n\t\t}\n\n\t\tvar dec = mxCodecRegistry.getCodec(ctor);\n\n\t\tif (dec != null)\n\t\t{\n\t\t\tobj = dec.decode(this, node, into);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobj = node.cloneNode(true);\n\t\t\tobj.removeAttribute('as');\n\t\t}\n\t}\n\n\treturn obj;\n};\n\n/**\n * Function: encodeCell\n *\n * Encoding of cell hierarchies is built-into the core, but\n * is a higher-level function that needs to be explicitely\n * used by the respective object encoders (eg. <mxModelCodec>,\n * <mxChildChangeCodec> and <mxRootChangeCodec>). This\n * implementation writes the given cell and its children as a\n * (flat) sequence into the given node. The children are not\n * encoded if the optional includeChildren is false. The\n * function is in charge of adding the result into the\n * given node and has no return value.\n *\n * Parameters:\n *\n * cell - <mxCell> to be encoded.\n * node - Parent XML node to add the encoded cell into.\n * includeChildren - Optional boolean indicating if the\n * function should include all descendents. Default is true.\n */\nmxCodec.prototype.encodeCell = function(cell, node, includeChildren)\n{\n\tnode.appendChild(this.encode(cell));\n\n\tif (includeChildren == null || includeChildren)\n\t{\n\t\tvar childCount = cell.getChildCount();\n\n\t\tfor (var i = 0; i < childCount; i++)\n\t\t{\n\t\t\tthis.encodeCell(cell.getChildAt(i), node);\n\t\t}\n\t}\n};\n\n/**\n * Function: isCellCodec\n *\n * Returns true if the given codec is a cell codec. This uses\n * <mxCellCodec.isCellCodec> to check if the codec is of the\n * given type.\n */\nmxCodec.prototype.isCellCodec = function(codec)\n{\n\tif (codec != null && typeof(codec.isCellCodec) == 'function')\n\t{\n\t\treturn codec.isCellCodec();\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: decodeCell\n *\n * Decodes cells that have been encoded using inversion, ie.\n * where the user object is the enclosing node in the XML,\n * and restores the group and graph structure in the cells.\n * Returns a new <mxCell> instance that represents the\n * given node.\n *\n * Parameters:\n *\n * node - XML node that contains the cell data.\n * restoreStructures - Optional boolean indicating whether\n * the graph structure should be restored by calling insert\n * and insertEdge on the parent and terminals, respectively.\n * Default is true.\n */\nmxCodec.prototype.decodeCell = function(node, restoreStructures)\n{\n\trestoreStructures = (restoreStructures != null) ? restoreStructures : true;\n\tvar cell = null;\n\n\tif (node != null && node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t{\n\t\t// Tries to find a codec for the given node name. If that does\n\t\t// not return a codec then the node is the user object (an XML node\n\t\t// that contains the mxCell, aka inversion).\n\t\tvar decoder = mxCodecRegistry.getCodec(node.nodeName);\n\n\t\t// Tries to find the codec for the cell inside the user object.\n\t\t// This assumes all node names inside the user object are either\n\t\t// not registered or they correspond to a class for cells.\n\t\tif (!this.isCellCodec(decoder))\n\t\t{\n\t\t\tvar child = node.firstChild;\n\n\t\t\twhile (child != null && !this.isCellCodec(decoder))\n\t\t\t{\n\t\t\t\tdecoder = mxCodecRegistry.getCodec(child.nodeName);\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isCellCodec(decoder))\n\t\t{\n\t\t\tdecoder = mxCodecRegistry.getCodec(mxCell);\n\t\t}\n\n\t\tcell = decoder.decode(this, node);\n\n\t\tif (restoreStructures)\n\t\t{\n\t\t\tthis.insertIntoGraph(cell);\n\t\t}\n\t}\n\n\treturn cell;\n};\n\n/**\n * Function: insertIntoGraph\n *\n * Inserts the given cell into its parent and terminal cells.\n */\nmxCodec.prototype.insertIntoGraph = function(cell)\n{\n\tvar parent = cell.parent;\n\tvar source = cell.getTerminal(true);\n\tvar target = cell.getTerminal(false);\n\n\t// Fixes possible inconsistencies during insert into graph\n\tcell.setTerminal(null, false);\n\tcell.setTerminal(null, true);\n\tcell.parent = null;\n\n\tif (parent != null)\n\t{\n\t\tif (parent == cell)\n\t\t{\n\t\t\tthrow new Error(parent.id + ': Self Reference');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent.insert(cell);\n\t\t}\n\t}\n\n\tif (source != null)\n\t{\n\t\tsource.insertEdge(cell, true);\n\t}\n\n\tif (target != null)\n\t{\n\t\ttarget.insertEdge(cell, false);\n\t}\n};\n\n/**\n * Function: setAttribute\n *\n * Sets the attribute on the specified node to value. This is a\n * helper method that makes sure the attribute and value arguments\n * are not null.\n *\n * Parameters:\n *\n * node - XML node to set the attribute for.\n * attributes - Attributename to be set.\n * value - New value of the attribute.\n */\nmxCodec.prototype.setAttribute = function(node, attribute, value)\n{\n\tif (attribute != null && value != null)\n\t{\n\t\tnode.setAttribute(attribute, value);\n\t}\n};\n\n__mxOutput.mxCodec = typeof mxCodec !== 'undefined' ? mxCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxObjectCodec\n *\n * Generic codec for JavaScript objects that implements a mapping between\n * JavaScript objects and XML nodes that maps each field or element to an\n * attribute or child node, and vice versa.\n *\n * Atomic Values:\n *\n * Consider the following example.\n *\n * (code)\n * var obj = new Object();\n * obj.foo = \"Foo\";\n * obj.bar = \"Bar\";\n * (end)\n *\n * This object is encoded into an XML node using the following.\n *\n * (code)\n * var enc = new mxCodec();\n * var node = enc.encode(obj);\n * (end)\n *\n * The output of the encoding may be viewed using <mxLog> as follows.\n *\n * (code)\n * mxLog.show();\n * mxLog.debug(mxUtils.getPrettyXml(node));\n * (end)\n *\n * Finally, the result of the encoding looks as follows.\n *\n * (code)\n * <Object foo=\"Foo\" bar=\"Bar\"/>\n * (end)\n *\n * In the above output, the foo and bar fields have been mapped to attributes\n * with the same names, and the name of the constructor was used for the\n * nodename.\n *\n * Booleans:\n *\n * Since booleans are numbers in JavaScript, all boolean values are encoded\n * into 1 for true and 0 for false. The decoder also accepts the string true\n * and false for boolean values.\n *\n * Objects:\n *\n * The above scheme is applied to all atomic fields, that is, to all non-object\n * fields of an object. For object fields, a child node is created with a\n * special attribute that contains the fieldname. This special attribute is\n * called \"as\" and hence, as is a reserved word that should not be used for a\n * fieldname.\n *\n * Consider the following example where foo is an object and bar is an atomic\n * property of foo.\n *\n * (code)\n * var obj = {foo: {bar: \"Bar\"}};\n * (end)\n *\n * This will be mapped to the following XML structure by mxObjectCodec.\n *\n * (code)\n * <Object>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Object>\n * (end)\n *\n * In the above output, the inner Object node contains the as-attribute that\n * specifies the fieldname in the enclosing object. That is, the field foo was\n * mapped to a child node with an as-attribute that has the value foo.\n *\n * Arrays:\n *\n * Arrays are special objects that are either associative, in which case each\n * key, value pair is treated like a field where the key is the fieldname, or\n * they are a sequence of atomic values and objects, which is mapped to a\n * sequence of child nodes. For object elements, the above scheme is applied\n * without the use of the special as-attribute for creating each child. For\n * atomic elements, a special add-node is created with the value stored in the\n * value-attribute.\n *\n * For example, the following array contains one atomic value and one object\n * with a field called bar. Furthermore it contains two associative entries\n * called bar with an atomic value, and foo with an object value.\n *\n * (code)\n * var obj = [\"Bar\", {bar: \"Bar\"}];\n * obj[\"bar\"] = \"Bar\";\n * obj[\"foo\"] = {bar: \"Bar\"};\n * (end)\n *\n * This array is represented by the following XML nodes.\n *\n * (code)\n * <Array bar=\"Bar\">\n *   <add value=\"Bar\"/>\n *   <Object bar=\"Bar\"/>\n *   <Object bar=\"Bar\" as=\"foo\"/>\n * </Array>\n * (end)\n *\n * The Array node name is the name of the constructor. The additional\n * as-attribute in the last child contains the key of the associative entry,\n * whereas the second last child is part of the array sequence and does not\n * have an as-attribute.\n *\n * References:\n *\n * Objects may be represented as child nodes or attributes with ID values,\n * which are used to lookup the object in a table within <mxCodec>. The\n * <isReference> function is in charge of deciding if a specific field should\n * be encoded as a reference or not. Its default implementation returns true if\n * the fieldname is in <idrefs>, an array of strings that is used to configure\n * the <mxObjectCodec>.\n *\n * Using this approach, the mapping does not guarantee that the referenced\n * object itself exists in the document. The fields that are encoded as\n * references must be carefully chosen to make sure all referenced objects\n * exist in the document, or may be resolved by some other means if necessary.\n *\n * For example, in the case of the graph model all cells are stored in a tree\n * whose root is referenced by the model's root field. A tree is a structure\n * that is well suited for an XML representation, however, the additional edges\n * in the graph model have a reference to a source and target cell, which are\n * also contained in the tree. To handle this case, the source and target cell\n * of an edge are treated as references, whereas the children are treated as\n * objects. Since all cells are contained in the tree and no edge references a\n * source or target outside the tree, this setup makes sure all referenced\n * objects are contained in the document.\n *\n * In the case of a tree structure we must further avoid infinite recursion by\n * ignoring the parent reference of each child. This is done by returning true\n * in <isExcluded>, whose default implementation uses the array of excluded\n * fieldnames passed to the mxObjectCodec constructor.\n *\n * References are only used for cells in mxGraph. For defining other\n * referencable object types, the codec must be able to work out the ID of an\n * object. This is done by implementing <mxCodec.reference>. For decoding a\n * reference, the XML node with the respective id-attribute is fetched from the\n * document, decoded, and stored in a lookup table for later reference. For\n * looking up external objects, <mxCodec.lookup> may be implemented.\n *\n * Expressions:\n *\n * For decoding JavaScript expressions, the add-node may be used with a text\n * content that contains the JavaScript expression. For example, the following\n * creates a field called foo in the enclosing object and assigns it the value\n * of <mxConstants.ALIGN_LEFT>.\n *\n * (code)\n * <Object>\n *   <add as=\"foo\">mxConstants.ALIGN_LEFT</add>\n * </Object>\n * (end)\n *\n * The resulting object has a field called foo with the value \"left\". Its XML\n * representation looks as follows.\n *\n * (code)\n * <Object foo=\"left\"/>\n * (end)\n *\n * This means the expression is evaluated at decoding time and the result of\n * the evaluation is stored in the respective field. Valid expressions are all\n * JavaScript expressions, including function definitions, which are mapped to\n * functions on the resulting object.\n *\n * Expressions are only evaluated if <allowEval> is true.\n *\n * Constructor: mxObjectCodec\n *\n * Constructs a new codec for the specified template object.\n * The variables in the optional exclude array are ignored by\n * the codec. Variables in the optional idrefs array are\n * turned into references in the XML. The optional mapping\n * may be used to map from variable names to XML attributes.\n * The argument is created as follows:\n *\n * (code)\n * var mapping = new Object();\n * mapping['variableName'] = 'attribute-name';\n * (end)\n *\n * Parameters:\n *\n * template - Prototypical instance of the object to be\n * encoded/decoded.\n * exclude - Optional array of fieldnames to be ignored.\n * idrefs - Optional array of fieldnames to be converted to/from\n * references.\n * mapping - Optional mapping from field- to attributenames.\n */\nfunction mxObjectCodec(template, exclude, idrefs, mapping)\n{\n\tthis.template = template;\n\n\tthis.exclude = (exclude != null) ? exclude : [];\n\tthis.idrefs = (idrefs != null) ? idrefs : [];\n\tthis.mapping = (mapping != null) ? mapping : [];\n\n\tthis.reverse = new Object();\n\n\tfor (var i in this.mapping)\n\t{\n\t\tthis.reverse[this.mapping[i]] = i;\n\t}\n};\n\n/**\n * Variable: allowEval\n *\n * Static global switch that specifies if expressions in arrays are allowed.\n * Default is false. NOTE: Enabling this carries a possible security risk.\n */\nmxObjectCodec.allowEval = false;\n\n/**\n * Variable: template\n *\n * Holds the template object associated with this codec.\n */\nmxObjectCodec.prototype.template = null;\n\n/**\n * Variable: exclude\n *\n * Array containing the variable names that should be\n * ignored by the codec.\n */\nmxObjectCodec.prototype.exclude = null;\n\n/**\n * Variable: idrefs\n *\n * Array containing the variable names that should be\n * turned into or converted from references. See\n * <mxCodec.getId> and <mxCodec.getObject>.\n */\nmxObjectCodec.prototype.idrefs = null;\n\n/**\n * Variable: mapping\n *\n * Maps from from fieldnames to XML attribute names.\n */\nmxObjectCodec.prototype.mapping = null;\n\n/**\n * Variable: reverse\n *\n * Maps from from XML attribute names to fieldnames.\n */\nmxObjectCodec.prototype.reverse = null;\n\n/**\n * Function: getName\n *\n * Returns the name used for the nodenames and lookup of the codec when\n * classes are encoded and nodes are decoded. For classes to work with\n * this the codec registry automatically adds an alias for the classname\n * if that is different than what this returns. The default implementation\n * returns the classname of the template class.\n */\nmxObjectCodec.prototype.getName = function()\n{\n\treturn mxUtils.getFunctionName(this.template.constructor);\n};\n\n/**\n * Function: cloneTemplate\n *\n * Returns a new instance of the template for this codec.\n */\nmxObjectCodec.prototype.cloneTemplate = function()\n{\n\treturn new this.template.constructor();\n};\n\n/**\n * Function: getFieldName\n *\n * Returns the fieldname for the given attributename.\n * Looks up the value in the <reverse> mapping or returns\n * the input if there is no reverse mapping for the\n * given name.\n */\nmxObjectCodec.prototype.getFieldName = function(attributename)\n{\n\tif (attributename != null)\n\t{\n\t\tvar mapped = this.reverse[attributename];\n\n\t\tif (mapped != null)\n\t\t{\n\t\t\tattributename = mapped;\n\t\t}\n\t}\n\n\treturn attributename;\n};\n\n/**\n * Function: getAttributeName\n *\n * Returns the attributename for the given fieldname.\n * Looks up the value in the <mapping> or returns\n * the input if there is no mapping for the\n * given name.\n */\nmxObjectCodec.prototype.getAttributeName = function(fieldname)\n{\n\tif (fieldname != null)\n\t{\n\t\tvar mapped = this.mapping[fieldname];\n\n\t\tif (mapped != null)\n\t\t{\n\t\t\tfieldname = mapped;\n\t\t}\n\t}\n\n\treturn fieldname;\n};\n\n/**\n * Function: isExcluded\n *\n * Returns true if the given attribute is to be ignored by the codec. This\n * implementation returns true if the given fieldname is in <exclude> or\n * if the fieldname equals <mxObjectIdentity.FIELD_NAME>.\n *\n * Parameters:\n *\n * obj - Object instance that contains the field.\n * attr - Fieldname of the field.\n * value - Value of the field.\n * write - Boolean indicating if the field is being encoded or decoded.\n * Write is true if the field is being encoded, else it is being decoded.\n */\nmxObjectCodec.prototype.isExcluded = function(obj, attr, value, write)\n{\n\treturn attr == mxObjectIdentity.FIELD_NAME ||\n\t\tmxUtils.indexOf(this.exclude, attr) >= 0;\n};\n\n/**\n * Function: isReference\n *\n * Returns true if the given fieldname is to be treated\n * as a textual reference (ID). This implementation returns\n * true if the given fieldname is in <idrefs>.\n *\n * Parameters:\n *\n * obj - Object instance that contains the field.\n * attr - Fieldname of the field.\n * value - Value of the field.\n * write - Boolean indicating if the field is being encoded or decoded.\n * Write is true if the field is being encoded, else it is being decoded.\n */\nmxObjectCodec.prototype.isReference = function(obj, attr, value, write)\n{\n\treturn mxUtils.indexOf(this.idrefs, attr) >= 0;\n};\n\n/**\n * Function: encode\n *\n * Encodes the specified object and returns a node\n * representing then given object. Calls <beforeEncode>\n * after creating the node and <afterEncode> with the\n * resulting node after processing.\n *\n * Enc is a reference to the calling encoder. It is used\n * to encode complex objects and create references.\n *\n * This implementation encodes all variables of an\n * object according to the following rules:\n *\n * - If the variable name is in <exclude> then it is ignored.\n * - If the variable name is in <idrefs> then <mxCodec.getId>\n * is used to replace the object with its ID.\n * - The variable name is mapped using <mapping>.\n * - If obj is an array and the variable name is numeric\n * (ie. an index) then it is not encoded.\n * - If the value is an object, then the codec is used to\n * create a child node with the variable name encoded into\n * the \"as\" attribute.\n * - Else, if <encodeDefaults> is true or the value differs\n * from the template value, then ...\n * - ... if obj is not an array, then the value is mapped to\n * an attribute.\n * - ... else if obj is an array, the value is mapped to an\n * add child with a value attribute or a text child node,\n * if the value is a function.\n *\n * If no ID exists for a variable in <idrefs> or if an object\n * cannot be encoded, a warning is issued using <mxLog.warn>.\n *\n * Returns the resulting XML node that represents the given\n * object.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n */\nmxObjectCodec.prototype.encode = function(enc, obj)\n{\n\tvar node = enc.document.createElement(this.getName());\n\n\tobj = this.beforeEncode(enc, obj, node);\n\tthis.encodeObject(enc, obj, node);\n\n\treturn this.afterEncode(enc, obj, node);\n};\n\n/**\n * Function: encodeObject\n *\n * Encodes the value of each member in then given obj into the given node using\n * <encodeValue>.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node that contains the encoded object.\n */\nmxObjectCodec.prototype.encodeObject = function(enc, obj, node)\n{\n\tenc.setAttribute(node, 'id', enc.getId(obj));\n\n    for (var i in obj)\n    {\n\t\tvar name = i;\n\t\tvar value = obj[name];\n\n    \tif (value != null && !this.isExcluded(obj, name, value, true))\n    \t{\n    \t\tif (mxUtils.isInteger(name))\n    \t\t{\n    \t\t\tname = null;\n    \t\t}\n\n    \t\tthis.encodeValue(enc, obj, name, value, node);\n    \t}\n    }\n};\n\n/**\n * Function: encodeValue\n *\n * Converts the given value according to the mappings\n * and id-refs in this codec and uses <writeAttribute>\n * to write the attribute into the given node.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object whose property is going to be encoded.\n * name - XML node that contains the encoded object.\n * value - Value of the property to be encoded.\n * node - XML node that contains the encoded object.\n */\nmxObjectCodec.prototype.encodeValue = function(enc, obj, name, value, node)\n{\n\tif (value != null)\n\t{\n\t\tif (this.isReference(obj, name, value, true))\n\t\t{\n\t\t\tvar tmp = enc.getId(value);\n\n\t\t\tif (tmp == null)\n\t\t\t{\n\t\t    \tmxLog.warn('mxObjectCodec.encode: No ID for ' +\n\t\t    \t\tthis.getName() + '.' + name + '=' + value);\n\t\t    \treturn; // exit\n\t\t    }\n\n\t\t    value = tmp;\n\t\t}\n\n\t\tvar defaultValue = this.template[name];\n\n\t\t// Checks if the value is a default value and\n\t\t// the name is correct\n\t\tif (name == null || enc.encodeDefaults || defaultValue != value)\n\t\t{\n\t\t\tname = this.getAttributeName(name);\n\t\t\tthis.writeAttribute(enc, obj, name, value, node);\n\t\t}\n\t}\n};\n\n/**\n * Function: writeAttribute\n *\n * Writes the given value into node using <writePrimitiveAttribute>\n * or <writeComplexAttribute> depending on the type of the value.\n */\nmxObjectCodec.prototype.writeAttribute = function(enc, obj, name, value, node)\n{\n\tif (typeof(value) != 'object' /* primitive type */)\n\t{\n\t\tthis.writePrimitiveAttribute(enc, obj, name, value, node);\n\t}\n\telse /* complex type */\n\t{\n\t\tthis.writeComplexAttribute(enc, obj, name, value, node);\n\t}\n};\n\n/**\n * Function: writePrimitiveAttribute\n *\n * Writes the given value as an attribute of the given node.\n */\nmxObjectCodec.prototype.writePrimitiveAttribute = function(enc, obj, name, value, node)\n{\n\tvalue = this.convertAttributeToXml(enc, obj, name, value, node);\n\n\tif (name == null)\n\t{\n\t\tvar child = enc.document.createElement('add');\n\n\t\tif (typeof(value) == 'function')\n\t\t{\n    \t\tchild.appendChild(enc.document.createTextNode(value));\n    \t}\n    \telse\n    \t{\n    \t\tenc.setAttribute(child, 'value', value);\n    \t}\n\n\t\tnode.appendChild(child);\n\t}\n\telse if (typeof(value) != 'function')\n\t{\n    \tenc.setAttribute(node, name, value);\n\t}\n};\n\n/**\n * Function: writeComplexAttribute\n *\n * Writes the given value as a child node of the given node.\n */\nmxObjectCodec.prototype.writeComplexAttribute = function(enc, obj, name, value, node)\n{\n\tvar child = enc.encode(value);\n\n\tif (child != null)\n\t{\n\t\tif (name != null)\n\t\t{\n    \t\tchild.setAttribute('as', name);\n    \t}\n\n    \tnode.appendChild(child);\n\t}\n\telse\n\t{\n\t\tmxLog.warn('mxObjectCodec.encode: No node for ' + this.getName() + '.' + name + ': ' + value);\n\t}\n};\n\n/**\n * Function: convertAttributeToXml\n *\n * Converts true to \"1\" and false to \"0\" is <isBooleanAttribute> returns true.\n * All other values are not converted.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Objec to convert the attribute for.\n * name - Name of the attribute to be converted.\n * value - Value to be converted.\n */\nmxObjectCodec.prototype.convertAttributeToXml = function(enc, obj, name, value)\n{\n\t// Makes sure to encode boolean values as numeric values\n\tif (this.isBooleanAttribute(enc, obj, name, value))\n\t{\n\t\t// Checks if the value is true (do not use the value as is, because\n\t\t// this would check if the value is not null, so 0 would be true)\n\t\tvalue = (value == true) ? '1' : '0';\n\t}\n\n\treturn value;\n};\n\n/**\n * Function: isBooleanAttribute\n *\n * Returns true if the given object attribute is a boolean value.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Objec to convert the attribute for.\n * name - Name of the attribute to be converted.\n * value - Value of the attribute to be converted.\n */\nmxObjectCodec.prototype.isBooleanAttribute = function(enc, obj, name, value)\n{\n\treturn (typeof(value.length) == 'undefined' && (value == true || value == false));\n};\n\n/**\n * Function: convertAttributeFromXml\n *\n * Converts booleans and numeric values to the respective types. Values are\n * numeric if <isNumericAttribute> returns true.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be converted.\n * obj - Objec to convert the attribute for.\n */\nmxObjectCodec.prototype.convertAttributeFromXml = function(dec, attr, obj)\n{\n\tvar value = attr.value;\n\n\tif (this.isNumericAttribute(dec, attr, obj))\n\t{\n\t\tvalue = parseFloat(value);\n\n\t\tif (isNaN(value) || !isFinite(value))\n\t\t{\n\t\t\tvalue = 0;\n\t\t}\n\t}\n\n\treturn value;\n};\n\n/**\n * Function: isNumericAttribute\n *\n * Returns true if the given XML attribute is or should be a numeric value.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be converted.\n * obj - Objec to convert the attribute for.\n */\nmxObjectCodec.prototype.isNumericAttribute = function(dec, attr, obj)\n{\n\t// Handles known numeric attributes for generic objects\n\tvar result = (obj.constructor == mxGeometry &&\n\t\t(attr.name == 'x' || attr.name == 'y' ||\n\t\tattr.name == 'width' || attr.name == 'height')) ||\n\t\t(obj.constructor == mxPoint &&\n\t\t(attr.name == 'x' || attr.name == 'y')) ||\n\t\tmxUtils.isNumeric(attr.value);\n\n\treturn result;\n};\n\n/**\n * Function: beforeEncode\n *\n * Hook for subclassers to pre-process the object before\n * encoding. This returns the input object. The return\n * value of this function is used in <encode> to perform\n * the default encoding into the given node.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node to encode the object into.\n */\nmxObjectCodec.prototype.beforeEncode = function(enc, obj, node)\n{\n\treturn obj;\n};\n\n/**\n * Function: afterEncode\n *\n * Hook for subclassers to post-process the node\n * for the given object after encoding and return the\n * post-processed node. This implementation returns\n * the input node. The return value of this method\n * is returned to the encoder from <encode>.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * obj - Object to be encoded.\n * node - XML node that represents the default encoding.\n */\nmxObjectCodec.prototype.afterEncode = function(enc, obj, node)\n{\n\treturn node;\n};\n\n/**\n * Function: decode\n *\n * Parses the given node into the object or returns a new object\n * representing the given node.\n *\n * Dec is a reference to the calling decoder. It is used to decode\n * complex objects and resolve references.\n *\n * If a node has an id attribute then the object cache is checked for the\n * object. If the object is not yet in the cache then it is constructed\n * using the constructor of <template> and cached in <mxCodec.objects>.\n *\n * This implementation decodes all attributes and childs of a node\n * according to the following rules:\n *\n * - If the variable name is in <exclude> or if the attribute name is \"id\"\n * or \"as\" then it is ignored.\n * - If the variable name is in <idrefs> then <mxCodec.getObject> is used\n * to replace the reference with an object.\n * - The variable name is mapped using a reverse <mapping>.\n * - If the value has a child node, then the codec is used to create a\n * child object with the variable name taken from the \"as\" attribute.\n * - If the object is an array and the variable name is empty then the\n * value or child object is appended to the array.\n * - If an add child has no value or the object is not an array then\n * the child text content is evaluated using <mxUtils.eval>.\n *\n * For add nodes where the object is not an array and the variable name\n * is defined, the default mechanism is used, allowing to override/add\n * methods as follows:\n *\n * (code)\n * <Object>\n *   <add as=\"hello\"><![CDATA[\n *     function(arg1) {\n *       mxUtils.alert('Hello '+arg1);\n *     }\n *   ]]></add>\n * </Object>\n * (end)\n *\n * If no object exists for an ID in <idrefs> a warning is issued\n * using <mxLog.warn>.\n *\n * Returns the resulting object that represents the given XML node\n * or the object given to the method as the into parameter.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * into - Optional objec to encode the node into.\n */\nmxObjectCodec.prototype.decode = function(dec, node, into)\n{\n\tvar id = node.getAttribute('id');\n\tvar obj = dec.objects[id];\n\n\tif (obj == null)\n\t{\n\t\tobj = into || this.cloneTemplate();\n\n\t\tif (id != null)\n\t\t{\n\t\t\tdec.putObject(id, obj);\n\t\t}\n\t}\n\n\tnode = this.beforeDecode(dec, node, obj);\n\tthis.decodeNode(dec, node, obj);\n\n    return this.afterDecode(dec, node, obj);\n};\n\n/**\n * Function: decodeNode\n *\n * Calls <decodeAttributes> and <decodeChildren> for the given node.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\nmxObjectCodec.prototype.decodeNode = function(dec, node, obj)\n{\n\tif (node != null)\n\t{\n\t\tthis.decodeAttributes(dec, node, obj);\n\t\tthis.decodeChildren(dec, node, obj);\n\t}\n};\n\n/**\n * Function: decodeAttributes\n *\n * Decodes all attributes of the given node using <decodeAttribute>.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\nmxObjectCodec.prototype.decodeAttributes = function(dec, node, obj)\n{\n\tvar attrs = node.attributes;\n\n\tif (attrs != null)\n\t{\n\t\tfor (var i = 0; i < attrs.length; i++)\n\t\t{\n\t\t\tthis.decodeAttribute(dec, attrs[i], obj);\n\t\t}\n\t}\n};\n\n/**\n * Function: isIgnoredAttribute\n *\n * Returns true if the given attribute should be ignored. This implementation\n * returns true if the attribute name is \"as\" or \"id\".\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be decoded.\n * obj - Objec to encode the attribute into.\n */\nmxObjectCodec.prototype.isIgnoredAttribute = function(dec, attr, obj)\n{\n\treturn attr.nodeName == 'as' || attr.nodeName == 'id';\n};\n\n/**\n * Function: decodeAttribute\n *\n * Reads the given attribute into the specified object.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * attr - XML attribute to be decoded.\n * obj - Objec to encode the attribute into.\n */\nmxObjectCodec.prototype.decodeAttribute = function(dec, attr, obj)\n{\n\tif (!this.isIgnoredAttribute(dec, attr, obj))\n\t{\n\t\tvar name = attr.nodeName;\n\n\t\t// Converts the string true and false to their boolean values.\n\t\t// This may require an additional check on the obj to see if\n\t\t// the existing field is a boolean value or uninitialized, in\n\t\t// which case we may want to convert true and false to a string.\n\t\tvar value = this.convertAttributeFromXml(dec, attr, obj);\n\t\tvar fieldname = this.getFieldName(name);\n\n\t\tif (this.isReference(obj, fieldname, value, false))\n\t\t{\n\t\t\tvar tmp = dec.getObject(value);\n\n\t\t\tif (tmp == null)\n\t\t\t{\n\t\t    \tmxLog.warn('mxObjectCodec.decode: No object for ' +\n\t\t    \t\tthis.getName() + '.' + name + '=' + value);\n\t\t    \treturn; // exit\n\t\t    }\n\n\t\t    value = tmp;\n\t\t}\n\n\t\tif (!this.isExcluded(obj, name, value, false))\n\t\t{\n\t\t\t//mxLog.debug(mxUtils.getFunctionName(obj.constructor)+'.'+name+'='+value);\n\t\t\tobj[name] = value;\n\t\t}\n\t}\n};\n\n/**\n * Function: decodeChildren\n *\n * Decodes all children of the given node using <decodeChild>.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Objec to encode the node into.\n */\nmxObjectCodec.prototype.decodeChildren = function(dec, node, obj)\n{\n\tvar child = node.firstChild;\n\n\twhile (child != null)\n\t{\n\t\tvar tmp = child.nextSibling;\n\n\t\tif (child.nodeType == mxConstants.NODETYPE_ELEMENT &&\n\t\t\t!this.processInclude(dec, child, obj))\n\t\t{\n\t\t\tthis.decodeChild(dec, child, obj);\n\t\t}\n\n\t\tchild = tmp;\n\t}\n};\n\n/**\n * Function: decodeChild\n *\n * Reads the specified child into the given object.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * child - XML child element to be decoded.\n * obj - Objec to encode the node into.\n */\nmxObjectCodec.prototype.decodeChild = function(dec, child, obj)\n{\n\tvar fieldname = this.getFieldName(child.getAttribute('as'));\n\n\tif (fieldname == null || !this.isExcluded(obj, fieldname, child, false))\n\t{\n\t\tvar template = this.getFieldTemplate(obj, fieldname, child);\n\t\tvar value = null;\n\n\t\tif (child.nodeName == 'add')\n\t\t{\n\t\t\tvalue = child.getAttribute('value');\n\n\t\t\tif (value == null && mxObjectCodec.allowEval)\n\t\t\t{\n\t\t\t\tvalue = mxUtils.eval(mxUtils.getTextContent(child));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalue = dec.decode(child, template);\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tthis.addObjectValue(obj, fieldname, value, template);\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tthrow new Error(e.message + ' for ' + child.nodeName);\n\t\t}\n\t}\n};\n\n/**\n * Function: getFieldTemplate\n *\n * Returns the template instance for the given field. This returns the\n * value of the field, null if the value is an array or an empty collection\n * if the value is a collection. The value is then used to populate the\n * field for a new instance. For strongly typed languages it may be\n * required to override this to return the correct collection instance\n * based on the encoded child.\n */\nmxObjectCodec.prototype.getFieldTemplate = function(obj, fieldname, child)\n{\n\tvar template = obj[fieldname];\n\n\t// Non-empty arrays are replaced completely\n    if (template instanceof Array && template.length > 0)\n    {\n        template = null;\n    }\n\n    return template;\n};\n\n/**\n * Function: addObjectValue\n *\n * Sets the decoded child node as a value of the given object. If the\n * object is a map, then the value is added with the given fieldname as a\n * key. If the fieldname is not empty, then setFieldValue is called or\n * else, if the object is a collection, the value is added to the\n * collection. For strongly typed languages it may be required to\n * override this with the correct code to add an entry to an object.\n */\nmxObjectCodec.prototype.addObjectValue = function(obj, fieldname, value, template)\n{\n\tif (value != null && value != template)\n\t{\n\t\tif (fieldname != null && fieldname.length > 0)\n\t\t{\n\t\t\tobj[fieldname] = value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobj.push(value);\n\t\t}\n\t\t//mxLog.debug('Decoded '+mxUtils.getFunctionName(obj.constructor)+'.'+fieldname+': '+value);\n\t}\n};\n\n/**\n * Function: processInclude\n *\n * Returns true if the given node is an include directive and\n * executes the include by decoding the XML document. Returns\n * false if the given node is not an include directive.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the encoding/decoding process.\n * node - XML node to be checked.\n * into - Optional object to pass-thru to the codec.\n */\nmxObjectCodec.prototype.processInclude = function(dec, node, into)\n{\n\tif (node.nodeName == 'include')\n\t{\n\t\tvar name = node.getAttribute('name');\n\n\t\tif (name != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar xml = mxUtils.load(name).getDocumentElement();\n\n\t\t\t\tif (xml != null)\n\t\t\t\t{\n\t\t\t\t\tdec.decode(xml, into);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Function: beforeDecode\n *\n * Hook for subclassers to pre-process the node for\n * the specified object and return the node to be\n * used for further processing by <decode>.\n * The object is created based on the template in the\n * calling method and is never null. This implementation\n * returns the input node. The return value of this\n * function is used in <decode> to perform\n * the default decoding into the given object.\n *\n * Parameters:\n *\n * dec - <mxCodec> that controls the decoding process.\n * node - XML node to be decoded.\n * obj - Object to encode the node into.\n */\nmxObjectCodec.prototype.beforeDecode = function(dec, node, obj)\n{\n\treturn node;\n};\n\n/**\n * Function: afterDecode\n *\n * Hook for subclassers to post-process the object after\n * decoding. This implementation returns the given object\n * without any changes. The return value of this method\n * is returned to the decoder from <decode>.\n *\n * Parameters:\n *\n * enc - <mxCodec> that controls the encoding process.\n * node - XML node to be decoded.\n * obj - Object that represents the default decoding.\n */\nmxObjectCodec.prototype.afterDecode = function(dec, node, obj)\n{\n\treturn obj;\n};\n\n__mxOutput.mxObjectCodec = typeof mxObjectCodec !== 'undefined' ? mxObjectCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxCellCodec\n\t *\n\t * Codec for <mxCell>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - children\n\t * - edges\n\t * - overlays\n\t * - mxTransient\n\t *\n\t * Reference Fields:\n\t *\n\t * - parent\n\t * - source\n\t * - target\n\t *\n\t * Transient fields can be added using the following code:\n\t *\n\t * mxCodecRegistry.getCodec(mxCell).exclude.push('name_of_field');\n\t *\n\t * To subclass <mxCell>, replace the template and add an alias as\n\t * follows.\n\t *\n\t * (code)\n\t * function CustomCell(value, geometry, style)\n\t * {\n\t *   mxCell.apply(this, arguments);\n\t * }\n\t *\n\t * mxUtils.extend(CustomCell, mxCell);\n\t *\n\t * mxCodecRegistry.getCodec(mxCell).template = new CustomCell();\n\t * mxCodecRegistry.addAlias('CustomCell', 'mxCell');\n\t * (end)\n\t */\n\tvar codec = new mxObjectCodec(new mxCell(),\n\t\t['children', 'edges', 'overlays', 'mxTransient'],\n\t\t['parent', 'source', 'target']);\n\n\t/**\n\t * Function: isCellCodec\n\t *\n\t * Returns true since this is a cell codec.\n\t */\n\tcodec.isCellCodec = function()\n\t{\n\t\treturn true;\n\t};\n\n\t/**\n\t * Overidden to disable conversion of value to number.\n\t */\n\tcodec.isNumericAttribute = function(dec, attr, obj)\n\t{\n\t\treturn attr.nodeName !== 'value' && mxObjectCodec.prototype.isNumericAttribute.apply(this, arguments);\n\t};\n\n\t/**\n\t * Function: isExcluded\n\t *\n\t * Excludes user objects that are XML nodes.\n\t */\n\tcodec.isExcluded = function(obj, attr, value, isWrite)\n\t{\n\t\treturn mxObjectCodec.prototype.isExcluded.apply(this, arguments) ||\n\t\t\t(isWrite && attr == 'value' &&\n\t\t\tvalue.nodeType == mxConstants.NODETYPE_ELEMENT);\n\t};\n\n\t/**\n\t * Function: afterEncode\n\t *\n\t * Encodes an <mxCell> and wraps the XML up inside the\n\t * XML of the user object (inversion).\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tif (obj.value != null && obj.value.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Wraps the graphical annotation up in the user object (inversion)\n\t\t\t// by putting the result of the default encoding into a clone of the\n\t\t\t// user object (node type 1) and returning this cloned user object.\n\t\t\tvar tmp = node;\n\t\t\tnode = mxUtils.importNode(enc.document, obj.value, true);\n\t\t\tnode.appendChild(tmp);\n\n\t\t\t// Moves the id attribute to the outermost XML node, namely the\n\t\t\t// node which denotes the object boundaries in the file.\n\t\t\tvar id = tmp.getAttribute('id');\n\t\t\tnode.setAttribute('id', id);\n\t\t\ttmp.removeAttribute('id');\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes an <mxCell> and uses the enclosing XML node as\n\t * the user object for the cell (inversion).\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tvar inner = node.cloneNode(true);\n\t\tvar classname = this.getName();\n\n\t\tif (node.nodeName != classname)\n\t\t{\n\t\t\t// Passes the inner graphical annotation node to the\n\t\t\t// object codec for further processing of the cell.\n\t\t\tvar tmp = node.getElementsByTagName(classname)[0];\n\n\t\t\tif (tmp != null && tmp.parentNode == node)\n\t\t\t{\n\t\t\t\tmxUtils.removeWhitespace(tmp, true);\n\t\t\t\tmxUtils.removeWhitespace(tmp, false);\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\tinner = tmp;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinner = null;\n\t\t\t}\n\n\t\t\t// Creates the user object out of the XML node\n\t\t\tobj.value = node.cloneNode(true);\n\t\t\tvar id = obj.value.getAttribute('id');\n\n\t\t\tif (id != null)\n\t\t\t{\n\t\t\t\tobj.setId(id);\n\t\t\t\tobj.value.removeAttribute('id');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Uses ID from XML file as ID for cell in model\n\t\t\tobj.setId(node.getAttribute('id'));\n\t\t}\n\n\t\t// Preprocesses and removes all Id-references in order to use the\n\t\t// correct encoder (this) for the known references to cells (all).\n\t\tif (inner != null)\n\t\t{\n\t\t\tfor (var i = 0; i < this.idrefs.length; i++)\n\t\t\t{\n\t\t\t\tvar attr = this.idrefs[i];\n\t\t\t\tvar ref = inner.getAttribute(attr);\n\n\t\t\t\tif (ref != null)\n\t\t\t\t{\n\t\t\t\t\tinner.removeAttribute(attr);\n\t\t\t\t\tvar object = dec.objects[ref] || dec.lookup(ref);\n\n\t\t\t\t\tif (object == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Needs to decode forward reference\n\t\t\t\t\t\tvar element = dec.getElementById(ref);\n\n\t\t\t\t\t\tif (element != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar decoder = mxCodecRegistry.codecs[element.nodeName] || this;\n\t\t\t\t\t\t\tobject = decoder.decode(dec, element);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tobj[attr] = object;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn inner;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxCellCodec = typeof mxCellCodec !== 'undefined' ? mxCellCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxModelCodec\n\t *\n\t * Codec for <mxGraphModel>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t */\n\tvar codec = new mxObjectCodec(new mxGraphModel());\n\n\t/**\n\t * Function: encodeObject\n\t *\n\t * Encodes the given <mxGraphModel> by writing a (flat) XML sequence of\n\t * cell nodes as produced by the <mxCellCodec>. The sequence is\n\t * wrapped-up in a node with the name root.\n\t */\n\tcodec.encodeObject = function(enc, obj, node)\n\t{\n\t\tvar rootNode = enc.document.createElement('root');\n\t\tenc.encodeCell(obj.getRoot(), rootNode);\n\t\tnode.appendChild(rootNode);\n\t};\n\n\t/**\n\t * Function: decodeChild\n\t *\n\t * Overrides decode child to handle special child nodes.\n\t */\n\tcodec.decodeChild = function(dec, child, obj)\n\t{\n\t\tif (child.nodeName == 'root')\n\t\t{\n\t\t\tthis.decodeRoot(dec, child, obj);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmxObjectCodec.prototype.decodeChild.apply(this, arguments);\n\t\t}\n\t};\n\n\t/**\n\t * Function: decodeRoot\n\t *\n\t * Reads the cells into the graph model. All cells\n\t * are children of the root element in the node.\n\t */\n\tcodec.decodeRoot = function(dec, root, model)\n\t{\n\t\tvar rootCell = null;\n\t\tvar tmp = root.firstChild;\n\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tvar cell = dec.decodeCell(tmp);\n\n\t\t\tif (cell != null && cell.getParent() == null)\n\t\t\t{\n\t\t\t\trootCell = cell;\n\t\t\t}\n\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\n\n\t\t// Sets the root on the model if one has been decoded\n\t\tif (rootCell != null)\n\t\t{\n\t\t\tmodel.setRoot(rootCell);\n\t\t}\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxModelCodec = typeof mxModelCodec !== 'undefined' ? mxModelCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxRootChangeCodec\n\t *\n\t * Codec for <mxRootChange>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec> and\n\t * the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - model\n\t * - previous\n\t * - root\n\t */\n\tvar codec = new mxObjectCodec(new mxRootChange(),\n\t\t['model', 'previous', 'root']);\n\n\t/**\n\t * Function: onEncode\n\t *\n\t * Encodes the child recursively.\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tenc.encodeCell(obj.root, node);\n\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes the optional children as cells\n\t * using the respective decoder.\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tif (node.firstChild != null &&\n\t\t\tnode.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Makes sure the original node isn't modified\n\t\t\tnode = node.cloneNode(true);\n\n\t\t\tvar tmp = node.firstChild;\n\t\t\tobj.root = dec.decodeCell(tmp, false);\n\n\t\t\tvar tmp2 = tmp.nextSibling;\n\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\ttmp = tmp2;\n\n\t\t\twhile (tmp != null)\n\t\t\t{\n\t\t\t\ttmp2 = tmp.nextSibling;\n\t\t\t\tdec.decodeCell(tmp);\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\ttmp = tmp2;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores the state by assigning the previous value.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\tobj.previous = obj.root;\n\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxRootChangeCodec = typeof mxRootChangeCodec !== 'undefined' ? mxRootChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxChildChangeCodec\n\t *\n\t * Codec for <mxChildChange>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec> and\n\t * the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - model\n\t * - previous\n\t * - previousIndex\n\t * - child\n\t *\n\t * Reference Fields:\n\t *\n\t * - parent\n\t */\n\tvar codec = new mxObjectCodec(new mxChildChange(),\n\t\t['model', 'child', 'previousIndex'],\n\t\t['parent', 'previous']);\n\n\t/**\n\t * Function: isReference\n\t *\n\t * Returns true for the child attribute if the child\n\t * cell had a previous parent or if we're reading the\n\t * child as an attribute rather than a child node, in\n\t * which case it's always a reference.\n\t */\n\tcodec.isReference = function(obj, attr, value, isWrite)\n\t{\n\t\tif (attr == 'child' && (!isWrite || obj.model.contains(obj.previous)))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn mxUtils.indexOf(this.idrefs, attr) >= 0;\n\t};\n\n\t/**\n\t * Function: isExcluded\n\t *\n\t * Excludes references to parent or previous if not in the model.\n\t */\n  \tcodec.isExcluded = function(obj, attr, value, write)\n  \t{\n  \t\treturn mxObjectCodec.prototype.isExcluded.apply(this, arguments) ||\n  \t\t\t(write && value != null && (attr == 'previous' ||\n  \t\t\tattr == 'parent') && !obj.model.contains(value));\n  \t};\n\n\t/**\n\t * Function: afterEncode\n\t *\n\t * Encodes the child recusively and adds the result\n\t * to the given node.\n\t */\n\tcodec.afterEncode = function(enc, obj, node)\n\t{\n\t\tif (this.isReference(obj, 'child', obj.child, true))\n\t\t{\n\t\t\t// Encodes as reference (id)\n\t\t\tnode.setAttribute('child', enc.getId(obj.child));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// At this point, the encoder is no longer able to know which cells\n\t\t\t// are new, so we have to encode the complete cell hierarchy and\n\t\t\t// ignore the ones that are already there at decoding time. Note:\n\t\t\t// This can only be resolved by moving the notify event into the\n\t\t\t// execute of the edit.\n\t\t\tenc.encodeCell(obj.child, node);\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes the any child nodes as using the respective\n\t * codec from the registry.\n\t */\n\tcodec.beforeDecode = function(dec, node, obj)\n\t{\n\t\tif (node.firstChild != null &&\n\t\t\tnode.firstChild.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t{\n\t\t\t// Makes sure the original node isn't modified\n\t\t\tnode = node.cloneNode(true);\n\n\t\t\tvar tmp = node.firstChild;\n\t\t\tobj.child = dec.decodeCell(tmp, false);\n\n\t\t\tvar tmp2 = tmp.nextSibling;\n\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\ttmp = tmp2;\n\n\t\t\twhile (tmp != null)\n\t\t\t{\n\t\t\t\ttmp2 = tmp.nextSibling;\n\n\t\t\t\tif (tmp.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t{\n\t\t\t\t\t// Ignores all existing cells because those do not need to\n\t\t\t\t\t// be re-inserted into the model. Since the encoded version\n\t\t\t\t\t// of these cells contains the new parent, this would leave\n\t\t\t\t\t// to an inconsistent state on the model (ie. a parent\n\t\t\t\t\t// change without a call to parentForCellChanged).\n\t\t\t\t\tvar id = tmp.getAttribute('id');\n\n\t\t\t\t\tif (dec.lookup(id) == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdec.decodeCell(tmp);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\ttmp = tmp2;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar childRef = node.getAttribute('child');\n\t\t\tobj.child = dec.getObject(childRef);\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores object state in the child change.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\t// Cells are decoded here after a complete transaction so the previous\n\t\t// parent must be restored on the cell for the case where the cell was\n\t\t// added. This is needed for the local model to identify the cell as a\n\t\t// new cell and register the ID.\n        if (obj.child != null)\n        {\n            if (obj.child.parent != null && obj.previous != null &&\n                obj.child.parent != obj.previous)\n            {\n                obj.previous = obj.child.parent;\n            }\n\n            obj.child.parent = obj.previous;\n            obj.previous = obj.parent;\n            obj.previousIndex = obj.index;\n        }\n\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxChildChangeCodec = typeof mxChildChangeCodec !== 'undefined' ? mxChildChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxTerminalChangeCodec\n\t *\n\t * Codec for <mxTerminalChange>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec> and\n\t * the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - model\n\t * - previous\n\t *\n\t * Reference Fields:\n\t *\n\t * - cell\n\t * - terminal\n\t */\n\tvar codec = new mxObjectCodec(new mxTerminalChange(),\n\t\t['model', 'previous'], ['cell', 'terminal']);\n\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores the state by assigning the previous value.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\tobj.previous = obj.terminal;\n\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxTerminalChangeCodec = typeof mxTerminalChangeCodec !== 'undefined' ? mxTerminalChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxGenericChangeCodec\n *\n * Codec for <mxValueChange>s, <mxStyleChange>s, <mxGeometryChange>s,\n * <mxCollapseChange>s and <mxVisibleChange>s. This class is created\n * and registered dynamically at load time and used implicitely\n * via <mxCodec> and the <mxCodecRegistry>.\n *\n * Transient Fields:\n *\n * - model\n * - previous\n *\n * Reference Fields:\n *\n * - cell\n *\n * Constructor: mxGenericChangeCodec\n *\n * Factory function that creates a <mxObjectCodec> for\n * the specified change and fieldname.\n *\n * Parameters:\n *\n * obj - An instance of the change object.\n * variable - The fieldname for the change data.\n */\nvar mxGenericChangeCodec = function(obj, variable)\n{\n\tvar codec = new mxObjectCodec(obj,  ['model', 'previous'], ['cell']);\n\n\t/**\n\t * Function: afterDecode\n\t *\n\t * Restores the state by assigning the previous value.\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\t// Allows forward references in sessions. This is a workaround\n\t\t// for the sequence of edits in mxGraph.moveCells and cellsAdded.\n\t\tif (mxUtils.isNode(obj.cell))\n\t\t{\n\t\t\tobj.cell = dec.decodeCell(obj.cell, false);\n\t\t}\n\n\t\tobj.previous = obj[variable];\n\n\t\treturn obj;\n\t};\n\n\treturn codec;\n};\n\n// Registers the codecs\nmxCodecRegistry.register(mxGenericChangeCodec(new mxValueChange(), 'value'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxStyleChange(), 'style'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxGeometryChange(), 'geometry'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxCollapseChange(), 'collapsed'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxVisibleChange(), 'visible'));\nmxCodecRegistry.register(mxGenericChangeCodec(new mxCellAttributeChange(), 'value'));\n\n__mxOutput.mxGenericChangeCodec = typeof mxGenericChangeCodec !== 'undefined' ? mxGenericChangeCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxGraphCodec\n\t *\n\t * Codec for <mxGraph>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - graphListeners\n\t * - eventListeners\n\t * - view\n\t * - container\n\t * - cellRenderer\n\t * - editor\n\t * - selection\n\t */\n\treturn new mxObjectCodec(new mxGraph(),\n\t\t['graphListeners', 'eventListeners', 'view', 'container',\n\t\t'cellRenderer', 'editor', 'selection']);\n\n}());\n\n__mxOutput.mxGraphCodec = typeof mxGraphCodec !== 'undefined' ? mxGraphCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxGraphViewCodec\n\t *\n\t * Custom encoder for <mxGraphView>s. This class is created\n\t * and registered dynamically at load time and used implicitely via\n\t * <mxCodec> and the <mxCodecRegistry>. This codec only writes views\n\t * into a XML format that can be used to create an image for\n\t * the graph, that is, it contains absolute coordinates with\n\t * computed perimeters, edge styles and cell styles.\n\t */\n\tvar codec = new mxObjectCodec(new mxGraphView());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Encodes the given <mxGraphView> using <encodeCell>\n\t * starting at the model's root. This returns the\n\t * top-level graph node of the recursive encoding.\n\t */\n\tcodec.encode = function(enc, view)\n\t{\n\t\treturn this.encodeCell(enc, view,\n\t\t\tview.graph.getModel().getRoot());\n\t};\n\n\t/**\n\t * Function: encodeCell\n\t *\n\t * Recursively encodes the specifed cell. Uses layer\n\t * as the default nodename. If the cell's parent is\n\t * null, then graph is used for the nodename. If\n\t * <mxGraphModel.isEdge> returns true for the cell,\n\t * then edge is used for the nodename, else if\n\t * <mxGraphModel.isVertex> returns true for the cell,\n\t * then vertex is used for the nodename.\n\t *\n\t * <mxGraph.getLabel> is used to create the label\n\t * attribute for the cell. For graph nodes and vertices\n\t * the bounds are encoded into x, y, width and height.\n\t * For edges the points are encoded into a points\n\t * attribute as a space-separated list of comma-separated\n\t * coordinate pairs (eg. x0,y0 x1,y1 ... xn,yn). All\n\t * values from the cell style are added as attribute\n\t * values to the node.\n\t */\n\tcodec.encodeCell = function(enc, view, cell)\n\t{\n\t\tvar model = view.graph.getModel();\n\t\tvar state = view.getState(cell);\n\t\tvar parent = model.getParent(cell);\n\n\t\tif (parent == null || state != null)\n\t\t{\n\t\t\tvar childCount = model.getChildCount(cell);\n\t\t\tvar geo = view.graph.getCellGeometry(cell);\n\t\t\tvar name = null;\n\n\t\t\tif (parent == model.getRoot())\n\t\t\t{\n\t\t\t\tname = 'layer';\n\t\t\t}\n\t\t\telse if (parent == null)\n\t\t\t{\n\t\t\t\tname = 'graph';\n\t\t\t}\n\t\t\telse if (model.isEdge(cell))\n\t\t\t{\n\t\t\t\tname = 'edge';\n\t\t\t}\n\t\t\telse if (childCount > 0 && geo != null)\n\t\t\t{\n\t\t\t\tname = 'group';\n\t\t\t}\n\t\t\telse if (model.isVertex(cell))\n\t\t\t{\n\t\t\t\tname = 'vertex';\n\t\t\t}\n\n\t\t\tif (name != null)\n\t\t\t{\n\t\t\t\tvar node = enc.document.createElement(name);\n\t\t\t\tvar lab = view.graph.getLabel(cell);\n\n\t\t\t\tif (lab != null)\n\t\t\t\t{\n\t\t\t\t\tnode.setAttribute('label', view.graph.getLabel(cell));\n\n\t\t\t\t\tif (view.graph.isHtmlLabel(cell))\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.setAttribute('html', true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (parent == null)\n\t\t\t\t{\n\t\t\t\t\tvar bounds = view.getGraphBounds();\n\n\t\t\t\t\tif (bounds != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.setAttribute('x', Math.round(bounds.x));\n\t\t\t\t\t\tnode.setAttribute('y', Math.round(bounds.y));\n\t\t\t\t\t\tnode.setAttribute('width', Math.round(bounds.width));\n\t\t\t\t\t\tnode.setAttribute('height', Math.round(bounds.height));\n\t\t\t\t\t}\n\n\t\t\t\t\tnode.setAttribute('scale', view.scale);\n\t\t\t\t}\n\t\t\t\telse if (state != null && geo != null)\n\t\t\t\t{\n\t\t\t\t\t// Writes each key, value in the style pair to an attribute\n\t\t\t\t    for (var i in state.style)\n\t\t\t\t    {\n\t\t\t\t    \tvar value = state.style[i];\n\n\t\t\t\t    \t// Tries to turn objects and functions into strings\n\t\t\t\t\t    if (typeof(value) == 'function' &&\n\t\t\t\t\t\t\ttypeof(value) == 'object')\n\t\t\t\t\t\t{\n\t\t\t\t\t    \tvalue = mxStyleRegistry.getName(value);\n\t\t\t\t        }\n\n\t\t\t\t    \tif (value != null &&\n\t\t\t\t    \t\ttypeof(value) != 'function' &&\n\t\t\t\t\t\t\ttypeof(value) != 'object')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.setAttribute(i, value);\n\t\t\t\t        }\n\t\t\t\t    }\n\n\t\t\t\t\tvar abs = state.absolutePoints;\n\n\t\t\t\t\t// Writes the list of points into one attribute\n\t\t\t\t\tif (abs != null && abs.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pts = Math.round(abs[0].x) + ',' + Math.round(abs[0].y);\n\n\t\t\t\t\t\tfor (var i=1; i<abs.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpts += ' ' + Math.round(abs[i].x) + ',' +\n\t\t\t\t\t\t\t\tMath.round(abs[i].y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode.setAttribute('points', pts);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Writes the bounds into 4 attributes\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.setAttribute('x', Math.round(state.x));\n\t\t\t\t\t\tnode.setAttribute('y', Math.round(state.y));\n\t\t\t\t\t\tnode.setAttribute('width', Math.round(state.width));\n\t\t\t\t\t\tnode.setAttribute('height', Math.round(state.height));\n\t\t\t\t\t}\n\n\t\t\t\t\tvar offset = state.absoluteOffset;\n\n\t\t\t\t\t// Writes the offset into 2 attributes\n\t\t\t\t\tif (offset != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (offset.x != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.setAttribute('dx', Math.round(offset.x));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (offset.y != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnode.setAttribute('dy', Math.round(offset.y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var i=0; i<childCount; i++)\n\t\t\t\t{\n\t\t\t\t\tvar childNode = this.encodeCell(enc,\n\t\t\t\t\t\t\tview, model.getChildAt(cell, i));\n\n\t\t\t\t\tif (childNode != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnode.appendChild(childNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxGraphViewCodec = typeof mxGraphViewCodec !== 'undefined' ? mxGraphViewCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxStylesheetCodec\n *\n * Codec for <mxStylesheet>s. This class is created and registered\n * dynamically at load time and used implicitely via <mxCodec>\n * and the <mxCodecRegistry>.\n */\nvar mxStylesheetCodec = mxCodecRegistry.register(function()\n{\n\tvar codec = new mxObjectCodec(new mxStylesheet());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Encodes a stylesheet. See <decode> for a description of the\n\t * format.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\tvar node = enc.document.createElement(this.getName());\n\n\t\tfor (var i in obj.styles)\n\t\t{\n\t\t\tvar style = obj.styles[i];\n\t\t\tvar styleNode = enc.document.createElement('add');\n\n\t\t\tif (i != null)\n\t\t\t{\n\t\t\t\tstyleNode.setAttribute('as', i);\n\n\t\t\t\tfor (var j in style)\n\t\t\t\t{\n\t\t\t\t\tvar value = this.getStringValue(j, style[j]);\n\n\t\t\t\t\tif (value != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar entry = enc.document.createElement('add');\n\t\t\t\t\t\tentry.setAttribute('value', value);\n\t\t\t\t\t\tentry.setAttribute('as', j);\n\t\t\t\t\t\tstyleNode.appendChild(entry);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (styleNode.childNodes.length > 0)\n\t\t\t\t{\n\t\t\t\t\tnode.appendChild(styleNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t    return node;\n\t};\n\n\t/**\n\t * Function: getStringValue\n\t *\n\t * Returns the string for encoding the given value.\n\t */\n\tcodec.getStringValue = function(key, value)\n\t{\n\t\tvar type = typeof(value);\n\n\t\tif (type == 'function')\n\t\t{\n\t\t\tvalue = mxStyleRegistry.getName(style[j]);\n\t\t}\n\t\telse if (type == 'object')\n\t\t{\n\t\t\tvalue = null;\n\t\t}\n\n\t\treturn value;\n\t};\n\n\t/**\n\t * Function: decode\n\t *\n\t * Reads a sequence of the following child nodes\n\t * and attributes:\n\t *\n\t * Child Nodes:\n\t *\n\t * add - Adds a new style.\n\t *\n\t * Attributes:\n\t *\n\t * as - Name of the style.\n\t * extend - Name of the style to inherit from.\n\t *\n\t * Each node contains another sequence of add and remove nodes with the following\n\t * attributes:\n\t *\n\t * as - Name of the style (see <mxConstants>).\n\t * value - Value for the style.\n\t *\n\t * Instead of the value-attribute, one can put Javascript expressions into\n\t * the node as follows if <mxStylesheetCodec.allowEval> is true:\n\t * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>\n\t *\n\t * A remove node will remove the entry with the name given in the as-attribute\n\t * from the style.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * <mxStylesheet as=\"stylesheet\">\n\t *   <add as=\"text\">\n\t *     <add as=\"fontSize\" value=\"12\"/>\n\t *   </add>\n\t *   <add as=\"defaultVertex\" extend=\"text\">\n\t *     <add as=\"shape\" value=\"rectangle\"/>\n\t *   </add>\n\t * </mxStylesheet>\n\t * (end)\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tvar obj = into || new this.template.constructor();\n\t\tvar id = node.getAttribute('id');\n\n\t\tif (id != null)\n\t\t{\n\t\t\tdec.objects[id] = obj;\n\t\t}\n\n\t\tnode = node.firstChild;\n\n\t\twhile (node != null)\n\t\t{\n\t\t\tif (!this.processInclude(dec, node, obj) && node.nodeName == 'add')\n\t\t\t{\n\t\t\t\tvar as = node.getAttribute('as');\n\n\t\t\t\tif (as != null)\n\t\t\t\t{\n\t\t\t\t\tvar extend = node.getAttribute('extend');\n\t\t\t\t\tvar style = (extend != null) ? mxUtils.clone(obj.styles[extend]) : null;\n\n\t\t\t\t\tif (style == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (extend != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmxLog.warn('mxStylesheetCodec.decode: stylesheet ' +\n\t\t\t\t\t\t\t\textend + ' not found to extend');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstyle = new Object();\n\t\t\t\t\t}\n\n\t\t\t\t\tvar entry = node.firstChild;\n\n\t\t\t\t\twhile (entry != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (entry.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t \tvar key = entry.getAttribute('as');\n\n\t\t\t\t\t\t \tif (entry.nodeName == 'add')\n\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \tvar text = mxUtils.getTextContent(entry);\n\t\t\t\t\t\t\t \tvar value = null;\n\n\t\t\t\t\t\t\t \tif (text != null && text.length > 0 && mxStylesheetCodec.allowEval)\n\t\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \t\tvalue = mxUtils.eval(text);\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t\t \telse\n\t\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \t\tvalue = entry.getAttribute('value');\n\n\t\t\t\t\t\t\t \t\tif (mxUtils.isNumeric(value))\n\t\t\t\t\t\t\t \t\t{\n\t\t\t\t\t\t\t\t\t\tvalue = parseFloat(value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t \t}\n\n\t\t\t\t\t\t\t \tif (value != null)\n\t\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t \t\tstyle[key] = value;\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t \t}\n\t\t\t\t\t\t \telse if (entry.nodeName == 'remove')\n\t\t\t\t\t\t \t{\n\t\t\t\t\t\t \t\tdelete style[key];\n\t\t\t\t\t\t \t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tentry = entry.nextSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\tobj.putCellStyle(as, style);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnode = node.nextSibling;\n\t\t}\n\n\t\treturn obj;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n/**\n * Variable: allowEval\n *\n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content. Default is true. Set this to false if stylesheets\n * may contain user input.\n */\nmxStylesheetCodec.allowEval = true;\n\n__mxOutput.mxStylesheetCodec = typeof mxStylesheetCodec !== 'undefined' ? mxStylesheetCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxDefaultKeyHandlerCodec\n\t *\n\t * Custom codec for configuring <mxDefaultKeyHandler>s. This class is created\n\t * and registered dynamically at load time and used implicitely via\n\t * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\n\t * data for existing key handlers, it does not encode or create key handlers.\n\t */\n\tvar codec = new mxObjectCodec(new mxDefaultKeyHandler());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Returns null.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\treturn null;\n\t};\n\n\t/**\n\t * Function: decode\n\t *\n\t * Reads a sequence of the following child nodes\n\t * and attributes:\n\t *\n\t * Child Nodes:\n\t *\n\t * add - Binds a keystroke to an actionname.\n\t *\n\t * Attributes:\n\t *\n\t * as - Keycode.\n\t * action - Actionname to execute in editor.\n\t * control - Optional boolean indicating if\n\t * \t\tthe control key must be pressed.\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * <mxDefaultKeyHandler as=\"keyHandler\">\n\t *   <add as=\"88\" control=\"true\" action=\"cut\"/>\n\t *   <add as=\"67\" control=\"true\" action=\"copy\"/>\n\t *   <add as=\"86\" control=\"true\" action=\"paste\"/>\n\t * </mxDefaultKeyHandler>\n\t * (end)\n\t *\n\t * The keycodes are for the x, c and v keys.\n\t *\n\t * See also: <mxDefaultKeyHandler.bindAction>,\n\t * http://www.js-examples.com/page/tutorials__key_codes.html\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tif (into != null)\n\t\t{\n\t\t\tvar editor = into.editor;\n\t\t\tnode = node.firstChild;\n\n\t\t\twhile (node != null)\n\t\t\t{\n\t\t\t\tif (!this.processInclude(dec, node, into) &&\n\t\t\t\t\tnode.nodeName == 'add')\n\t\t\t\t{\n\t\t\t\t\tvar as = node.getAttribute('as');\n\t\t\t\t\tvar action = node.getAttribute('action');\n\t\t\t\t\tvar control = node.getAttribute('control');\n\n\t\t\t\t\tinto.bindAction(as, action, control);\n\t\t\t\t}\n\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn into;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxDefaultKeyHandlerCodec = typeof mxDefaultKeyHandlerCodec !== 'undefined' ? mxDefaultKeyHandlerCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\n/**\n * Class: mxDefaultToolbarCodec\n *\n * Custom codec for configuring <mxDefaultToolbar>s. This class is created\n * and registered dynamically at load time and used implicitely via\n * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\n * data for existing toolbars handlers, it does not encode or create toolbars.\n */\nvar mxDefaultToolbarCodec = mxCodecRegistry.register(function()\n{\n\tvar codec = new mxObjectCodec(new mxDefaultToolbar());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Returns null.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\treturn null;\n\t};\n\n\t/**\n\t * Function: decode\n\t *\n\t * Reads a sequence of the following child nodes\n\t * and attributes:\n\t *\n\t * Child Nodes:\n\t *\n\t * add - Adds a new item to the toolbar. See below for attributes.\n\t * separator - Adds a vertical separator. No attributes.\n\t * hr - Adds a horizontal separator. No attributes.\n\t * br - Adds a linefeed. No attributes.\n\t *\n\t * Attributes:\n\t *\n\t * as - Resource key for the label.\n\t * action - Name of the action to execute in enclosing editor.\n\t * mode - Modename (see below).\n\t * template - Template name for cell insertion.\n\t * style - Optional style to override the template style.\n\t * icon - Icon (relative/absolute URL).\n\t * pressedIcon - Optional icon for pressed state (relative/absolute URL).\n\t * id - Optional ID to be used for the created DOM element.\n\t * toggle - Optional 0 or 1 to disable toggling of the element. Default is\n\t * 1 (true).\n\t *\n\t * The action, mode and template attributes are mutually exclusive. The\n\t * style can only be used with the template attribute. The add node may\n\t * contain another sequence of add nodes with as and action attributes\n\t * to create a combo box in the toolbar. If the icon is specified then\n\t * a list of the child node is expected to have its template attribute\n\t * set and the action is ignored instead.\n\t *\n\t * Nodes with a specified template may define a function to be used for\n\t * inserting the cloned template into the graph. Here is an example of such\n\t * a node:\n\t *\n\t * (code)\n\t * <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"><![CDATA[\n\t *   function (editor, cell, evt, targetCell)\n\t *   {\n\t *     var pt = mxUtils.convertPoint(\n\t *       editor.graph.container, mxEvent.getClientX(evt),\n\t *         mxEvent.getClientY(evt));\n\t *     return editor.addVertex(targetCell, cell, pt.x, pt.y);\n\t *   }\n\t * ]]></add>\n\t * (end)\n\t *\n\t * In the above function, editor is the enclosing <mxEditor> instance, cell\n\t * is the clone of the template, evt is the mouse event that represents the\n\t * drop and targetCell is the cell under the mousepointer where the drop\n\t * occurred. The targetCell is retrieved using <mxGraph.getCellAt>.\n\t *\n\t * Futhermore, nodes with the mode attribute may define a function to\n\t * be executed upon selection of the respective toolbar icon. In the\n\t * example below, the default edge style is set when this specific\n\t * connect-mode is activated:\n\t *\n\t * (code)\n\t * <add as=\"connect\" mode=\"connect\"><![CDATA[\n\t *   function (editor)\n\t *   {\n\t *     if (editor.defaultEdge != null)\n\t *     {\n\t *       editor.defaultEdge.style = 'straightEdge';\n\t *     }\n\t *   }\n\t * ]]></add>\n\t * (end)\n\t *\n\t * Both functions require <mxDefaultToolbarCodec.allowEval> to be set to true.\n\t *\n\t * Modes:\n\t *\n\t * select - Left mouse button used for rubberband- & cell-selection.\n\t * connect - Allows connecting vertices by inserting new edges.\n\t * pan - Disables selection and switches to panning on the left button.\n\t *\n\t * Example:\n\t *\n\t * To add items to the toolbar:\n\t *\n\t * (code)\n\t * <mxDefaultToolbar as=\"toolbar\">\n\t *   <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\n\t *   <br/><hr/>\n\t *   <add as=\"select\" mode=\"select\" icon=\"images/select.gif\"/>\n\t *   <add as=\"connect\" mode=\"connect\" icon=\"images/connect.gif\"/>\n\t * </mxDefaultToolbar>\n\t * (end)\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tif (into != null)\n\t\t{\n\t\t\tvar editor = into.editor;\n\t\t\tnode = node.firstChild;\n\n\t\t\twhile (node != null)\n\t\t\t{\n\t\t\t\tif (node.nodeType == mxConstants.NODETYPE_ELEMENT)\n\t\t\t\t{\n\t\t\t\t\tif (!this.processInclude(dec, node, into))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (node.nodeName == 'separator')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinto.addSeparator();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (node.nodeName == 'br')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinto.toolbar.addBreak();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (node.nodeName == 'hr')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinto.toolbar.addLine();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (node.nodeName == 'add')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar as = node.getAttribute('as');\n\t\t\t\t\t\t\tas = mxResources.get(as) || as;\n\t\t\t\t\t\t\tvar icon = node.getAttribute('icon');\n\t\t\t\t\t\t\tvar pressedIcon = node.getAttribute('pressedIcon');\n\t\t\t\t\t\t\tvar action = node.getAttribute('action');\n\t\t\t\t\t\t\tvar mode = node.getAttribute('mode');\n\t\t\t\t\t\t\tvar template = node.getAttribute('template');\n\t\t\t\t\t\t\tvar toggle = node.getAttribute('toggle') != '0';\n\t\t\t\t\t\t\tvar text = mxUtils.getTextContent(node);\n\t\t\t\t\t\t\tvar elt = null;\n\n\t\t\t\t\t\t\tif (action != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\telt = into.addItem(as, icon, action, pressedIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (mode != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar funct = (mxDefaultToolbarCodec.allowEval) ? mxUtils.eval(text) : null;\n\t\t\t\t\t\t\t\telt = into.addMode(as, icon, mode, pressedIcon, funct);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (template != null || (text != null && text.length > 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar cell = editor.templates[template];\n\t\t\t\t\t\t\t\tvar style = node.getAttribute('style');\n\n\t\t\t\t\t\t\t\tif (cell != null && style != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcell = editor.graph.cloneCell(cell);\n\t\t\t\t\t\t\t\t\tcell.setStyle(style);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar insertFunction = null;\n\n\t\t\t\t\t\t\t\tif (text != null && text.length > 0 && mxDefaultToolbarCodec.allowEval)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tinsertFunction = mxUtils.eval(text);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\telt = into.addPrototype(as, icon, cell, pressedIcon, insertFunction, toggle);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar children = mxUtils.getChildNodes(node);\n\n\t\t\t\t\t\t\t\tif (children.length > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (icon == null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar combo = into.addActionCombo(as);\n\n\t\t\t\t\t\t\t\t\t\tfor (var i=0; i<children.length; i++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvar child = children[i];\n\n\t\t\t\t\t\t\t\t\t\t\tif (child.nodeName == 'separator')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinto.addOption(combo, '---');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (child.nodeName == 'add')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar lab = child.getAttribute('as');\n\t\t\t\t\t\t\t\t\t\t\t\tvar act = child.getAttribute('action');\n\t\t\t\t\t\t\t\t\t\t\t\tinto.addActionOption(combo, lab, act);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar select = null;\n\t\t\t\t\t\t\t\t\t\tvar create = function()\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvar template = editor.templates[select.value];\n\n\t\t\t\t\t\t\t\t\t\t\tif (template != null)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar clone = template.clone();\n\t\t\t\t\t\t\t\t\t\t\t\tvar style = select.options[select.selectedIndex].cellStyle;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (style != null)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tclone.setStyle(style);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn clone;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tmxLog.warn('Template '+template+' not found');\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\tvar img = into.addPrototype(as, icon, create, null, null, toggle);\n\t\t\t\t\t\t\t\t\t\tselect = into.addCombo();\n\n\t\t\t\t\t\t\t\t\t\t// Selects the toolbar icon if a selection change\n\t\t\t\t\t\t\t\t\t\t// is made in the corresponding combobox.\n\t\t\t\t\t\t\t\t\t\tmxEvent.addListener(select, 'change', function()\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tinto.toolbar.selectMode(img, function(evt)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar pt = mxUtils.convertPoint(editor.graph.container,\n\t\t\t\t\t\t\t\t\t\t\t\t\tmxEvent.getClientX(evt), mxEvent.getClientY(evt));\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn editor.addVertex(null, funct(), pt.x, pt.y);\n\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\tinto.toolbar.noReset = false;\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t// Adds the entries to the combobox\n\t\t\t\t\t\t\t\t\t\tfor (var i=0; i<children.length; i++)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tvar child = children[i];\n\n\t\t\t\t\t\t\t\t\t\t\tif (child.nodeName == 'separator')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tinto.addOption(select, '---');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if (child.nodeName == 'add')\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar lab = child.getAttribute('as');\n\t\t\t\t\t\t\t\t\t\t\t\tvar tmp = child.getAttribute('template');\n\t\t\t\t\t\t\t\t\t\t\t\tvar option = into.addOption(select, lab, tmp || template);\n\t\t\t\t\t\t\t\t\t\t\t\toption.cellStyle = child.getAttribute('style');\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Assigns an ID to the created element to access it later.\n\t\t\t\t\t\t\tif (elt != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar id = node.getAttribute('id');\n\n\t\t\t\t\t\t\t\tif (id != null && id.length > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\telt.setAttribute('id', id);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\t\t}\n\n\t\treturn into;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n/**\n * Variable: allowEval\n *\n * Static global switch that specifies if the use of eval is allowed for\n * evaluating text content. Default is true. Set this to false if stylesheets\n * may contain user input\n */\nmxDefaultToolbarCodec.allowEval = true;\n\n__mxOutput.mxDefaultToolbarCodec = typeof mxDefaultToolbarCodec !== 'undefined' ? mxDefaultToolbarCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxDefaultPopupMenuCodec\n\t *\n\t * Custom codec for configuring <mxDefaultPopupMenu>s. This class is created\n\t * and registered dynamically at load time and used implicitely via\n\t * <mxCodec> and the <mxCodecRegistry>. This codec only reads configuration\n\t * data for existing popup menus, it does not encode or create menus. Note\n\t * that this codec only passes the configuration node to the popup menu,\n\t * which uses the config to dynamically create menus. See\n\t * <mxDefaultPopupMenu.createMenu>.\n\t */\n\tvar codec = new mxObjectCodec(new mxDefaultPopupMenu());\n\n\t/**\n\t * Function: encode\n\t *\n\t * Returns null.\n\t */\n\tcodec.encode = function(enc, obj)\n\t{\n\t\treturn null;\n\t};\n\n\t/**\n\t * Function: decode\n\t *\n\t * Uses the given node as the config for <mxDefaultPopupMenu>.\n\t */\n\tcodec.decode = function(dec, node, into)\n\t{\n\t\tvar inc = node.getElementsByTagName('include')[0];\n\n\t\tif (inc != null)\n\t\t{\n\t\t\tthis.processInclude(dec, inc, into);\n\t\t}\n\t\telse if (into != null)\n\t\t{\n\t\t\tinto.config = node;\n\t\t}\n\n\t\treturn into;\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxDefaultPopupMenuCodec = typeof mxDefaultPopupMenuCodec !== 'undefined' ? mxDefaultPopupMenuCodec : undefined;\n\n/**\n * Copyright (c) 2006-2015, JGraph Ltd\n * Copyright (c) 2006-2015, Gaudenz Alder\n */\nmxCodecRegistry.register(function()\n{\n\t/**\n\t * Class: mxEditorCodec\n\t *\n\t * Codec for <mxEditor>s. This class is created and registered\n\t * dynamically at load time and used implicitely via <mxCodec>\n\t * and the <mxCodecRegistry>.\n\t *\n\t * Transient Fields:\n\t *\n\t * - modified\n\t * - lastSnapshot\n\t * - ignoredChanges\n\t * - undoManager\n\t * - graphContainer\n\t * - toolbarContainer\n\t */\n\tvar codec = new mxObjectCodec(new mxEditor(),\n\t\t['modified', 'lastSnapshot', 'ignoredChanges',\n\t\t'undoManager', 'graphContainer', 'toolbarContainer']);\n\n\t/**\n\t * Function: beforeDecode\n\t *\n\t * Decodes the ui-part of the configuration node by reading\n\t * a sequence of the following child nodes and attributes\n\t * and passes the control to the default decoding mechanism:\n\t *\n\t * Child Nodes:\n\t *\n\t * stylesheet - Adds a CSS stylesheet to the document.\n\t * resource - Adds the basename of a resource bundle.\n\t * add - Creates or configures a known UI element.\n\t *\n\t * These elements may appear in any order given that the\n\t * graph UI element is added before the toolbar element\n\t * (see Known Keys).\n\t *\n\t * Attributes:\n\t *\n\t * as - Key for the UI element (see below).\n\t * element - ID for the element in the document.\n\t * style - CSS style to be used for the element or window.\n\t * x - X coordinate for the new window.\n\t * y - Y coordinate for the new window.\n\t * width - Width for the new window.\n\t * height - Optional height for the new window.\n\t * name - Name of the stylesheet (absolute/relative URL).\n\t * basename - Basename of the resource bundle (see <mxResources>).\n\t *\n\t * The x, y, width and height attributes are used to create a new\n\t * <mxWindow> if the element attribute is not specified in an add\n\t * node. The name and basename are only used in the stylesheet and\n\t * resource nodes, respectively.\n\t *\n\t * Known Keys:\n\t *\n\t * graph - Main graph element (see <mxEditor.setGraphContainer>).\n\t * title - Title element (see <mxEditor.setTitleContainer>).\n\t * toolbar - Toolbar element (see <mxEditor.setToolbarContainer>).\n\t * status - Status bar element (see <mxEditor.setStatusContainer>).\n\t *\n\t * Example:\n\t *\n\t * (code)\n\t * <ui>\n\t *   <stylesheet name=\"css/process.css\"/>\n\t *   <resource basename=\"resources/app\"/>\n\t *   <add as=\"graph\" element=\"graph\"\n\t *     style=\"left:70px;right:20px;top:20px;bottom:40px\"/>\n\t *   <add as=\"status\" element=\"status\"/>\n\t *   <add as=\"toolbar\" x=\"10\" y=\"20\" width=\"54\"/>\n\t * </ui>\n\t * (end)\n\t */\n\tcodec.afterDecode = function(dec, node, obj)\n\t{\n\t\t// Assigns the specified templates for edges\n\t\tvar defaultEdge = node.getAttribute('defaultEdge');\n\n\t\tif (defaultEdge != null)\n\t\t{\n\t\t\tnode.removeAttribute('defaultEdge');\n\t\t\tobj.defaultEdge = obj.templates[defaultEdge];\n\t\t}\n\n\t\t// Assigns the specified templates for groups\n\t\tvar defaultGroup = node.getAttribute('defaultGroup');\n\n\t\tif (defaultGroup != null)\n\t\t{\n\t\t\tnode.removeAttribute('defaultGroup');\n\t\t\tobj.defaultGroup = obj.templates[defaultGroup];\n\t\t}\n\n\t\treturn obj;\n\t};\n\n\t/**\n\t * Function: decodeChild\n\t *\n\t * Overrides decode child to handle special child nodes.\n\t */\n\tcodec.decodeChild = function(dec, child, obj)\n\t{\n\t\tif (child.nodeName == 'Array')\n\t\t{\n\t\t\tvar role = child.getAttribute('as');\n\n\t\t\tif (role == 'templates')\n\t\t\t{\n\t\t\t\tthis.decodeTemplates(dec, child, obj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (child.nodeName == 'ui')\n\t\t{\n\t\t\tthis.decodeUi(dec, child, obj);\n\t\t\treturn;\n\t\t}\n\n\t\tmxObjectCodec.prototype.decodeChild.apply(this, arguments);\n\t};\n\n\t/**\n\t * Function: decodeTemplates\n\t *\n\t * Decodes the cells from the given node as templates.\n\t */\n\tcodec.decodeUi = function(dec, node, editor)\n\t{\n\t\tvar tmp = node.firstChild;\n\t\twhile (tmp != null)\n\t\t{\n\t\t\tif (tmp.nodeName == 'add')\n\t\t\t{\n\t\t\t\tvar as = tmp.getAttribute('as');\n\t\t\t\tvar elt = tmp.getAttribute('element');\n\t\t\t\tvar style = tmp.getAttribute('style');\n\t\t\t\tvar element = null;\n\n\t\t\t\tif (elt != null)\n\t\t\t\t{\n\t\t\t\t\telement = document.getElementById(elt);\n\n\t\t\t\t\tif (element != null && style != null)\n\t\t\t\t\t{\n\t\t\t\t\t\telement.style.cssText += ';' + style;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar x = parseInt(tmp.getAttribute('x'));\n\t\t\t\t\tvar y = parseInt(tmp.getAttribute('y'));\n\t\t\t\t\tvar width = tmp.getAttribute('width');\n\t\t\t\t\tvar height = tmp.getAttribute('height');\n\n\t\t\t\t\t// Creates a new window around the element\n\t\t\t\t\telement = document.createElement('div');\n\t\t\t\t\telement.style.cssText = style;\n\n\t\t\t\t\tvar wnd = new mxWindow(mxResources.get(as) || as,\n\t\t\t\t\t\telement, x, y, width, height, false, true);\n\t\t\t\t\twnd.setVisible(true);\n\t\t\t\t}\n\n\t\t\t\t// TODO: Make more generic\n\t\t\t\tif (as == 'graph')\n\t\t\t\t{\n\t\t\t\t\teditor.setGraphContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'toolbar')\n\t\t\t\t{\n\t\t\t\t\teditor.setToolbarContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'title')\n\t\t\t\t{\n\t\t\t\t\teditor.setTitleContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'status')\n\t\t\t\t{\n\t\t\t\t\teditor.setStatusContainer(element);\n\t\t\t\t}\n\t\t\t\telse if (as == 'map')\n\t\t\t\t{\n\t\t\t\t\teditor.setMapContainer(element);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (tmp.nodeName == 'resource')\n\t\t\t{\n\t\t\t\tmxResources.add(tmp.getAttribute('basename'));\n\t\t\t}\n\t\t\telse if (tmp.nodeName == 'stylesheet')\n\t\t\t{\n\t\t\t\tmxClient.link('stylesheet', tmp.getAttribute('name'));\n\t\t\t}\n\n\t\t\ttmp = tmp.nextSibling;\n\t\t}\n\t};\n\n\t/**\n\t * Function: decodeTemplates\n\t *\n\t * Decodes the cells from the given node as templates.\n\t */\n\tcodec.decodeTemplates = function(dec, node, editor)\n\t{\n\t\tif (editor.templates == null)\n\t\t{\n\t\t\teditor.templates = [];\n\t\t}\n\n\t\tvar children = mxUtils.getChildNodes(node);\n\t\tfor (var j=0; j<children.length; j++)\n\t\t{\n\t\t\tvar name = children[j].getAttribute('as');\n\t\t\tvar child = children[j].firstChild;\n\n\t\t\twhile (child != null && child.nodeType != 1)\n\t\t\t{\n\t\t\t\tchild = child.nextSibling;\n\t\t\t}\n\n\t\t\tif (child != null)\n\t\t\t{\n\t\t\t\t// LATER: Only single cells means you need\n\t\t\t\t// to group multiple cells within another\n\t\t\t\t// cell. This should be changed to support\n\t\t\t\t// arrays of cells, or the wrapper must\n\t\t\t\t// be automatically handled in this class.\n\t\t\t\teditor.templates[name] = dec.decodeCell(child);\n\t\t\t}\n\t\t}\n\t};\n\n\t// Returns the codec into the registry\n\treturn codec;\n\n}());\n\n__mxOutput.mxEditorCodec = typeof mxEditorCodec !== 'undefined' ? mxEditorCodec : undefined;\nreturn __mxOutput;\n};\n}));\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var global = require('./_global');\nvar macrotask = require('./_task').set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = require('./_cof')(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n","var core = module.exports = { version: '2.6.9' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","module.exports = {};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n","module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var global = require('./_global');\nvar navigator = global.navigator;\n\nmodule.exports = navigator && navigator.userAgent || '';\n","'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = require('./_a-function');\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n","// 7.2.8 IsRegExp(argument)\nvar isObject = require('./_is-object');\nvar cof = require('./_cof');\nvar MATCH = require('./_wks')('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","var anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar newPromiseCapability = require('./_new-promise-capability');\n\nmodule.exports = function (C, x) {\n  anObject(C);\n  if (isObject(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./_is-regexp');\nvar defined = require('./_defined');\n\nmodule.exports = function (that, searchString, NAME) {\n  if (isRegExp(searchString)) throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","var redefine = require('./_redefine');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n","module.exports = require('./_shared')('native-function-to-string', Function.toString);\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n"],"sourceRoot":""}